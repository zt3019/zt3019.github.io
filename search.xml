<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Computer_Fundamentals</title>
    <url>/2021/10/13/Computer-Fundamentals/</url>
    <content><![CDATA[<h1 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h1><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><ul>
<li>计算机网络体系结构<ul>
<li><a href="https://imgtu.com/i/5KpnqU"><img src="https://z3.ax1x.com/2021/10/13/5KpnqU.png" alt="5KpnqU.png"></a></li>
<li>应用层<ul>
<li>应用层用来规定应用进程在通信时所遵循的协议，应用层的许多协议都是基于客户服务器方式。</li>
<li>涉及到的协议：<ul>
<li>域名系统DNS：将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</li>
<li>HTTP协议：超文本传输协议，所有的万维网文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。</li>
<li>邮件传输协议：SMTP</li>
</ul>
</li>
</ul>
</li>
<li>运输层<ul>
<li>只有位于网络边缘部分的主机的协议栈才有运输层，和网络层不同，网络层是为主机之间提供逻辑通信，<font color=red>而运输层为应用程序之间提供通用的数据传输服务（端到端服务）。运输层拥有流量控制（防止过载，即过多的数据注入到网络中），拥塞控制（抑制数据的传输速率）等功能。</font>为上层协议提供端到端的可靠和透明的数据传输服务，上层服务用户不必关心通信子网的实现细节。</li>
<li>运输层主要使用以下两种协议<ul>
<li>传输控制协议TCP：面向连接的协议，提供可靠的数据传输服务。</li>
<li>用户数据报协议UDP：无连接的协议，不提供可靠交付。</li>
</ul>
</li>
<li>运行在TCP上的协议<ul>
<li>HTTP协议（超文本传输协议）：web服务器传输超文本到本地浏览器的传送协议。端口：80</li>
<li>HTTPS（安全超文本传输协议），HTTP协议的安全版本。端口：443</li>
<li>FTP（文件传输协议），用于文件传输，端口：21</li>
<li>SMTP（简单邮件传输协议），用来发送电子邮件。端口：25</li>
<li>SSH，用于加密安全登录用</li>
</ul>
</li>
<li>运行在UDP上的协议<ul>
<li>DNS（域名服务），用于完成地址查找，邮件转发等工作</li>
<li>SNMP（简单网络管理协议），用于网络信息的收集和网络管理</li>
<li>NTP（网络时间协议），用于网络同步。</li>
<li>DHCP（动态主机配置协议），动态配置IP地址。</li>
</ul>
</li>
</ul>
</li>
<li>网络层<ul>
<li><font color=red>网络层采用了IP数据报服务：通过IP寻址来建立两个节点之间的连接，</font>之后把运输层产生的报文段或用户数据报封装成分组和包进行传送，在发送分组时不需要先建立连接，每一个分组独立发送，与其前后的分组无关，在这个过程中网络层不提供端到端的可靠传输服务，尽最大努力进行交付（由网络的主机中的运输层复杂可靠交付）</li>
<li>相关协议：<ul>
<li>与IP协议配套使用的<font color=red>地址解析协议ARP</font></li>
<li>ARP协议完成了IP地址与物理地址的映射，用于动态解析以太网硬件的地址。（IP地址到MAC地址之间的映射）</li>
</ul>
</li>
<li>IP地址部分参考博客<a href="https://blog.csdn.net/w372426096/article/details/78484119">IP地址详解</a></li>
<li>IP地址：整个得因特网就是一个单一的，抽象的网络。IP地址就是给因特网上的每一个主机（或路由器）的每一个接口分配一个在全世界范围内唯一的32位的标识符。</li>
<li>所谓分类的IP地址，就是将IP地址划分为若干固定类，每一类地址都由两个固定长度的字段组成，其中一个字段是<strong>网络号 net-id</strong>，它标志主机（或路由器）所连接到的网络，一个网络号在整个因特网范围内必须是唯一的。而另一个字段则是<strong>主机号 host-id</strong>，它标志该主机（或路由器），一个主机号在它前面的网络号所指明的网络范围内必须是唯一的。由此可见，一个IP地址在整个因特网范围内是唯一的。<ul>
<li><a href="https://imgtu.com/i/5QkpZt"><img src="https://z3.ax1x.com/2021/10/14/5QkpZt.png" alt="5QkpZt.png"></a></li>
<li>地址划分</li>
<li><a href="https://imgtu.com/i/5QkNe1"><img src="https://z3.ax1x.com/2021/10/14/5QkNe1.png" alt="5QkNe1.png"></a></li>
<li><a href="https://imgtu.com/i/5QkjYT"><img src="https://z3.ax1x.com/2021/10/14/5QkjYT.png" alt="5QkjYT.png"></a></li>
<li>子网掩码<ul>
<li>路由器会把子网掩码和收到的数据报地址的目的IP地址145.13.310进行按位与操作，得出所要找的子网网络地址</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>数据链路层<ul>
<li><font color=red>数据链路层：两台设备之间的数据传输，可以看成是在一条管道上进行的，传送的数据单位是帧（每一帧包括数据和必要的控制信息），数据链路层保证传输数据的正确性。</font></li>
</ul>
</li>
<li>物理层<ul>
<li>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流。</li>
</ul>
</li>
</ul>
</li>
<li>TCP与UDP<ul>
<li>TCP/IP即传输控制协议，是面向连接的协议，发送数据前要先建立连接，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达。<ul>
<li>其传送的运输协议数据单元是TCP报文</li>
<li>支持点对点单播，不支持多播。广播</li>
<li>提供可靠服务</li>
<li>复杂。用于大多数应用。如：万维网，电子邮件，文件传送等。</li>
</ul>
</li>
<li>UDP它是属于TCP/IP协议族中的一种，是无连接的协议，发送数据之前不需要建立连接，是没有可靠性的协议，因为不需要建立连接所以可以在网络上以任何可能的路径传输，因此，能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的。<ul>
<li>无连接的协议，提供无连接服务</li>
<li>其传送的运输协议数据单元TPDU是UDP报文或用户数据报</li>
<li>支持单播，多播，广播</li>
<li>不提供可靠交付</li>
<li>简单，适用于很多应用。</li>
</ul>
</li>
</ul>
</li>
<li><strong>三次握手，四次挥手</strong><ul>
<li><strong>三次握手：</strong>TCP建立连接的过程</li>
<li>客户端向服务器发送SYN—》服务端返回SYN，ACK—》客户端发送ACK</li>
<li>三次握手的目的是建立可靠的通信信道，主要目的就是双方确认自己与对方的发送与接收正常。</li>
<li><strong>四次挥手：</strong>数据传输结束后，通信双方都可释放连接，我们将释放连接的过程称为四次挥手。<ul>
<li>客户端对服务器发送关闭连接的请求</li>
<li>服务器收到客户端的关闭连接请求后，回复一个确认收到的消息</li>
<li>服务器确定不会再给客户发消息后，对客户端发送，准备关闭连接的消息</li>
<li>客户端收到服务器要关闭连接的消息后，给服务器发送：已收到关闭连接的消息</li>
</ul>
</li>
</ul>
</li>
<li><strong>HTTP协议</strong><ul>
<li>HTTP是一个基于TCP/IP通信协议来传输数据的协议。HTTP协议工作于客户端-服务器端架构之上，实现可靠性的传输文字，图片，音频，视频等超文本数据的规范，格式简称为“超文本传输协议”。HTTP协议属于应用层，用户访问的第一层就是HTTP<ul>
<li>简单快速：客户端向服务器发送请求时，只需要传送请求方法和路径即可。</li>
<li>灵活：HTTP允许传输任意类型的数据对象。</li>
<li>无连接：限制每次连接只处理一个请求。服务器处理完客户请求，并收到客户应答后，即断开连接。</li>
<li>无状态：协议对于事务处理没有记忆能力。</li>
</ul>
</li>
</ul>
</li>
<li>HTTPS于HTTP<ul>
<li>端口不同，HTTP是80，HTTPS是443</li>
<li>安全性：HTTP是超文本传输协议，信息是明文传输，HTTPS是通过SSL加密处理的传输协议，更加安全。</li>
<li>HTTPS需要拿到CA证书，需要付费</li>
</ul>
</li>
<li>一次完整的HTTP请求<ul>
<li>HTTP协议采用请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求方法，URL，协议版本，请求头部和请求数据。服务器以一个状态作为响应，响应内容包括协议版本，成功或者错误的代码，服务器信息，响应头部和响应数据。</li>
<li>Web浏览器与Web服务器之间将完成下列7个步骤：<ul>
<li>建立TCP连接，三次握手</li>
<li>Web浏览器向Web服务器发送请求行</li>
<li>Web浏览器发送请求头，浏览器发送请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。</li>
<li>Web服务器应答：客户机向服务器发出请求后，服务器会向客户机回送应答，（HTTP/1.1 200 OK）应答的第一部分是协议的版本号和应答状态码</li>
<li>Web服务器发送应答头：正如客户端会随同请求发送关于自身的信息一样，服务器也会随应答向用户发送关于它自己的数据及被请求的文档。</li>
<li>Web服务器向浏览器发送数据：Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为止，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。</li>
<li>Web服务器关闭TCP连接，四次挥手。</li>
</ul>
</li>
</ul>
</li>
<li>输入网址到获取页面的过程<ul>
<li>浏览器搜索自身的DNS缓存，搜索操作系统的DNS缓存，读取本地Host文件和向本地DNS服务器进行查询等。</li>
<li>浏览器获得域名对应的IP地址之后，浏览器向服务器请求建立连接，发起三次握手</li>
<li>TCP/IP链接建立起来后，浏览器向服务器发送HTTP请求</li>
<li>服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果以及相应的视图返回给浏览器</li>
<li>浏览器解析并渲染视图，若遇到js文件，css文件，图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源。</li>
<li>浏览器根据其请求到的资源，数据渲染页面，最终向用户呈现一个完整的页面。</li>
</ul>
</li>
<li>HTTP版本对比<ul>
<li>HTTP1.0<ul>
<li>是一种无状态，无连接的应用层协议（短连接）</li>
<li>浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）</li>
</ul>
</li>
<li>HTTP1.1（长连接）<ul>
<li>默认持久连接节省通信量，只要客户端服务端任意一端没有明确提出断开TCP连接，就一直保持连接。（长连接）.</li>
</ul>
</li>
<li>HTTP2.0<ul>
<li>服务器推送（就是服务器可以对一个客户端请求发送多个响应。服务器向客户端推送资源无需客户端明确的请求）</li>
</ul>
</li>
</ul>
</li>
<li>GET方法和POST方法（HTTP协议中的请求方式）<ul>
<li>GET:用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器</li>
<li>POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式</li>
<li>GET方法与POST方法的区别：<ul>
<li>功能上：GET一般用来从服务器获取资源，POST一般用来更新服务器上的资源</li>
<li>安全性：GET是不安全的，因为GET请求提交的数据将明文出现在URL上（请求头上），可能会泄露私密信息；POST请求参数则被包装到请求体中，相对更安全。</li>
<li>数据量：GET传输的数据量小，因为受URL长度限制，但效率较高；POST可以传输大量数据，所以上传文件只能用POST方式。</li>
</ul>
</li>
</ul>
</li>
<li>Session和Cookie的对比<ul>
<li><font color=red>Cookie是由Web服务器保存在用户浏览器上的文件（key-value格式），可以包含用户相关的信息。</font>客户端向服务器发起请求时，会携带服务器端之前创建的cookie，服务器端通过cookie中携带的数据区分不同的用户。</li>
<li>Session：<font color=red>session是浏览器和服务器对话过程中，服务器会分配一块存储空间给session。</font>服务器默认会为客户浏览器的cookie中设置 sessionid，这个sessionid就和cookie对应，浏览器在向服务器请求过程中传输的cookie 包含 sessionid ，服务器根据传输cookie 中的 sessionid 获取出会话中存储的信息，然后确定会话的身份信息。</li>
<li>区别：<ul>
<li>安全性：cookie数据存放在客户端上，安全性较差，session数据放在服务器上，安全性相对更高</li>
<li>大小限制：cookie有大小限制，单个cookie保存的数据不能超过4K,session无此限制，理论上只与服务器的内存大小有关</li>
<li>服务器资源消耗：session是保存在服务器端上会存在一段时间才会消失，当访问增多，对服务器性能有影响。</li>
<li>实现机制：session的实现常常依赖于Cookie机制，通过Cookie机制回传SessionID。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ul>
<li>进程与线程<ul>
<li>进程是资源分配的基本单位。线程是独立调度的基本单位。一个进程中可以有多个线程，他们共享进程资源。</li>
<li>区别：<ul>
<li>拥有资源：进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</li>
<li>调度：线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程的切换，从一个进程的线程切换到另一个进程的线程时，会引起进程切换。</li>
<li>系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，所付出的开销远大于创建或撤销线程时的开销。线程切换时只需保存和设置少量寄存器内容，开销很小。</li>
<li>通信方面：线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助IPC（进程间通信）</li>
</ul>
</li>
</ul>
</li>
<li>进程通信<ul>
<li>进程通信：进程间传输信息。进程同步：控制多个进程按一定顺序执行</li>
<li>通信方式：<ul>
<li>管道<ul>
<li>管道是通过pipe函数创建的。</li>
<li>支持单向交替传输</li>
<li>只能在父子进程或者兄弟进程中使用</li>
</ul>
</li>
<li>FIFO</li>
<li>消息队列</li>
<li>信息量<ul>
<li>它是一个计数器，用于为多个进程提供对共享数据对象的访问。</li>
</ul>
</li>
<li>共享存储<ul>
<li>允许多个进程共享一个给定的存储区。因为数据不需要在进程间复制，所以这是最快的一种IPC。</li>
</ul>
</li>
<li>套接字<ul>
<li>它可以用于不同机器之间的进程通信</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>死锁<ul>
<li>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞现象，若无外力作用，它们都将无法推进下去。</li>
<li>产生死锁的必要条件<ul>
<li>互斥</li>
<li>占有和等待</li>
<li>不可抢占</li>
<li>环路等待</li>
</ul>
</li>
</ul>
</li>
<li>虚拟内存<ul>
<li>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</li>
<li>页面置换算法</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Hbase简介</title>
    <url>/2020/11/17/HBase%20introduction/</url>
    <content><![CDATA[<h1 id="分布式数据库HBase简介"><a href="#分布式数据库HBase简介" class="headerlink" title="分布式数据库HBase简介"></a>分布式数据库HBase简介</h1><ol>
<li><p>概述    </p>
<ul>
<li>HBase是针对谷歌BigTable的开源实现，是一个高可靠，高性能，面向列，可伸缩的分布式数据库           </li>
<li>可以用来存储非结构化和半结构化的松散数据</li>
</ul>
</li>
<li><p>数据模型</p>
<ul>
<li>索引通过四个元素来定位：行键，列族，列限定符，时间戳</li>
<li> 面向列的存储</li>
</ul>
</li>
<li><p>实现原理 </p>
<ul>
<li>HBase的功能组件<blockquote>
<p>库函数<br>Master服务器<br>Region服务器    </p>
</blockquote>
</li>
<li>两个核心概念表和Region<blockquote>
<p>一个HBase表被划分成多个Region<br>一个Region会分裂成多个新的Region</p>
</blockquote>
</li>
<li>怎么实现Region定位<blockquote>
<p>三层结构索引实现Region的定位<br>Zookeeper文件<br>-ROOT-表<br>.MEAT.表      </p>
</blockquote>
</li>
</ul>
</li>
<li><p>运行机制</p>
<ul>
<li>HBase的系统架构<blockquote>
<p><img src="https://img-blog.csdnimg.cn/2020070104123335.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTE1NDU1OQ==,size_16,color_FFFFFF,t_70#pic_center" title="系统架构图"><br>Zookeeper服务器（被大量用于分布式系统，提供配置维护，域名服务，分布式同步服务）实现协同管理服务，提供管家功能（维护和管理整个HBase集群）<br>Master服务器作用：1.对表增删改查。2.负责不同Region服务器的负载均衡。3.负责调整分裂合并后Region的分布。4.负责重新分配故障，失效的Region服务器</p>
</blockquote>
</li>
<li>Region服务器（负责用户数据的存储和管理）的工作原理</li>
<li>Store的工作原理</li>
<li>HLog的工作原理</li>
</ul>
</li>
<li><p>编程实践<br>HBase安装及实践，参考厦门大学数据库实验室博客<br><a href="http://dblab.xmu.edu.cn/blog/2442-2/">参考链接</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>大数据</category>
        <category>老hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>HA&amp;ZooKeeper</title>
    <url>/2021/06/02/HAHA-zk/</url>
    <content><![CDATA[<h1 id="HA-amp-ZooKeeper"><a href="#HA-amp-ZooKeeper" class="headerlink" title="HA&amp;ZooKeeper"></a>HA&amp;ZooKeeper</h1><h2 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h2><h3 id="zk概述"><a href="#zk概述" class="headerlink" title="zk概述"></a>zk概述</h3><ul>
<li>ZooKeeper是一个开源的分布式的，为分布式应用提供协调服务的Apache项目。</li>
<li>设计模式：是一个基于观察者模式设计的分布式服务管理框架，它辅助存储和管理大家都关心的数据，然后接受观察者的注册，一旦这些数据的状态发生变化，Zookeeper就将负责通知已经在Zookeeper上注册的那些观察者做出相应的反应。</li>
<li>Zookeeper特点，数据结构<ul>
<li><a href="https://imgtu.com/i/2lpCjI"><img src="https://z3.ax1x.com/2021/06/02/2lpCjI.png" alt="2lpCjI.png"></a></li>
<li><a href="https://imgtu.com/i/2lpmCQ"><img src="https://z3.ax1x.com/2021/06/02/2lpmCQ.png" alt="2lpmCQ.png"></a></li>
</ul>
</li>
</ul>
<h3 id="zk实战应用"><a href="#zk实战应用" class="headerlink" title="zk实战应用"></a>zk实战应用</h3><ul>
<li><p>客户端命令</p>
</li>
<li><p>启动客户端：zkCli.sh</p>
<table>
<thead>
<tr>
<th>命令基本语法</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>help</td>
<td>显示所有操作命令</td>
</tr>
<tr>
<td>ls path [watch]</td>
<td>使用 ls 命令来查看当前znode中所包含的内容</td>
</tr>
<tr>
<td>ls2 path [watch]</td>
<td>查看当前节点数据并能看到更新次数等数据</td>
</tr>
<tr>
<td>create</td>
<td>普通创建-s  含有序列-e  临时（重启或者超时消失）</td>
</tr>
<tr>
<td>get path [watch]</td>
<td>获得节点的值</td>
</tr>
<tr>
<td>set</td>
<td>设置节点的具体值</td>
</tr>
<tr>
<td>stat</td>
<td>查看节点状态</td>
</tr>
<tr>
<td>delete</td>
<td>删除节点</td>
</tr>
<tr>
<td>rmr</td>
<td>递归删除节点</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="zk内部原理"><a href="#zk内部原理" class="headerlink" title="zk内部原理"></a>zk内部原理</h3><ul>
<li><p>节点类型</p>
<p><a href="https://imgtu.com/i/2lpq2j"><img src="https://z3.ax1x.com/2021/06/02/2lpq2j.png" alt="2lpq2j.png"></a></p>
</li>
</ul>
<ul>
<li><p>Stat结构体</p>
<ol>
<li><p>czxid-创建节点的事务zxid</p>
<p>每次修改ZooKeeper状态都会收到一个zxid形式的时间戳，也就是ZooKeeper事务ID。</p>
<p>事务ID是ZooKeeper中所有修改总的次序。每个修改都有唯一的zxid，如果zxid1小于zxid2，那么zxid1在zxid2之前发生。</p>
</li>
</ol>
</li>
<li><p>监听器原理</p>
<p> <img src="C:\Users\Hasee\AppData\Roaming\Typora\typora-user-images\image-20210602195353003.png" alt="image-20210602195353003"></p>
</li>
<li><p>选举机制</p>
<ul>
<li><a href="https://imgtu.com/i/2l9oO1"><img src="https://z3.ax1x.com/2021/06/02/2l9oO1.png" alt="2l9oO1.png"></a><ol>
<li>集群会通过比较先会比较zxid,若zxid相同则比较myid选择leader(每次修改ZooKeeper状态都会收到一个zxid形式的时间戳，也就是ZooKeeper事务ID)</li>
<li>若第一次启动集群（zxid相等）myid如图所示：则大致流程如下：<ol>
<li>server1投票给自己，但是票数没到集群机器的半数以上，选举无法进行。server1状态为LOOKING</li>
<li>server2启动，发起选举，投票给自己，1发现2的myid大，更改选票为2。同理选举依然没法完成。</li>
<li>3启动，发起选举，投给自己，1，2发现3的myid大。则1，2将选票投给3，3获得三票。成为Leader,1,2更改状态为FOLLOWING。3更改状态为LEADING。</li>
<li>4启动，发起选举，1，2，3不在是LOOKING状态，不会更改选票信息。交换选票信息后，3为3票，4为一票，少数服从多数，更改选票信息为server3，更改状态为FOLLOWING。</li>
<li>同4一样</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
<li><p>ZAB</p>
<ul>
<li><p>ZAB协议是专门为zookeeper实现分布式协调功能而设计。zookeeper主要是根据ZAB协议是实现分布式系统数据一致性</p>
</li>
<li><p>写数据流程：</p>
<p><a href="https://imgtu.com/i/2lERBj"><img src="https://z3.ax1x.com/2021/06/02/2lERBj.png" alt="2lERBj.png"></a></p>
<ul>
<li>三个服务器会对是否写数据提出意见，都同意那正常执行写操作</li>
<li>一个server不同意而总票数支持同意，该server自杀再重启，再朝Leader同步信息</li>
<li>leader不同意，但总票数同意。leader自杀重启，重新选举leader，重启后再向leader同步数据</li>
<li>为什么会不同意：查看zxid，如果发来的zxid事物请求比自身的大才会同意</li>
<li>总之就是要尽可能的保持集群数据的一致性。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="HA"><a href="#HA" class="headerlink" title="HA"></a>HA</h2><h3 id="HA概述"><a href="#HA概述" class="headerlink" title="HA概述"></a>HA概述</h3><ul>
<li>HA（High Availablity）</li>
<li>实现高可用最重要的是消除单点故障</li>
<li>防止出现namenode节点挂了，无法正常提供服务</li>
</ul>
<h3 id="HA工作机制"><a href="#HA工作机制" class="headerlink" title="HA工作机制"></a>HA工作机制</h3><ul>
<li><p>故障转移机制 HDFS-HA</p>
<p><a href="https://imgtu.com/i/2lA1SS"><img src="https://z3.ax1x.com/2021/06/02/2lA1SS.png" alt="2lA1SS.png"></a></p>
</li>
<li><p>故障转移机制</p>
<ul>
<li>为了保证数据不丢失，一个失效后另一个补上不会丢失数据，日志文件写到第三方平台（相当于2nn）</li>
<li>新激活的namenode 可以从第三方，读取edits文件将缺少的数据补上，防止数据丢失</li>
<li>Zkfc检测到假死后是通过zookeeper服务器将信息传到其它的namenode的zkfc</li>
</ul>
</li>
<li><p>YARN-HA</p>
<p><a href="https://imgtu.com/i/2lAaF0"><img src="https://z3.ax1x.com/2021/06/02/2lAaF0.png" alt="2lAaF0.png"></a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
        <tag>HA</tag>
      </tags>
  </entry>
  <entry>
    <title>Java网络编程基础</title>
    <url>/2021/04/23/Java-network/</url>
    <content><![CDATA[<h1 id="Java网络编程基础"><a href="#Java网络编程基础" class="headerlink" title="Java网络编程基础"></a>Java网络编程基础</h1><h2 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> network;<br><br><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.BufferedWriter;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.io.InputStreamReader;<br><span class="hljs-keyword">import</span> java.io.OutputStream;<br><span class="hljs-keyword">import</span> java.io.OutputStreamWriter;<br><span class="hljs-keyword">import</span> java.net.ServerSocket;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><span class="hljs-keyword">import</span> java.time.LocalDateTime;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetTest</span> </span>&#123;<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">server3</span><span class="hljs-params">()</span> </span>&#123;<br>		ServerSocket server = <span class="hljs-keyword">null</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8888</span>); <span class="hljs-comment">// 绑定端口</span><br>			<span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>				System.out.println(<span class="hljs-string">&quot;服务器在8888端口监听中.....&quot;</span>);<br>				<span class="hljs-keyword">final</span> Socket socket1 = server.accept();<br>				;<br>				Runnable runner = <span class="hljs-keyword">new</span> Runnable() &#123;<br>					<span class="hljs-meta">@Override</span><br>					<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>						BufferedWriter bufferedWriter = <span class="hljs-keyword">null</span>;<br>						<span class="hljs-keyword">try</span> &#123;<br>							bufferedWriter = <span class="hljs-keyword">new</span> BufferedWriter(<span class="hljs-keyword">new</span> OutputStreamWriter(socket1.getOutputStream()));<br>							bufferedWriter.write(<span class="hljs-string">&quot;我是服务器, 现在时间 : &quot;</span> + LocalDateTime.now());<br>							bufferedWriter.newLine();<br>							bufferedWriter.flush(); <span class="hljs-comment">// 把数据真的刷入网线中</span><br>						&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>							e.printStackTrace();<br>						&#125; <span class="hljs-keyword">finally</span> &#123;<br>							<span class="hljs-keyword">if</span> (bufferedWriter != <span class="hljs-keyword">null</span>) &#123;<br>								<span class="hljs-keyword">try</span> &#123;<br>									bufferedWriter.close();<br>								&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>								&#125;<br>							&#125;<br>							<span class="hljs-keyword">if</span> (socket1 != <span class="hljs-keyword">null</span>) &#123;<br>								<span class="hljs-keyword">try</span> &#123;<br>									socket1.close();<br>								&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>								&#125;<br>							&#125;<br>						&#125;<br>						<span class="hljs-keyword">try</span> &#123;<br>							Thread.sleep(<span class="hljs-number">5000</span>);<br>						&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>							e.printStackTrace();<br>						&#125;<br>					&#125;<br>				&#125;;<br>				<span class="hljs-keyword">new</span> Thread(runner).start();<br>			&#125;<br>		&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br><br>			<span class="hljs-keyword">if</span> (server != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					System.out.println(<span class="hljs-string">&quot;服务器关闭....&quot;</span>);<br>					server.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">client3</span><span class="hljs-params">()</span> </span>&#123;<br>		Socket socket2 = <span class="hljs-keyword">null</span>;<br>		BufferedReader bufferedReader = <span class="hljs-keyword">null</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			socket2 = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8888</span>);<br>			bufferedReader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(socket2.getInputStream()));<br>			String readLine = bufferedReader.readLine();<br>			System.out.println(readLine);<br>		&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			<span class="hljs-keyword">if</span> (bufferedReader != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					bufferedReader.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">if</span> (socket2 != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					socket2.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">// 从客户端发送文件给服务端，服务端保存到本地。并返回“发送成功”给客户端。并关闭相应的连接。</span><br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">server2</span><span class="hljs-params">()</span> </span>&#123;<br>		ServerSocket server = <span class="hljs-keyword">null</span>;<br>		Socket socket1 = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 网络套接字</span><br><br>		InputStream nis = <span class="hljs-keyword">null</span>;<br>		FileOutputStream fos = <span class="hljs-keyword">null</span>;<br>		BufferedWriter netWriter = <span class="hljs-keyword">null</span>;<br><br>		<span class="hljs-keyword">try</span> &#123;<br>			server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">7777</span>);<span class="hljs-comment">// 指定服务器接口</span><br>			socket1 = server.accept();<br>			nis = socket1.getInputStream();<br>			fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;朴树 - 猎户星座2.mp3&quot;</span>);<br>			netWriter = <span class="hljs-keyword">new</span> BufferedWriter(<span class="hljs-keyword">new</span> OutputStreamWriter(socket1.getOutputStream()));<br><br>			<span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">8192</span>];<br>			<span class="hljs-keyword">int</span> realCount = nis.read(buf);<br>			<span class="hljs-keyword">while</span> (realCount != -<span class="hljs-number">1</span>) &#123;<br>				fos.write(buf, <span class="hljs-number">0</span>, realCount);<br>				realCount = nis.read(buf);<br>			&#125;<br>			netWriter.write(<span class="hljs-string">&quot;发送成功&quot;</span>);<br>			netWriter.newLine();<br>			netWriter.flush();<br><br>		&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			<span class="hljs-keyword">if</span> (netWriter != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					netWriter.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">if</span> (fos != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					fos.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">if</span> (nis != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					nis.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">if</span> (socket1 != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					socket1.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">if</span> (server != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					server.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">client2</span><span class="hljs-params">()</span> </span>&#123;<br>		Socket socket2 = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 网络套接字</span><br><br>		FileInputStream fis = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 文件输入流</span><br>		OutputStream nos = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 网络输出流</span><br>		BufferedReader netReader = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 网络输入流</span><br>		<span class="hljs-keyword">try</span> &#123;<br>			socket2 = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">7777</span>);<br>			fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;src/朴树 - 猎户星座.mp3&quot;</span>);<span class="hljs-comment">// 要传到服务器端的文件，先读入到客户端</span><br>			nos = socket2.getOutputStream();<span class="hljs-comment">// 传输到服务器端的文件输出流</span><br>			netReader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(socket2.getInputStream()));<span class="hljs-comment">// 读取服务器端返回的数据</span><br><br>			<span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">8192</span>];<br>			<span class="hljs-comment">// 读取数据</span><br>			<span class="hljs-keyword">int</span> realCount = fis.read(buf);<br>			<span class="hljs-keyword">while</span> (realCount != -<span class="hljs-number">1</span>) &#123;<br>				<span class="hljs-comment">// 1) 处理已经读的数据</span><br>				nos.write(buf, <span class="hljs-number">0</span>, realCount);<br>				<span class="hljs-comment">// 2) 继续读</span><br>				realCount = fis.read(buf);<br>			&#125;<br>			nos.flush();<span class="hljs-comment">// 将在缓存中的数据全部输出去</span><br>			socket2.shutdownOutput();<span class="hljs-comment">// 关闭输出流</span><br><br>			String readLine = netReader.readLine();<span class="hljs-comment">// 接受服务器端的数据</span><br>			System.out.println(readLine);<br><br>		&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<span class="hljs-comment">// 关闭相应的资源</span><br>			<span class="hljs-keyword">if</span> (netReader != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					netReader.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">if</span> (nos != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					nos.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">if</span> (fis != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					fis.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">if</span> (socket2 != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					socket2.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">server</span><span class="hljs-params">()</span> </span>&#123;<br>		ServerSocket server = <span class="hljs-keyword">null</span>;<br>		Socket socket1 = <span class="hljs-keyword">null</span>;<br>		BufferedReader bufferedReader = <span class="hljs-keyword">null</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">9999</span>); <span class="hljs-comment">// 绑定9999端口.</span><br>			socket1 = server.accept(); <span class="hljs-comment">// 接受客户端的连接请求, 此方法会引起阻塞.</span><br>			System.out.println(socket1);<br>			<span class="hljs-comment">// 服务器端的socket1和客户端的socket2就建立了双向的网络通道</span><br>			InputStream inputStream = socket1.getInputStream();<br>			InputStreamReader isr = <span class="hljs-keyword">new</span> InputStreamReader(inputStream);<br><br>			bufferedReader = <span class="hljs-keyword">new</span> BufferedReader(isr);<br>			String readLine = bufferedReader.readLine();<br>			System.out.println(readLine);<br>		&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			<span class="hljs-keyword">if</span> (bufferedReader != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					bufferedReader.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br><br>			<span class="hljs-keyword">if</span> (socket1 != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					socket1.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br><br>			<span class="hljs-keyword">if</span> (server != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					server.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br><br>			&#125;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">client</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">// 连接服务器, 必须知道ip和端口.</span><br>		Socket socket2 = <span class="hljs-keyword">null</span>;<br>		BufferedWriter bufferedWriter = <span class="hljs-keyword">null</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			socket2 = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">9999</span>);<br>			System.out.println(socket2);<br>			<span class="hljs-comment">// 客户端的socket2和服务器端的socket1就建立了双向的网络通道</span><br>			OutputStream outputStream = socket2.getOutputStream();<br>			OutputStreamWriter osw = <span class="hljs-keyword">new</span> OutputStreamWriter(outputStream);<br>			bufferedWriter = <span class="hljs-keyword">new</span> BufferedWriter(osw);<br>			bufferedWriter.write(<span class="hljs-string">&quot;你好, 服务器, 俺是客户端.....&quot;</span>);<br>			bufferedWriter.newLine();<span class="hljs-comment">// 必须要有换行</span><br>			bufferedWriter.flush();<br>		&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			<span class="hljs-keyword">if</span> (bufferedWriter != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					bufferedWriter.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br><br>			<span class="hljs-keyword">if</span> (socket2 != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					socket2.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h2 id="杀死本机被占用的端口号"><a href="#杀死本机被占用的端口号" class="headerlink" title="杀死本机被占用的端口号"></a>杀死本机被占用的端口号</h2><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">netstat</span> -ano   查看操作系统所有占用端口的进程<br><span class="hljs-attribute">netstat</span> -ano | findstr <span class="hljs-string">&quot;9999&quot;</span> 获取占用了<span class="hljs-number">9999</span>端口的进程<br><span class="hljs-attribute">taskkill</span> /F /pid <span class="hljs-number">1234</span> 关闭进程号为<span class="hljs-number">1234</span>的进程<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive_WindowFunction</title>
    <url>/2022/02/25/Hive-WindowFunction/</url>
    <content><![CDATA[<h1 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h1><h2 id="partition-by-子句"><a href="#partition-by-子句" class="headerlink" title="partition by 子句"></a>partition by 子句</h2><ul>
<li><p>窗口函数</p>
<ul>
<li><p>窗口函数，也叫OLAP函数（Online Anallytical Processing,联机分析处理），可以对数据库进行实时分析处理。</p>
</li>
<li><p>基本语法：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">&lt;窗口函数&gt; <span class="hljs-keyword">over</span> (<span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> &lt;用于分组的列名&gt;<br>                <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> &lt;用于排序的列名&gt;)<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>语法中&lt;窗口函数&gt;的位置，可以放下以下两种函数：</p>
<ul>
<li><p>专用窗口函数，包括后面要讲到的rank,dense_rank,row-number等专用窗口函数</p>
</li>
<li><p>聚合函数，sum,avg,count,max,min等</p>
</li>
<li><p>````<br>select *,<br>   rank() over (partition by 班级</p>
<pre><code>             order by 成绩 desc) as ranking
</code></pre>
<p>from 班级表</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><br>  ![](https://pic2.zhimg.com/v2<span class="hljs-number">-451</span>c70aa24c68aa7142693fd27c85605_r.jpg)<br><br>* 简单来说，窗口函数具有以下功能<br>  <br>  - 同时具有分组和排序的功能<br>  - 不减少原表的行数<br><br>## <span class="hljs-keyword">window</span>子句<br><br>* 如果只使用<span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> 子句，未指定<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 的话，我们的聚合就是分组内的聚合<br><br>* 使用了<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span>子句，未使用<span class="hljs-keyword">window</span>子句的情况下，默认从起点到当前行。<br><br>* 当同一个<span class="hljs-keyword">select</span>查询中存在多个窗口函数时，他们互相之间是没有影响的。每个窗口函数应用自己的规则。<br><br>* <span class="hljs-keyword">window</span>子句<br><br>  - <span class="hljs-keyword">PRECEDING</span>：往前<br><br>  - <span class="hljs-keyword">FOLLOWING</span>：往后<br><br>  - <span class="hljs-keyword">CURRENT</span> <span class="hljs-keyword">ROW</span>：往前行<br><br>  - <span class="hljs-keyword">UNBOUNDED</span>：起点<br><br>  - <span class="hljs-keyword">UNBOUNDED</span> <span class="hljs-keyword">PRECEDING</span> : 表示从前面的起点<br><br>  - <span class="hljs-keyword">UNBOUNDED</span> <span class="hljs-keyword">FOLLOWING</span> ：表示到后面的终点<br><br>  - ````sqlite<br>    <span class="hljs-keyword">select</span> <span class="hljs-type">name</span>,orderdate,<span class="hljs-keyword">cost</span>,<br>    sum(<span class="hljs-keyword">cost</span>) <span class="hljs-keyword">over</span>() <span class="hljs-keyword">as</span> sample1,<span class="hljs-comment">--所有行相加</span><br>    sum(<span class="hljs-keyword">cost</span>) <span class="hljs-keyword">over</span>(<span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> <span class="hljs-type">name</span>) <span class="hljs-keyword">as</span> sample2,<span class="hljs-comment">--按name分组，组内数据相加</span><br>    sum(<span class="hljs-keyword">cost</span>) <span class="hljs-keyword">over</span>(<span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> <span class="hljs-type">name</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> orderdate) <span class="hljs-keyword">as</span> sample3,<span class="hljs-comment">--按name分组，组内数据累加</span><br>    sum(<span class="hljs-keyword">cost</span>) <span class="hljs-keyword">over</span>(<span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> <span class="hljs-type">name</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> orderdate <span class="hljs-keyword">rows</span> <span class="hljs-keyword">between</span> <span class="hljs-keyword">UNBOUNDED</span> <span class="hljs-keyword">PRECEDING</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">current</span> <span class="hljs-keyword">row</span> )  <span class="hljs-keyword">as</span> sample4 ,<span class="hljs-comment">--和sample3一样,由起点到当前行的聚合</span><br>    sum(<span class="hljs-keyword">cost</span>) <span class="hljs-keyword">over</span>(<span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> <span class="hljs-type">name</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> orderdate <span class="hljs-keyword">rows</span> <span class="hljs-keyword">between</span> <span class="hljs-number">1</span> <span class="hljs-keyword">PRECEDING</span>   <span class="hljs-keyword">and</span> <span class="hljs-keyword">current</span> <span class="hljs-keyword">row</span>) <span class="hljs-keyword">as</span> sample5, <span class="hljs-comment">--当前行和前面一行做聚合</span><br>    sum(<span class="hljs-keyword">cost</span>) <span class="hljs-keyword">over</span>(<span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> <span class="hljs-type">name</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> orderdate <span class="hljs-keyword">rows</span> <span class="hljs-keyword">between</span> <span class="hljs-number">1</span> <span class="hljs-keyword">PRECEDING</span>   <span class="hljs-keyword">AND</span> <span class="hljs-number">1</span> <span class="hljs-keyword">FOLLOWING</span>  ) <span class="hljs-keyword">as</span> sample6,<span class="hljs-comment">--当前行和前边一行及后面一行</span><br>    sum(<span class="hljs-keyword">cost</span>) <span class="hljs-keyword">over</span>(<span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> <span class="hljs-type">name</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> orderdate <span class="hljs-keyword">rows</span> <span class="hljs-keyword">between</span> <span class="hljs-keyword">current</span> <span class="hljs-keyword">row</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">UNBOUNDED</span> <span class="hljs-keyword">FOLLOWING</span> ) <span class="hljs-keyword">as</span> sample7 <span class="hljs-comment">--当前行及后面所有行</span><br>    <span class="hljs-keyword">from</span> t_window;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">name</span>    orderdate   cost    sample<span class="hljs-number">1</span> sample<span class="hljs-number">2</span> sample<span class="hljs-number">3</span> sample<span class="hljs-number">4</span> sample<span class="hljs-number">5</span> sample<span class="hljs-number">6</span> sample<span class="hljs-number">7</span><br><span class="hljs-attribute">jack</span>    <span class="hljs-number">2015</span>-<span class="hljs-number">01</span>-<span class="hljs-number">01</span>  <span class="hljs-number">10</span>  <span class="hljs-number">661</span> <span class="hljs-number">176</span> <span class="hljs-number">10</span>  <span class="hljs-number">10</span>  <span class="hljs-number">10</span>  <span class="hljs-number">56</span>  <span class="hljs-number">176</span><br><span class="hljs-attribute">jack</span>    <span class="hljs-number">2015</span>-<span class="hljs-number">01</span>-<span class="hljs-number">05</span>  <span class="hljs-number">46</span>  <span class="hljs-number">661</span> <span class="hljs-number">176</span> <span class="hljs-number">56</span>  <span class="hljs-number">56</span>  <span class="hljs-number">56</span>  <span class="hljs-number">111</span> <span class="hljs-number">166</span><br><span class="hljs-attribute">jack</span>    <span class="hljs-number">2015</span>-<span class="hljs-number">01</span>-<span class="hljs-number">08</span>  <span class="hljs-number">55</span>  <span class="hljs-number">661</span> <span class="hljs-number">176</span> <span class="hljs-number">111</span> <span class="hljs-number">111</span> <span class="hljs-number">101</span> <span class="hljs-number">124</span> <span class="hljs-number">120</span><br><span class="hljs-attribute">jack</span>    <span class="hljs-number">2015</span>-<span class="hljs-number">02</span>-<span class="hljs-number">03</span>  <span class="hljs-number">23</span>  <span class="hljs-number">661</span> <span class="hljs-number">176</span> <span class="hljs-number">134</span> <span class="hljs-number">134</span> <span class="hljs-number">78</span>  <span class="hljs-number">120</span> <span class="hljs-number">65</span><br><span class="hljs-attribute">jack</span>    <span class="hljs-number">2015</span>-<span class="hljs-number">04</span>-<span class="hljs-number">06</span>  <span class="hljs-number">42</span>  <span class="hljs-number">661</span> <span class="hljs-number">176</span> <span class="hljs-number">176</span> <span class="hljs-number">176</span> <span class="hljs-number">65</span>  <span class="hljs-number">65</span>  <span class="hljs-number">42</span><br><span class="hljs-attribute">mart</span>    <span class="hljs-number">2015</span>-<span class="hljs-number">04</span>-<span class="hljs-number">08</span>  <span class="hljs-number">62</span>  <span class="hljs-number">661</span> <span class="hljs-number">299</span> <span class="hljs-number">62</span>  <span class="hljs-number">62</span>  <span class="hljs-number">62</span>  <span class="hljs-number">130</span> <span class="hljs-number">299</span><br><span class="hljs-attribute">mart</span>    <span class="hljs-number">2015</span>-<span class="hljs-number">04</span>-<span class="hljs-number">09</span>  <span class="hljs-number">68</span>  <span class="hljs-number">661</span> <span class="hljs-number">299</span> <span class="hljs-number">130</span> <span class="hljs-number">130</span> <span class="hljs-number">130</span> <span class="hljs-number">205</span> <span class="hljs-number">237</span><br><span class="hljs-attribute">mart</span>    <span class="hljs-number">2015</span>-<span class="hljs-number">04</span>-<span class="hljs-number">11</span>  <span class="hljs-number">75</span>  <span class="hljs-number">661</span> <span class="hljs-number">299</span> <span class="hljs-number">205</span> <span class="hljs-number">205</span> <span class="hljs-number">143</span> <span class="hljs-number">237</span> <span class="hljs-number">169</span><br><span class="hljs-attribute">mart</span>    <span class="hljs-number">2015</span>-<span class="hljs-number">04</span>-<span class="hljs-number">13</span>  <span class="hljs-number">94</span>  <span class="hljs-number">661</span> <span class="hljs-number">299</span> <span class="hljs-number">299</span> <span class="hljs-number">299</span> <span class="hljs-number">169</span> <span class="hljs-number">169</span> <span class="hljs-number">94</span><br><span class="hljs-attribute">neil</span>    <span class="hljs-number">2015</span>-<span class="hljs-number">05</span>-<span class="hljs-number">10</span>  <span class="hljs-number">12</span>  <span class="hljs-number">661</span> <span class="hljs-number">92</span>  <span class="hljs-number">12</span>  <span class="hljs-number">12</span>  <span class="hljs-number">12</span>  <span class="hljs-number">92</span>  <span class="hljs-number">92</span><br><span class="hljs-attribute">neil</span>    <span class="hljs-number">2015</span>-<span class="hljs-number">06</span>-<span class="hljs-number">12</span>  <span class="hljs-number">80</span>  <span class="hljs-number">661</span> <span class="hljs-number">92</span>  <span class="hljs-number">92</span>  <span class="hljs-number">92</span>  <span class="hljs-number">92</span>  <span class="hljs-number">92</span>  <span class="hljs-number">80</span><br><span class="hljs-attribute">tony</span>    <span class="hljs-number">2015</span>-<span class="hljs-number">01</span>-<span class="hljs-number">02</span>  <span class="hljs-number">15</span>  <span class="hljs-number">661</span> <span class="hljs-number">94</span>  <span class="hljs-number">15</span>  <span class="hljs-number">15</span>  <span class="hljs-number">15</span>  <span class="hljs-number">44</span>  <span class="hljs-number">94</span><br><span class="hljs-attribute">tony</span>    <span class="hljs-number">2015</span>-<span class="hljs-number">01</span>-<span class="hljs-number">04</span>  <span class="hljs-number">29</span>  <span class="hljs-number">661</span> <span class="hljs-number">94</span>  <span class="hljs-number">44</span>  <span class="hljs-number">44</span>  <span class="hljs-number">44</span>  <span class="hljs-number">94</span>  <span class="hljs-number">79</span><br><span class="hljs-attribute">tony</span>    <span class="hljs-number">2015</span>-<span class="hljs-number">01</span>-<span class="hljs-number">07</span>  <span class="hljs-number">50</span>  <span class="hljs-number">661</span> <span class="hljs-number">94</span>  <span class="hljs-number">94</span>  <span class="hljs-number">94</span>  <span class="hljs-number">79</span>  <span class="hljs-number">79</span>  <span class="hljs-number">50</span><br></code></pre></td></tr></table></figure>



<h2 id="窗口函数中的序列函数"><a href="#窗口函数中的序列函数" class="headerlink" title="窗口函数中的序列函数"></a>窗口函数中的序列函数</h2><ul>
<li>Hive中常用的序列函数有下面几个：</li>
</ul>
<h3 id="NTILE"><a href="#NTILE" class="headerlink" title="NTILE"></a>NTILE</h3><ul>
<li><p>NTILE(n),用于将分组数据按照顺序切分成n片，返回当前切片值</p>
</li>
<li><p>NTILE 不支持ROWS BETWEEN</p>
</li>
<li><p>如果切片步均匀，默认增加第一个切片的分布</p>
</li>
<li><p>案例：假如我们想要给每位顾客购买金额前1/3的交易记录，我们便可以使用这个函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs sqlite">select name,orderdate,cost,<br>       ntile(3) over() as sample1 , --全局数据切片<br>       ntile(3) over(partition by name), -- 按照name进行分组,在分组内将数据切成3份<br>       ntile(3) over(order by cost),--全局按照cost升序排列,数据切成3份<br>       ntile(3) over(partition by name order by cost ) --按照name分组，在分组内按照cost升序排列,数据切成3份<br>from t_window<br></code></pre></td></tr></table></figure></li>
<li><p>````<br>name    orderdate   cost    sample1 sample2 sample3 sample4<br>jack    2015-01-01  10  3   1   1   1<br>jack    2015-02-03  23  3   1   1   1<br>jack    2015-04-06  42  2   2   2   2<br>jack    2015-01-05  46  2   2   2   2<br>jack    2015-01-08  55  2   3   2   3<br>mart    2015-04-08  62  2   1   2   1<br>mart    2015-04-09  68  1   2   3   1<br>mart    2015-04-11  75  1   3   3   2<br>mart    2015-04-13  94  1   1   3   3<br>neil    2015-05-10  12  1   2   1   1<br>neil    2015-06-12  80  1   1   3   2<br>tony    2015-01-02  15  3   2   1   1<br>tony    2015-01-04  29  3   3   1   2<br>tony    2015-01-07  50  2   1   2   3</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><br>* <br><br>### row_number,rank,dense_rank<br><br>* row_number()  取直接的数字排名，比较值相同也不会重复<br>* rank()  类似于高考排名，比较值相同则排名相同，下一个排名数字会跳跃<br>* dense_rank  比较值相同则排名相同，但是排名的数字不会跳跃<br><br>### LAG和LEAD函数<br><br>* LAG(col,n,default_val) ：往前第n行数据,没有数据则返回default_val<br><br>* LEAD(col,n,default_val)：往后第n行数据,没有数据则返回default_val<br><br>* 案例：我们要查看顾客上次的购买时间<br><br>  ````sqlite<br>  <span class="hljs-keyword">select</span> <span class="hljs-type">name</span>,orderdate,<span class="hljs-keyword">cost</span>,<br>  lag(orderdate,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;1900-01-01&#x27;</span>) <span class="hljs-keyword">over</span>(<span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> <span class="hljs-type">name</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> orderdate ) <span class="hljs-keyword">as</span> time1,<br>  lag(orderdate,<span class="hljs-number">2</span>) <span class="hljs-keyword">over</span> (<span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> <span class="hljs-type">name</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> orderdate) <span class="hljs-keyword">as</span> time2<br>  <span class="hljs-keyword">from</span> t_window;<br></code></pre></td></tr></table></figure></li>
<li><p>结果：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">name</span>    orderdate   cost    time<span class="hljs-number">1</span>   time<span class="hljs-number">2</span><br><span class="hljs-attribute">jack</span>    <span class="hljs-number">2015</span>-<span class="hljs-number">01</span>-<span class="hljs-number">01</span>  <span class="hljs-number">10</span>  <span class="hljs-number">1900</span>-<span class="hljs-number">01</span>-<span class="hljs-number">01</span>  NULL<br><span class="hljs-attribute">jack</span>    <span class="hljs-number">2015</span>-<span class="hljs-number">01</span>-<span class="hljs-number">05</span>  <span class="hljs-number">46</span>  <span class="hljs-number">2015</span>-<span class="hljs-number">01</span>-<span class="hljs-number">01</span>  NULL<br><span class="hljs-attribute">jack</span>    <span class="hljs-number">2015</span>-<span class="hljs-number">01</span>-<span class="hljs-number">08</span>  <span class="hljs-number">55</span>  <span class="hljs-number">2015</span>-<span class="hljs-number">01</span>-<span class="hljs-number">05</span>  <span class="hljs-number">2015</span>-<span class="hljs-number">01</span>-<span class="hljs-number">01</span><br><span class="hljs-attribute">jack</span>    <span class="hljs-number">2015</span>-<span class="hljs-number">02</span>-<span class="hljs-number">03</span>  <span class="hljs-number">23</span>  <span class="hljs-number">2015</span>-<span class="hljs-number">01</span>-<span class="hljs-number">08</span>  <span class="hljs-number">2015</span>-<span class="hljs-number">01</span>-<span class="hljs-number">05</span><br><span class="hljs-attribute">jack</span>    <span class="hljs-number">2015</span>-<span class="hljs-number">04</span>-<span class="hljs-number">06</span>  <span class="hljs-number">42</span>  <span class="hljs-number">2015</span>-<span class="hljs-number">02</span>-<span class="hljs-number">03</span>  <span class="hljs-number">2015</span>-<span class="hljs-number">01</span>-<span class="hljs-number">08</span><br><span class="hljs-attribute">mart</span>    <span class="hljs-number">2015</span>-<span class="hljs-number">04</span>-<span class="hljs-number">08</span>  <span class="hljs-number">62</span>  <span class="hljs-number">1900</span>-<span class="hljs-number">01</span>-<span class="hljs-number">01</span>  NULL<br><span class="hljs-attribute">mart</span>    <span class="hljs-number">2015</span>-<span class="hljs-number">04</span>-<span class="hljs-number">09</span>  <span class="hljs-number">68</span>  <span class="hljs-number">2015</span>-<span class="hljs-number">04</span>-<span class="hljs-number">08</span>  NULL<br><span class="hljs-attribute">mart</span>    <span class="hljs-number">2015</span>-<span class="hljs-number">04</span>-<span class="hljs-number">11</span>  <span class="hljs-number">75</span>  <span class="hljs-number">2015</span>-<span class="hljs-number">04</span>-<span class="hljs-number">09</span>  <span class="hljs-number">2015</span>-<span class="hljs-number">04</span>-<span class="hljs-number">08</span><br><span class="hljs-attribute">mart</span>    <span class="hljs-number">2015</span>-<span class="hljs-number">04</span>-<span class="hljs-number">13</span>  <span class="hljs-number">94</span>  <span class="hljs-number">2015</span>-<span class="hljs-number">04</span>-<span class="hljs-number">11</span>  <span class="hljs-number">2015</span>-<span class="hljs-number">04</span>-<span class="hljs-number">09</span><br><span class="hljs-attribute">neil</span>    <span class="hljs-number">2015</span>-<span class="hljs-number">05</span>-<span class="hljs-number">10</span>  <span class="hljs-number">12</span>  <span class="hljs-number">1900</span>-<span class="hljs-number">01</span>-<span class="hljs-number">01</span>  NULL<br><span class="hljs-attribute">neil</span>    <span class="hljs-number">2015</span>-<span class="hljs-number">06</span>-<span class="hljs-number">12</span>  <span class="hljs-number">80</span>  <span class="hljs-number">2015</span>-<span class="hljs-number">05</span>-<span class="hljs-number">10</span>  NULL<br><span class="hljs-attribute">tony</span>    <span class="hljs-number">2015</span>-<span class="hljs-number">01</span>-<span class="hljs-number">02</span>  <span class="hljs-number">15</span>  <span class="hljs-number">1900</span>-<span class="hljs-number">01</span>-<span class="hljs-number">01</span>  NULL<br><span class="hljs-attribute">tony</span>    <span class="hljs-number">2015</span>-<span class="hljs-number">01</span>-<span class="hljs-number">04</span>  <span class="hljs-number">29</span>  <span class="hljs-number">2015</span>-<span class="hljs-number">01</span>-<span class="hljs-number">02</span>  NULL<br><span class="hljs-attribute">tony</span>    <span class="hljs-number">2015</span>-<span class="hljs-number">01</span>-<span class="hljs-number">07</span>  <span class="hljs-number">50</span>  <span class="hljs-number">2015</span>-<span class="hljs-number">01</span>-<span class="hljs-number">04</span>  <span class="hljs-number">2015</span>-<span class="hljs-number">01</span>-<span class="hljs-number">02</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="first-value和last-value"><a href="#first-value和last-value" class="headerlink" title="first_value和last_value"></a>first_value和last_value</h3><ul>
<li><p>first_value取分组内排序后，截止到当前行，第一个值</p>
</li>
<li><p>last_value取分组内排序后，截止到当前行，最后一个值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs sqlite">select name,orderdate,cost,<br>first_value(orderdate) over(partition by name order by orderdate) as time1,<br>last_value(orderdate) over(partition by name order by orderdate) as time2<br>from t_window<br></code></pre></td></tr></table></figure>

<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">name</span>    orderdate   cost    time<span class="hljs-number">1</span>   time<span class="hljs-number">2</span><br><span class="hljs-attribute">jack</span>    <span class="hljs-number">2015</span>-<span class="hljs-number">01</span>-<span class="hljs-number">01</span>  <span class="hljs-number">10</span>  <span class="hljs-number">2015</span>-<span class="hljs-number">01</span>-<span class="hljs-number">01</span>  <span class="hljs-number">2015</span>-<span class="hljs-number">01</span>-<span class="hljs-number">01</span><br><span class="hljs-attribute">jack</span>    <span class="hljs-number">2015</span>-<span class="hljs-number">01</span>-<span class="hljs-number">05</span>  <span class="hljs-number">46</span>  <span class="hljs-number">2015</span>-<span class="hljs-number">01</span>-<span class="hljs-number">01</span>  <span class="hljs-number">2015</span>-<span class="hljs-number">01</span>-<span class="hljs-number">05</span><br><span class="hljs-attribute">jack</span>    <span class="hljs-number">2015</span>-<span class="hljs-number">01</span>-<span class="hljs-number">08</span>  <span class="hljs-number">55</span>  <span class="hljs-number">2015</span>-<span class="hljs-number">01</span>-<span class="hljs-number">01</span>  <span class="hljs-number">2015</span>-<span class="hljs-number">01</span>-<span class="hljs-number">08</span><br><span class="hljs-attribute">jack</span>    <span class="hljs-number">2015</span>-<span class="hljs-number">02</span>-<span class="hljs-number">03</span>  <span class="hljs-number">23</span>  <span class="hljs-number">2015</span>-<span class="hljs-number">01</span>-<span class="hljs-number">01</span>  <span class="hljs-number">2015</span>-<span class="hljs-number">02</span>-<span class="hljs-number">03</span><br><span class="hljs-attribute">jack</span>    <span class="hljs-number">2015</span>-<span class="hljs-number">04</span>-<span class="hljs-number">06</span>  <span class="hljs-number">42</span>  <span class="hljs-number">2015</span>-<span class="hljs-number">01</span>-<span class="hljs-number">01</span>  <span class="hljs-number">2015</span>-<span class="hljs-number">04</span>-<span class="hljs-number">06</span><br><span class="hljs-attribute">mart</span>    <span class="hljs-number">2015</span>-<span class="hljs-number">04</span>-<span class="hljs-number">08</span>  <span class="hljs-number">62</span>  <span class="hljs-number">2015</span>-<span class="hljs-number">04</span>-<span class="hljs-number">08</span>  <span class="hljs-number">2015</span>-<span class="hljs-number">04</span>-<span class="hljs-number">08</span><br><span class="hljs-attribute">mart</span>    <span class="hljs-number">2015</span>-<span class="hljs-number">04</span>-<span class="hljs-number">09</span>  <span class="hljs-number">68</span>  <span class="hljs-number">2015</span>-<span class="hljs-number">04</span>-<span class="hljs-number">08</span>  <span class="hljs-number">2015</span>-<span class="hljs-number">04</span>-<span class="hljs-number">09</span><br><span class="hljs-attribute">mart</span>    <span class="hljs-number">2015</span>-<span class="hljs-number">04</span>-<span class="hljs-number">11</span>  <span class="hljs-number">75</span>  <span class="hljs-number">2015</span>-<span class="hljs-number">04</span>-<span class="hljs-number">08</span>  <span class="hljs-number">2015</span>-<span class="hljs-number">04</span>-<span class="hljs-number">11</span><br><span class="hljs-attribute">mart</span>    <span class="hljs-number">2015</span>-<span class="hljs-number">04</span>-<span class="hljs-number">13</span>  <span class="hljs-number">94</span>  <span class="hljs-number">2015</span>-<span class="hljs-number">04</span>-<span class="hljs-number">08</span>  <span class="hljs-number">2015</span>-<span class="hljs-number">04</span>-<span class="hljs-number">13</span><br><span class="hljs-attribute">neil</span>    <span class="hljs-number">2015</span>-<span class="hljs-number">05</span>-<span class="hljs-number">10</span>  <span class="hljs-number">12</span>  <span class="hljs-number">2015</span>-<span class="hljs-number">05</span>-<span class="hljs-number">10</span>  <span class="hljs-number">2015</span>-<span class="hljs-number">05</span>-<span class="hljs-number">10</span><br><span class="hljs-attribute">neil</span>    <span class="hljs-number">2015</span>-<span class="hljs-number">06</span>-<span class="hljs-number">12</span>  <span class="hljs-number">80</span>  <span class="hljs-number">2015</span>-<span class="hljs-number">05</span>-<span class="hljs-number">10</span>  <span class="hljs-number">2015</span>-<span class="hljs-number">06</span>-<span class="hljs-number">12</span><br><span class="hljs-attribute">tony</span>    <span class="hljs-number">2015</span>-<span class="hljs-number">01</span>-<span class="hljs-number">02</span>  <span class="hljs-number">15</span>  <span class="hljs-number">2015</span>-<span class="hljs-number">01</span>-<span class="hljs-number">02</span>  <span class="hljs-number">2015</span>-<span class="hljs-number">01</span>-<span class="hljs-number">02</span><br><span class="hljs-attribute">tony</span>    <span class="hljs-number">2015</span>-<span class="hljs-number">01</span>-<span class="hljs-number">04</span>  <span class="hljs-number">29</span>  <span class="hljs-number">2015</span>-<span class="hljs-number">01</span>-<span class="hljs-number">02</span>  <span class="hljs-number">2015</span>-<span class="hljs-number">01</span>-<span class="hljs-number">04</span><br><span class="hljs-attribute">tony</span>    <span class="hljs-number">2015</span>-<span class="hljs-number">01</span>-<span class="hljs-number">07</span>  <span class="hljs-number">50</span>  <span class="hljs-number">2015</span>-<span class="hljs-number">01</span>-<span class="hljs-number">02</span>  <span class="hljs-number">2015</span>-<span class="hljs-number">01</span>-<span class="hljs-number">07</span><br><br></code></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Hive</category>
      </categories>
      <tags>
        <tag>Hive</tag>
        <tag>窗口函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/2021/05/11/Linux/</url>
    <content><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="vim的三种模式"><a href="#vim的三种模式" class="headerlink" title="vim的三种模式"></a>vim的三种模式</h2><h3 id="一般模式"><a href="#一般模式" class="headerlink" title="一般模式"></a>一般模式</h3><ul>
<li>以vi/vim编辑器打开一个文件就进入了一般默认，是默认的默认</li>
<li>在一般模式中可以对文件进行复制、粘贴、删除、撤销</li>
<li>常用的命令<ul>
<li>yy<ul>
<li>复制一行</li>
</ul>
</li>
<li>y数字y<ul>
<li>复制多行</li>
</ul>
</li>
<li>dd<ul>
<li>删除一行</li>
</ul>
</li>
<li>d数字d<ul>
<li>删除多行</li>
</ul>
</li>
<li>p<ul>
<li>粘贴</li>
</ul>
</li>
<li>u<ul>
<li>撤销</li>
</ul>
</li>
<li>^<ul>
<li>回到行头</li>
</ul>
</li>
<li>$<ul>
<li>回到行尾</li>
</ul>
</li>
<li>gg或1+G<ul>
<li>回到页头</li>
</ul>
</li>
<li>G<ul>
<li>回到页尾</li>
</ul>
</li>
<li>数字+G<ul>
<li>回到某一行<h3 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h3></li>
</ul>
</li>
</ul>
</li>
<li>在一般模式中输入i、o、a或I、O、A时就进入了编辑模式</li>
<li>在编辑模式中按Esc又回到一般模式</li>
<li>常用的命令<ul>
<li>i<ul>
<li>在光标前插入</li>
</ul>
</li>
<li>o<ul>
<li>在下一行插入<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3></li>
</ul>
</li>
</ul>
</li>
<li>在一般模式中输入:、/或？时就进入了命令模式</li>
<li>在命令模式中按Esc又回到一般模式</li>
<li>常用的命令<ul>
<li>:w<ul>
<li>保存</li>
</ul>
</li>
<li>:q<ul>
<li>推出</li>
</ul>
</li>
<li>:!<ul>
<li>强制执行</li>
</ul>
</li>
<li>:wq！<ul>
<li>保存并强制退出</li>
</ul>
</li>
<li>ZZ<ul>
<li>如果没有修改直接退出，修改了保存后退出</li>
</ul>
</li>
<li>:%s/old 字符/new 字符<ul>
<li>批量替换字符</li>
</ul>
</li>
<li>:nohl<ul>
<li>取消高亮显示</li>
</ul>
</li>
<li>/要查找的词或?要查找的词<ul>
<li>通过n或N进行向上或向下的查找</li>
</ul>
</li>
<li>:set nu<ul>
<li>设置显示行号</li>
</ul>
</li>
<li>:set nonu<ul>
<li>取消显示行号</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="网络相关命令"><a href="#网络相关命令" class="headerlink" title="网络相关命令"></a>网络相关命令</h2><ul>
<li>ifconfig<ul>
<li>查询ip地址</li>
</ul>
</li>
<li>hostname<ul>
<li>查看主机名</li>
<li>修改主机名<ul>
<li>vim /etc/sysconfig/network</li>
</ul>
</li>
<li>配置ip地址与主机名的映射关系<ul>
<li>vim /etc/hosts</li>
</ul>
</li>
</ul>
</li>
<li>service 管理后台服务<ul>
<li>service 服务名 start<ul>
<li>开启某个服务</li>
</ul>
</li>
<li>service 服务名 stop<ul>
<li>关闭某个服务</li>
</ul>
</li>
<li>service 服务名 status<ul>
<li>查看服务的状态</li>
</ul>
</li>
</ul>
</li>
<li>chkconfig 查看开机启动状态<ul>
<li>chkconfig 服务名 on<ul>
<li>开启某个服务开机自启</li>
</ul>
</li>
<li>chkconfig 服务名 off<ul>
<li>关闭某个服务开机自启</li>
</ul>
</li>
<li>chkconfig 服务名 –list<ul>
<li>查看某个服务的开机自启状态</li>
<li>一共有7个运行级别（0到6）<ul>
<li>如果2、3、4、5这四个运行级别是开启的则当前服务就是开机自启的</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="帮助相关命令"><a href="#帮助相关命令" class="headerlink" title="帮助相关命令"></a>帮助相关命令</h2><ul>
<li>man和help<ul>
<li>查询命令的帮助信息</li>
</ul>
</li>
<li>常用的快捷键<ul>
<li>ctrl + l<ul>
<li>清屏</li>
</ul>
</li>
<li>ctrl + c<ul>
<li>停止进程</li>
</ul>
</li>
<li>一定要善用Tab键<ul>
<li>可以帮助我们自动补全路径，防止出错</li>
</ul>
</li>
<li>通过上下键查询最近输入过的命令</li>
<li>ctrl + alt<ul>
<li>鼠标在虚拟机之间和主机之间切换</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="文件相关命令"><a href="#文件相关命令" class="headerlink" title="文件相关命令"></a>文件相关命令</h2><ul>
<li>pwd<ul>
<li>查看当前所在的工作目录</li>
</ul>
</li>
<li>cd<ul>
<li>进入某个目录<ul>
<li>通过绝对路径和相对路径都可以进入某个目录</li>
</ul>
</li>
<li>cd -<ul>
<li>返回上一次所在的目录</li>
</ul>
</li>
<li>cd或cd ~<ul>
<li>回到自己的家目录</li>
</ul>
</li>
</ul>
</li>
<li>rm -rf <ul>
<li>强制删除文件或目录，不提示</li>
</ul>
</li>
<li>touch 文件名<ul>
<li>创建一个空文件</li>
</ul>
</li>
<li>mkdir<ul>
<li>创建目录</li>
</ul>
</li>
<li>echo “要输出的内容”<ul>
<li>输出内容到控制台</li>
</ul>
</li>
<li>cat 文件<ul>
<li>查看小文件</li>
</ul>
</li>
<li>less 文件<ul>
<li>查看大文件<ul>
<li>通过pageup和pagedown键翻页</li>
</ul>
</li>
</ul>
</li>
<li>cp 源文件 目录<ul>
<li>将某个文件复制到某个目录下</li>
</ul>
</li>
<li>mv<ul>
<li>mv 老名字 新名字<ul>
<li>给文件重命名</li>
</ul>
</li>
<li>mv 源文件 目录<ul>
<li>剪切文件到某个目录下</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="搜索查找类命令"><a href="#搜索查找类命令" class="headerlink" title="搜索查找类命令"></a>搜索查找类命令</h2><ul>
<li>find 某个目录 [选项] 内容<ul>
<li>在某个目录下查找相关内容</li>
<li>选项<ul>
<li>-name <ul>
<li>根据文件名称查找</li>
</ul>
</li>
<li>-user<ul>
<li>根据文件所属的用户查找</li>
</ul>
</li>
<li>-size<ul>
<li>根据文件的大小查找</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>grep<ul>
<li>通常结合管道符 | 进行过滤查找</li>
<li>ll /root | grep -n atguigu.txt<ul>
<li>查找/root目录下是否包含atguigu.txt文件，并且会显示出行号</li>
</ul>
</li>
</ul>
</li>
<li>which<ul>
<li>查询某个命令在那个目录下</li>
</ul>
</li>
</ul>
<h2 id="压缩解压缩类命令"><a href="#压缩解压缩类命令" class="headerlink" title="压缩解压缩类命令"></a>压缩解压缩类命令</h2><ul>
<li>tar -zcvf  xxx.tar.gz 要压缩的内容<ul>
<li>压缩文件</li>
</ul>
</li>
<li>tar -zxvf xxx.tar.gz<ul>
<li>解压缩tar包</li>
</ul>
</li>
</ul>
<h2 id="进程线程类命令"><a href="#进程线程类命令" class="headerlink" title="进程线程类命令"></a>进程线程类命令</h2><ul>
<li>ps -aux | grep xxx<ul>
<li>查看内存和CPU的占用率</li>
</ul>
</li>
<li>ps -ef | grep xxx<ul>
<li>查看进程和父进程的ID</li>
</ul>
</li>
<li>kill -9 进程ID<ul>
<li>通过进程ID杀死进程</li>
</ul>
</li>
<li>killall 进程名<ul>
<li>通过进程名杀死进程</li>
</ul>
</li>
<li>netstat -nlp | grep 端口号<ul>
<li>查看端口号是否被占用</li>
</ul>
</li>
</ul>
<h2 id="RPM软件包和YUM仓库"><a href="#RPM软件包和YUM仓库" class="headerlink" title="RPM软件包和YUM仓库"></a>RPM软件包和YUM仓库</h2><ul>
<li>rpm -qa<ul>
<li>查询安装的所有的rpm软件包</li>
</ul>
</li>
<li>rpm -qa | grep 软件名<ul>
<li>查询安装的某个软件的rpm软件包名</li>
</ul>
</li>
<li>rpm -e –nodeps rpm软件包名<ul>
<li>不检查依赖协助某个rpm软件包</li>
</ul>
</li>
<li>rpm -ivh rpm软件包名<ul>
<li>安装rpm软件包</li>
</ul>
</li>
<li>yum -y install<ul>
<li>安装rpm软件包</li>
</ul>
</li>
<li>yum -y update<ul>
<li>更新rpm软件包</li>
</ul>
</li>
<li>yum -y check-update<ul>
<li>检查某个rpm软件包是否有更新</li>
</ul>
</li>
<li>yum -y remove<ul>
<li>卸载rpm软件包</li>
</ul>
</li>
<li>yum list<ul>
<li>查询所有缓存的rpm软件包</li>
</ul>
</li>
<li>yum clean all<ul>
<li>清除缓存</li>
</ul>
</li>
<li>yum makecache<ul>
<li>建立缓存</li>
</ul>
</li>
<li>yum deplist<ul>
<li>显示yum软件包的所有依赖关系</li>
</ul>
</li>
</ul>
<h2 id="文件权限管理"><a href="#文件权限管理" class="headerlink" title="文件权限管理"></a>文件权限管理</h2><ul>
<li>文件属性<ul>
<li>Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。在Linux中我们可以使用ll或者ls -l命令来显示一个文件的属性以及文件所属的用户和组。</li>
<li><a href="https://imgtu.com/i/ga5mY6"><img src="https://z3.ax1x.com/2021/05/11/ga5mY6.md.png" alt="ga5mY6.md.png"></a></li>
<li>首位表示类型<ul>
<li>符号 - 代表文件</li>
<li>符号 d 代表目录</li>
<li>符号 l 代表链接文档</li>
</ul>
</li>
<li>第1-3位确定属主（该文件的所有者）拥有该文件的权限。—User </li>
<li>第4-6位确定属组（所有者的同组用户）拥有该文件的权限，—Group </li>
<li>第7-9位确定其他用户拥有该文件的权限 —Other </li>
</ul>
</li>
<li>chmod修改权限<ul>
<li>方式一：<ul>
<li>chmod  [{ugoa}{+-=}{rwx}] 文件或目录 </li>
<li>chmod g+x houge.txt</li>
<li>chmod u-x,o+x houge.txt</li>
</ul>
</li>
<li>方式二：<ul>
<li>chmod  [mode=421 ]  [文件或目录]</li>
<li>u:所有者  g:所有组  o:其他人  a:所有人(u、g、o的总和)</li>
<li>r=4 w=2 x=1        rwx=4+2+1=7 </li>
<li>chmod 777 houge.txt</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Crontab调度"><a href="#Crontab调度" class="headerlink" title="Crontab调度"></a>Crontab调度</h2><ul>
<li><p>基本语法</p>
<ul>
<li>crontab -e：修改crontab文件。如果文件不存在会自动创建</li>
<li>crontab -l：显示crontab文件</li>
<li>crontab -r：删除crontab文件</li>
<li>crontab -ir：删除crontab文件前提醒用户</li>
</ul>
</li>
<li><p>脚本加执行权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo chmod +x my.sh<br></code></pre></td></tr></table></figure></li>
<li><p>时间显示</p>
</li>
<li><pre><code>例子：
    # 每月的最后1天
    0 0 L * * *

    说明：
    Linux
    *    *    *    *    *
    -    -    -    -    -
    |    |    |    |    |
    |    |    |    |    +----- day of week (0 - 7) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
    |    |    |    +---------- month (1 - 12) OR jan,feb,mar,apr ...
    |    |    +--------------- day of month (1 - 31)
    |    +-------------------- hour (0 - 23)
    +------------------------- minute (0 - 59)
</code></pre>
</li>
<li></li>
<li><table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">是否必填</th>
<th align="left">允许值</th>
<th align="left">允许特殊字符</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Seconds</td>
<td align="left">是</td>
<td align="left">0–59</td>
<td align="left"><code>*,-</code></td>
<td align="left">标准实现不支持此字段。</td>
</tr>
<tr>
<td align="left">Minutes</td>
<td align="left">是</td>
<td align="left">0–59</td>
<td align="left"><code>*,-</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Hours</td>
<td align="left">是</td>
<td align="left">0–23</td>
<td align="left"><code>*,-</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Day of month</td>
<td align="left">是</td>
<td align="left">1–31</td>
<td align="left"><code>*,-?LW</code></td>
<td align="left"><code>?LW</code>只有部分软件实现了</td>
</tr>
<tr>
<td align="left">Month</td>
<td align="left">是</td>
<td align="left">1–12 or JAN–DEC</td>
<td align="left"><code>*,-</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Day of week</td>
<td align="left">是</td>
<td align="left">0–7 or SUN–SAT</td>
<td align="left"><code>*,-?L#</code></td>
<td align="left"><code>?L#</code>只有部分软件实现了 Linux和Spring的允许值为0-7，0和7为周日 Quartz的允许值为1-7，1为周日</td>
</tr>
<tr>
<td align="left">Year</td>
<td align="left">否</td>
<td align="left">1970–2099</td>
<td align="left"><code>*,-</code></td>
<td align="left">标准实现不支持此字段。</td>
</tr>
</tbody></table>
</li>
<li><p>标准字段</p>
<ul>
<li><code>,</code>用于分隔列表。例如，在第5个字段（星期几）中使用<code>MON,WED,FRI</code>表示周一，周三和周五</li>
<li><code>-</code>字符定义范围。例如，<code>2000-2010</code>，表示2000年至2010年期间的每年，包括2000年和2010年</li>
</ul>
</li>
<li><p>非标准字段</p>
<ul>
<li><strong>“L”</strong>代表“Last”</li>
<li>“day of month”字段可以使用<strong>“W”</strong>字符。指定最接近给定日期的工作日（星期一-星期五）</li>
<li>分钟字段设置 <code>*/5</code>表示每5分钟一次，注意：这里指的是能被5整除的分钟数。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>algorithm</title>
    <url>/2021/10/04/algorithm/</url>
    <content><![CDATA[<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><ul>
<li>首先，动态规划问题一般形式就是求最值，求解动态规划的核心问题是穷举。</li>
<li>由于动态规划这类问题基本存在<strong>重叠子问题</strong>，如果暴力求解的话效率会很低，所以需要<strong>备忘录或者DP table</strong>来优化穷举过程。</li>
<li>动态规划问题一定会具备<strong>最优子结构</strong>，这样就能通过子问题求解原问题。要符合最优子结构，子问题之间必须相互独立。</li>
<li>正确的<strong>状态转移方程</strong>才能正确的求解。</li>
<li>求解动态规划的一般办法：<ul>
<li>确定基础案例，也就是最简单的子问题。</li>
<li>确定状态，也就是原问题和子问题中会变化的量</li>
<li>确定选择，也就是导致状态变化的行为</li>
<li>明确dp 数组的含义</li>
</ul>
</li>
</ul>
<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><ul>
<li>常见排序算法的时间复杂度，稳定性<ul>
<li><a href="https://imgtu.com/i/5KSEnO"><img src="https://z3.ax1x.com/2021/10/13/5KSEnO.png" alt="5KSEnO.png"></a></li>
</ul>
</li>
</ul>
<h2 id="大数取余算法"><a href="#大数取余算法" class="headerlink" title="大数取余算法"></a>大数取余算法</h2><ul>
<li>场景：当一个数很大时，大到基本类型都放不下，这时我们需要用String来存储数字。那么怎么进行取余操作呢？</li>
<li>我们根据一个例子来看看：<ul>
<li><a href="https://imgtu.com/i/5KlnOS"><img src="https://z3.ax1x.com/2021/10/13/5KlnOS.png" alt="5KlnOS.png"></a></li>
<li>计算过程<ul>
<li>第一位数字4： 4%3=1；</li>
<li>第二位数字4：（1*10+4）%3=2</li>
<li>第三位数字3：（2*10+3）%3=2</li>
</ul>
</li>
<li>最终的结果是最后一步计算得到的余数2.</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>flume</title>
    <url>/2021/06/21/flume/</url>
    <content><![CDATA[<h1 id="Flume"><a href="#Flume" class="headerlink" title="Flume"></a>Flume</h1><h2 id="Flume概述"><a href="#Flume概述" class="headerlink" title="Flume概述"></a>Flume概述</h2><ul>
<li><p>配置文档，自定义Source,Interceptor,sink就来看官方文档：<a href="http://flume.apache.org/releases/content/1.9.0/FlumeUserGuide.html#spooling-directory-source">官方文档</a></p>
</li>
<li><p>flume是一个高可用的，可靠的，分布式的<em><strong>海量日志采集，聚合，和传输的系统</strong></em>基于流式框架，灵活简单。</p>
</li>
<li><p>基础架构：</p>
<p><a href="https://imgtu.com/i/REvBm8"><img src="https://z3.ax1x.com/2021/06/21/REvBm8.png" alt="REvBm8.png"></a></p>
<ul>
<li>Agent:是一个JVM进程，它以事件的形式将数据从源头送至目的</li>
<li>source负责接收数据到Flume agent 的组件。可以处理各种类型，格式的日志数据。例如：spooling directory，netcat,avro,exec</li>
<li>sink不断轮询channel中的事件并且批量的移除他们，将这些事件批量写入到存储或索引系统，或者被发送到另一个flume agent。sink组件发送目的地包括：hdfs,logger,avro,file,HBase</li>
<li>Channel是位于source和sink之间缓冲区。Flume自带两种Channel：Memory Channel和File Channel。</li>
</ul>
</li>
<li><p>event:flume传输数据的基本单元。由Header和Body组成。Header用来存放该event的一些属性，为K-V结构，Body用来存放该条数据，形式为字节数组。</p>
</li>
</ul>
<h2 id="flume入门案例"><a href="#flume入门案例" class="headerlink" title="flume入门案例"></a>flume入门案例</h2><ul>
<li><p>实时监控Hive日志，并上传到HDFS中</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><code class="hljs nix"><span class="hljs-number">1</span>.第一种方式<br>flume-ng agent --name agent的名字 --conf 配置文件的目录 --conf-file agent的配置文件（自己手动写）-Dflume.root.<span class="hljs-attr">logger=INFO,console</span><br><br>需要写配置文件<br>基本步骤：<br><span class="hljs-comment">#1.agent的source,channel,sink组件</span><br><span class="hljs-comment">#2.source配置</span><br><span class="hljs-comment">#3.channel配置</span><br><span class="hljs-comment">#4.sink配置</span><br><span class="hljs-comment">#5.source,channel,sink之间的关系</span><br><span class="hljs-comment"># Name the components on this agent</span><br>a2.<span class="hljs-attr">sources</span> = r2<br>a2.<span class="hljs-attr">sinks</span> = k2<br>a2.<span class="hljs-attr">channels</span> = c2<br><br><span class="hljs-comment"># Describe/configure the source</span><br>a2.sources.r2.<span class="hljs-attr">type</span> = exec<br>a2.sources.r2.<span class="hljs-attr">command</span> = tail -F /opt/module/hive/logs/hive.log<br>a2.sources.r2.<span class="hljs-attr">shell</span> = /bin/bash -c<br><br><span class="hljs-comment"># Describe the sink</span><br>a2.sinks.k2.<span class="hljs-attr">type</span> = hdfs<br>a2.sinks.k2.hdfs.<span class="hljs-attr">path</span> = hdfs://hadoop102:<span class="hljs-number">8020</span>/flume/%Y%m%d/%H<br><span class="hljs-comment">#上传文件的前缀</span><br>a2.sinks.k2.hdfs.<span class="hljs-attr">filePrefix</span> = logs-<br><span class="hljs-comment">#是否按照时间滚动文件夹</span><br>a2.sinks.k2.hdfs.<span class="hljs-attr">round</span> = <span class="hljs-literal">true</span><br><span class="hljs-comment">#多少时间单位创建一个新的文件夹</span><br>a2.sinks.k2.hdfs.<span class="hljs-attr">roundValue</span> = <span class="hljs-number">1</span><br><span class="hljs-comment">#重新定义时间单位</span><br>a2.sinks.k2.hdfs.<span class="hljs-attr">roundUnit</span> = hour<br><span class="hljs-comment">#是否使用本地时间戳</span><br>a2.sinks.k2.hdfs.<span class="hljs-attr">useLocalTimeStamp</span> = <span class="hljs-literal">true</span><br><span class="hljs-comment">#积攒多少个Event才flush到HDFS一次</span><br>a2.sinks.k2.hdfs.<span class="hljs-attr">batchSize</span> = <span class="hljs-number">100</span><br><span class="hljs-comment">#设置文件类型，可支持压缩</span><br>a2.sinks.k2.hdfs.<span class="hljs-attr">fileType</span> = DataStream<br><span class="hljs-comment">#多久生成一个新的文件</span><br>a2.sinks.k2.hdfs.<span class="hljs-attr">rollInterval</span> = <span class="hljs-number">60</span><br><span class="hljs-comment">#设置每个文件的滚动大小</span><br>a2.sinks.k2.hdfs.<span class="hljs-attr">rollSize</span> = <span class="hljs-number">134217700</span><br><span class="hljs-comment">#文件的滚动与Event数量无关</span><br>a2.sinks.k2.hdfs.<span class="hljs-attr">rollCount</span> = <span class="hljs-number">0</span><br><br><span class="hljs-comment"># Use a channel which buffers events in memory</span><br>a2.channels.c2.<span class="hljs-attr">type</span> = memory<br>a2.channels.c2.<span class="hljs-attr">capacity</span> = <span class="hljs-number">1000</span><br>a2.channels.c2.<span class="hljs-attr">transactionCapacity</span> = <span class="hljs-number">100</span><br><br><span class="hljs-comment"># Bind the source and sink to the channel</span><br>a2.sources.r2.<span class="hljs-attr">channels</span> = c2<br>a2.sinks.k2.<span class="hljs-attr">channel</span> = c2<br></code></pre></td></tr></table></figure></li>
<li><p>log4j.properties(日志架构)，类似于程序中的调试代码，输出一些东西，供编码的时候调试。但是项目上线后不能再直接输出，于是将这些调试输出输出到专门的日志文件中。</p>
</li>
</ul>
<h2 id="Flume进阶"><a href="#Flume进阶" class="headerlink" title="Flume进阶"></a>Flume进阶</h2><ul>
<li><p>flume事务。主要是为了保证数据不会丢失。</p>
<p><a href="https://imgtu.com/i/RZxhvR"><img src="https://z3.ax1x.com/2021/06/22/RZxhvR.png" alt="RZxhvR.png"></a></p>
</li>
<li><p>flume agent内部原理：</p>
<p><a href="https://imgtu.com/i/RZxsbV"><img src="https://z3.ax1x.com/2021/06/22/RZxsbV.png" alt="RZxsbV.png"></a></p>
</li>
</ul>
<ul>
<li><ol>
<li><p>Source接受数据，将数据以event的形式发给ChannnelProcessor</p>
</li>
<li><p>ChannelProcessor将事件传递给拦截器，在拦截其中可以对event数据进行更改。</p>
</li>
<li><p>拦截器再将事件返回到ChannelProcessor，ChannelProcessor将每个事件给Channel选择器。ChannelSelector的作用就是选出Event将要被发往哪个Channel。其共有两种类型，分别是Replicating（复制）和Multiplexing（多路复用）。</p>
</li>
<li><p>再返回到ChannelProcessor，根据选择器的选择，event进入不同的channel</p>
</li>
<li><p>SinkProcessor再决定channel中的enevt的走向。</p>
<p>SinkProcessor共有三种类型，分别是DefaultSinkProcessor、LoadBalancingSinkProcessor和FailoverSinkProcessor。</p>
<p>DefaultSinkProcessor对应的是单个的Sink，LoadBalancingSinkProcessor和FailoverSinkProcessor对应的是Sink Group，LoadBalancingSinkProcessor可以实现负载均衡的功能，FailoverSinkProcessor可以错误恢复的功能(故障转移）。</p>
</li>
</ol>
</li>
<li><p>flume拓扑结构</p>
<ul>
<li>简单串联。多个agent串起来</li>
<li>复制和多路复用。Flume支持将事件流向一个或者多个目的地。这种模式可以将相同数据复制到多个channel中，或者将不同数据分发到不同的channel中，sink可以选择传送到不同的目的地。</li>
<li>负载均衡和故障转移。Flume支持使用将多个sink逻辑上分到一个sink组，sink组配合不同的SinkProcessor可以实现负载均衡和错误恢复的功能。</li>
<li>聚合。将多台服务器部署一个flume日志采集，再将所有日志聚合到一个集中收集日志的flume，由此上传到HDFS,HBase，进行数据分析。</li>
</ul>
</li>
</ul>
<h3 id="API编程"><a href="#API编程" class="headerlink" title="API编程"></a>API编程</h3><ul>
<li>可以查看官网的开发者文档。</li>
<li>自定义Interceptor。定义类实现Interceptor接口，重写四个方法（初始化，单event修改，多event修改，关闭资源）还需要一个Builder静态内部类。</li>
</ul>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="flume的source-sink-Channel的作用？"><a href="#flume的source-sink-Channel的作用？" class="headerlink" title="flume的source,sink,Channel的作用？"></a>flume的source,sink,Channel的作用？</h3><ul>
<li><p>作用：</p>
<p>（1）Source组件是专门用来收集数据的，可以处理各种类型、各种格式的日志数据，包括avro、thrift、exec、jms、spooling directory、netcat、sequence generator、syslog、http、legacy</p>
<p>（2）Channel组件对采集到的数据进行缓存，可以存放在Memory或File中。</p>
<p>（3）Sink组件是用于把数据发送到目的地的组件，目的地包括Hdfs、Logger、avro、thrift、ipc、file、Hbase、solr、自定义。</p>
</li>
</ul>
<h3 id="flume参数调优"><a href="#flume参数调优" class="headerlink" title="flume参数调优"></a>flume参数调优</h3><ul>
<li><p><em><strong>1. source</strong></em></p>
<p>增加Source个（使用Tair Dir Source时可增加FileGroups个数）可以增大Source的读取数据的能力。例如：当某一个目录产生的文件过多时需要将这个文件目录拆分成多个文件目录，同时配置好多个Source 以保证Source有足够的能力获取到新产生的数据。</p>
<p>batchSize参数决定Source一次批量运输到Channel的event条数，适当调大这个参数可以提高Source搬运Event到Channel时的性能。</p>
<p><em><strong>2. Channel:</strong></em></p>
<p>type 选择memory时Channel的性能最好，但是如果Flume进程意外挂掉可能会丢失数据。type选择file时Channel的容错性更好，但是性能上会比memory channel差。</p>
<p>使用file Channel时dataDirs配置多个不同盘下的目录可以提高性能。</p>
<p>Capacity 参数决定Channel可容纳最大的event条数。transactionCapacity 参数决定每次Source往channel里面写的最大event条数和每次Sink从channel里面读的最大event条数。transactionCapacity需要大于Source和Sink的batchSize参数。</p>
<p><em><strong>3. Sink</strong></em></p>
<p>增加Sink的个数可以增加Sink消费event的能力。Sink也不是越多越好够用就行，过多的Sink会占用系统资源，造成系统资源不必要的浪费。</p>
<p>batchSize参数决定Sink一次批量从Channel读取的event条数，适当调大这个参数可以提高Sink从Channel搬出event的性能。</p>
</li>
</ul>
<h3 id="flume数据是否会丢失？"><a href="#flume数据是否会丢失？" class="headerlink" title="flume数据是否会丢失？"></a>flume数据是否会丢失？</h3><ul>
<li>flume采用事务机制，Flume使用两个独立的事务分别负责从Soucrce到Channel，以及从Channel到Sink的事件传递。如果因为某种原因使得事件无法记录，那么事务将会回滚。</li>
<li>正是因为flume完善的事务机制，flume不会丢失数据。</li>
<li>唯一可能丢失数据的情况是Channel采用memoryChannel，agent宕机导致数据丢失，或者Channel存储数据已满，导致Source不再写入，未写入的数据丢失。</li>
<li>Flume不会丢失数据，但是有可能造成数据的重复，例如数据已经成功由Sink发出，但是没有接收到响应，Sink会再次发送数据，此时可能会导致数据的重复。</li>
</ul>
]]></content>
      <categories>
        <category>大数据</category>
        <category>flume</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>flume</tag>
      </tags>
  </entry>
  <entry>
    <title>hbase</title>
    <url>/2021/06/27/hbase/</url>
    <content><![CDATA[<h1 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h1><h2 id="HBbse概述"><a href="#HBbse概述" class="headerlink" title="HBbse概述"></a>HBbse概述</h2><ul>
<li><p>HBase是一种分布式，可扩展，，支持海量数据存储的NoSQL数据库。</p>
</li>
<li><p>逻辑结构</p>
</li>
<li><p><a href="https://imgtu.com/i/RJBhlV"><img src="https://z3.ax1x.com/2021/06/27/RJBhlV.png" alt="RJBhlV.png"></a></p>
</li>
<li><p>row key类似于主键</p>
</li>
<li><p>region在行上的一个切分，几行分一个region</p>
</li>
<li><p>列族：Column Qualifier。</p>
</li>
<li><p>store：按照region和列族可以分为一个个store</p>
</li>
<li><p>物理结构</p>
<p><a href="https://imgtu.com/i/RJBomF"><img src="https://z3.ax1x.com/2021/06/27/RJBomF.png" alt="RJBomF.png"></a></p>
</li>
<li><p>数据模型</p>
<p><strong>1.</strong> <em><strong>Name Space</strong></em></p>
<p>命名空间，类似于关系型数据库的DatabBase概念，每个命名空间下有多个表。HBase有两个自带的命名空间，分别是hbase和default，hbase中存放的是HBase内置的表，default表是用户默认使用的命名空间。</p>
<p><strong>2.</strong> <em><strong>Region</strong></em></p>
<p>类似于关系型数据库的表概念。不同的是，HBase定义表时只需要声明列族即可，不需要声明具体的列。这意味着，往HBase写入数据时，字段可以动态、按需指定。因此，和关系型数据库相比，HBase能够轻松应对字段变更的场景。</p>
<p><strong>3.</strong> <em><strong>Row</strong></em></p>
<p>HBase表中的每行数据都由一个<em><strong>RowKey</strong></em>和多个<em><strong>Column</strong></em>（列）组成，数据是按照RowKey的字典顺序存储的，并且查询数据时只能根据RowKey进行检索，所以RowKey的设计十分重要。</p>
<p><strong>4.</strong> <em><strong>Column</strong></em></p>
<p>HBase中的每个列都由Column Family(列族)和Column Qualifier（列限定符）进行限定，例如info：name，info：age。建表时，只需指明列族，而列限定符无需预先定义。</p>
<p><strong>5.</strong> <em><strong>Time</strong></em> <em><strong>Stamp</strong></em></p>
<p>用于标识数据的不同版本（version），每条数据写入时，如果不指定时间戳，系统会自动为其加上该字段，其值为写入HBase的时间。</p>
<p><strong>6.</strong> <em><strong>Cell</strong></em></p>
<p>由{rowkey, column Family：column Qualifier, time Stamp} 唯一确定的单元。cell中的数据是没有类型的，全部是字节数组形式存贮。</p>
</li>
<li><p>架构</p>
<p><a href="https://imgtu.com/i/RJDyjK"><img src="https://z3.ax1x.com/2021/06/27/RJDyjK.png" alt="RJDyjK.png"></a></p>
</li>
<li><p>Region Server：region的管理者</p>
</li>
<li><p>Master：所有Region Server的管理者</p>
</li>
<li><p>Zookeeper：HBase通过Zookeeper来做Master的高可用、RegionServer的监控、元数据的入口以及集群配置的维护等工作。</p>
</li>
<li><p>HDFS:HDFS为HBase提供最终的底层数据存储服务，同时为HBase提供高可用的支持。</p>
</li>
<li><p>一个RegionServer中有多个Region，每个Region中有多个store，每个Store中有一个Memstore和多个StoreFile</p>
</li>
</ul>
<h2 id="HBase架构"><a href="#HBase架构" class="headerlink" title="HBase架构"></a>HBase架构</h2><p><a href="https://imgtu.com/i/RDKkkR"><img src="https://z3.ax1x.com/2021/06/30/RDKkkR.png" alt="RDKkkR.png"></a></p>
<p>HBase分多个RegionServer，每个RegionServer内又有多个Region，每个Region中又有多个store，store中数据先写到内存，再写到SotreFile（分布式文件系统）上去。</p>
<ul>
<li>WAL:Write-Ahead logfile，防止写入内存后数据丢失，先写到这样一个日志文件中。类似于yarn中的edits文件。</li>
<li>保存实际数据的物理文件，StoreFile以HFile的形式存储在HDFS上。每个Store会有一个或多个StoreFile（HFile），数据在每个StoreFile中都是有序的。</li>
</ul>
<h3 id="写数据流程"><a href="#写数据流程" class="headerlink" title="写数据流程"></a>写数据流程</h3><p><a href="https://imgtu.com/i/RDKXHH"><img src="https://z3.ax1x.com/2021/06/30/RDKXHH.png" alt="RDKXHH.png"></a></p>
<p>meta表中存放了表的信息，而meta的元数据信息存放在ZK上。</p>
<ol>
<li><p>Client先访问zookeeper，获取hbase:meta（）表位于哪个Region Server，client如果在MetaCache中发现有该表的信息，就不会向ZK请求获取meta的位置了。</p>
</li>
<li><p>访问对应的Region Server，获取hbase:meta表，根据读请求的namespace:table/rowkey，查询出目标数据位于哪个Region Server中的哪个Region中。并将该table的region信息以及meta表的位置信息缓存在客户端的meta cache，方便下次访问。</p>
</li>
<li><p>与目标Region Server进行通讯；</p>
</li>
<li><p>将数据顺序写入（追加）到WAL；</p>
</li>
<li><p>将数据写入对应的MemStore，数据会在MemStore进行排序；</p>
</li>
<li><p>向客户端发送ack；</p>
</li>
<li><p>等达到MemStore的刷写时机后，将数据刷写到HFile（分布式存储中）。</p>
</li>
</ol>
<h3 id="MemStore的刷写时机"><a href="#MemStore的刷写时机" class="headerlink" title="MemStore的刷写时机"></a>MemStore的刷写时机</h3><ul>
<li>当某个memstroe的大小达到了<strong>hbase.hregion.memstore.flush.size</strong>（默认值128M），其所在region的所有memstore都会刷写。但是数据持续写入到memstore也不会达到128就刷，当memstore的大小达到了128*4时，会阻止继续往该memstore写数据。</li>
<li>Java heap size 堆栈大小, 指Java 虚拟机的内存大小。在Java虚拟机中，分配多少内存用于调用对象,函数和数组。因为底层中，函数和数组的调用在计算机中是用堆栈实现。</li>
<li>当region server中memstore的总大小达到<br><strong>java_heapsize*hbase.regionserver.global.memstore.size.upper.limit</strong>（默认值0.95），<br>Region server会把它的所有region按照其所有memstore的大小顺序（由大到小）依次进行刷写。直到region server中所有region的memstore的总大小减小到*<strong>hbase.regionserver.global.memstore.size.lower.limit</strong>以下。</li>
<li>当region server中memstore的总大小达到<br><strong>java_heapsize*hbase.regionserver.global.memstore.size</strong>（默认值0.4）<br>时，会阻止继续往所有的memstore写数据。</li>
<li>达到自动刷写时间。默认1h。<strong>hbase.regionserver.optionalcacheflushinterval</strong></li>
</ul>
<h3 id="读数据流程"><a href="#读数据流程" class="headerlink" title="读数据流程"></a>读数据流程</h3><p><a href="https://imgtu.com/i/RrMr7Q"><img src="https://z3.ax1x.com/2021/07/01/RrMr7Q.png" alt="RrMr7Q.png"></a></p>
<ul>
<li>与写数据流程差不多。说一下区别，去目标RegionServer读取数据时，会向Block Cache(读缓存),MemStore,StoreFile中查询数据，并将所有数据进行合并。此处所有数据是指同一条数据的不同版本（time stamp）或者不同的类型（Put/Delete）。</li>
<li>将从文件中查询到的数据块缓存到Block Cache中。客户端从读缓存中读取相应的数据。返回ACK。</li>
</ul>
<h3 id="StoreFile-Compaction"><a href="#StoreFile-Compaction" class="headerlink" title="StoreFile Compaction"></a>StoreFile Compaction</h3><ul>
<li><p>由于memstore每次刷写都会生成一个新的HFile，且同一个字段的不同版本（timestamp）和不同类型（Put/Delete）有可能会分布在不同的HFile中，因此查询时需要遍历所有的HFile。为了减少HFile的个数，以及清理掉过期和删除的数据，会进行StoreFile Compaction。</p>
</li>
<li><p>Compaction（合并）分为两种：分别是Minor Compaction和Major Compaction。</p>
</li>
<li><p>Minor Compaction会将临近的若干个较小的HFile合并成一个较大的HFile，但不会清理过期和删除的数据。默认是三个小文件会进行合并，达到一定的数量后也不会直接合并，会根据一个算法判断是否要进行合并。</p>
</li>
<li><p>Major Compaction会将一个Store下的所有的HFile合并成一个大HFile，并且会清理掉过期和删除的数据。比较耗费资源，默认是一星期进行一次。</p>
</li>
</ul>
<h3 id="Region-Split"><a href="#Region-Split" class="headerlink" title="Region Split"></a>Region Split</h3><ul>
<li><p>默认情况下，每个Table起初只有一个Region，随着数据的不断写入，Region会自动进行拆分。刚拆分时，两个子Region都位于当前的Region Server，但处于负载均衡的考虑，HMaster有可能会将某个Region转移给其他的Region Server。</p>
</li>
<li><p>分裂时机：如果当前RegionServer上只有一个Region，当这个Region中的所有Store file的总和超过2*hbase.hregion.memstore.flush.size分裂，否则按照超过hbase.hregion.max.filesize 分裂。</p>
</li>
<li><p>这样切分会尽量使每个Table的在每个RegionServer中的Region数量尽量一致。</p>
</li>
</ul>
<h2 id="Hive与HBase集成"><a href="#Hive与HBase集成" class="headerlink" title="Hive与HBase集成"></a>Hive与HBase集成</h2><ul>
<li>hive默认是有jar包可与HBase集成的，可以用Hive对HBase中的数据进行分析，再将分析结果又返回到HBase中，方便其它的工作对分析好的数据的使用。</li>
</ul>
<h2 id="Phoenix"><a href="#Phoenix" class="headerlink" title="Phoenix"></a>Phoenix</h2><ul>
<li>Phoenix是HBase的开源SQL皮肤。可以使用标准JDBC API代替HBase客户端API来创建表，插入数据和查询HBase数据。</li>
<li>可以用类sql语言操作hbase</li>
<li>优势：支持索引。</li>
</ul>
]]></content>
      <tags>
        <tag>大数据</tag>
        <tag>flume</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/09/22/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Hadoop简介</title>
    <url>/2020/10/21/hadoop-introduction/</url>
    <content><![CDATA[<h1 id="hadoop简介"><a href="#hadoop简介" class="headerlink" title="hadoop简介"></a>hadoop简介</h1><p>1.定义：<br>hadoop是一个开源分布式计算平台，为用户提供了底层细节透明的分布式基础框架。<br>2.特性：    </p>
<ul>
<li>高可靠性    </li>
<li>高效性</li>
<li>高可扩展性</li>
<li>高容错性</li>
<li>成本低</li>
<li>运行在linux中</li>
<li>支持多种编程语言</li>
</ul>
<p>3.版本</p>
<ul>
<li>1.0</li>
<li>2.0</li>
</ul>
<p>4.hadoop结构</p>
<ul>
<li><img src="https://img-blog.csdnimg.cn/20191024090622860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZtMzQ1Njg5,size_16,color_FFFFFF,t_70" alt="图片展示" title="Hadoop项目结构图"></li>
<li>参考别人博客的<a href="https://blog.csdn.net/fm345689/article/details/102715230">文字记录</a></li>
</ul>
<p>5.Hadoop项目核心模块</p>
<ul>
<li>Hadoop Common：为Hadoop其他模块提供支持实用程序。</li>
<li>HDFS：提供对应用程序数据的高吞吐量访问</li>
<li>Hadoop YARN：作业调度和集群资源管理的框架</li>
<li>MapReduce：YARN系统的大型数据集并行处理技术</li>
</ul>
<p>6.Hadoop RPC工作原理</p>
<p>7.MapReduce工作原理</p>
<blockquote>
<ul>
<li>策略：分而治之</li>
<li>计算向数据靠拢而不是数据向计算靠拢</li>
</ul>
</blockquote>
<p>8.HDFS工作原理</p>
<p>9.YARN工作原理</p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>老hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>project</title>
    <url>/2021/09/29/project/</url>
    <content><![CDATA[<h1 id="项目总结"><a href="#项目总结" class="headerlink" title="项目总结"></a>项目总结</h1><h2 id="数据采集项目"><a href="#数据采集项目" class="headerlink" title="数据采集项目"></a>数据采集项目</h2><ul>
<li>项目框架版本：<ul>
<li>hadoop 3.1.3<ul>
<li>Hadoop本身不支持LZO压缩，需要下载并重新编译hadoop-lzo</li>
<li>在core-site.xml增加配置支持LZO压缩</li>
<li>创建LZO索引，LZO压缩文件可切片的特性依赖于其索引</li>
</ul>
</li>
<li>flume 1.9</li>
<li>kafka 2.41</li>
<li>Zookeeper 3.5.7</li>
<li>hive 3.1.2</li>
<li>spark 2.1.1</li>
</ul>
</li>
<li>项目架构<ul>
<li><a href="https://imgtu.com/i/4fmBm8"><img src="https://z3.ax1x.com/2021/09/28/4fmBm8.png" alt="4fmBm8.png"></a></li>
</ul>
</li>
</ul>
<h3 id="日志数据采集平台"><a href="#日志数据采集平台" class="headerlink" title="日志数据采集平台"></a>日志数据采集平台</h3><ul>
<li><p>埋点用户行为数据的形式：</p>
<ul>
<li>存储在文件中</li>
<li>分为启动日志数据（启动日志=公共字段+启动事件数据）和事件日志数据</li>
</ul>
</li>
<li><p>埋点用户行为数据：（数据流动路径）</p>
<ul>
<li><p>生产flume数据流向</p>
</li>
<li><p><img src="file:///C:\Users\Hasee\AppData\Local\Temp\ksohtml\wps747A.tmp.jpg" alt="img"></p>
</li>
</ul>
</li>
<li><p>生产flume</p>
<ul>
<li><p>为什么用Kafka，基于磁盘，当数据峰值来临时可以消峰，暂时存储在Kafka中，防止太多数据涌入HDFS导致Hadoop 宕机。</p>
</li>
<li><p>采用TaiDirSource:支持断点续传，多目录。数据可能会重复，后续再处理</p>
</li>
<li><p>采用Kafka Channel：速度高于 MemoryChannel + KafkaSink</p>
</li>
<li><p>flume具体配置，flume配置文件一般命名成数据的走向形式，例如：file-flume-kafka.conf</p>
</li>
<li><p>flume 五步走：(具体配置查看官网的各个组件不同的案例)</p>
<ul>
<li>定义Source，Channel, Sink组件</li>
<li>配置Source</li>
<li>配置Channel</li>
<li>配置Sink</li>
<li>配置三者之间的关系</li>
</ul>
</li>
<li><p>配置拦截器</p>
<ul>
<li><p>打包，然后放到flume/lib/目录下 </p>
</li>
<li><p>ETL拦截器</p>
<ul>
<li>过滤时间戳不合法和Json数据不完整的数据。</li>
<li>实现Interceptor接口，重写initialize(),intercept()，close()方法，实现一个静态内部类，返回定义的拦截器对象。intercept()重载了两个，分别表示单event处理，多event处理（多event处理一般只需要在里面调用单event处理就行了）</li>
<li>启动日志判断是否是以“{”开头“}”结尾</li>
<li>判断事件日志的格式：<ul>
<li>1.是否是时间戳+logs，</li>
<li>2.时间戳是否是合法的时间戳：时间戳长度是否为13，NumberUtils.isDigits() :判断字符串中是否全为数字</li>
<li>logs是否以“{” 开头，“}” 结尾</li>
</ul>
</li>
</ul>
</li>
<li><p>日志类型区分拦截器</p>
<ul>
<li>主要是为了给ChannelSelector配置mutiplexing根据event头，将启动日志和事件日志分开，进入不同的KafkaTopic。</li>
<li>在intercept()方法中，getHeaders()，再根据body中的数据判断为启动日志还是事件日志，分别给头加上不同的标识，要与配置的flume 文件匹配。headers.put(“topic”,”topic_start”);headers.put(“topic”,”topic_event”);</li>
</ul>
</li>
</ul>
</li>
<li><p>生产flume配置</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">a1.sources</span>=r1<br><span class="hljs-attr">a1.channels</span>=c1 c2<br><br><span class="hljs-comment"># configure source</span><br><span class="hljs-attr">a1.sources.r1.type</span> = TAILDIR<br><span class="hljs-attr">a1.sources.r1.positionFile</span> = /opt/module/flume/test/log_position.json<br><span class="hljs-attr">a1.sources.r1.filegroups</span> = f1<br><span class="hljs-attr">a1.sources.r1.filegroups.f1</span> = /tmp/logs/app.+<br><span class="hljs-attr">a1.sources.r1.fileHeader</span> = <span class="hljs-literal">true</span><br><span class="hljs-attr">a1.sources.r1.channels</span> = c1 c2<br><br><span class="hljs-comment">#interceptor</span><br><span class="hljs-attr">a1.sources.r1.interceptors</span> =  i1 i2<br><span class="hljs-attr">a1.sources.r1.interceptors.i1.type</span> = com.zt.flume.interceptor.LogETLInterceptor<span class="hljs-variable">$Builder</span><br><span class="hljs-attr">a1.sources.r1.interceptors.i2.type</span> = com.zt.flume.interceptor.LogTypeInterceptor<span class="hljs-variable">$Builder</span><br><span class="hljs-comment">#配置多路复用，根据header的不同去往不同的channel</span><br><span class="hljs-attr">a1.sources.r1.selector.type</span> = multiplexing<br><span class="hljs-attr">a1.sources.r1.selector.header</span> = topic<br><span class="hljs-attr">a1.sources.r1.selector.mapping.topic_start</span> = c1<br><span class="hljs-attr">a1.sources.r1.selector.mapping.topic_event</span> = c2<br><br><span class="hljs-comment"># configure channel</span><br><span class="hljs-attr">a1.channels.c1.type</span> = org.apache.flume.channel.kafka.KafkaChannel<br><span class="hljs-attr">a1.channels.c1.kafka.bootstrap.servers</span> = hadoop100:<span class="hljs-number">9092</span>,hadoop101:<span class="hljs-number">9092</span>,hadoop102:<span class="hljs-number">9092</span><br><span class="hljs-attr">a1.channels.c1.kafka.topic</span> = topic_start<br><span class="hljs-comment">#配置parseAsFlumeEvent为false，不让header信息传到Kafka中去，只传输body中的数据</span><br><span class="hljs-attr">a1.channels.c1.parseAsFlumeEvent</span> = <span class="hljs-literal">false</span><br><span class="hljs-attr">a1.channels.c1.kafka.consumer.group.id</span> = flume-consumer<br><br><span class="hljs-attr">a1.channels.c2.type</span> = org.apache.flume.channel.kafka.KafkaChannel<br><span class="hljs-attr">a1.channels.c2.kafka.bootstrap.servers</span> = hadoop100:<span class="hljs-number">9092</span>,hadoop101:<span class="hljs-number">9092</span>,hadoop102:<span class="hljs-number">9092</span><br><span class="hljs-attr">a1.channels.c2.kafka.topic</span> = topic_event<br><span class="hljs-attr">a1.channels.c2.parseAsFlumeEvent</span> = <span class="hljs-literal">false</span><br><span class="hljs-attr">a1.channels.c2.kafka.consumer.group.id</span> = flume-consumer<br></code></pre></td></tr></table></figure>

<ul>
<li>–conf/-c:表示配置文件存储来conf/目录</li>
<li>–name/-n:表示给agent起名为a1</li>
<li>–conf-file/-f：flume本次读取的配置文件</li>
<li>-Dflume.root.logger=INFO,console ：-D表示flume运行时动态修改flume.root.logger参数属性值，并将控制台日志打印级别设置为INFO级别。日志级别包括:log、info、warn、error。</li>
<li>flume-ng agent –conf-file /opt/module/flume/conf/file-flume-kafka.conf –name a1 -Dflume.root.logger=INFO,LOGFILE</li>
</ul>
</li>
</ul>
</li>
<li><p>消费flume</p>
<ul>
<li><p><a href="https://imgtu.com/i/4fWyEq"><img src="https://z3.ax1x.com/2021/09/28/4fWyEq.png" alt="4fWyEq.png"></a></p>
</li>
<li><p>flume agent里面的组件更多的时候代表的是逻辑上的概念。比如两个KafkaChannel ,但是Kafka集群却可以有很多。</p>
</li>
<li><p>采用Kafka Source  FileChannel  HDFS Sink的方式传输数据</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-comment">## 组件</span><br><span class="hljs-attr">a1.sources</span>=r1 r2<br><span class="hljs-attr">a1.channels</span>=c1 c2<br><span class="hljs-attr">a1.sinks</span>=k1 k2<br><br><span class="hljs-comment">## source1</span><br><span class="hljs-attr">a1.sources.r1.type</span> = org.apache.flume.source.kafka.KafkaSource<br><span class="hljs-comment">#一次传出event的条数</span><br><span class="hljs-attr">a1.sources.r1.batchSize</span> = <span class="hljs-number">5000</span><br><span class="hljs-attr">a1.sources.r1.batchDurationMillis</span> = <span class="hljs-number">2000</span><br><span class="hljs-attr">a1.sources.r1.kafka.bootstrap.servers</span> = hadoop100:<span class="hljs-number">9092</span>,hadoop101:<span class="hljs-number">9092</span>,hadoop102:<span class="hljs-number">9092</span><br><span class="hljs-attr">a1.sources.r1.kafka.topics</span>=topic_start<br><br><span class="hljs-comment">## source2</span><br><span class="hljs-attr">a1.sources.r2.type</span> = org.apache.flume.source.kafka.KafkaSource<br><span class="hljs-attr">a1.sources.r2.batchSize</span> = <span class="hljs-number">5000</span><br><span class="hljs-attr">a1.sources.r2.batchDurationMillis</span> = <span class="hljs-number">2000</span><br><span class="hljs-attr">a1.sources.r2.kafka.bootstrap.servers</span> = hadoop100:<span class="hljs-number">9092</span>,hadoop101:<span class="hljs-number">9092</span>,hadoop102:<span class="hljs-number">9092</span><br><span class="hljs-attr">a1.sources.r2.kafka.topics</span>=topic_event<br><br><span class="hljs-comment">## channel1</span><br><span class="hljs-attr">a1.channels.c1.type</span> = file<br><span class="hljs-attr">a1.channels.c1.checkpointDir</span> = /opt/module/flume/checkpoint/behavior1<br><span class="hljs-attr">a1.channels.c1.dataDirs</span> = /opt/module/flume/data/behavior1/<br><span class="hljs-attr">a1.channels.c1.maxFileSize</span> = <span class="hljs-number">2146435071</span><br><span class="hljs-attr">a1.channels.c1.capacity</span> = <span class="hljs-number">1000000</span><br><span class="hljs-attr">a1.channels.c1.keep-alive</span> = <span class="hljs-number">6</span><br><br><span class="hljs-comment">## channel2</span><br><span class="hljs-attr">a1.channels.c2.type</span> = file<br><span class="hljs-attr">a1.channels.c2.checkpointDir</span> = /opt/module/flume/checkpoint/behavior2<br><span class="hljs-attr">a1.channels.c2.dataDirs</span> = /opt/module/flume/data/behavior2/<br><span class="hljs-attr">a1.channels.c2.maxFileSize</span> = <span class="hljs-number">2146435071</span><br><span class="hljs-attr">a1.channels.c2.capacity</span> = <span class="hljs-number">1000000</span><br><span class="hljs-attr">a1.channels.c2.keep-alive</span> = <span class="hljs-number">6</span><br><br><span class="hljs-comment">## sink1</span><br><span class="hljs-attr">a1.sinks.k1.type</span> = hdfs<br><span class="hljs-attr">a1.sinks.k1.hdfs.path</span> = /origin_data/gmall/log/topic_start/%Y-%m-%d<br><span class="hljs-attr">a1.sinks.k1.hdfs.filePrefix</span> = logstart-<br><br><span class="hljs-comment">##sink2</span><br><span class="hljs-attr">a1.sinks.k2.type</span> = hdfs<br><span class="hljs-attr">a1.sinks.k2.hdfs.path</span> = /origin_data/gmall/log/topic_event/%Y-%m-%d<br><span class="hljs-attr">a1.sinks.k2.hdfs.filePrefix</span> = logevent-<br><br><span class="hljs-comment">## 不要产生大量小文件</span><br><span class="hljs-attr">a1.sinks.k1.hdfs.rollInterval</span> = <span class="hljs-number">10</span><br><span class="hljs-attr">a1.sinks.k1.hdfs.rollSize</span> = <span class="hljs-number">134217728</span><br><span class="hljs-attr">a1.sinks.k1.hdfs.rollCount</span> = <span class="hljs-number">0</span><br><br><span class="hljs-attr">a1.sinks.k2.hdfs.rollInterval</span> = <span class="hljs-number">10</span><br><span class="hljs-attr">a1.sinks.k2.hdfs.rollSize</span> = <span class="hljs-number">134217728</span><br><span class="hljs-attr">a1.sinks.k2.hdfs.rollCount</span> = <span class="hljs-number">0</span><br><br><span class="hljs-comment">## 控制输出文件是原生文件。</span><br><span class="hljs-attr">a1.sinks.k1.hdfs.fileType</span> = CompressedStream <br><span class="hljs-attr">a1.sinks.k2.hdfs.fileType</span> = CompressedStream <br><br><span class="hljs-attr">a1.sinks.k1.hdfs.codeC</span> = lzop<br><span class="hljs-attr">a1.sinks.k2.hdfs.codeC</span> = lzop<br><br><span class="hljs-comment">## 三者之间的关系</span><br><span class="hljs-attr">a1.sources.r1.channels</span> = c1<br><span class="hljs-attr">a1.sinks.k1.channel</span>= c1<br><br><span class="hljs-attr">a1.sources.r2.channels</span> = c2<br><span class="hljs-attr">a1.sinks.k2.channel</span>= c2<br></code></pre></td></tr></table></figure></li>
<li><p>HDFS Sink产生小文件问题 </p>
<ul>
<li><p>a1.sinks.k1.hdfs.rollInterval = 10  多久生产一个新文件10s</p>
<p>a1.sinks.k1.hdfs.rollSize = 134217728  设置每个文件的滚动大小128M</p>
<p>a1.sinks.k1.hdfs.rollCount = 0    文件的滚动与Event数量无关  never roll based on number of events)</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="业务数据采集平台"><a href="#业务数据采集平台" class="headerlink" title="业务数据采集平台"></a>业务数据采集平台</h3><ul>
<li>电商常识<ul>
<li>SKU（库存量基本单位），每种产品均对应有唯一的SKU号</li>
<li>SPU（商品信息聚合的最小单位）</li>
<li>iPhoneX手机就是SPU。一台银色、128G内存的、支持联通网络的iPhoneX，就是SKU。</li>
</ul>
</li>
<li>电商业务表结构<ul>
<li><a href="https://imgtu.com/i/4hPENt"><img src="https://z3.ax1x.com/2021/09/28/4hPENt.png" alt="4hPENt.png"></a></li>
</ul>
</li>
</ul>
<ul>
<li><p>同步策略</p>
<ul>
<li>数据同步策略类型包括：全量同步策略，增量同步策略，新增及变化同步策略，特殊同步策略</li>
<li>全量表：存储完整的数据<ul>
<li>每日全量，就是每天存储一份完整数据，作为一个分区</li>
<li>适用于表数据量不大，且每天会有新数据插入，也会有旧数据修改的场景</li>
</ul>
</li>
<li>增量表：存储新增加的数据<ul>
<li>每日增量，就是每天存储一份增量数据，作为一个分区</li>
<li>适用于表数据量大，且每天只会有新数据插入的场景</li>
</ul>
</li>
<li>新增及变化表：存储新增加的数据和变化的数据<ul>
<li>每日新增及变化，就是存储创建时间和操作时间都是今天的数据。</li>
<li>适用场景，表的数据量大，既会有新增，又会有变化</li>
</ul>
</li>
<li>特殊表：只需要存储一次<ul>
<li>某些特殊的维度表，可不必遵循上述同步策略</li>
<li>客观世界维度：没有变化的客观世界维度（性别，地区，名族，政治成分，鞋子尺码）可以只存一份固定值。</li>
<li>日期维度：日期维度可以一次性导入一年或若干年的数据</li>
<li>地区维度：省份表，地区表</li>
</ul>
</li>
</ul>
</li>
<li><p>业务数据导入HDFS</p>
<ul>
<li><p>分析表同步策略</p>
<p><a href="https://imgtu.com/i/4hiS5q"><img src="https://z3.ax1x.com/2021/09/28/4hiS5q.png" alt="4hiS5q.png"></a></p>
<ul>
<li>活动参与商品表没有放入ods层</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>根据不同的同步策略，编写脚本把数据导入到HDFS中去。采用sqoop将数据传入，采用LZO压缩</li>
</ul>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程基础</title>
    <url>/2021/04/20/multithreading/</url>
    <content><![CDATA[<h1 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h1><h2 id="1-程序，进程，线程"><a href="#1-程序，进程，线程" class="headerlink" title="1.程序，进程，线程"></a>1.程序，进程，线程</h2><blockquote>
<ul>
<li>程序：（可以执行的静态代码，是保存在硬盘上的一个文件）是为完成特定任务，用某种语言编写的一组指令的集合。即<em><strong>一段静态的代码</strong></em>，静态对象.</li>
<li>进程：（正在执行中的一个程序，在内存中处于激活状态，有生命周期）是程序的一次执行过程，或是<em><strong>正在运行的一个程序</strong></em>。动态过程：有它自身的产生、存在和消亡的过程</li>
<li>线程：（进程中的子任务）进程可以进一步细化为线程，是一个程序内部的一条执行路径</li>
</ul>
</blockquote>
<h2 id="2-Java中多线程的创建和使用"><a href="#2-Java中多线程的创建和使用" class="headerlink" title="2.Java中多线程的创建和使用"></a>2.Java中多线程的创建和使用</h2><blockquote>
<ul>
<li>实现Runnable接口与继承Thread类</li>
<li><h3 id="Thread类的主要方法"><a href="#Thread类的主要方法" class="headerlink" title="Thread类的主要方法"></a>Thread类的主要方法</h3><blockquote>
<ul>
<li>每个线程都是通过某个特定Thread对象的run()方法来完成操作的，经常把run()方法的主题称为线程体</li>
<li>通过该Thread对象的start()方法来调用这个线程</li>
<li>static Thread currentThread(),返回当前方法正在执行此方法所压入的栈的线程对象</li>
<li>void join()它的作用是调用此方法的另一个线程阻塞，当前线程执行完再执行另一个线程</li>
<li>static void sleep(long millis)作用是让当前线程（正在执行此方法的栈的线程）进入睡眠状态<blockquote>
<ul>
<li>两种方式结束sleep状态：1.时间到了。2.被其他进程打断 interrupt() 方法</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="创建并启动线程的方式"><a href="#创建并启动线程的方式" class="headerlink" title="创建并启动线程的方式"></a>创建并启动线程的方式</h3><h4 id="实现Runnable的方式"><a href="#实现Runnable的方式" class="headerlink" title="实现Runnable的方式"></a>实现Runnable的方式</h4><blockquote>
<blockquote>
<ol>
<li>写一个具体类，实现Runnable接口，并实现接口中的抽象方法run(),这个run方法就是线程体</li>
<li>创建这个具体类对象，并把这个对象作为实参，创建Thread线程对象</li>
<li>调用Thread线程对象的start方法</li>
</ol>
<ul>
<li>代码示例</li>
</ul>
</blockquote>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> multi_thread;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">200</span>;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>		System.out.println(cnt);<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>			<span class="hljs-keyword">synchronized</span> (<span class="hljs-string">&quot;&quot;</span>) &#123;<span class="hljs-comment">// ()中是一个锁对象，任意对象都可以做锁，称为互斥锁，作用是只允许一个线程进入执行，其他线程等待</span><br><br>				cnt -= <span class="hljs-number">2</span>;<br>				<span class="hljs-keyword">try</span> &#123;<br>					Thread.sleep(<span class="hljs-number">10</span>);<br>				&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>					<span class="hljs-comment">// TODO Auto-generated catch block</span><br>					e.printStackTrace();<br>				&#125;<br>				System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;: &quot;</span> + cnt);<br>			&#125;<br>		&#125;<br>	&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> multi_thread;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CounterTest</span> </span>&#123;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		Runnable counter = <span class="hljs-keyword">new</span> Counter();<br>		Thread thread1 = <span class="hljs-keyword">new</span> Thread(counter);<br>		Thread thread2 = <span class="hljs-keyword">new</span> Thread(counter);<br>		thread1.start();<br>		thread2.start();<br>	&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>
<h4 id="继承Thread的方式"><a href="#继承Thread的方式" class="headerlink" title="继承Thread的方式"></a>继承Thread的方式</h4><blockquote>
<blockquote>
<ol>
<li>写一个类，继承Thread,并重写run方法，此方法就是线程体</li>
<li>创建这个类的对象，相当于创建了线程对象</li>
<li>调用这个线程对象的start方法</li>
</ol>
<ul>
<li>代码示例</li>
</ul>
</blockquote>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> multi_thread;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++) &#123;<br>			System.out.println(currentThread().getName()+<span class="hljs-string">&quot; &quot;</span>+i);<br>		&#125;<br>	&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTest2</span> </span>&#123;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		Thread myThread1 = <span class="hljs-keyword">new</span> MyThread();<br>		myThread1.start();<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++) &#123;<br>			System.out.println(<span class="hljs-string">&quot;-----main &quot;</span>+i);<br>		&#125;<br>	&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>
<h4 id="使用callable接口创建多线程"><a href="#使用callable接口创建多线程" class="headerlink" title="使用callable接口创建多线程"></a>使用callable接口创建多线程</h4><blockquote>
<ul>
<li>落地方法call()</li>
<li>Callable接口作为JDK1.5新增的接口，与使用Runnable相比其功能更强大些。</li>
<li>相比run()方法，可以有返回值</li>
<li>方法可以抛出异常</li>
<li>支持泛型的返回值</li>
<li>需要借助FutureTask类，比如获取返回结果。</li>
<li>Callable接口一般用于配合ExecutorService使用</li>
</ul>
</blockquote>
<h5 id="Feture接口"><a href="#Feture接口" class="headerlink" title="Feture接口"></a>Feture接口</h5><blockquote>
<ul>
<li>可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等。</li>
<li>FutrueTask是Futrue接口的实现类</li>
<li>FutureTask 同时实现了Runnable, Future接口。它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。</li>
<li>多个线程同时执行一个FutureTask，只要一个线程执行完毕，其他线程不会再执行其call()方法。</li>
<li>get()方法会阻塞当前线程！<br>实例代码:</li>
</ul>
</blockquote>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> MyThread implements Callable&lt;<span class="hljs-type">Integer</span>&gt; &#123;<br>	@Override<br>	<span class="hljs-built_in">public</span> <span class="hljs-type">Integer</span> <span class="hljs-keyword">call</span>() throws <span class="hljs-keyword">Exception</span> &#123;<br>		<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(Thread.currentThread().getName()+&quot; Come in call&quot;);<br>		//睡<span class="hljs-number">5</span>秒<br>		TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);<br>		//返回<span class="hljs-number">200</span>的状态码<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">200</span>;<br>		<br>	&#125;<br>&#125;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> CallableTest &#123;<br>	<span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) throws InterruptedException, ExecutionException &#123;<br>		MyThread myThread = <span class="hljs-built_in">new</span> MyThread();<br>		FutureTask&lt;<span class="hljs-type">Integer</span>&gt; futureTask = <span class="hljs-built_in">new</span> FutureTask&lt;&gt;(myThread);<br>		<span class="hljs-built_in">new</span> Thread(futureTask, &quot;未来任务&quot;).<span class="hljs-keyword">start</span>();<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;主线程结束！&quot;);<br>		<span class="hljs-type">Integer</span> <span class="hljs-type">integer</span> = futureTask.<span class="hljs-keyword">get</span>();<br>		<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-type">integer</span>);<br>		<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="线程池创建多线程"><a href="#线程池创建多线程" class="headerlink" title="线程池创建多线程"></a>线程池创建多线程</h4><blockquote>
<ul>
<li>线程池：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。因此提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。</li>
<li>优点<blockquote>
<ol>
<li>提高响应速度（减少了创建新线程的时间）</li>
<li>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</li>
<li>便于线程管理    </li>
</ol>
</blockquote>
</li>
<li>ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor。</li>
<li>void execute(Runnable command) ：执行任务/命令，没有返回值，一般用来执行Runnable</li>
<li><T> Future<T> submit(Callable<T> task)：执行任务，有返回值，一般用来执行Callable</li>
<li>void shutdown() ：关闭连接池</li>
<li>创建线程池的方式：<blockquote>
<ol>
<li>直接通过ThreadPoolExecutor实现类new</li>
<li>通过工厂类Executors的静态方法创建，本质上也是通过1)创建的线程池</li>
</ol>
</blockquote>
</li>
</ul>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>		<span class="hljs-comment">//创建一个包含10个线程的线程池</span><br>		ExecutorService executorService = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Executors</span>.</span></span><span class="hljs-keyword">new</span><span class="hljs-constructor">FixedThreadPool(10)</span>;<br><span class="hljs-comment">//		ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br>		<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">12</span>; i++) &#123;<br>			executorService.execute(<span class="hljs-literal">()</span>-&gt;&#123;<br>				<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>);<br>			&#125;);<br>		&#125;<br>		executorService.shutdown<span class="hljs-literal">()</span>;<br>	&#125;<br></code></pre></td></tr></table></figure>
<h2 id="3-线程的同步"><a href="#3-线程的同步" class="headerlink" title="3.线程的同步"></a>3.线程的同步</h2><blockquote>
<ul>
<li>synchronized (lock){}</li>
<li>()中是一个锁对象，任意对象都可以做锁，称为互斥锁，作用是只允许一个线程进入执行，其他线程等待</li>
<li>具有原子性，不可分割</li>
<li>synchronized()可重入锁（同一个线程可以无限次获取同一个锁）</li>
<li>避免死锁：不要嵌套synchronized，即使有嵌套，锁对象尽量少</li>
</ul>
</blockquote>
<h3 id="synchronized和Lock的区别"><a href="#synchronized和Lock的区别" class="headerlink" title="synchronized和Lock的区别"></a>synchronized和Lock的区别</h3><blockquote>
<ul>
<li>synchronized不需要手动上锁和解锁，lock需要手动上锁和解锁</li>
<li>synchronized能实现的功能lock都可以实现，且lock更加强大</li>
</ul>
</blockquote>
<h2 id="JUC工具类"><a href="#JUC工具类" class="headerlink" title="JUC工具类"></a>JUC工具类</h2><h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">package com.atguigu.juc;<br><br>import java.util.concurrent.ExecutorService;<br>import java.util.concurrent.Executors;<br>import java.util.concurrent.locks.ReadWriteLock;<br>import java.util.concurrent.locks.ReentrantReadWriteLock;<br><br><span class="hljs-keyword">class</span> MyQueue &#123;<br>	<span class="hljs-comment">// 创建读写锁</span><br>	ReadWriteLock rwl = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ReentrantReadWriteLock()</span>;<br><br>	<span class="hljs-keyword">private</span> Object obj;<br><br>	public void read<span class="hljs-constructor">Obj()</span> &#123;<br>		<span class="hljs-comment">// 上读锁</span><br>		rwl.read<span class="hljs-constructor">Lock()</span>.lock<span class="hljs-literal">()</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">&quot;当前线程读到的内容是：&quot;</span> + obj);<br><br>		&#125; finally &#123;<br>			<span class="hljs-comment">// 解读锁</span><br>			rwl.read<span class="hljs-constructor">Lock()</span>.unlock<span class="hljs-literal">()</span>;<br>		&#125;<br>	&#125;<br><br>	public void write<span class="hljs-constructor">Obj(Object <span class="hljs-params">obj</span>)</span> &#123;<br>		<span class="hljs-comment">// 上写锁</span><br>		rwl.write<span class="hljs-constructor">Lock()</span>.lock<span class="hljs-literal">()</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			this.obj = obj;<br>			<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">&quot;当前线程写入的内容是：&quot;</span> + obj);<br>		&#125; finally &#123;<br>			<span class="hljs-comment">// 解写锁</span><br>			rwl.write<span class="hljs-constructor">Lock()</span>.unlock<span class="hljs-literal">()</span>;<br>		&#125;<br>	&#125;<br><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @Description: 一个线程写入,100个线程读取</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> */</span><br>public <span class="hljs-keyword">class</span> ReadWriteLockDemo &#123;<br>	public static void main(String<span class="hljs-literal">[]</span> args) throws InterruptedException &#123;<br>		<span class="hljs-comment">// 创建资源对象</span><br>		MyQueue mq = <span class="hljs-keyword">new</span> <span class="hljs-constructor">MyQueue()</span>;<br>		<span class="hljs-comment">// 一个线程写入</span><br>		<span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(()</span> -&gt; &#123;<br>			mq.write<span class="hljs-constructor">Obj(<span class="hljs-string">&quot;写入的内容&quot;</span>)</span>;<br>		&#125;, <span class="hljs-string">&quot;AA&quot;</span>).start<span class="hljs-literal">()</span>;<br>		<span class="hljs-comment">// 100个线程读取</span><br>		ExecutorService executorService = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Executors</span>.</span></span><span class="hljs-keyword">new</span><span class="hljs-constructor">FixedThreadPool(100)</span>;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>			executorService.execute(<span class="hljs-literal">()</span> -&gt; &#123;<br>				mq.read<span class="hljs-constructor">Obj()</span>;<br>			&#125;);<br>		&#125;<br>		executorService.shutdown<span class="hljs-literal">()</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">package com.atguigu.juc;<br><br>import java.util.concurrent.CountDownLatch;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @Description:</span><br><span class="hljs-comment"> *  *让一些线程阻塞直到另一些线程完成一系列操作后才被唤醒。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 解释：6个同学陆续离开教室后值班同学才可以关门。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * main主线程必须要等前面6个线程完成全部工作后，自己才能开干 </span><br><span class="hljs-comment"> */</span><br>public <span class="hljs-keyword">class</span> CountDownLatchDemo<br>&#123;<br>	public static void main(String<span class="hljs-literal">[]</span> args) throws InterruptedException<br>	&#123;<br>		CountDownLatch cd = <span class="hljs-keyword">new</span> <span class="hljs-constructor">CountDownLatch(6)</span>;<br>		<span class="hljs-comment">//6个同学离开教室</span><br>		<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">6</span>; i++) &#123;<br>			<span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(()</span>-&gt;&#123;<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>+<span class="hljs-string">&quot;号同学离开教室&quot;</span>);&#125;, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>value<span class="hljs-constructor">Of(<span class="hljs-params">i</span>)</span>).start<span class="hljs-literal">()</span>;<br>		<span class="hljs-comment">//减少计数</span><br>			cd.count<span class="hljs-constructor">Down()</span>;<br>		&#125;<br>		<span class="hljs-comment">//等待		</span><br>		cd.await<span class="hljs-literal">()</span>;<br>		<span class="hljs-comment">//班长锁门</span><br>		<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>+<span class="hljs-string">&quot;班长锁门&quot;</span>);<br>	&#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino">package com.atguigu.juc;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.BrokenBarrierException;<br><span class="hljs-keyword">import</span> java.util.concurrent.CyclicBarrier;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @Description: TODO(这里用一句话描述这个类的作用)  </span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * CyclicBarrier</span><br><span class="hljs-comment"> * 的字面意思是可循环（Cyclic）使用的屏障（Barrier）。它要做的事情是，</span><br><span class="hljs-comment"> * 让一组线程到达一个屏障（也可以叫同步点）时被阻塞，</span><br><span class="hljs-comment"> * 直到最后一个线程到达屏障时，屏障才会开门，所有</span><br><span class="hljs-comment"> * 被屏障拦截的线程才会继续干活。</span><br><span class="hljs-comment"> * 线程进入屏障通过CyclicBarrier的await()方法。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 集齐7颗龙珠就可以召唤神龙</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CyclicBarrierDemo</span></span><br><span class="hljs-class">&#123;</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> NUMBER = <span class="hljs-number">7</span>;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-comment">//CyclicBarrier(int parties, Runnable barrierAction) </span><br>		CyclicBarrier cb = <span class="hljs-keyword">new</span> CyclicBarrier(NUMBER, ()-&gt; &#123;System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;可以召唤神龙了&quot;</span>);&#125;);<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=NUMBER;i++) &#123;<br>			<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;System.out.<span class="hljs-built_in">println</span>(Thread.currentThread().getName()+<span class="hljs-string">&quot;号被收集&quot;</span>);<br>			<span class="hljs-keyword">try</span> &#123;<br>				cb.await();<br>			&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>				e.printStackTrace();<br>			&#125; <br>			&#125;,<span class="hljs-keyword">String</span>.valueOf(i) ).start();<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">package com.atguigu.juc;<br><br>import java.util.Random;<br>import java.util.concurrent.Semaphore;<br>import java.util.concurrent.TimeUnit;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @Description: TODO(这里用一句话描述这个类的作用)</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> *               在信号量上我们定义两种操作： acquire（获取）</span><br><span class="hljs-comment"> *               当一个线程调用acquire操作时，它要么通过成功获取信号量（信号量减1）， 要么一直等下去，直到有线程释放信号量，或超时。</span><br><span class="hljs-comment"> *               release（释放）实际上会将信号量的值加1，然后唤醒等待的线程。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> *               信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> *               情景：3个停车位，6部汽车争抢车位</span><br><span class="hljs-comment"> */</span><br>public <span class="hljs-keyword">class</span> SemaphoreDemo &#123;<br>	public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>		<span class="hljs-comment">// 3个停车位</span><br>		Semaphore semaphore = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Semaphore(3)</span>;<br>		<span class="hljs-comment">// 6部汽车抢车位</span><br>		<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">6</span>; i++) &#123;<br>			<span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(()</span> -&gt; &#123;<br>				<span class="hljs-comment">// 获取资源</span><br>				<span class="hljs-keyword">try</span> &#123;<br>					semaphore.acquire<span class="hljs-literal">()</span>;<br>					<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">&quot;号驶入停车位&quot;</span>);<br>					<span class="hljs-comment">// 停车3秒</span><br>					<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TimeUnit</span>.</span><span class="hljs-module"><span class="hljs-identifier">SECONDS</span>.</span></span>sleep(<span class="hljs-number">3</span>);<br>					<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">&quot;号驶出停车位&quot;</span>);<br>					<span class="hljs-comment">// 释放资源</span><br>					semaphore.release<span class="hljs-literal">()</span>;<br>				&#125; catch (Exception e) &#123;<br>					e.print<span class="hljs-constructor">StackTrace()</span>;<br>				&#125;<br>			&#125;, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>value<span class="hljs-constructor">Of(<span class="hljs-params">i</span>)</span>).start<span class="hljs-literal">()</span>;<br>		&#125;<br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>project_logcollect</title>
    <url>/2021/07/04/project-logcollect/</url>
    <content><![CDATA[<h1 id="电商采集项目搭建流程"><a href="#电商采集项目搭建流程" class="headerlink" title="电商采集项目搭建流程"></a>电商采集项目搭建流程</h1><h2 id="自动生成数据脚本"><a href="#自动生成数据脚本" class="headerlink" title="自动生成数据脚本"></a>自动生成数据脚本</h2><ul>
<li>生成用于测试的数据</li>
</ul>
<h2 id="数据采集模块"><a href="#数据采集模块" class="headerlink" title="数据采集模块"></a>数据采集模块</h2><h3 id="Hadoop安装"><a href="#Hadoop安装" class="headerlink" title="Hadoop安装"></a>Hadoop安装</h3><ul>
<li><p>在这里只说以下大致步骤以及容易出错的地方</p>
</li>
<li><p>配置集群之间分发数据的脚本，以及集群之间ssh免密登录</p>
</li>
<li><p>hadoop安装，解压就行，注意解压的目录。</p>
</li>
<li><p>核心文件配置：</p>
<ul>
<li><font color=red>core-site.xml</font>文件配置</li>
<li><font color=red>hdfs-site.xml</font>文件配置，因为是测试，在这里设置HDFS副本数量为1，防止存储不够，浪费存储。</li>
<li><font color=red>yran-site.xml</font>文件配置</li>
<li><font color=red>mapred-site.xml</font>文件</li>
<li>workers文件配置，注意不用多打空格等输入错误，里面配置hadoop的datanode节点的主机名。</li>
</ul>
</li>
<li><p>第一次启动注意要先格式化namenode。bin/hdfs namenode -format</p>
</li>
<li><p>常见web客户端：</p>
<ul>
<li>hadoop100:9870。HDFS的Web界面</li>
<li>yarn的web界面：hadoop101:8088</li>
<li>历史服务器hadoop102:19888</li>
</ul>
</li>
<li><p>单点启动关闭命令</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment">#HDFS组件</span><br>hdfs --daemon <span class="hljs-literal">start</span>/<span class="hljs-literal">stop</span> namenode/datanode/secondarynamenode<br><span class="hljs-comment">#Yarn</span><br>yarn --daemon <span class="hljs-literal">start</span>/<span class="hljs-literal">stop</span>  resourcemanager/nodemanager<br><span class="hljs-comment">#历史服务器</span><br>mapred --daemon <span class="hljs-literal">start</span> historyserver<br></code></pre></td></tr></table></figure></li>
<li><p>配置历史服务器</p>
</li>
<li><p>配置日志的聚集</p>
</li>
<li><p>集群时间同步</p>
</li>
<li><p>配置一下压缩</p>
</li>
<li><p>可以测试一下集群基础性能</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><br>读写性能测试<br><span class="hljs-comment">#读取HDFS集群的10个128M文件</span><br>hadoop jar <span class="hljs-regexp">/opt/m</span>odule<span class="hljs-regexp">/hadoop-3.1.3/</span>share<span class="hljs-regexp">/hadoop/m</span>apreduce/hadoop-mapreduce-client-jobclient-<span class="hljs-number">3.1</span>.<span class="hljs-number">3</span>-tests.jar TestDFSIO -read -nrFiles <span class="hljs-number">10</span> -fileSize <span class="hljs-number">128</span>MB<br><span class="hljs-comment">#删除测试数据</span><br>hadoop jar <span class="hljs-regexp">/opt/m</span>odule<span class="hljs-regexp">/hadoop-3.1.3/</span>share<span class="hljs-regexp">/hadoop/m</span>apreduce/hadoop-mapreduce-client-jobclient-<span class="hljs-number">3.1</span>.<span class="hljs-number">3</span>-tests.jar TestDFSIO -clean<br><br>运算速度测试<br><span class="hljs-comment">#使用RandomWriter来产生随机数，每个节点运行10个Map任务，每个Map产生大约1G大小的二进制随机数</span><br>hadoop jar <span class="hljs-regexp">/opt/m</span>odule<span class="hljs-regexp">/hadoop-3.1.3/</span>share<span class="hljs-regexp">/hadoop/m</span>apreduce/hadoop-mapreduce-examples-<span class="hljs-number">3.1</span>.<span class="hljs-number">3</span>.jar randomwriter random-data<br><span class="hljs-comment">#执行排序程序</span><br>hadoop jar <span class="hljs-regexp">/opt/m</span>odule<span class="hljs-regexp">/hadoop-3.1.3/</span>share<span class="hljs-regexp">/hadoop/m</span>apreduce/hadoop-mapreduce-examples-<span class="hljs-number">3.1</span>.<span class="hljs-number">3</span>.jar sort random-data sorted-data<br><span class="hljs-comment">#验证数据是否排序成功</span><br>hadoop jar <span class="hljs-regexp">/opt/m</span>odule<span class="hljs-regexp">/hadoop-3.1.3/</span>share<span class="hljs-regexp">/hadoop/m</span>apreduce/hadoop-mapreduce-client-jobclient-<span class="hljs-number">3.1</span>.<span class="hljs-number">3</span>-tests.jar testmapredsort -sortInput random-data -sortOutput sorted-data<br></code></pre></td></tr></table></figure></li>
</ul>
<p><a href="https://imgtu.com/i/RWzQ8f"><img src="https://z3.ax1x.com/2021/07/04/RWzQ8f.png" alt="RWzQ8f.png"></a></p>
<h3 id="ZooKeeper安装"><a href="#ZooKeeper安装" class="headerlink" title="ZooKeeper安装"></a>ZooKeeper安装</h3><ul>
<li><p>在/zookeeper-3.5.7/这个目录下创建zkData</p>
</li>
<li><p>在/zookeeper-3.5.7/zkData目录下创建一个myid的文件，myid唯一。</p>
</li>
<li><p>重命名/zookeeper-3.5.7/conf这个目录下的zoo_sample.cfg为zoo.cfg</p>
</li>
<li><p>修改数据存储路径：dataDir=/opt/module/zookeeper-3.5.7/zkData</p>
</li>
<li><p>cluster下增加集群配置</p>
</li>
</ul>
<h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><ul>
<li><p>Kafka遇到的坑：– Error while fetching metadata with correlation id : {LEADER_NOT_AVAILABLE}</p>
<ul>
<li><p>原因：无法识别Kafka hostname</p>
</li>
<li><p>解决：修改kafka/config/server.properties配置</p>
</li>
<li><p>配置llisteners=PLAINTEXT://hadoop100:9092</p>
</li>
<li><p> 配置advertised.listeners=PLAINTEXT://hadoop100:9092</p>
</li>
</ul>
</li>
<li><p>Kafka压力测试</p>
</li>
</ul>
<h3 id="项目基础架构"><a href="#项目基础架构" class="headerlink" title="项目基础架构"></a>项目基础架构</h3><ul>
<li><a href="https://imgtu.com/i/W5gHcF"><img src="https://z3.ax1x.com/2021/07/27/W5gHcF.png" alt="W5gHcF.png"></a></li>
</ul>
]]></content>
      <categories>
        <category>项目</category>
        <category>电商数据采集项目</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>电商采集项目</tag>
      </tags>
  </entry>
  <entry>
    <title>shell介绍</title>
    <url>/2021/05/11/shell_introduction/</url>
    <content><![CDATA[<h1 id="shell介绍"><a href="#shell介绍" class="headerlink" title="shell介绍"></a>shell介绍</h1><h2 id="shell简介"><a href="#shell简介" class="headerlink" title="shell简介"></a>shell简介</h2><ul>
<li><p>shell是一个命令行解释器，它接受应用程序或者用户命令，然后调用操作系统内核</p>
</li>
<li><p>Linux提供的解释器有：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@hadoop101 ~]$ cat /etc/shells <br>/bin/sh<br>/bin/bash<br>/sbin/nologin<br>/bin/dash<br>/bin/tcsh<br>/bin/csh<br></code></pre></td></tr></table></figure></li>
<li><p>Centos默认的解析器是bash</p>
</li>
<li><p>bash和sh的关系：sh是引用了bash，最终sh实际上还是bash命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@hadoop101 bin]$ ll | grep bash<br>-rwxr-xr-x. 1 root root 941880 5月  11 2016 bash<br>lrwxrwxrwx. 1 root root      4 5月  27 2017 sh -&gt; bash<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="shell脚本基本格式"><a href="#shell脚本基本格式" class="headerlink" title="shell脚本基本格式"></a>shell脚本基本格式</h2><ul>
<li><p>脚本以<font color=red>#!/bin/bash</font>开头</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@hadoop101 datas]$ touch helloworld.sh<br>[root@hadoop101 datas]$ vi helloworld.sh<br><br>在helloworld.sh中输入如下内容<br><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>echo &quot;helloworld&quot;<br></code></pre></td></tr></table></figure></li>
<li><p>执行方式</p>
<ul>
<li><p>采用bash或sh+脚本的相对路径或绝对路径（不用赋予脚本+x权限）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sh helloworld.sh<br>bash helloworld.sh<br></code></pre></td></tr></table></figure></li>
<li><p>采用输入脚本的绝对路径或相对路径执行脚本（必须具有可执行权限+x）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">chmod +x helloworld.sh<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>第一种执行方法，本质是bash解析器帮你执行脚本，所以脚本本身不需要执行权限。第二种执行方法，本质是脚本需要自己执行，所以需要执行权限。</p>
</li>
</ul>
<h2 id="shell中的变量"><a href="#shell中的变量" class="headerlink" title="shell中的变量"></a>shell中的变量</h2><h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><ul>
<li><p>常用系统变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@hadoop101 datas]$ echo $HOME<br>/home/atguigu<br><span class="hljs-meta">#</span><span class="bash"> 常用系统变量 <span class="hljs-variable">$HOME</span>、<span class="hljs-variable">$PWD</span>、<span class="hljs-variable">$SHELL</span>、<span class="hljs-variable">$USER</span></span><br><span class="hljs-meta">#</span><span class="bash">显示当前shell中所有变量</span><br>set<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h3><ul>
<li><p>（1）定义变量：变量=值 </p>
<p>（2）撤销变量：unset 变量</p>
<p>（3）声明静态变量：readonly变量，注意：不能unset</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@hadoop101 datas]$ A=5<br>[root@hadoop101 datas]$ echo $A<br>5<br>[root@hadoop101 datas]$ unset A<br>[root@hadoop101 datas]$ echo $A<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">	<span class="hljs-variable">$n</span>	（功能描述：n为数字，<span class="hljs-variable">$0</span>代表该脚本名称，<span class="hljs-variable">$1</span>-<span class="hljs-variable">$9</span>代表第一到第九个参数，十以上的参数，十以上的参数需要用大括号包含，如<span class="hljs-variable">$&#123;10&#125;</span>）</span><br><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-variable">$#</span>	（功能描述：获取所有输入参数个数，常用于循环）。</span><br><span class="hljs-meta">#</span><span class="bash">	$*	（功能描述：这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体）</span><br><span class="hljs-meta">#</span><span class="bash">	<span class="hljs-variable">$@</span>	（功能描述：这个变量也代表命令行中所有的参数，不过<span class="hljs-variable">$@</span>把每个参数区分对待）</span><br><span class="hljs-meta">#</span><span class="bash"> $？	（功能描述：最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值为非0（具体是哪个数，由命令自己来决定），则证明上一个命令执行不正确了。）</span><br><br></code></pre></td></tr></table></figure>



<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">（1）“$((运算式))”或“$[运算式]”</span><br><span class="hljs-meta">#</span><span class="bash">（2）expr  + , - , \*,  /,  %    加，减，乘，除，取余</span><br><span class="hljs-meta">#</span><span class="bash">注意：expr运算符间要有空格</span><br>expr 2 + 3<br></code></pre></td></tr></table></figure>



<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">[ condition ]（注意condition前后要有空格）</span><br><span class="hljs-meta">#</span><span class="bash">注意：条件非空即为<span class="hljs-literal">true</span>，[ atguigu ]返回<span class="hljs-literal">true</span>，[] 返回<span class="hljs-literal">false</span>。</span><br><span class="hljs-meta">#</span><span class="bash">两个整数之间比较</span><br><span class="hljs-meta">#</span><span class="bash">2. 常用判断条件</span><br>字符串比较<br><br>字符串比较：<br>    =       等于,如:if [ &quot;$a&quot; = &quot;$b&quot; ]<br>    ==     等于,如:if [ &quot;$a&quot; == &quot;$b&quot; ], 与=等价<br>               注意:==的功能在[[]]和[]中的行为是不同的,如下:<br>               1 [[ $a == z* ]]    # 如果$a以&quot;z&quot;开头(模式匹配)那么将为true<br>               2 [[ $a == &quot;z*&quot; ]] # 如果$a等于z*(字符匹配),那么结果为true<br>               3<br>               4 [ $a == z* ]      # File globbing 和word splitting将会发生<br>               5 [ &quot;$a&quot; == &quot;z*&quot; ] # 如果$a等于z*(字符匹配),那么结果为true<br><br>    !=      不等于,如:if [ &quot;$a&quot; != &quot;$b&quot; ]， 这个操作符将在[[]]结构中使用模式匹配.<br>    &lt;       小于,在ASCII字母顺序下.如:<br>               if [[ &quot;$a&quot; &lt; &quot;$b&quot; ]]<br>               if [ &quot;$a&quot; \&lt; &quot;$b&quot; ]     在[]结构中&quot;&lt;&quot;需要被转义.<br>    &gt;       大于,在ASCII字母顺序下.如:<br>           if [[ &quot;$a&quot; &gt; &quot;$b&quot; ]]<br>           if [ &quot;$a&quot; \&gt; &quot;$b&quot; ]  在[]结构中&quot;&gt;&quot;需要被转义.<br>    -z       字符串为&quot;null&quot;.就是长度为0.<br>    -n       字符串不为&quot;null&quot;<br><span class="hljs-meta">#</span><span class="bash">（1）两个整数之间比较</span><br><span class="hljs-meta">#</span><span class="bash">-lt 小于（less than）			-le 小于等于（less equal）</span><br><span class="hljs-meta">#</span><span class="bash">-eq 等于（equal）				-gt 大于（greater than）</span><br><span class="hljs-meta">#</span><span class="bash">-ge 大于等于（greater equal）	-ne 不等于（Not equal）</span><br><span class="hljs-meta">#</span><span class="bash">（2）按照文件权限进行判断</span><br><span class="hljs-meta">#</span><span class="bash">-r 有读的权限（<span class="hljs-built_in">read</span>）			-w 有写的权限（write）</span><br><span class="hljs-meta">#</span><span class="bash">-x 有执行的权限（execute）</span><br><span class="hljs-meta">#</span><span class="bash">（3）按照文件类型进行判断</span><br><span class="hljs-meta">#</span><span class="bash">-f 文件存在并且是一个常规的文件（file）</span><br><span class="hljs-meta">#</span><span class="bash">-e 文件存在（existence）		-d 文件存在并是一个目录（directory）</span><br></code></pre></td></tr></table></figure>

<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><ul>
<li>if语句</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">（1）[ 条件判断式 ]，中括号和条件判断式之间必须有空格</span><br><span class="hljs-meta">#</span><span class="bash">（2）<span class="hljs-keyword">if</span>后要有空格</span><br><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><br>if [ $1 -eq &quot;1&quot; ]<br>then<br>        echo &quot;banzhang zhen shuai&quot;<br>elif [ $1 -eq &quot;2&quot; ]<br>then<br>        echo &quot;cls zhen mei&quot;<br>fi<br><br></code></pre></td></tr></table></figure>

<ul>
<li><p>case语句</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">1)<span class="hljs-keyword">case</span>行尾必须为单词“<span class="hljs-keyword">in</span>”，每一个模式匹配必须以右括号“）”结束。</span><br><span class="hljs-meta">#</span><span class="bash">2)双分号“;;”表示命令序列结束，相当于java中的<span class="hljs-built_in">break</span>。</span><br><span class="hljs-meta">#</span><span class="bash">3)最后的“*）”表示默认模式，相当于java中的default。</span><br><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><br>case $1 in<br>&quot;1&quot;)<br>        echo &quot;banzhang&quot;<br>;;<br><br>&quot;2&quot;)<br>        echo &quot;cls&quot;<br>;;<br>*)<br>        echo &quot;renyao&quot;<br>;;<br>esac<br></code></pre></td></tr></table></figure></li>
<li><p>for循环</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 基本语法一：</span><br><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><br>s=0<br>for((i=0;i&lt;=100;i++))<br>do<br>        s=$[$s+$i]<br>done<br><span class="hljs-meta">#</span><span class="bash"> 基本语法二：</span><br><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><span class="hljs-meta">#</span><span class="bash">打印数字</span><br><br>for i in $*<br>    do<br>      echo &quot;ban zhang love $i &quot;<br>    done<br></code></pre></td></tr></table></figure></li>
<li><p>while循环</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-keyword">while</span>循环从1叫到100</span><br><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>s=0<br>i=1<br>while [ $i -le 100 ]<br>do<br>        s=$[$s+$i]<br>        i=$[$i+1]<br>done<br><br>echo $s<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="read读取控制台输入"><a href="#read读取控制台输入" class="headerlink" title="read读取控制台输入"></a>read读取控制台输入</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">	<span class="hljs-built_in">read</span>(选项)(参数)</span><br><span class="hljs-meta">#</span><span class="bash">	选项：</span><br><span class="hljs-meta">#</span><span class="bash">-p：指定读取值时的提示符；</span><br><span class="hljs-meta">#</span><span class="bash">-t：指定读取值时等待的时间（秒）。</span><br><span class="hljs-meta">#</span><span class="bash">参数</span><br><span class="hljs-meta">#</span><span class="bash">	变量：指定读取值的变量名</span><br><span class="hljs-meta">#</span><br><span class="hljs-meta">#</span><br><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><br>read -t 7 -p &quot;Enter your name in 7 seconds &quot; NAME<br>echo $NAME<br></code></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li><p>系统函数</p>
</li>
<li><p>basename [string / pathname] [suffix]  （功能描述：basename命令会删掉所有的前缀包括最后一个（‘/’）字符，然后将字符串显示出来。</p>
</li>
<li><p>选项：</p>
<p>suffix为后缀，如果suffix被指定了，basename会将pathname或string中的suffix去掉。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@hadoop101 datas]$ basename /home/atguigu/banzhang.txt <br>banzhang.txt<br>[root@hadoop101 datas]$ basename /home/atguigu/banzhang.txt .txt<br>banzhang<br></code></pre></td></tr></table></figure></li>
<li><p>dirname 文件绝对路径        （功能描述：从给定的包含绝对路径的文件名中去除文件名（非目录的部分），然后返回剩下的路径（目录的部分））</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@hadoop101 ~]$ dirname /home/atguigu/banzhang.txt <br>/home/atguigu<br></code></pre></td></tr></table></figure></li>
<li><p>自定义函数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">1．基本语法</span><br><span class="hljs-meta">#</span><span class="bash">[ <span class="hljs-keyword">function</span> ] funname[()]</span><br><span class="hljs-meta">#</span><span class="bash">&#123;</span><br><span class="hljs-meta">#</span><span class="bash">	Action;</span><br><span class="hljs-meta">#</span><span class="bash">	[<span class="hljs-built_in">return</span> int;]</span><br><span class="hljs-meta">#</span><span class="bash">&#125;</span><br><span class="hljs-meta">#</span><span class="bash">funname</span><br><span class="hljs-meta">#</span><span class="bash">2．经验技巧</span><br><span class="hljs-meta">#</span><span class="bash">	（1）必须在调用函数地方之前，先声明函数，shell脚本是逐行运行。不会像其它语言一样先编译。</span><br><span class="hljs-meta">#</span><span class="bash">	（2）函数返回值，只能通过$?系统变量获得，可以显示加：<span class="hljs-built_in">return</span>返回，如果不加，将以最后一条<span class="hljs-comment">#命令运行结果，作为返回值。return后跟数值n(0-255)</span></span><br><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>function sum()<br>&#123;<br>    s=0<br>    s=$[ $1 + $2 ]<br>    echo &quot;$s&quot;<br>&#125;<br><br>read -p &quot;Please input the number1: &quot; n1;<br>read -p &quot;Please input the number2: &quot; n2;<br>sum $n1 $n2;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="shell工具"><a href="#shell工具" class="headerlink" title="shell工具"></a>shell工具</h2><h3 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h3><ul>
<li><p>cut:cut的工作就是“剪”，具体的说就是在文件中负责剪切数据用的。cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段输出。</p>
</li>
<li><p>cut [选项参数]  filename     说明：默认分隔符是制表符</p>
</li>
<li><table>
<thead>
<tr>
<th align="left">选项参数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-f</td>
<td>列号，提取第几列</td>
</tr>
<tr>
<td align="left">-d</td>
<td>分隔符，按照指定分隔符分割列</td>
</tr>
<tr>
<td align="left">-c</td>
<td>指定具体字符</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@hadoop101 datas]$ touch cut.txt<br>[root@hadoop101 datas]$ vim cut.txt<br>dong shen<br>guan zhen<br>wo  wo<br>lai  lai<br>le  le<br><br>[root@hadoop101 datas]$ cut -d &quot; &quot; -f 2,3 cut.txt <br>shen<br>zhen<br> wo<br> lai<br> le<br> <br> [root@hadoop101 datas]$ cut -d &quot; &quot; -f 1 cut.txt <br>dong<br>guan<br>wo<br>lai<br>le<br><br>[root@hadoop101 datas]$ cat cut.txt | grep &quot;guan&quot; | cut -d &quot; &quot; -f 1<br>guan<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><ul>
<li><p>sed是一种流编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”，接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向存储输出。</p>
</li>
<li><ol>
<li>基本用法</li>
</ol>
<p>sed [选项参数]  ‘command’  filename</p>
<ol start="2">
<li>选项参数说明</li>
</ol>
<table>
<thead>
<tr>
<th>选项参数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-e</td>
<td>直接在指令列模式上进行sed的动作编辑。</td>
</tr>
<tr>
<td>-i</td>
<td>直接编辑文件</td>
</tr>
</tbody></table>
<ol start="3">
<li>命令功能描述</li>
</ol>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>a</strong></td>
<td>新增，a的后面可以接字串，在下一行出现,a前面可以指定行</td>
</tr>
<tr>
<td>d</td>
<td>删除</td>
</tr>
<tr>
<td>s</td>
<td>查找并替换</td>
</tr>
</tbody></table>
</li>
</ul>
<ul>
<li><p>command中可以匹配正则表达式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 将“mei nv”这个单词插入到sed.txt第二行下，打印。</span><br>[root@hadoop102 datas]$ sed &#x27;2a mei nv&#x27; sed.txt <br>dong shen<br>guan zhen<br>mei nv<br>wo  wo<br>lai  lai<br>le  le<br><span class="hljs-meta">#</span><span class="bash"> 文件内容并没有改变</span><br>[root@hadoop102 datas]$ cat sed.txt <br>dong shen<br>guan zhen<br>wo  wo<br>lai  lai<br>le  le<br><span class="hljs-meta">#</span><span class="bash"> 注意：‘g’表示global，全部替换</span><br>[atguigu@hadoop102 datas]$ sed &#x27;s/wo/ni/g&#x27; sed.txt <br>dong shen<br>guan zhen<br>ni  ni<br>lai  lai<br>le  le<br><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><ul>
<li><p>一个强大的文本分析工具，把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行分析处理。</p>
</li>
<li><ol>
<li>基本用法</li>
</ol>
<p>awk [选项参数] ‘pattern1{action1} pattern2{action2}…’ filename</p>
<p>pattern：表示AWK在数据中查找的内容，就是匹配模式</p>
<p>action：在找到匹配内容时所执行的一系列命令</p>
<ol start="2">
<li>选项参数说明</li>
</ol>
<table>
<thead>
<tr>
<th>选项参数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-F</td>
<td>指定输入文件折分隔符</td>
</tr>
<tr>
<td>-v</td>
<td>赋值一个用户定义变量</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><br><span class="hljs-meta">#</span><span class="bash">（1）搜索passwd文件以root关键字开头的所有行，并输出该行的第7列。</span><br>[root@hadoop102 datas]$ awk -F: &#x27;/^root/&#123;print $7&#125;&#x27; passwd <br>/bin/bash<br><span class="hljs-meta">#</span><span class="bash">（2）搜索passwd文件以root关键字开头的所有行，并输出该行的第1列和第7列，中间以“，”号分割。</span><br>[root@hadoop102 datas]$ awk -F: &#x27;/^root/&#123;print $1&quot;,&quot;$7&#125;&#x27; passwd <br>root,/bin/bash<br><span class="hljs-meta">#</span><span class="bash">注意：只有匹配了pattern的行才会执行action</span><br><span class="hljs-meta">#</span><span class="bash">（3）只显示/etc/passwd的第一列和第七列，以逗号分割，且在所有行前面添加列名user，shell在<span class="hljs-comment">#最后一行添加&quot;dahaige，/bin/zuishuai&quot;。</span></span><br>[root@hadoop102 datas]$ awk -F : &#x27;BEGIN&#123;print &quot;user, shell&quot;&#125; &#123;print $1&quot;,&quot;$7&#125; END&#123;print &quot;dahaige,/bin/zuishuai&quot;&#125;&#x27; passwd<br>user, shell<br>root,/bin/bash<br>bin,/sbin/nologin<br>。。。<br>atguigu,/bin/bash<br>dahaige,/bin/zuishuai<br><span class="hljs-meta">#</span><span class="bash">注意：BEGIN 在所有数据读取行之前执行；END 在所有数据执行之后执行。</span><br><span class="hljs-meta">#</span><span class="bash">（4）将passwd文件中的用户id增加数值1并输出</span><br>[root@hadoop102 datas]$ awk -v i=1 -F: &#x27;&#123;print $3+i&#125;&#x27; passwd<br>1<br>2<br>3<br>4<br></code></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>awk的内置变量</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>FILENAME</td>
<td>文件名</td>
</tr>
<tr>
<td>NR</td>
<td>已读的记录数</td>
</tr>
<tr>
<td>NF</td>
<td>浏览记录的域的个数（切割后，列的个数）</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><ul>
<li><p>sort命令是在Linux里非常有用，它将文件进行排序，并将排序结果标准输出。</p>
</li>
<li><p>基本语法</p>
<p>sort(选项)(参数)</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-n</td>
<td>依照数值的大小排序</td>
</tr>
<tr>
<td>-r</td>
<td>以相反的顺序来排序</td>
</tr>
<tr>
<td>-t</td>
<td>设置排序时所用的分隔字符</td>
</tr>
<tr>
<td>-k</td>
<td>指定需要排序的列</td>
</tr>
</tbody></table>
<p>参数：指定待排序的文件列表</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>sql_userful_function</title>
    <url>/2022/06/13/sql-userful-function/</url>
    <content><![CDATA[<h1 id="常用的SQL函数"><a href="#常用的SQL函数" class="headerlink" title="常用的SQL函数"></a>常用的SQL函数</h1><h2 id="常见的MySQL关系型数据库"><a href="#常见的MySQL关系型数据库" class="headerlink" title="常见的MySQL关系型数据库"></a>常见的MySQL关系型数据库</h2><ul>
<li><p>date_format(date,format)</p>
<ul>
<li><p><strong>date</strong>参数是合法的日期，<strong>format</strong>规定日期/时间的输出格式。</p>
</li>
<li><p>````mysql<br>select date_format(‘2021-10-01 10:00:00’,’%Y-%m-%d %h:%i:%s’)</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><code class="hljs gherkin"><br>  - |<span class="hljs-string"> %a   </span>|<span class="hljs-string"> 缩写星期名                                     </span>|<br>    |<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---------------------------------------------- </span>|<br>    |<span class="hljs-string"> %b   </span>|<span class="hljs-string"> 缩写月名                                       </span>|<br>    |<span class="hljs-string"> %c   </span>|<span class="hljs-string"> 月，数值                                       </span>|<br>    |<span class="hljs-string"> %D   </span>|<span class="hljs-string"> 带有英文前缀的月中的天                         </span>|<br>    |<span class="hljs-string"> %d   </span>|<span class="hljs-string"> 月的天，数值(00-31)                            </span>|<br>    |<span class="hljs-string"> %e   </span>|<span class="hljs-string"> 月的天，数值(0-31)                             </span>|<br>    |<span class="hljs-string"> %f   </span>|<span class="hljs-string"> 微秒                                           </span>|<br>    |<span class="hljs-string"> %H   </span>|<span class="hljs-string"> 小时 (00-23)                                   </span>|<br>    |<span class="hljs-string"> %h   </span>|<span class="hljs-string"> 小时 (01-12)                                   </span>|<br>    |<span class="hljs-string"> %I   </span>|<span class="hljs-string"> 小时 (01-12)                                   </span>|<br>    |<span class="hljs-string"> %i   </span>|<span class="hljs-string"> 分钟，数值(00-59)                              </span>|<br>    |<span class="hljs-string"> %j   </span>|<span class="hljs-string"> 年的天 (001-366)                               </span>|<br>    |<span class="hljs-string"> %k   </span>|<span class="hljs-string"> 小时 (0-23)                                    </span>|<br>    |<span class="hljs-string"> %l   </span>|<span class="hljs-string"> 小时 (1-12)                                    </span>|<br>    |<span class="hljs-string"> %M   </span>|<span class="hljs-string"> 月名                                           </span>|<br>    |<span class="hljs-string"> %m   </span>|<span class="hljs-string"> 月，数值(00-12)                                </span>|<br>    |<span class="hljs-string"> %p   </span>|<span class="hljs-string"> AM 或 PM                                       </span>|<br>    |<span class="hljs-string"> %r   </span>|<span class="hljs-string"> 时间，12-小时（hh:mm:ss AM 或 PM）             </span>|<br>    |<span class="hljs-string"> %S   </span>|<span class="hljs-string"> 秒(00-59)                                      </span>|<br>    |<span class="hljs-string"> %s   </span>|<span class="hljs-string"> 秒(00-59)                                      </span>|<br>    |<span class="hljs-string"> %T   </span>|<span class="hljs-string"> 时间, 24-小时 (hh:mm:ss)                       </span>|<br>    |<span class="hljs-string"> %U   </span>|<span class="hljs-string"> 周 (00-53) 星期日是一周的第一天                </span>|<br>    |<span class="hljs-string"> %u   </span>|<span class="hljs-string"> 周 (00-53) 星期一是一周的第一天                </span>|<br>    |<span class="hljs-string"> %V   </span>|<span class="hljs-string"> 周 (01-53) 星期日是一周的第一天，与 %X 使用    </span>|<br>    |<span class="hljs-string"> %v   </span>|<span class="hljs-string"> 周 (01-53) 星期一是一周的第一天，与 %x 使用    </span>|<br>    |<span class="hljs-string"> %W   </span>|<span class="hljs-string"> 星期名                                         </span>|<br>    |<span class="hljs-string"> %w   </span>|<span class="hljs-string"> 周的天 （0=星期日, 6=星期六）                  </span>|<br>    |<span class="hljs-string"> %X   </span>|<span class="hljs-string"> 年，其中的星期日是周的第一天，4 位，与 %V 使用 </span>|<br>    |<span class="hljs-string"> %x   </span>|<span class="hljs-string"> 年，其中的星期一是周的第一天，4 位，与 %v 使用 </span>|<br>    |<span class="hljs-string"> %Y   </span>|<span class="hljs-string"> 年，4 位                                       </span>|<br>    |<span class="hljs-string"> %y   </span>|<span class="hljs-string"> 年，2 位                                       </span>|<br><br><span class="hljs-symbol">*</span> concat(str1,str2,...)    ，concat_ws(seperator,string1,string2)<br><br>  - MySQL `CONCAT()`函数需要一个或多个字符串参数，并将它们连接成一个字符串。`CONCAT()`函数需要至少一个参数，否则会引起错误。 <br>  - MySQL提供了一种特殊形式的`CONCAT()`函数：`CONCAT_WS()`函数。`CONCAT_WS()`函数将两个或多个字符串值与预定义的分隔符相连接。<br><br><span class="hljs-symbol">*</span> timediff(dt1,dt2)<br><br>  - `TIMEDIFF`函数接受两个必须为相同类型的参数，即`TIME`或`DATETIME`。 `TIMEDIFF`函数返回表示为时间值的`dt1 - dt2`的结果。<br>  - `TIMEDIFF`函数的结果是一个`TIME`值，范围是从`-838:59:59`到`838:59:59`。<br><br><span class="hljs-symbol">*</span> TIMESTAMPDIFF(unit,begin,end); <br><br>  - `TIMESTAMPDIFF`函数返回`end-begin`的结果，其中`begin`和`end`是[DATE](http://www.yiibai.com/mysql/date.html)或[DATETIME](http://www.yiibai.com/mysql/datetime.html)表达式。<br>  - `TIMESTAMPDIFF`函数允许其参数具有混合类型，例如，`begin`是`DATE`值，`end`可以是`DATETIME`值。 如果使用`DATE`值，则`TIMESTAMPDIFF`函数将其视为时间部分为`“00:00:00”`的`DATETIME`值。<br>  - `unit`参数是确定(`end-begin`)的结果的单位，表示为整数。 以下是有效单位：<br>    - MICROSECOND<br>    - SECOND<br>    - MINUTE<br>    - HOUR<br>    - DAY<br>    - WEEK<br>    - MONTH<br>    - QUARTER<br>    - YEAR<br><br><span class="hljs-symbol">*</span> 数据类型转换函数<br><br>  - cast(&#x27;2022-01-01 00:00:00&#x27; as datetime)<br>  - convert(&#x27;2021-01-01 00:00:00&#x27;,datetime)<br><br><span class="hljs-symbol">*</span> date_sub(date,INTERVAL expr type) <br><br>  - 从日期减去指定的时间间隔<br>  - <span class="hljs-symbol">*</span>date<span class="hljs-symbol">*</span> 参数是合法的日期表达式。<span class="hljs-symbol">*</span>expr<span class="hljs-symbol">*</span> 参数是您希望添加的时间间隔。<br><br><span class="hljs-symbol">*</span> DATE_ADD(date,INTERVAL expr type)<br><br>  - 从日期加上指定的时间间隔<br><br>  - <span class="hljs-symbol">*</span>date<span class="hljs-symbol">*</span> 参数是合法的日期表达式。<span class="hljs-symbol">*</span>expr<span class="hljs-symbol">*</span> 参数是您希望添加的时间间隔。<br><br>  - |<span class="hljs-string"> MICROSECOND        </span>|<br>    |<span class="hljs-string"> ------------------ </span>|<br>    |<span class="hljs-string"> SECOND             </span>|<br>    |<span class="hljs-string"> MINUTE             </span>|<br>    |<span class="hljs-string"> HOUR               </span>|<br>    |<span class="hljs-string"> DAY                </span>|<br>    |<span class="hljs-string"> WEEK               </span>|<br>    |<span class="hljs-string"> MONTH              </span>|<br>    |<span class="hljs-string"> QUARTER            </span>|<br>    |<span class="hljs-string"> YEAR               </span>|<br>    |<span class="hljs-string"> SECOND_MICROSECOND </span>|<br>    |<span class="hljs-string"> MINUTE_MICROSECOND </span>|<br>    |<span class="hljs-string"> MINUTE_SECOND      </span>|<br>    |<span class="hljs-string"> HOUR_MICROSECOND   </span>|<br>    |<span class="hljs-string"> HOUR_SECOND        </span>|<br>    |<span class="hljs-string"> HOUR_MINUTE        </span>|<br>    |<span class="hljs-string"> DAY_MICROSECOND    </span>|<br>    |<span class="hljs-string"> DAY_SECOND         </span>|<br>    |<span class="hljs-string"> DAY_MINUTE         </span>|<br>    |<span class="hljs-string"> DAY_HOUR           </span>|<br>    |<span class="hljs-string"> YEAR_MONTH         </span>|<br><br><span class="hljs-symbol">*</span> round(x,d)<br><br>  - x指要处理的数，d是指保留几位小数<br><br><span class="hljs-symbol">*</span> ifnull(expression_1,expression_2)<br><br>  - MySQL IFNULL函数是MySQL控制流函数之一，它接受两个参数，如果不是NULL，则返回第一个参数。 否则，IFNULL函数返回第二个参数。<br><br><span class="hljs-symbol">*</span> year(datetime)函数 取时间的年份<br><br><span class="hljs-symbol">*</span> month(datetime) 取月份<br><br><span class="hljs-symbol">*</span> dayofmonth() 取一个月的第几天<br><br><span class="hljs-symbol">*</span> if(expr1,expr2,expr3)函数<br><br>  - if() 类似与三元表达式，如果expr1的值为true，则返回expr2的值，如果expr1的值为false,则返回expr3的值<br><br><span class="hljs-symbol">*</span> substring_index(“待截取有用部分的字符串”，“截取数据依据的字符”，截取字符的位置N)<br><br><span class="hljs-symbol">*</span> substr(string,start,length)<br><br>  - string：表示要截取的字符串<br>  - start：规定字符串从何处开始。（1表示第一个下标）<br>  - length：可选<br><br><span class="hljs-symbol">*</span> 插入数据<br><br>  - INSERT INTO t1(field1,field2) VALUE(v001,v002)<br>  - INSERT INTO t1(field1,field2) VALUES(v101,v102),(v201,v202),(v301,v302),(v401,v402);　<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>在插入批量数据时方式2优于方式1<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><br>  - INSERT INTO t2(field1,field2) SELECT col1,col2 FROM t1 WHERE<br>  - INSERT INTO t2 SELECT id, name, address FROM t1<br><br><span class="hljs-symbol">*</span> LENGTH( 字段名) <br><br>  - 返回字段中值的长度<br>  - mysql5.0版本以上：<br>    - UTF-8：一个汉字等于3个字节，英文是一个字节<br>    - GBK：一个汉字等于2个字节，英文是一个字节<br><br><span class="hljs-symbol">*</span> REPLACE(str,old_string,new_string);<br><br>  - 使用新的字符串替换表的列中的字符串<br><br><span class="hljs-symbol">*</span> curdate()  取时间 %Y-%m-%d<br><br><span class="hljs-symbol">*</span> curtime()  取时间 %H:%i%s<br><br><span class="hljs-symbol">*</span> |<span class="hljs-string"> NOW()               </span>|<span class="hljs-string"> CURDATE()  </span>|<span class="hljs-string"> CURTIME() </span>|<br>  |<span class="hljs-string"> :------------------ </span>|<span class="hljs-string"> :--------- </span>|<span class="hljs-string"> :-------- </span>|<br>  |<span class="hljs-string"> 2008-12-29 16:25:46 </span>|<span class="hljs-string"> 2008-12-29 </span>|<span class="hljs-string"> 16:25:46  </span>|<br><br><span class="hljs-symbol">*</span> with t as () 语句其实就是把一大堆重复用到的sql语句放在with as里面，取一个别名，后面的查询就可以用它，这样对于大批量的sql语句起到一个优化的作用，而且清楚明了<br><br>  ````sql<br>  with e as (select <span class="hljs-symbol">*</span> from scott.emp e where e.empno=4)<br>  select <span class="hljs-symbol">*</span> from e;<br>  <br>  <br>  with<br>  e as (select <span class="hljs-symbol">*</span> from scott.emp),<br>  d as (select <span class="hljs-symbol">*</span> from scott.dept)<br>  select <span class="hljs-symbol">*</span> from e, d where e.deptno = d.deptno;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>shuju_qiinxie</title>
    <url>/2021/10/22/shuju-qiinxie/</url>
    <content><![CDATA[<h1 id="数据倾斜"><a href="#数据倾斜" class="headerlink" title="数据倾斜"></a>数据倾斜</h1><h2 id="数据倾斜描述"><a href="#数据倾斜描述" class="headerlink" title="数据倾斜描述"></a>数据倾斜描述</h2><ul>
<li>正常的数据分布理论上都是倾斜的，就是常说的2-8原则。不同的数据字段可能的数据倾斜一般有两种情况：<ul>
<li>唯一值非常少</li>
<li>唯一值比较多</li>
</ul>
</li>
</ul>
<h2 id="数据倾斜产生的原因"><a href="#数据倾斜产生的原因" class="headerlink" title="数据倾斜产生的原因"></a>数据倾斜产生的原因</h2><ul>
<li>数据倾斜在MapReduce编程模型中十分常见,用最通俗易懂的话来说,数据倾斜无非就是大量的相同key被partition分配到一个分区里,造成了’一个人累死,其他人闲死’的情况,这种情况是我们不能接受的,这也违背了并行计算的初衷,首先一个节点要承受着巨大的压力,而其他节点计算完毕后要一直等待这个忙碌的节点,也拖累了整体的计算时间,可以说效率是十分低下的。</li>
<li>产生的现象：<ul>
<li>其它的任务都执行完成了，一个任务一直卡在某个进度，一直没有完成。</li>
<li>本来应该能正常执行的任务，出现OOM(内存溢出)。</li>
</ul>
</li>
</ul>
<h3 id="数据倾斜的解决"><a href="#数据倾斜的解决" class="headerlink" title="数据倾斜的解决"></a>数据倾斜的解决</h3><ul>
<li>数据倾斜只会发生在shuffle中，在hive中，表的join,group by。在spark中常见可能会触发shuffle操作的算子：distinct，groupByKey,reduceByKey,aggregateByKey,join,cogroup,repartition等。</li>
<li>对于hive HQL来说解决的办法：<ul>
<li>group by 时的数据倾斜:解决办法：hive.groupby.skewindata=true<ul>
<li>控制生成两个MRJob，第一个MR的map的输出结果随机分配到reduce中，减少某些key值条数过多，某些key 值条数过少造成的数据倾斜问题。</li>
<li>第二个MR再根据预处理的数据结果，按照group By Key分布到reduce中，（这个过程可以保证相同的Group By Key分布到同一个reduce中），最后完成最终的聚合操作。</li>
</ul>
</li>
<li>join时数据倾斜，对于一些热点key，他们所在的reduce运行较慢。解决方式：<ul>
<li>过滤不正常的记录</li>
<li>数据去重</li>
<li>使用map join</li>
<li>打开set Hive.optimize.skewjoin = true;  </li>
</ul>
</li>
<li>无法从sql层面优化时，可以从业务算法角度提升<ul>
<li>只读需要的列和分区</li>
<li>周，月任务按天累计计算</li>
<li>先聚合后join</li>
</ul>
</li>
<li>Reduce任务数不合理<ul>
<li>set mapred.reduce.tasks=N</li>
</ul>
</li>
<li>业务数据本身存在倾斜<ul>
<li>配置参数，优化SQL语句，将数据值较多的数据分散到多个reduce中</li>
</ul>
</li>
<li>多维分析带来的低效<ul>
<li>当含有rollup和cube语句的from子句中包含子查询或者join时，将子查询或join的结果放到临时表，然后从临时表中读取数据做多维分析  </li>
</ul>
</li>
</ul>
</li>
<li>对于Spark来说解决的办法<ul>
<li>使用hive  ETL预处理数据</li>
<li>过滤少量导致数据倾斜的key</li>
<li>提高shuffle操作的并行度</li>
<li>两阶段聚合<ul>
<li>第一次是局部聚合，先给每个key打上一个随机数，这样就不会数据倾斜了，先局部聚合</li>
<li>第二次是全局聚合，把随机前缀去掉，再进行全局聚合</li>
</ul>
</li>
<li>将reduce join 转为map join</li>
</ul>
</li>
<li>spark数据倾斜的解决详细内容可见博客<a href="https://blog.csdn.net/weixin_35353187/article/details/84303518">spark 数据倾斜</a></li>
</ul>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>数据倾斜</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM</title>
    <url>/2021/05/02/JVM/</url>
    <content><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="JVM定义"><a href="#JVM定义" class="headerlink" title="JVM定义"></a>JVM定义</h2><blockquote>
<ul>
<li>JVM是运行在操作系统之上的，它与硬件没有直接的交互</li>
<li>通过编译器将 Java 程序转换成该虚拟机所能识别的指令序列，也称 Java 字节码。Java虚拟机会将字节码，即class文件加载到JVM中。由JVM进行解释和执行</li>
</ul>
</blockquote>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><blockquote>
<ul>
<li>类加载器，即ClassLoader,它负责加载class文件，class文件在文件开头有特定的文件标示，并且ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定</li>
</ul>
</blockquote>
<h3 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h3><h4 id="虚拟机自带的类加载器"><a href="#虚拟机自带的类加载器" class="headerlink" title="虚拟机自带的类加载器"></a>虚拟机自带的类加载器</h4><ol>
<li>启动类加载器：主要负责加载jre中的最为基础、最为重要的类。如$JAVA_HOME/jre/lib/rt.jar等，以及由虚拟机参数 -Xbootclasspath 指定的类。由于它由C++代码实现，没有对应的java对象，因此在java中，尝试获取此类时，只能使用null来指代。</li>
<li>扩展类加载器：由Java代码实现，用于加载相对次要、但又通用的类，比如存放在 JRE 的 lib/ext 目录下 jar 包中的类，以及由系统变量 java.ext.dirs 指定的类。如$JAVA_HOME/jre/lib/ext/*.jar。</li>
<li>应用程序类加载器：由Java代码实现， 它负责加载应用程序路径下的类。（这里的应用程序路径，便是指虚拟机参数 -cp/-classpath、系统变量 java.class.path 或环境变量 CLASSPATH 所指定的路径。）默认情况下，应用程序中包含的类便是由应用类加载器加载的。</li>
</ol>
<h4 id="用户自定义的加载器"><a href="#用户自定义的加载器" class="headerlink" title="用户自定义的加载器"></a>用户自定义的加载器</h4><blockquote>
<ul>
<li>Java.lang.ClassLoader的子类，用户可以定制类的加载方式。例如可以对 class 文件进行加密，加载时再利用自定义的类加载器对其解密。</li>
</ul>
</blockquote>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><blockquote>
<ul>
<li>双亲委派模型：每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。</li>
<li>应用程序类加载器的父类是扩展类加载器，扩展类加载器的父类是启动类加载器</li>
<li>优点：1.避免类的重复加载。2.防止核心API中定义的类型不会被用户恶意替换和篡改</li>
</ul>
</blockquote>
<h2 id="JVM的内存模型"><a href="#JVM的内存模型" class="headerlink" title="JVM的内存模型"></a>JVM的内存模型</h2><p><a href="https://imgtu.com/i/gZ2GDO" title="内存模型图片"><img src="https://z3.ax1x.com/2021/05/02/gZ2GDO.png" alt="gZ2GDO.png"></a></p>
<ul>
<li>Java虚拟机将运行时内存区域划分为五个部分，分别为<font color=red>方法区，堆，PC寄存器，Java方法栈和本地方法栈</font>。</li>
<li>执行Java代码首先需要使用类加载器将它编译成而成的class文件加载到Java虚拟机中。加载后的Java类会被存放于方法区（Method Area）中。实际运行时，虚拟机会执行方法区内的代码。</li>
<li>在虚拟机中，方法区和堆为线程共享，也是垃圾回收的重点照顾区域。栈空间为线程私有，基本不会出现垃圾回收。</li>
<li>Java虚拟机将栈细分为面向Java方法的Java方法栈，面向本地方法（c++写的native方法）的本地方法栈，以及存放各个执行线程执行位置的PC寄存器（程序计数器）</li>
<li>在运行过程中，每当调用进入一个Java方法，Java虚拟机会在当前线程的Java方法栈中生成一个栈帧（栈的一片区域），用以存放局部变量以及字节码的操作数。这个栈帧的大小是提前计算好的，而且Java虚拟机不要求栈帧在内存空间里连续分布。当推出当前执行的方法时，不管是正常返回还是异常返回，Java虚拟机均会弹出当前线程的当前栈帧，并将之舍弃。</li>
</ul>
<blockquote>
<ul>
<li>Execution Engine执行引擎负责解释命令，提交操作系统执行</li>
<li>Native Method Stack:定义了很多调用本地操作系统的方法，也称之为本地方法接口</li>
<li>每个线程都有一个程序计数器，是线程私有的,就是一个指针</li>
<li>方法区：所有定义的方法的信息都保存在该区域，此区属于共享区间。<br>静态变量+常量+类信息(构造方法/接口定义)+运行时常量池存在方法区中。</li>
<li>JDK1.7之前通过永久代实现方法区，1.7之前字符串常量池放到方法区中</li>
<li>JDK1.8之后，通过元空间实现方法区，1.7之后字符串常量放到堆中</li>
</ul>
</blockquote>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><blockquote>
<ul>
<li>栈我们也叫内存，是线程私有的，生命周期随线程的生命周期，线程结束栈内存释放</li>
<li>栈：8种基本类型的变量+对象的引用变量+实例方法都是在栈内存中分配</li>
<li>在栈区域规定了两种异常状态：如果线程请求的栈深度大于虚拟机所允许的深度，则抛出StackOverflowError异常；如果虚拟机栈可以动态扩展，在扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</li>
<li>栈帧：一个线程的每个方法在调用时都会在栈上划分一块区域，用于存储方法所需要的变量等信息，这块区域称之为栈帧（stack frame）。栈由多个栈帧构成，好比一部电影由多个帧的画面构成。</li>
</ul>
</blockquote>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ul>
<li>堆内存:存储的是数组和对象（其实数组就是对象），凡是new建立的都是在堆中，堆中存放的都是实体（对象），实体用于封装数据，而且是封装多个（实体的多个属性），如果一个数据消失，这个实体也没有消失，还可以用，所以堆是不会随时释放的，但是栈不一样，栈里存放的都是单个变量，变量被释放了，那就没有了。堆里的实体虽然不会被释放，但是会被当成垃圾，Java有垃圾回收机制不定时的收取。</li>
</ul>
<blockquote>
<ul>
<li>逻辑上分为三部分：1.新生区。2.养老区。3.永久区。（1.8后改为元空间）</li>
<li>新生区进一步分为：<blockquote>
<ul>
<li>伊甸园区</li>
<li>幸存区<blockquote>
<ul>
<li>幸存from区</li>
<li>幸存to区</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li>在物理上划分，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )。新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor</li>
<li>创建对象的过程<blockquote>
<ul>
<li>新new的对象会放在伊甸园区（大对象直接进入老年代），伊甸园区的对象存活率非常低，当伊甸园区快满时会触发轻量级的垃圾回收机制（MinorGC）MinorGC会回收伊甸园区和幸存from区，会将伊甸园的幸存者标记复制到幸存to区，from区中的幸存者会根据它的年龄判断它的去向：默认情况下，如果年龄小于15则被标记到to区，如果年龄大于15则被标记复制到养老区，然后from区和to区交换角色（to区又为空了，下次又是回收from区的)</li>
<li>当养老区内存不足时会触发重量级垃圾回收机制（MajorGC/fullGC），如果养老区无法回收内存则会出现OOM异常</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="JVM常见参数设置"><a href="#JVM常见参数设置" class="headerlink" title="JVM常见参数设置"></a>JVM常见参数设置</h3><blockquote>
<ul>
<li>-Xms:堆初始值（默认为物理内存的1/64）</li>
<li>-Xmx:堆最大可用值（默认为物理内存的1/4）</li>
<li>-Xss:每个线程的栈大小，默认为1M，此值不能设置过大，否则会减少线程并发数。</li>
</ul>
</blockquote>
<h3 id="常见异常"><a href="#常见异常" class="headerlink" title="常见异常"></a>常见异常</h3><blockquote>
<ul>
<li>错误原因: java.lang.OutOfMemoryError: Java heap space 堆内存溢出</li>
<li>解决办法:调大堆内存大小 </li>
<li>错误原因: java.lang.StackOverflowError表示为栈溢出，一般产生于递归调用。</li>
<li>解决办法:设置线程最大调用深度，默认是1m</li>
</ul>
</blockquote>
<h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><blockquote>
<ul>
<li>GC:JVM中的Garbage Collection，简称GC，它会不定时去堆内存中清理不可达对象。</li>
<li>分类：两种类型，一种是普通GC（minor GC），一种是全局GC（major GC or Full GC）</li>
<li>　新生代GC（minor GC）：只针对新生代区域的GC。</li>
<li>老年代GC（major GC or Full GC）：针对老年代的GC，偶尔伴随对新生代的GC以及对永久代的GC。</li>
<li>Minor GC触发机制：当年轻代满时就会触发Minor GC，这里的年轻代满指的是Eden区满，Survivor满不会引发GC。</li>
<li>Full GC触发机制：当年老代满时会引发Full GC，Full GC将会同时回收年轻代、年老代，当永久代满时也会引发Full GC，会导致Class、Method元信息的卸载</li>
<li>工作特点：理论上GC过程中会频繁收集Young区，很少收集Old区，基本不动Perm区（元空间/方法区）</li>
</ul>
</blockquote>
<h3 id="标记不可达对象"><a href="#标记不可达对象" class="headerlink" title="标记不可达对象"></a>标记不可达对象</h3><blockquote>
<ul>
<li>引用计数法：引用计数法就是如果一个对象没有被任何引用指向，则可视之为垃圾。这种方法的缺点就是不能检测到循环指向的存在。</li>
<li>可达性分析（GC ROOTS算法）简单理解，可以理解为堆外指向堆内的引用</li>
</ul>
</blockquote>
<h3 id="垃圾回收的三种方式"><a href="#垃圾回收的三种方式" class="headerlink" title="垃圾回收的三种方式"></a>垃圾回收的三种方式</h3><ol>
<li>清除：第一种是清除（sweep），即把死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表（free list）之中</li>
<li>压缩：第二种是压缩（compact），即把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间</li>
<li>复制第三种则是复制（copy），即把内存区域分为两等分，分别用两个指针 from 和 to 来维护，并且只是用 from 指针指向的内存区域来分配内<blockquote>
<ul>
<li>总结：回收死亡对象的内存共有三种方式，分别为：会造成内存碎片的清除、性能开销较大的压缩、以及堆使用效率较低的复制。</li>
</ul>
</blockquote>
</li>
</ol>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><ol>
<li>标记复制算法 因此Minor GC使用的则是标记-复制算法，理性情况下：，Eden 区中的对象基本都死亡了，那么需要复制的数据将非常少，因此采用这种标记 - 复制算法的效果极好。<blockquote>
<ul>
<li>优点：不会产生内存碎片 </li>
<li>缺点：需要双倍空间，浪费内存</li>
</ul>
</blockquote>
</li>
<li>标记清除算法 老年代一般是由标记清除或者是标记清除与标记压缩的混合实现<blockquote>
<ul>
<li>优点：不需要双倍空间</li>
<li>缺点：1.会产生内存碎片 2.需要停止整个应用程序 3.需要维护内存碎片的地址列表</li>
</ul>
</blockquote>
</li>
<li>标记压缩算法<blockquote>
<ul>
<li>优点：1.不需要双倍空间，也不会产生内存碎片 2.不需要维护内存碎片的列表，只需要记录内存的起始地址即可 </li>
<li>缺点：开销大，需要更新对象的地址</li>
</ul>
</blockquote>
</li>
<li>标记清除压缩算法 标记清除压缩(Mark-Sweep-Compact)算法是标记清除算法和标记压缩算法的结合算法。其原理和标记清除算法一致，只不过会在多次GC后，进行一次Compact压缩操作！</li>
</ol>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="JVM内存分几个区，每个区的作用是什么？"><a href="#JVM内存分几个区，每个区的作用是什么？" class="headerlink" title="JVM内存分几个区，每个区的作用是什么？"></a>JVM内存分几个区，每个区的作用是什么？</h3><ul>
<li>方法区<ul>
<li>有时候也称为永久代，该区很少发生垃圾回收，在这里进行GC主要是对方法区里的常量池和对类型的卸载。</li>
<li>方法区用来存放已经被虚拟机加载的类信息，常量，静态变量和即时编译器编译后的代码等数据。</li>
<li>该区域是被线程共享的。</li>
<li>静态变量+常量+类信息(构造方法/接口定义)+运行时常量池存在方法区中</li>
</ul>
</li>
<li>Java栈<ul>
<li>8种基本类型的变量+对象的引用变量+实例方法都是在栈内存中分配</li>
<li>是线程私有的，它的生命周期与线程相同</li>
<li>在栈区域规定了两种异常状态：如果线程请求的栈深度大于虚拟机所允许的深度，则抛出StackOverflowError异常；如果虚拟机栈可以动态扩展，在扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</li>
</ul>
</li>
<li>本地方法栈<ul>
<li>本地方法栈和Java栈类似，只不过本地方法栈为Native方法服务</li>
</ul>
</li>
<li>堆<ul>
<li>堆是所有线程所共享的一块内存，在虚拟机启动时创建，几乎所有的对象实例都在这里创建，因此该区域经常发生垃圾回收操作。</li>
<li>堆区被所有线程共享</li>
</ul>
</li>
<li>程序计数器<ul>
<li>内存空间小，字节码解释器工作时通过改变这个计数值可以选取下一条需要执行的字节码指令。该内存区域是唯一一个Java虚拟机规范没有规定任何OOM情况的区域。</li>
<li>线程私有的</li>
</ul>
</li>
</ul>
<h3 id="Java类加载过程"><a href="#Java类加载过程" class="headerlink" title="Java类加载过程"></a>Java类加载过程</h3><ul>
<li>加载</li>
<li>验证</li>
<li>解析</li>
<li>初始化</li>
</ul>
<h3 id="如何判断一个对象是否存活"><a href="#如何判断一个对象是否存活" class="headerlink" title="如何判断一个对象是否存活"></a>如何判断一个对象是否存活</h3><ul>
<li>引用计数法<ul>
<li>引用计数法就是如果一个对象没有被任何引用指向，则视之为垃圾。这种方法的缺点就是不能检测到循环指向的存在。</li>
</ul>
</li>
<li>可达性算法（引用链法）</li>
<li>根据搜索算法的基本思路就是通过一系列名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链时，则证明此对象时不可用的。</li>
</ul>
<h3 id="Java中的垃圾收集的方法有哪些"><a href="#Java中的垃圾收集的方法有哪些" class="headerlink" title="Java中的垃圾收集的方法有哪些"></a>Java中的垃圾收集的方法有哪些</h3><ul>
<li>在上面</li>
</ul>
<h3 id="什么是类加载器，类加载器有哪些"><a href="#什么是类加载器，类加载器有哪些" class="headerlink" title="什么是类加载器，类加载器有哪些"></a>什么是类加载器，类加载器有哪些</h3><ul>
<li><p>类加载器，即ClassLoader,它负责加载class文件，class文件在文件开头有特定的文件标示，并且ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定</p>
</li>
<li><p>在上面</p>
</li>
</ul>
<h3 id="简述Java内存分配以及垃圾回收策略Minor-GC，Major-GC（Full-GC）"><a href="#简述Java内存分配以及垃圾回收策略Minor-GC，Major-GC（Full-GC）" class="headerlink" title="简述Java内存分配以及垃圾回收策略Minor GC，Major GC（Full GC）"></a>简述Java内存分配以及垃圾回收策略Minor GC，Major GC（Full GC）</h3><ul>
<li>在上面</li>
</ul>
<h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><ul>
<li><p>线程和进程</p>
<ul>
<li>程序(program)是为完成特定任务，用某种语言编写的一组指令的集合。即指一段静态的代码。</li>
<li>进程(process)是程序的一次执行过程，或是正在运行的一个程序。进程是一个动态的过程，即有它自身的产生，存在和消亡的过程。每个Java程序都有一个隐含的主程序，即main 方法</li>
<li>线程（thread）是进程内部的一条具体的执行路径。若一个程序可同一时间执行多个线程，就是支持多线程的。</li>
<li>总结：程序是静态的，程序运行后变为一个进程，一个进程内部可以有多个线程同时执行。进程是所有线程的集合，每一个线程是进程中的一条路径。线程是直接去竞争cpu资源的。</li>
</ul>
</li>
<li><p>线程安全</p>
<ul>
<li>当多个线程同时共享同一个全局变量或静态变量，<font color=red>做写的操作时</font>，可能会发生数据冲突问题，也就是线程安全问题。</li>
</ul>
</li>
<li><p>线程安全的解决方式</p>
<ul>
<li><p>使用多线程之间同步或使用锁（lock）可以解决线程安全问题。</p>
</li>
<li><p>使用同步代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">synchronized(同一个对象)&#123;</span><br><span class="hljs-comment">	可能会发生线程冲突问题</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ticket</span></span><br><span class="hljs-class"></span>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">30</span>;<br>	<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sale</span><span class="hljs-params">()</span> </span>&#123;<br>		<br>		<span class="hljs-keyword">if</span> (number &gt; <span class="hljs-number">0</span>) &#123;<br>			System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;卖出第：\t&quot;</span> + (number--) + <span class="hljs-string">&quot;\t 还剩下：&quot;</span> + number);<br>		&#125;<br>	&#125;<br><br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SaleTicket</span> </span><br><span class="hljs-class"></span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-comment">//创建资源对象</span><br>		Ticket tc = <span class="hljs-keyword">new</span> Ticket();<br>		<span class="hljs-comment">//创建AA线程、</span><br>		<span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>			<br>			<span class="hljs-meta">@Override</span><br>			<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>				<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">40</span>; i++) &#123;<br>					<span class="hljs-comment">//卖票</span><br>					tc.sale();<br>				&#125;<br>			&#125;<br>		&#125;, <span class="hljs-string">&quot;AA&quot;</span>).start();<br>		<span class="hljs-comment">//创建BB线程、</span><br>		<span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>			<br>			<span class="hljs-meta">@Override</span><br>			<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>				<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">40</span>; i++) &#123;<br>					<span class="hljs-comment">//卖票</span><br>					tc.sale();<br>				&#125;<br>			&#125;<br>		&#125;, <span class="hljs-string">&quot;BB&quot;</span>).start();<br>		<span class="hljs-comment">//创建CC线程、</span><br>		<span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>			<br>			<span class="hljs-meta">@Override</span><br>			<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>				<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">40</span>; i++) &#123;<br>					<span class="hljs-comment">//卖票</span><br>					tc.sale();<br>				&#125;<br>			&#125;<br>		&#125;, <span class="hljs-string">&quot;CC&quot;</span>).start();<br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>使用Lock解决线程安全</p>
<ul>
<li><p>java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。Lock实现提供更广泛的锁定操作可以比使用 synchronized获得方法和声明更好。</p>
</li>
<li><p>相比于synchronized的有系统获取锁和释放锁，Lock需要自己动手实现加锁和释放锁，因此会更加灵活。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ticket</span></span><br><span class="hljs-class"></span>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">30</span>;<br>	<br>	<span class="hljs-comment">//创建锁</span><br>	Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sale</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">//上锁</span><br>		lock.lock();<br>		<span class="hljs-keyword">try</span> &#123;<br>			<span class="hljs-keyword">if</span> (number &gt; <span class="hljs-number">0</span>) &#123;<br>				System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;卖出第：\t&quot;</span> + (number--) + <span class="hljs-string">&quot;\t 还剩下：&quot;</span> + number);<br>			&#125;<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			<span class="hljs-comment">//解锁</span><br>			lock.unlock();<br>		&#125;<br>		<br>	&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SaleTicket</span> </span><br><span class="hljs-class"></span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span><span class="hljs-comment">//main所有程序的入口</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-comment">//创建资源对象</span><br>		Ticket tc = <span class="hljs-keyword">new</span> Ticket();<br>		<span class="hljs-comment">//创建AA线程、</span><br>		<span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>			<br>			<span class="hljs-meta">@Override</span><br>			<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>				<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">40</span>; i++) &#123;<br>					<span class="hljs-comment">//卖票</span><br>					tc.sale();<br>				&#125;<br>			&#125;<br>		&#125;, <span class="hljs-string">&quot;AA&quot;</span>).start();<br>		<span class="hljs-comment">//创建BB线程、</span><br>		<span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>			<br>			<span class="hljs-meta">@Override</span><br>			<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>				<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">40</span>; i++) &#123;<br>					<span class="hljs-comment">//卖票</span><br>					tc.sale();<br>				&#125;<br>			&#125;<br>		&#125;, <span class="hljs-string">&quot;BB&quot;</span>).start();<br>		<span class="hljs-comment">//创建CC线程、</span><br>		<span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>			<br>			<span class="hljs-meta">@Override</span><br>			<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>				<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">40</span>; i++) &#123;<br>					<span class="hljs-comment">//卖票</span><br>					tc.sale();<br>				&#125;<br>			&#125;<br>		&#125;, <span class="hljs-string">&quot;CC&quot;</span>).start();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="多线程的创建"><a href="#多线程的创建" class="headerlink" title="多线程的创建"></a>多线程的创建</h3><ul>
<li>继承Thread类<ul>
<li>定义子类继承Thread类</li>
<li>子类重写Thread类中的run方法</li>
<li>创建Thread子类对象，即创建了线程对象</li>
<li>调用线程对象start方法启动线程，默认调用run方法<ul>
<li>注意：如果只是调用run方法，则此时会在调用该方法的线程中来执行，而不是另启动一个线程</li>
</ul>
</li>
</ul>
</li>
<li>实现Runnable接口<ul>
<li>定义子类，实现Runnable接口</li>
<li>子类中重写Runnable接口中的run 方法</li>
<li>通过Thread类含参构造器创建线程对象，将Runnable接口的子类对象作为实际参数传递给Thread类的构造方法中。</li>
<li>调用Thread类的start方法启动线程，其最终调用Runnable子类接口的run方法。</li>
</ul>
</li>
<li>实现Runnable接口避免了单继承的局限性，多个线程可以共享同一个接口子类的对象，非常适合多个相同线程来处理同一份资源。</li>
<li>使用Callable 接口</li>
<li>与Runnable比较：<ul>
<li>相比于run方法可以有返回值</li>
<li>可以抛出异常</li>
<li>支持泛型的返回值</li>
<li>落地方法是call方法</li>
</ul>
</li>
<li>分布式锁<ul>
<li><font color=red>当在分布式模型下，数据只有一份（或有限制），此时需要利用锁的技术控制某一时刻修改数据的进程数。</font>分布式锁可以将标记存在内存，只是该内存不是某个进程分配的内存而是公共内存，如 Redis，通过set (key,value,nx,px,timeout)方法添加分布式锁。</li>
</ul>
</li>
<li>分布式事务<ul>
<li>分布式事务指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反射</title>
    <url>/2021/04/22/Java-reflect/</url>
    <content><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="单元测试类"><a href="#单元测试类" class="headerlink" title="单元测试类"></a>单元测试类</h2><blockquote>
<ul>
<li>单元测试方法的要求：类必须是公共的，必需不能有任何构造器</li>
<li>方法必修是公共非静态无返回值参数</li>
<li>执行：在方法名中右击，点击run as -junit</li>
<li>包装类：把基本数据类型包装成对象</li>
</ul>
</blockquote>
<h2 id="反射概述"><a href="#反射概述" class="headerlink" title="反射概述"></a>反射概述</h2><ul>
<li><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>
<p>要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象.</p>
</li>
<li><p>反射就是把Java类中的各种成分映射成一个个的Java对象</p>
<p>例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象。</p>
<p>   （其实：一个类中这些成员方法、构造方法、在加入类中都有一个类来描述）</p>
</li>
<li><p>参考链接：CSDN博客 <a href="https://blog.csdn.net/qq_36226453/article/details/82790375">链接</a></p>
</li>
</ul>
<h2 id="反射基础实例代码"><a href="#反射基础实例代码" class="headerlink" title="反射基础实例代码"></a>反射基础实例代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> reflect;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.junit.Assert.*;<br><br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.io.Serializable;<br><span class="hljs-keyword">import</span> java.lang.annotation.Annotation;<br><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map.Entry;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 反射 : java的动态处理技术</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(&#123;ElementType.TYPE, ElementType.FIELD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@interface</span> HelloAnnotation &#123;<br>	<span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;缺省名字&quot;</span>;<br>	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">id</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 10</span>;<br>&#125;<br><br><span class="hljs-meta">@HelloAnnotation(name=&quot;abc&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ArrayList</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span>, <span class="hljs-title">Comparable</span>, <span class="hljs-title">Runnable</span> </span>&#123;<br>	<br>	<span class="hljs-meta">@HelloAnnotation</span><br>	<span class="hljs-keyword">private</span> String name;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>	<span class="hljs-keyword">private</span> String gender;<br>	<br>	<span class="hljs-comment">//@HelloAnnotation</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Teacher</span><span class="hljs-params">()</span> </span>&#123;<br>	&#125;<br>	<span class="hljs-comment">//构造方法，Ctrl+Alt+S+O</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Teacher</span><span class="hljs-params">(String name)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.name = name;<br>	&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Teacher</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.age = age;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Teacher</span><span class="hljs-params">(String name,String gender)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.name = name;<br>		<span class="hljs-keyword">this</span>.gender = gender;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Teacher</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, String gender)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.name = name;<br>		<span class="hljs-keyword">this</span>.age = age;<br>		<span class="hljs-keyword">this</span>.gender = gender;<br>	&#125;<br>    <span class="hljs-comment">//set,get方法 快捷键Ctrl+Alt+S+R</span><br>	<span class="hljs-comment">//@HelloAnnotation</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> name;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.name = name;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> age;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.age = age;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getGender</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> gender;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setGender</span><span class="hljs-params">(String gender)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.gender = gender;<br>	&#125;<br>    <span class="hljs-comment">//Ctrl+Alt+S+S</span><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Teacher [name=&quot;</span> + name + <span class="hljs-string">&quot;, age=&quot;</span> + age + <span class="hljs-string">&quot;, gender=&quot;</span> + gender + <span class="hljs-string">&quot;]&quot;</span>;<br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lesson</span><span class="hljs-params">(String content, <span class="hljs-keyword">int</span> time)</span> </span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;老师在上[&quot;</span> + content + <span class="hljs-string">&quot;]课, 共上了[&quot;</span> + time +<span class="hljs-string">&quot;]小时&quot;</span>);<br>		<span class="hljs-comment">//return true;</span><br>		<span class="hljs-comment">//throw new RuntimeException(&quot;一个异常&quot;);</span><br>	&#125;<br>	<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReflectTest</span> </span>&#123;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testName</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>		Class clazz = Class.forName(<span class="hljs-string">&quot;reflect.Teacher&quot;</span>);<br>		Annotation[] annotations = clazz.getAnnotations();<br>		System.out.println(annotations.length);<br>		System.out.println(annotations[<span class="hljs-number">0</span>]);<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test14</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>		Class clazz = Class.forName(<span class="hljs-string">&quot;reflect.Teacher&quot;</span>);<br>		System.out.println(<span class="hljs-string">&quot;父类 : &quot;</span> + clazz.getSuperclass());<br>		Constructor[] constructors = clazz.getConstructors();<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; constructors.length; i++) &#123;<br>			System.out.println(<span class="hljs-string">&quot;构造器 : &quot;</span> + constructors[i]);<br>		&#125;<br>		System.out.println(<span class="hljs-string">&quot;************************************************&quot;</span>);<br>		Field[] fields = clazz.getFields(); <span class="hljs-comment">// 所有公共属性</span><br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; fields.length; i++) &#123;<br>			System.out.println(<span class="hljs-string">&quot;公共属性：&quot;</span>+fields[i]);<br>		&#125;<br>		<span class="hljs-comment">//反射尽量不要破坏封装性，容易发生严重后果，慎用getDeclared.....()方法</span><br>		Field[] declaredFields = clazz.getDeclaredFields(); <span class="hljs-comment">// 所有本类属性</span><br>		<span class="hljs-keyword">for</span> (Field field : declaredFields) &#123;<br>			System.out.println(<span class="hljs-string">&quot;本类属性：&quot;</span>+field);<br>		&#125;<br>		System.out.println(<span class="hljs-string">&quot;************************************************&quot;</span>);<br>		Method[] methods = clazz.getMethods();<span class="hljs-comment">//所有公共方法</span><br>		<span class="hljs-keyword">for</span> (Method method : methods) &#123;<br>			System.out.println(<span class="hljs-string">&quot;公共方法&quot;</span>+method);<br>		&#125;<br>		System.out.println(<span class="hljs-string">&quot;************************************************&quot;</span>);<br>		Method[] declaredMethods = clazz.getDeclaredMethods();<span class="hljs-comment">//所有本类方法</span><br>		<span class="hljs-keyword">for</span> (Method method : declaredMethods) &#123;<br>			System.out.println(<span class="hljs-string">&quot;本类方法：&quot;</span>+method);<br>		&#125;<br>	&#125;<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test13</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">try</span> &#123;<br>			Class clazz = Class.forName(<span class="hljs-string">&quot;reflect.Teacher&quot;</span>);<br>			Method lessonMethod = clazz.getDeclaredMethod(<span class="hljs-string">&quot;lesson&quot;</span>, String.class, <span class="hljs-keyword">int</span>.class);<br>			lessonMethod.setAccessible(<span class="hljs-keyword">true</span>);<br>			<br>			Short n = <span class="hljs-number">3</span>;<br>			Object retValue = lessonMethod.invoke(<span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;JavaWEB&quot;</span>, n); <span class="hljs-comment">// 静态方法传null, 不需要传入对象</span><br>			System.out.println(retValue);<br>		&#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (SecurityException e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (IllegalArgumentException e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123;<br>			e.printStackTrace();<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test12</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">try</span> &#123;<br>			Class clazz = Class.forName(<span class="hljs-string">&quot;reflect.Teacher&quot;</span>);<br>			Constructor constructor = clazz.getConstructor(String.class, <span class="hljs-keyword">int</span>.class, String.class);<br>			Object object = constructor.newInstance(<span class="hljs-string">&quot;佟刚&quot;</span>, <span class="hljs-number">40</span>, <span class="hljs-string">&quot;男&quot;</span>);<br>			<br>			<span class="hljs-comment">// getMethod只能获取公共的方法, 包括从父类继承的. </span><br>			<span class="hljs-comment">//Method lessonMethod = clazz.getMethod(&quot;lesson&quot;, String.class, int.class); </span><br>			<br>			<span class="hljs-comment">// getDeclaredMethod可以获取本类中所有声明的方法</span><br>			Method lessonMethod = clazz.getDeclaredMethod(<span class="hljs-string">&quot;lesson&quot;</span>, String.class, <span class="hljs-keyword">int</span>.class);<br>			lessonMethod.setAccessible(<span class="hljs-keyword">true</span>);<br>			<br>			Short n = <span class="hljs-number">3</span>;<br>			Object retValue = lessonMethod.invoke(object, <span class="hljs-string">&quot;JavaWEB&quot;</span>, n); <br>			System.out.println(retValue);<br>			<span class="hljs-comment">/*</span><br><span class="hljs-comment">		    private String outOfBoundsMsg(int index) &#123;</span><br><span class="hljs-comment">		        return &quot;Index: &quot;+index+&quot;, Size: &quot;+size;</span><br><span class="hljs-comment">		    &#125;</span><br><span class="hljs-comment">		    */</span><br>			<span class="hljs-comment">/*</span><br><span class="hljs-comment">			//拿父类的方法，会有警告，最好不要暴力访问私有方法，属性</span><br><span class="hljs-comment">			Method declaredMethod = clazz.getSuperclass().getDeclaredMethod(&quot;outOfBoundsMsg&quot;, int.class);</span><br><span class="hljs-comment">			System.out.println(declaredMethod);</span><br><span class="hljs-comment">			//危险操作</span><br><span class="hljs-comment">			declaredMethod.setAccessible(true);</span><br><span class="hljs-comment">			</span><br><span class="hljs-comment">			Object invoke = declaredMethod.invoke(object, 20);</span><br><span class="hljs-comment">			System.out.println(invoke);</span><br><span class="hljs-comment">			*/</span><br>		&#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123; <span class="hljs-comment">// 类未找到</span><br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123; <span class="hljs-comment">// 方法没有找到, 方法名错误或参数列表错误</span><br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (SecurityException e) &#123; <span class="hljs-comment">// 安全异常</span><br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (InstantiationException e) &#123; <span class="hljs-comment">// 创建对象时出现异常</span><br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123; <span class="hljs-comment">// 非法访问异常</span><br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (IllegalArgumentException e) &#123; <span class="hljs-comment">// 非法实参异常, 实参和形参不匹配, 类型和顺序和数量</span><br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123; <span class="hljs-comment">// 调用的目标方法内部出现异常了.</span><br>			e.printStackTrace();<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test11</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">try</span> &#123;<br>			Class clazz = Class.forName(<span class="hljs-string">&quot;reflect.Teacher&quot;</span>);<br>			Constructor constructor = clazz.getConstructor(String.class, <span class="hljs-keyword">int</span>.class, String.class);<br>			Object object = constructor.newInstance(<span class="hljs-string">&quot;佟刚&quot;</span>, <span class="hljs-number">40</span>, <span class="hljs-string">&quot;男&quot;</span>);<br>			<br>			<span class="hljs-comment">//object.lesson(&quot;JavaWEB&quot;, 3);</span><br>			<span class="hljs-comment">//先获取方法</span><br>			<br>			Method lessonMethod = clazz.getMethod(<span class="hljs-string">&quot;lesson&quot;</span>, String.class, <span class="hljs-keyword">int</span>.class); <span class="hljs-comment">// 后面是方法参数类型列表</span><br>			<span class="hljs-keyword">short</span> n = <span class="hljs-number">3</span>;<br>			Object retValue = lessonMethod.invoke(object, <span class="hljs-string">&quot;JavaWEB&quot;</span>, n); <span class="hljs-comment">// 后面是实参列表, 如果方法没有返回值, 它的返回值是null</span><br>			System.out.println(retValue);<br>		&#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123; <span class="hljs-comment">// 类未找到</span><br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123; <span class="hljs-comment">// 方法没有找到, 方法名错误或参数列表错误</span><br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (SecurityException e) &#123; <span class="hljs-comment">// 安全异常</span><br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (InstantiationException e) &#123; <span class="hljs-comment">// 创建对象时出现异常</span><br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123; <span class="hljs-comment">// 非法访问异常</span><br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (IllegalArgumentException e) &#123; <span class="hljs-comment">// 非法实参异常, 实参和形参不匹配, 类型和顺序和数量</span><br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123; <span class="hljs-comment">// 调用的目标方法内部出现异常了.</span><br>			e.printStackTrace();<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test10</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">try</span> &#123;<br>			Class clazz = Class.forName(<span class="hljs-string">&quot;reflect.Teacher&quot;</span>);<br>			<span class="hljs-comment">//Object object = clazz.newInstance(); 没有无参构造器时出问题</span><br>			<br>			<span class="hljs-comment">//public Teacher(String name, int age, String gender) 要想定位这个构造器, 必须让参数列表一致.</span><br>			<br>			<span class="hljs-comment">// 提供形式参数类型列表, 是类模板对象的列表</span><br>			Constructor constructor = clazz.getConstructor(String.class, <span class="hljs-keyword">int</span>.class, String.class); <span class="hljs-comment">// 定位合适的构造器</span><br>			<span class="hljs-comment">// 调用时必须给定实参列表</span><br>			Object object = constructor.newInstance(<span class="hljs-string">&quot;程程&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&quot;女&quot;</span>); <span class="hljs-comment">// new Teacher(&quot;程程&quot;, 20, &quot;女&quot;);</span><br>			System.out.println(object);<br>			<br>		&#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (InstantiationException e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123; <span class="hljs-comment">// 参数列表出错, 或者方法名出错</span><br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (SecurityException e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (IllegalArgumentException e) &#123; <span class="hljs-comment">// 方法调用时实参和形参不匹配</span><br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123;<br>			e.printStackTrace();<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test9</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException  </span>&#123;<br>		<span class="hljs-comment">//FileInputStream fis = new FileInputStream(&quot;只能读当前目录下的文件&quot;);</span><br>		ClassLoader classLoader = <span class="hljs-keyword">this</span>.getClass().getClassLoader();<br>		<span class="hljs-comment">// 只能加载build-path和src下的文件</span><br>		<span class="hljs-comment">//InputStream inputStream = classLoader.getResourceAsStream(&quot;com/sun/corba/se/impl/logging/LogStrings.properties&quot;); // 读取资源文件, 只要是Build-Path(classpath)中的文件都可以</span><br>		InputStream inputStream = classLoader.getResourceAsStream(<span class="hljs-string">&quot;s2&quot;</span>);<br>		Properties properties = <span class="hljs-keyword">new</span> Properties();<br>		properties.load(inputStream);<br>		<br>		Set&lt;Entry&lt;Object, Object&gt;&gt; entrySet = properties.entrySet();<br>		<span class="hljs-keyword">for</span> (Entry&lt;Object, Object&gt; entry : entrySet) &#123;<br>			System.out.println(entry);<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test8</span><span class="hljs-params">()</span>  </span>&#123;<br>		ClassLoader classLoader1 = ClassLoader.getSystemClassLoader(); <span class="hljs-comment">// 获取系统类加载器</span><br>		System.out.println(classLoader1);<br>		ClassLoader classLoader2 = <span class="hljs-keyword">this</span>.getClass().getClassLoader(); <span class="hljs-comment">// 使用最多的, 获取当前类的类加载器</span><br>		System.out.println(classLoader2);<br>		<br>		ClassLoader classLoader3 = classLoader1.getParent(); <span class="hljs-comment">// 获取父 &quot;类加载器&quot;,  是 扩展 &quot;类加载器&quot;</span><br>		System.out.println(classLoader3);<br>		<br>		ClassLoader classLoader4 = classLoader3.getParent(); <span class="hljs-comment">// 获取到的是引导类加载器(Bootstrap )</span><br>		System.out.println(classLoader4); <span class="hljs-comment">// 这个类加载器无法获取, 无法使用</span><br>		<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		双亲委派机制</span><br><span class="hljs-comment">		用户类加载器加载类时, 必须把此加载请求转发给父类加载器, 父类加载器再继续向父类加载器委派, 直到Bootstrap类加载器</span><br><span class="hljs-comment">		从Bootstrap类加载器开始真正加载, 各司其职. </span><br><span class="hljs-comment">		*/</span><br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test7</span><span class="hljs-params">()</span>  </span>&#123;<br>		Class strClazz = String.class;<br>		System.out.println(strClazz);<br>		<br>		<span class="hljs-comment">// 基本数据类型的类模板只能用第一种方式获取.</span><br>		Class clazz1 = <span class="hljs-keyword">int</span>.class; <span class="hljs-comment">// 基本数据类型也有相应的类模板对象, 但是不能获取属性和方法, 只能作为一个标记来使用.</span><br>		Class clazz2 = Integer.class; <span class="hljs-comment">// 这是一个普通类模板.</span><br>		System.out.println(clazz1 == clazz2);<br>		<br>		<span class="hljs-comment">// 判断类模板类型</span><br>		System.out.println(<span class="hljs-string">&quot;是否是基本型 : &quot;</span> + clazz1.isPrimitive());<br>		System.out.println(<span class="hljs-string">&quot;是否是基本型 : &quot;</span> + clazz2.isPrimitive());<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test6</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>		<span class="hljs-comment">// 获取类模板对象的方法 ，有４种</span><br>		<span class="hljs-comment">// 1) 直接通过类.class, 效率最高, 最安全.</span><br>		Class clazz1 = Teacher.class;<br>		<br>		<span class="hljs-comment">// 2) 根据对象, 调用它的getClass()方法获取, 此方法也很常用.</span><br>		Teacher teacher = <span class="hljs-keyword">new</span> Teacher(<span class="hljs-string">&quot;佟刚&quot;</span>, <span class="hljs-number">40</span>, <span class="hljs-string">&quot;男&quot;</span>);<br>		Class clazz2 = teacher.getClass();<br>		<br>		System.out.println(clazz1 == clazz2);<br>		<br>		<span class="hljs-comment">// 3) 反射中最常用的 Class.forName(&quot;全限定类名&quot;);</span><br>		Class clazz3 = Class.forName(<span class="hljs-string">&quot;reflect.Teacher&quot;</span>);<br>		System.out.println(clazz2 == clazz3);<br>		<br>		<span class="hljs-comment">// 4) 通过类加载器对象动态加载类</span><br>		ClassLoader classLoader = <span class="hljs-keyword">this</span>.getClass().getClassLoader();<br>		Class clazz4 = classLoader.loadClass(<span class="hljs-string">&quot;reflect.Teacher&quot;</span>);<br>		System.out.println(clazz3 == clazz4);<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>		Class clazz = Class.forName(<span class="hljs-string">&quot;reflect.Teacher&quot;</span>);<br>		String name = clazz.getName();<br>		System.out.println(<span class="hljs-string">&quot;类名 : &quot;</span> + name);<br>		System.out.println(<span class="hljs-string">&quot;简单类名 :  &quot;</span> + clazz.getSimpleName());<br>		Class superclass = clazz.getSuperclass();<br>		System.out.println(<span class="hljs-string">&quot;父类 : &quot;</span> + superclass);<br>		Class[] interfaces = clazz.getInterfaces();<br>		System.out.println(<span class="hljs-string">&quot;接口列表 &quot;</span>);<br>		<span class="hljs-keyword">for</span> (Class class1 : interfaces) &#123;<br>			System.out.println(class1);<br>		&#125;<br>		<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">try</span> &#123;<br>			Class clazz = Class.forName(<span class="hljs-string">&quot;reflect.Teacher&quot;</span>);<br>			Object object = clazz.newInstance();<br>			System.out.println(object);<br>			<br>			<span class="hljs-comment">//Field ageField = clazz.getField(&quot;age&quot;); // getField方法只能获取公共的属性, 也包括从父类继承的属性, 不可以获取私有属性</span><br>			Field ageField = clazz.getDeclaredField(<span class="hljs-string">&quot;age&quot;</span>); <span class="hljs-comment">// 获取本类中声明的任意属性 </span><br>			<span class="hljs-comment">// 暴力反射!!! 不推荐使用!!</span><br>			ageField.setAccessible(<span class="hljs-keyword">true</span>); <span class="hljs-comment">// 设置此属性为可访问的.</span><br>			ageField.set(object, <span class="hljs-number">40</span>); <br>			System.out.println(ageField.get(object)); <br>			<br>			Field nameField = clazz.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>			nameField.setAccessible(<span class="hljs-keyword">true</span>);<br>			nameField.set(object, <span class="hljs-string">&quot;佟刚&quot;</span>);<br>			<br>			System.out.println(object);<br>		&#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (InstantiationException e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123; <span class="hljs-comment">// 查找属性时, 有可能属性名不对, 可能是属性不存在</span><br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (SecurityException e) &#123; <span class="hljs-comment">// 如果有安全检查.</span><br>			e.printStackTrace();<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">try</span> &#123;<br>			Class clazz = Class.forName(<span class="hljs-string">&quot;reflect.Teacher&quot;</span>);<br>			Object object = clazz.newInstance();<br>			System.out.println(object);<br>			<br>			<span class="hljs-comment">// 要想使用属性, 1)先获取属性定义对象 2) 配合目标this对象完成对象属性的间接访问.</span><br>			Field ageField = clazz.getField(<span class="hljs-string">&quot;age&quot;</span>); <span class="hljs-comment">// 根据属性名获取属性的定义对象</span><br>			ageField.set(object, <span class="hljs-number">40</span>); <span class="hljs-comment">// 设置属性值, 相当于 object.age = 40; </span><br>			System.out.println(ageField.get(object)); <span class="hljs-comment">// 获取属性值,  相当于 System.out.println(object.age)</span><br>			<br>			Field nameField = clazz.getField(<span class="hljs-string">&quot;name&quot;</span>);<br>			nameField.set(object, <span class="hljs-string">&quot;佟刚&quot;</span>); <span class="hljs-comment">// object.name = &quot;佟刚&quot;</span><br>			<br>			Field genderField = clazz.getField(<span class="hljs-string">&quot;gender&quot;</span>);<br>			genderField.set(object, <span class="hljs-string">&quot;男&quot;</span>);<br>			<br>			System.out.println(object);<br>		&#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (InstantiationException e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123; <span class="hljs-comment">// 查找属性时, 有可能属性名不对, 可能是属性不存在</span><br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (SecurityException e) &#123; <span class="hljs-comment">// 如果有安全检查.</span><br>			e.printStackTrace();<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 软编码, 灵活, 把问题延迟到运行时.</span><br>		<span class="hljs-keyword">try</span> &#123;<br>			<span class="hljs-comment">// 干预类的加载, 直接获取类模板对象.</span><br>			Class clazz = Class.forName(<span class="hljs-string">&quot;reflect.Teacher&quot;</span>); <span class="hljs-comment">// 类名必须全限定!!!</span><br>			<span class="hljs-comment">// 通过类模板对象.newInstance创建实体对象</span><br>			Object object = clazz.newInstance(); <span class="hljs-comment">// 调用无参构造器创建对象</span><br>			System.out.println(object);<br>		&#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123; <span class="hljs-comment">// 在运行时动态加载类时, 发现没有找到类</span><br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (InstantiationException e) &#123; <span class="hljs-comment">// 在创建对象时出现异常, 可能是构造器不存在</span><br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123; <span class="hljs-comment">// 非法访问, 访问权限不够时出现</span><br>			e.printStackTrace();<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 编译时必须依赖类, 硬编码</span><br>		<br>		<span class="hljs-comment">//Teacher t1 = new Teacher(); // 强烈依赖类</span><br>		<span class="hljs-comment">//t1.name = &quot;佟刚&quot;;</span><br>		<span class="hljs-comment">//t1.age = 40;</span><br>		<span class="hljs-comment">//t1.gender = &quot;男&quot;;</span><br>		<br>		<span class="hljs-comment">//System.out.println(t1.name);</span><br>		<span class="hljs-comment">//System.out.println(t1.age);</span><br>		<span class="hljs-comment">//System.out.println(t1.gender);</span><br>		<br>		<span class="hljs-comment">//System.out.println(t1);</span><br>		<br>		Teacher t2 = <span class="hljs-keyword">new</span> Teacher(<span class="hljs-string">&quot;程程&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&quot;女&quot;</span>);<br>		System.out.println(t2);<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test0</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">// 测试方法所在的线程永远是守护线程</span><br>	&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-comment">// 守护线程, setDaemon(true); 此方法必须在start()以前调用.</span><br>		<span class="hljs-comment">// 主线程永远是用户线程</span><br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb</title>
    <url>/2021/05/26/JavaWeb/</url>
    <content><![CDATA[<h1 id="JavaWeb"><a href="#JavaWeb" class="headerlink" title="JavaWeb"></a>JavaWeb</h1><h2 id="网页的组成"><a href="#网页的组成" class="headerlink" title="网页的组成"></a>网页的组成</h2><ul>
<li>结构（HTML)<ul>
<li>超文本标记语言</li>
<li>网页的主要内容通过html来实现</li>
<li>用来写网页的语言</li>
</ul>
</li>
<li>表现（CSS)<ul>
<li>层叠样式表</li>
<li>网页的字体颜色、背景色、背景图片等通过它来实现</li>
<li>用来美化网页</li>
</ul>
</li>
<li>行为（JavaScript/jQuery）<ul>
<li>用来实现网页上的一下动态的效果</li>
</ul>
</li>
<li>一个良好的网页要求结构、表现、行为三者分离</li>
</ul>
<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><ul>
<li><p>常用的标签</p>
<ul>
<li><p>标题标签</p>
<ul>
<li>一共六个（h1到h6）</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><br>    一级标题<br><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span><br>    二级标题<br><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>...<br><span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span><br>    六级标题<br><span class="hljs-tag">&lt;/<span class="hljs-name">h6</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
<li><p>超链接</p>
<ul>
<li><p>通过a标签创建一个超链接</p>
<ul>
<li>通过a标签中的href属性指定要跳转的页面的地址</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;设置要跳转的页面的地址&quot;</span>&gt;</span>我是超链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>表格</p>
<ul>
<li>通过table标签创建一个表格<ul>
<li>表格中的行通过tr标签来表示<ul>
<li>表格中的表头通过th标签来表示</li>
<li>表格中的列（单元格）通过td标签来标签<ul>
<li>通过rowspan属性跨行合并单元格</li>
<li>通过colspan属性跨列合并单元格</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    	<span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>性别<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>年龄<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    	<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>盖伦<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>19<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
<li><p>表单</p>
<ul>
<li>使用form标签创建一个表单<ul>
<li>通过action属性指定要提交的服务器的地址</li>
<li>通过method属性指定提交的请求方式</li>
<li>通过input标签创建表单项<ul>
<li>type值是text的是文本框</li>
<li>type值是password的是密码框</li>
<li>type值是submit的是提交按钮</li>
<li>type值不可用任意指定，通过alt+/根据提示选择</li>
<li>必须给input指定name属性值<ul>
<li>name属性值可用任意指定</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 通过form标签创建一个表单 </span><br><span class="hljs-comment">		action属性：设置要提交的服务器的地址</span><br><span class="hljs-comment">		method属性：设置请求方式</span><br><span class="hljs-comment">			get：将发送一个GET请求，此时用户输入的数据是通过浏览器的地址栏进行传输</span><br><span class="hljs-comment">			post：将发送一个POST请求，此时用户输入的数据通过HTTP协议中请求报文中的请求体进行传输</span><br><span class="hljs-comment">	--&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;success.html&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>		<span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">			表单中的表单项通过input标签来创建，表单项的类型通过type属性来指定；</span><br><span class="hljs-comment">			必须给表单项指定name属性值，用户输入的数据通过name属性值进行携带，并以键值对的形式发送到</span><br><span class="hljs-comment">			服务器，多个键值对之间使用 &amp;符号分隔，例如：username=admin&amp;password=123456</span><br><span class="hljs-comment">		 --&gt;</span><br>		用户名称：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>		用户密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>		<span class="hljs-comment">&lt;!-- 提交按钮上显示的文字通过value指定 --&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;登录&quot;</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><ul>
<li><p>CSS样式可用书写的位置</p>
<ul>
<li><p>1）写在标签的style属性中</p>
<ul>
<li>结构与表现相耦合，不建议使用</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red;font-size: &quot;</span>&gt;</span>我是一个段落<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
<li><p>2）写在style标签中，style标签放在head标签中</p>
<ul>
<li>开发测试阶段使用这种方式</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><br><span class="css">	<span class="hljs-selector-id">#rd</span>&#123;</span><br><span class="css">		<span class="hljs-selector-tag">color</span>: <span class="hljs-selector-id">#FBA</span></span><br>	&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
<li><p>3）引入外部的css文件</p>
<ul>
<li>项目上线后使用这种方式</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;style.css&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>CSS种的基本选择器</p>
<ul>
<li>标签选择器</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &#123;<br>	<span class="hljs-attribute">color</span>: red<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>ID选择器<ul>
<li>格式：#id属性值</li>
</ul>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#p1</span> &#123;<br>	<span class="hljs-attribute">color</span>: green<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>类选择器<ul>
<li>格式：.class属性值</li>
</ul>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.p2</span> &#123;<br>	<span class="hljs-attribute">color</span>: blue<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>分组选择器</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#p1</span>, <span class="hljs-selector-class">.p2</span> &#123;<br>	<span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><ul>
<li><p>JavaScript可用书写的位置跟CSS类似，一共三种方式</p>
</li>
<li><p>变量</p>
<ul>
<li>通过var关键字声明一个变量</li>
<li>在使用变量的过程种可用给它赋任意值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a; a=<span class="hljs-number">123</span>; a=<span class="hljs-string">&quot;hello&quot;</span>;a=函数；a=对象；<br><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;javascript&quot;</span>;<br></code></pre></td></tr></table></figure></li>
<li><p>函数</p>
<ul>
<li>通过function关键字声明一个函数</li>
<li>在声明函数时不需要指定返回值的类型及形参的类型</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//方式一：</span><br><span class="hljs-comment">//不带参数的函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-comment">//函数体</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a,b</span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-comment">//方式二：</span><br><span class="hljs-keyword">var</span> sum2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b,c</span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> a + b + c;<br>&#125;<br><span class="hljs-comment">//我们通常是通过方式二这种方式将一个函数赋给对象的事件属性</span><br></code></pre></td></tr></table></figure></li>
<li><p>DOM</p>
<ul>
<li>全称：Document Object Model，文档对象模型</li>
<li>DOM种常用的属性和方法<ul>
<li>document.getElementById(“id属性值”)<ul>
<li>根据标签的id属性值获取一个具体的标签对象</li>
</ul>
</li>
<li>对象.innerHTML<ul>
<li>获取或设置成对出现的标签中的文本内容<ul>
<li>对象.innerHTML<ul>
<li>获取文本内容</li>
</ul>
</li>
<li>对象.innerHTML=”new valule”<ul>
<li>设置文本内容</li>
</ul>
</li>
</ul>
</li>
<li>在jQuery中与之对应的是text()/html()方法</li>
</ul>
</li>
<li>对象.onclick<ul>
<li>给对象绑定单击事件</li>
<li>在jQuery中与之对应的是click()方法</li>
</ul>
</li>
<li>对象.onfocus<ul>
<li>给对象绑定获取焦点事件</li>
<li>在jQuery中与之对应的是focus()方法</li>
</ul>
</li>
<li>对象.onblur<ul>
<li>给对象绑定失去焦点的事件</li>
<li>在jQuery中与之对应的是blur()方法</li>
</ul>
</li>
<li>对象.onchange<ul>
<li>给对象内容改变的事件</li>
<li>在jQuery中与之对应的是change()方法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><ul>
<li>Servlet是服务器端的一个组件，用来处理用户的请求</li>
<li>直接new一个Sersvlet，然后配置映射的请求地址即可</li>
<li>doGet和doPost方法中的两个参数request和response的作用<ul>
<li>request的作用<ul>
<li>获取请求参数</li>
<li>转发</li>
<li>它是一个域对象</li>
</ul>
</li>
<li>response的作用<ul>
<li>给浏览器响应一个字符串或一个页面</li>
<li>重定向</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//处理GET请求的方法</span><br>	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;doGet方法被调用&quot;</span>);<br>		<span class="hljs-comment">//request的作用</span><br>		<span class="hljs-comment">//1.获取请求参数</span><br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * GET请求的请求中文乱码问题的解决方案：</span><br><span class="hljs-comment">		 * 在Tomcat的配置文件server.xml中的第一个Connector标签中添加属性URIEncoding=&quot;UTF-8&quot;</span><br><span class="hljs-comment">		 */</span><br>		String username = request.getParameter(<span class="hljs-string">&quot;username&quot;</span>);<br>		String password = request.getParameter(<span class="hljs-string">&quot;password&quot;</span>);<br>		System.out.println(username);<br>		System.out.println(password);<br>		<span class="hljs-comment">//2.转发</span><br>		<span class="hljs-comment">//获取转发器</span><br>		RequestDispatcher requestDispatcher = request.getRequestDispatcher(<span class="hljs-string">&quot;WEB-INF/success.html&quot;</span>);<br>		<span class="hljs-comment">//进行请求的转发</span><br>		requestDispatcher.forward(request, response);<br>		<span class="hljs-comment">//3.request是一个域对象（下回分解）</span><br>	&#125;<br>	<span class="hljs-comment">//处理POST请求的方法</span><br>	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;doPost方法被调用&quot;</span>);<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * POST请求的请求中文乱码问题的解决方案：</span><br><span class="hljs-comment">		 * 在第一次获取请求参数之前，通过request设置字符集位UTF-8</span><br><span class="hljs-comment">		 */</span><br>		request.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>		String username = request.getParameter(<span class="hljs-string">&quot;username&quot;</span>);<br>		String password = request.getParameter(<span class="hljs-string">&quot;password&quot;</span>);<br>		System.out.println(username);<br>		System.out.println(password);<br>		<span class="hljs-comment">//response的作用</span><br>		<span class="hljs-comment">//1.给浏览器响应一个字符串或一个页面</span><br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * 响应中文乱码的解决方案：</span><br><span class="hljs-comment">		 * 	在获取流之前设置内容的类型，内容的类型中包含UTF-8字符集</span><br><span class="hljs-comment">		 */</span><br>		response.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<br>		PrintWriter writer = response.getWriter();<br><span class="hljs-comment">//		writer.write(&quot;Response Success!&quot;);</span><br><span class="hljs-comment">//		writer.write(&quot;响应成功！&quot;);</span><br><span class="hljs-comment">//		writer.write(&quot;&lt;!DOCTYPE html&gt;\r\n&quot; + </span><br><span class="hljs-comment">//				&quot;&lt;html&gt;\r\n&quot; + </span><br><span class="hljs-comment">//				&quot;&lt;head&gt;\r\n&quot; + </span><br><span class="hljs-comment">//				&quot;&lt;meta charset=\&quot;UTF-8\&quot;&gt;\r\n&quot; + </span><br><span class="hljs-comment">//				&quot;&lt;title&gt;Insert title here&lt;/title&gt;\r\n&quot; + </span><br><span class="hljs-comment">//				&quot;&lt;/head&gt;\r\n&quot; + </span><br><span class="hljs-comment">//				&quot;&lt;body&gt;\r\n&quot; + </span><br><span class="hljs-comment">//				&quot;	&lt;h1&gt;请求处理成功！&lt;/h1&gt;\r\n&quot; + </span><br><span class="hljs-comment">//				&quot;&lt;/body&gt;\r\n&quot; + </span><br><span class="hljs-comment">//				&quot;&lt;/html&gt;&quot;);</span><br>		<span class="hljs-comment">//2.重定向</span><br>		response.sendRedirect(<span class="hljs-string">&quot;WEB-INF/success.html&quot;</span>);<br>		<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * 转发与重定向的区别：</span><br><span class="hljs-comment">		 * 	1.转发浏览器发送一次请求；重定向浏览器发送两次请求</span><br><span class="hljs-comment">		 * 	2.转发浏览器地址栏地址无变化；重定向浏览器地址栏地址有变化</span><br><span class="hljs-comment">		 * 	3.转发可以访问WEB-INF目录下的资源；重定向不可以访问WEB-INF目录下的资源</span><br><span class="hljs-comment">		 * 	4.转发可以共享request域中的数据；重定向不可以共享request域中的数据</span><br><span class="hljs-comment">		 */</span><br>	&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><ul>
<li><p>JSP必须运行服务器上，它本质上是一个Servlet</p>
</li>
<li><p>HTML和Servlet能实现的功能JSP都可用实现</p>
</li>
<li><p>JSP中的基本语法</p>
<ul>
<li>JSP脚本片段<ul>
<li>格式：&lt;%   %&gt;</li>
<li>作用：在里面写Java代码</li>
</ul>
</li>
<li>JSP表达式<ul>
<li>格式：&lt;%=  %&gt;</li>
<li>作用：用来输出对象</li>
</ul>
</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;%<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">10</span> ; i++)&#123;<br>			<span class="hljs-comment">//out.print(&quot;伊朗要干美国了！&quot;);</span><br>	%&gt;<br>	&lt;h1&gt;伊朗要干美国了！&lt;/h1&gt;<br>	&lt;%	<br>		&#125;<br>	%&gt;<br><br> &lt;%=<span class="hljs-string">&quot;我是通过JSP表达式输出的&quot;</span> %&gt;<br></code></pre></td></tr></table></figure></li>
<li><p>四个域</p>
<ul>
<li>page域<ul>
<li>范围：当前页面</li>
<li>对应的域对象：pageContext</li>
<li>域对象的类型：PageContext</li>
</ul>
</li>
<li>request域<ul>
<li>范围：当前请求（一次请求）</li>
<li>对应的域对象：request</li>
<li>域对象的类型：HttpServletRequest</li>
</ul>
</li>
<li>session<ul>
<li>范围：当前会话（一次会话）</li>
<li>对应的域对象：session</li>
<li>域对象的类型：HttpSession</li>
</ul>
</li>
<li>application域<ul>
<li>范围：当前Web应用</li>
<li>对应的域对象：application</li>
<li>域对象的类型：ServletContext</li>
</ul>
</li>
<li>四个域对象都有以下三个方法<ul>
<li>void setAttribute(String key , Object value)</li>
<li>Object getAttribute(String key)</li>
<li>void removeAttribute(String key)</li>
</ul>
</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;!-- 在当前页面中分别向四个域中添加四个属性 --&gt;<br>	 &lt;%<br>	 	pageContext.setAttribute(<span class="hljs-string">&quot;pageKey&quot;</span>, <span class="hljs-string">&quot;pageValue&quot;</span>);<br>	 	request.setAttribute(<span class="hljs-string">&quot;reqKey&quot;</span>, <span class="hljs-string">&quot;reqValue&quot;</span>);<br>	 	session.setAttribute(<span class="hljs-string">&quot;sessKey&quot;</span>, <span class="hljs-string">&quot;sessValue&quot;</span>);<br>	 	application.setAttribute(<span class="hljs-string">&quot;appKey&quot;</span>, <span class="hljs-string">&quot;appValue&quot;</span>);<br>	 %&gt;<br>	 &lt;h1&gt;在当前页面中分别获取四个域中的属性值&lt;/h1&gt;<br>	 page域中的属性值是：&lt;%=pageContext.getAttribute(<span class="hljs-string">&quot;pageKey&quot;</span>) %&gt;&lt;br&gt;<br>	 request域中的属性值是：&lt;%=request.getAttribute(<span class="hljs-string">&quot;reqKey&quot;</span>) %&gt;&lt;br&gt;<br>	 session域中的属性值是：&lt;%=session.getAttribute(<span class="hljs-string">&quot;sessKey&quot;</span>) %&gt;&lt;br&gt;<br>	 application域中的属性值是：&lt;%=application.getAttribute(<span class="hljs-string">&quot;appKey&quot;</span>) %&gt;&lt;br&gt;<br></code></pre></td></tr></table></figure></li>
<li><p>EL</p>
<ul>
<li>EL全称是Expression Language，是JSP的内置表达式</li>
<li>格式：${表达式}</li>
<li>作用：主要用来获取域对象中的属性值，用来代替JSP的表达式</li>
<li>EL表达式获取数据时才输出，获取不到数据则什么也不输出</li>
<li>EL中的四个Scope对象<ul>
<li>pageScope<ul>
<li>获取page域中的属性值</li>
</ul>
</li>
<li>requestScope<ul>
<li>获取request域中的属性值</li>
</ul>
</li>
<li>sessionScope<ul>
<li>获取session域中的属性值</li>
</ul>
</li>
<li>applicationScope<ul>
<li>获取application域中的属性值</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;%<br>	 	Date date = <span class="hljs-keyword">new</span> Date();<br>	 	<span class="hljs-comment">//分别向四个域中添加四个属性</span><br>	 	pageContext.setAttribute(<span class="hljs-string">&quot;date&quot;</span>, date+<span class="hljs-string">&quot;-&quot;</span>);<br>	 	request.setAttribute(<span class="hljs-string">&quot;date&quot;</span>, date+<span class="hljs-string">&quot;--&quot;</span>);<br>	 	session.setAttribute(<span class="hljs-string">&quot;date&quot;</span>, date+<span class="hljs-string">&quot;---&quot;</span>);<br>	 	application.setAttribute(<span class="hljs-string">&quot;date&quot;</span>, date+<span class="hljs-string">&quot;----&quot;</span>);<br>	 %&gt;<br>	 通过JSP表达式获取域对象中的属性值：&lt;%=pageContext.getAttribute(<span class="hljs-string">&quot;date&quot;</span>) %&gt;&lt;br&gt;<br>	 通过EL表达式获取域对象中的属性值：$&#123;date &#125;&lt;br&gt;<br>	 通过EL表达式获取request域中的属性值：$&#123;requestScope.date &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><ul>
<li><p>全称：Asynchronous JavaScript And XML，通过JavaScript发送请求，使用XML作为响应数据，后来XML已经被另外一种数据格式JSON所替代</p>
</li>
<li><p>同步请求和异步请求的区别</p>
<ul>
<li>同步请求<ul>
<li>发送请求之后必须等待服务器的响应成功之后才能发送其他请求，有一个等待的过程</li>
<li>响应成功之后会刷新整个页面</li>
</ul>
</li>
<li>异步请求<ul>
<li>发送请求之后无需等待服务器的响应即可发送其他请求</li>
<li>响应成功之后不会刷新整个页面，可用局部更新页面中的内容</li>
</ul>
</li>
</ul>
</li>
<li><p>如果通过jQuery发送ajax请求</p>
<ul>
<li><p>使用$.ajax()方法发送Ajax请求</p>
<ul>
<li>ajax()方法中的常用选项<ul>
<li>url<ul>
<li>必须的。用来设置请求地址，值是一个字符串</li>
</ul>
</li>
<li>type<ul>
<li>可选的。用来设置请求方式。GET或POST，默认是GET，值是一个字符串</li>
</ul>
</li>
<li>data<ul>
<li>可选的。用来设置请求参数，值是一个字符串</li>
</ul>
</li>
<li>success<ul>
<li>可选的。用来设置一个回调函数，当响应成功之后系统会自动调用该函数，响应数据会以参数的形式传入到该函数中</li>
</ul>
</li>
<li>dataType<ul>
<li>可选的。用来设置响应数据的类型，如 text、json等</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">$.ajax(&#123;<br>				url:<span class="hljs-string">&quot;AjaxServlet&quot;</span>,<br>				type:<span class="hljs-string">&quot;get&quot;</span>,<br>				data:<span class="hljs-string">&quot;username=admin&amp;password=123456&quot;</span>,<br>				success:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)</span>&#123;<br>					<span class="hljs-comment">//将响应数据设置到span标签中</span><br>					$(<span class="hljs-string">&quot;#msg&quot;</span>).text(res);<br>				&#125;,<br>				dataType:<span class="hljs-string">&quot;text&quot;</span><br>			&#125;);<br></code></pre></td></tr></table></figure></li>
<li><p>JSON</p>
<ul>
<li>JOSN格式<ul>
<li>JSON对象</li>
<li>JSON数组</li>
</ul>
</li>
<li>JSON中接受的数据类型<ul>
<li>字符串</li>
<li>数字</li>
<li>null</li>
<li>布尔类型</li>
<li>数组</li>
<li>对象</li>
</ul>
</li>
<li>在JS中JSON对象和JSON字符串之间的转换<ul>
<li>JSON对象转JSON字符串<ul>
<li>JSON.stringify(JSON对象)</li>
</ul>
</li>
<li>JSON字符串转JSON对象<ul>
<li>JSON.parse(JSON字符串)</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//JSON的格式：</span><br>	<span class="hljs-comment">//1.JSON对象</span><br>	<span class="hljs-comment">//属性名必须使用双引号括起来；属性名和属性值之间使用冒号分隔；多个属性之间使用逗号分隔</span><br>	<span class="hljs-keyword">var</span> jsonObj = &#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;孙悟空&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">520</span>&#125;;<br><span class="hljs-comment">// 	alert(jsonObj);</span><br>	<span class="hljs-comment">//2.JSON数组</span><br>	<span class="hljs-keyword">var</span> jsonArry = [<span class="hljs-string">&quot;猪八戒&quot;</span>,<span class="hljs-number">1500</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">null</span>,jsonObj];<br>	<span class="hljs-comment">//获取jsonArry中的jsonObj中的age属性值</span><br><span class="hljs-comment">// 	alert(jsonArry[4].age);</span><br>	<br>	<span class="hljs-comment">//在JS中将JSON对象转换为JSON字符串</span><br>	<span class="hljs-keyword">var</span> objToStr = <span class="hljs-built_in">JSON</span>.stringify(jsonObj);<br><span class="hljs-comment">// 	alert(objToStr);</span><br>	<span class="hljs-comment">//声明一个JSON字符串</span><br>	<span class="hljs-keyword">var</span> jsonStr = <span class="hljs-string">&#x27;&#123;&quot;name&quot;:&quot;唐僧&quot;,&quot;age&quot;:18&#125;&#x27;</span>;<br><span class="hljs-comment">// 	alert(jsonStr);</span><br>	<span class="hljs-comment">//在JS中将JSON字符串转换为JSON对象</span><br>	<span class="hljs-keyword">var</span> strToObj = <span class="hljs-built_in">JSON</span>.parse(jsonStr);<br><span class="hljs-comment">// 	alert(strToObj.name);</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p>在Java中对象与JSON字符串之间的转换</p>
<ul>
<li><p>借助于第三方工具json-lib、jackson、gson等可用将Java对象转换为JSON字符串，也可用将JSON字符串转换回Java对象</p>
</li>
<li><p>通常是前端发送一个Ajax请求，在后台查询到对象之后将对象转换为JOSN字符串响应到前端</p>
</li>
<li><p>通过发送Ajax请求接收JSON格式的响应数据</p>
<ul>
<li>前端代码</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//发送Ajax请求接收JSON格式的响应数据</span><br>			$.ajax(&#123;<br>				url:<span class="hljs-string">&quot;JSONServlet&quot;</span>,<br>				success:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)</span>&#123;<br>					alert(res.id);<br>				&#125;,<br>				dataType:<span class="hljs-string">&quot;json&quot;</span><br>			&#125;);<br></code></pre></td></tr></table></figure>



<ul>
<li>后端代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="hljs-function">			<span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>		response.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<br>		<span class="hljs-comment">//假设从数据库中查询到员工的信息</span><br>		Employee employee = <span class="hljs-keyword">new</span> Employee(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;zhangsan@atguigu.com&quot;</span>);<br>		<span class="hljs-comment">//创建Gson对象</span><br>		Gson gson = <span class="hljs-keyword">new</span> Gson();<br>		<span class="hljs-comment">//将Employee对象转换为JSON字符串</span><br>		String json = gson.toJson(employee);<br>		System.out.println(json);<br>		<span class="hljs-comment">//给浏览器响应一个JSON格式的字符串</span><br>		response.getWriter().write(json);<br>	&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark</title>
    <url>/2021/08/27/Spark/</url>
    <content><![CDATA[<h1 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h1><h2 id="Spark入门"><a href="#Spark入门" class="headerlink" title="Spark入门"></a>Spark入门</h2><ul>
<li><p>spark是一种基于内存的快速，通用，可扩展的大数据分析计算引擎。</p>
</li>
<li><p>spark内置模块</p>
<p><a href="https://imgtu.com/i/h16ZB4"><img src="https://z3.ax1x.com/2021/08/28/h16ZB4.png" alt="h16ZB4.png"></a></p>
<ul>
<li>spark core：实现了Spark的基本功能，包含任务调度、内存管理、错误恢复、与存储系统交互等模块。Spark Core中还包含了对弹性分布式数据集(Resilient Distributed DataSet，简称RDD)的API定义。 </li>
<li>Spark SQL：是Spark用来操作结构化数据的程序包。通过Spark SQL，我们可以使用 SQL或者Apache Hive版本的HQL来查询数据。Spark SQL支持多种数据源，比如Hive表、Parquet以及JSON等。</li>
<li>Spark Streaming：是Spark提供的对实时数据进行流式计算的组件。提供了用来操作数据流的API，并且与Spark Core中的 RDD API高度对应。 </li>
<li>Spark MLlib：提供常见的机器学习功能的程序库。包括分类、回归、聚类、协同过滤等，还提供了模型评估、数据 导入等额外的支持功能。 </li>
<li>Spark GraphX：主要用于图形并行计算和图挖掘系统的组件。</li>
<li>集群管理器：Spark设计为可以高效地在一个计算节点到数千个计算节点之间伸缩计算。为了实现这样的要求，同时获得最大灵活性，Spark支持在各种集群管理器(Cluster Manager)上运行，包括Hadoop YARN、Apache Mesos，以及Spark自带的一个简易调度器，叫作独立调度器。</li>
</ul>
</li>
</ul>
<h3 id="Spark运行模式"><a href="#Spark运行模式" class="headerlink" title="Spark运行模式"></a>Spark运行模式</h3><ul>
<li>运行模式:单机模式，集群模式<ul>
<li>Local模式：本地部署单个spark模式</li>
<li>Standalone：spark自带的任务调度模式</li>
<li>YARN模式：spark使用Hadoop的YARN组件进行资源与任务调度。（重点）<ul>
<li>修改/opt/module/spark/conf/spark-env.sh，添加YARN_CONF_DIR配置:YARN_CONF_DIR=/opt/module/hadoop-3.1.3/etc/hadoop，保证后续运行任务的路径都变成集群路径</li>
</ul>
</li>
<li>Mesos模式：saprk使用Mesos平台进行资源与任务的调度。</li>
</ul>
</li>
<li>运行流程<ul>
<li>Spark有yarn-client和yarn-cluster两种模式，主要区别在于：Driver程序的运行节点。</li>
<li>yarn-client:Driver程序运行在客户端，适用于交互，调试，希望立即看到app的输出。</li>
<li>yarn-cluster：Driver程序运行在由ResourceManager启动的APPMaster，适用于生产环境。</li>
</ul>
</li>
<li>端口号总结<ul>
<li>spark历史服务器端口号：18080                         hadoop历史服务器端口号：19888</li>
<li>spark Master web服务器端口号：8080             Hadoop的namenode web端口号：9870</li>
<li>spark Master内部通信服务端口号：7077           Hadoop的namenode内部通信服务端口号：8020</li>
<li>Spark查看当前Spark-shell运行任务情况端口号：4040</li>
<li>hadoop yarn任务运行情况查看端口号：8088</li>
</ul>
</li>
</ul>
<h2 id="SparkCore"><a href="#SparkCore" class="headerlink" title="SparkCore"></a>SparkCore</h2><h3 id="RDD概述"><a href="#RDD概述" class="headerlink" title="RDD概述"></a>RDD概述</h3><ul>
<li><p>RDD（Resilient Distributed Dataset）弹性分布式数据集，是Spark中最基本的数据抽象。</p>
<ul>
<li><a href="https://imgtu.com/i/hdgUNq"><img src="https://z3.ax1x.com/2021/08/31/hdgUNq.png" alt="hdgUNq.png"></a></li>
</ul>
</li>
<li><p>RDD特性</p>
<p><a href="https://imgtu.com/i/hwcbRK"><img src="https://z3.ax1x.com/2021/09/01/hwcbRK.png" alt="hwcbRK.png"></a></p>
</li>
<li><p>yarn模式下的sparkWordCount实现案例：大致流程</p>
<ul>
<li><a href="https://imgtu.com/i/hdg2U1"><img src="https://z3.ax1x.com/2021/08/31/hdg2U1.png" alt="hdg2U1.png"></a></li>
<li><a href="https://imgtu.com/i/hwccGV"><img src="https://z3.ax1x.com/2021/09/01/hwccGV.png" alt="hwccGV.png"></a></li>
<li>任务从客户端发送到ReourceManager，RM指定一个NM创建一个AppMster进程，创建spark的一个Driver线程，Driver线程将任务分配到其它的NM，其它的NodeManager申请container，container会创建spark的一个excutor线程，RDD根据会根据分区进行一系列transformations转换定义，也会在一些情况下有shuffer过程，程序不会立刻执行，而是直到调用action触发调用RDD的计算。</li>
</ul>
</li>
</ul>
<h3 id="RDD编程"><a href="#RDD编程" class="headerlink" title="RDD编程"></a>RDD编程</h3><ul>
<li>在spark中只有遇到action（如rdd.collect）才会执行RDD的计算（即延迟计算）</li>
</ul>
<h4 id="RDD的创建"><a href="#RDD的创建" class="headerlink" title="RDD的创建"></a>RDD的创建</h4><ul>
<li>从集合中创建</li>
<li>从外部存储（HDFS，Hbase）创建</li>
<li>通过RDD的转换算子转换</li>
</ul>
<h4 id="分区规则"><a href="#分区规则" class="headerlink" title="分区规则"></a>分区规则</h4><ul>
<li><p>分区数：</p>
<ul>
<li><p>创建RDD的方法都可以指定分区数</p>
</li>
<li><p>如果SparkConf.setMaster(local[*])，从集合创建默认是cpu核数，从外部存储创建默认是math.min(分配给应用的CPU核数,2)</p>
</li>
</ul>
</li>
<li><p>数据分区规则：</p>
<ul>
<li>通过集合创建RDD的情况：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">positions</span></span>(length: <span class="hljs-type">Long</span>, numSlices: <span class="hljs-type">Int</span>): <span class="hljs-type">Iterator</span>[(<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>)] = &#123;<br>      (<span class="hljs-number">0</span> until numSlices).iterator.map &#123; i =&gt;<br>        <span class="hljs-keyword">val</span> start = ((i * length) / numSlices).toInt<br>        <span class="hljs-keyword">val</span> end = (((i + <span class="hljs-number">1</span>) * length) / numSlices).toInt<br>        (start, end)<br>      &#125;<br>    &#125;<br><span class="hljs-comment">//通过返回这样一个左闭右开的迭代元组对象，元组里面是以一组组下标，根据下标划分集合元素</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p>通过外部存储创建RDD的情况：</p>
<ul>
<li>默认分区规则math.min(分配给应用的CPU核数,2)</li>
<li>指定分区：在TextFile方法中，第二个参数minPartitions，表示最小分区数（是最小，不代表实际的分区数）</li>
<li>在实际计算分区个数时，会根据文件的总大小和最小分区数进行相除运算，如果余数为0，那最小分区数就是实际分区数，否则需要进一步计算得到分区数。</li>
<li>切片规划：调用FileInputFormat中的getSplits方法</li>
<li>注意：getSplits文件返回的是切片规划，真正读取是在compute方法中创建LineRecordReader读取的，有两个关键变量start=split.getStart()      end = start + split.getLength</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala">public <span class="hljs-type">InputSplit</span>[] getSplits(<span class="hljs-type">JobConf</span> job, int numSplits)<br>  <span class="hljs-keyword">throws</span> <span class="hljs-type">IOException</span> &#123;<br>  <span class="hljs-type">FileStatus</span>[] files = listStatus(job);<br>  <br>  <span class="hljs-comment">// Save the number of input files for metrics/loadgen</span><br>  job.setLong(<span class="hljs-type">NUM_INPUT_FILES</span>, files.length);<br>  long totalSize = <span class="hljs-number">0</span>;                           <span class="hljs-comment">// compute total size</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">FileStatus</span> file: files) &#123;                <span class="hljs-comment">// check we have valid files</span><br>    <span class="hljs-keyword">if</span> (file.isDirectory()) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">IOException</span>(<span class="hljs-string">&quot;Not a file: &quot;</span>+ file.getPath());<br>    &#125;<br>    totalSize += file.getLen();<br>  &#125;<br>    <br>  long goalSize = totalSize / (numSplits == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : numSplits);<br>  long minSize = <span class="hljs-type">Math</span>.max(job.getLong(org.apache.hadoop.mapreduce.lib.input.<br>    <span class="hljs-type">FileInputFormat</span>.<span class="hljs-type">SPLIT_MINSIZE</span>, <span class="hljs-number">1</span>), minSplitSize);<br>    <br>  <span class="hljs-comment">// generate splits</span><br>  <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-type">FileSplit</span>&gt; splits = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-type">FileSplit</span>&gt;(numSplits);<br>  <span class="hljs-type">NetworkTopology</span> clusterMap = <span class="hljs-keyword">new</span> <span class="hljs-type">NetworkTopology</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">FileStatus</span> file: files) &#123;<br>    <span class="hljs-type">Path</span> path = file.getPath();<br>    long length = file.getLen();<br>    <span class="hljs-keyword">if</span> (length != <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-type">FileSystem</span> fs = path.getFileSystem(job);<br>      <span class="hljs-type">BlockLocation</span>[] blkLocations;<br>      <span class="hljs-keyword">if</span> (file instanceof <span class="hljs-type">LocatedFileStatus</span>) &#123;<br>        blkLocations = ((<span class="hljs-type">LocatedFileStatus</span>) file).getBlockLocations();<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        blkLocations = fs.getFileBlockLocations(file, <span class="hljs-number">0</span>, length);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (isSplitable(fs, path)) &#123;<br>        long blockSize = file.getBlockSize();<br>        long splitSize = computeSplitSize(goalSize, minSize, blockSize);<br>    <br>        long bytesRemaining = length;<br>        <span class="hljs-keyword">while</span> (((double) bytesRemaining)/splitSize &gt; <span class="hljs-type">SPLIT_SLOP</span>) &#123;<br>          <span class="hljs-type">String</span>[] splitHosts = getSplitHosts(blkLocations,<br>              length-bytesRemaining, splitSize, clusterMap);<br>          splits.add(makeSplit(path, length-bytesRemaining, splitSize,<br>              splitHosts));<br>          bytesRemaining -= splitSize;<br>        &#125;<br>    <br>        <span class="hljs-keyword">if</span> (bytesRemaining != <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-type">String</span>[] splitHosts = getSplitHosts(blkLocations, length<br>              - bytesRemaining, bytesRemaining, clusterMap);<br>          splits.add(makeSplit(path, length - bytesRemaining, bytesRemaining,<br>              splitHosts));<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">String</span>[] splitHosts = getSplitHosts(blkLocations,<span class="hljs-number">0</span>,length,clusterMap);<br>        splits.add(makeSplit(path, <span class="hljs-number">0</span>, length, splitHosts));<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123; <br>      <span class="hljs-comment">//Create empty hosts array for zero length files</span><br>      splits.add(makeSplit(path, <span class="hljs-number">0</span>, length, <span class="hljs-keyword">new</span> <span class="hljs-type">String</span>[<span class="hljs-number">0</span>]));<br>    &#125;<br>  &#125;<br>  <span class="hljs-type">LOG</span>.debug(<span class="hljs-string">&quot;Total # of splits: &quot;</span> + splits.size());<br>  <span class="hljs-keyword">return</span> splits.toArray(<span class="hljs-keyword">new</span> <span class="hljs-type">FileSplit</span>[splits.size()]);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="Transformation转换算子（重点）"><a href="#Transformation转换算子（重点）" class="headerlink" title="Transformation转换算子（重点）"></a>Transformation转换算子（重点）</h3><ul>
<li>算子：从认知心理学角度来讲，解决问题其实是将问题的初始状态，通过一系列的转换操作（operator），变成解决状态。</li>
<li>转换算子（Transformation）执行完毕之后，会创建新的RDD，并不会马上执行计算。</li>
<li>行动算子（Action）执行后，才会触发计算。</li>
</ul>
<h4 id="Value类型"><a href="#Value类型" class="headerlink" title="Value类型"></a>Value类型</h4><ul>
<li><p>map</p>
<ul>
<li>对RDD中的元素进行一个个映射</li>
<li>新RDD中的每一个元素都是原来RDD中每一个元素依次应用f函数而得到的。</li>
</ul>
</li>
<li><p>mapPartitions</p>
<ul>
<li>以分区为单位，对RDD中的元素进行映射</li>
</ul>
</li>
<li><p>mapPartitionsWithIndex</p>
<ul>
<li>以分区为单位，对RDD中的元素进行映射，并且带分区编号</li>
</ul>
</li>
<li><p>flatMap</p>
<ul>
<li>对RDD中的元素进行扁平化处理</li>
<li>在flatMap操作中，f函数的返回值是一个集合，并且会将每一个该集合的元素拆分出来放到新的RDD中。</li>
</ul>
</li>
<li><p>glom</p>
<ul>
<li>将RDD中每一个分区中的单个元素，转换为数组</li>
</ul>
</li>
<li><p>groupBy</p>
<ul>
<li>按照一定的规则，对RDD中的元素进行分组</li>
<li>按照传入函数的返回值进行分组，将相同的key对应的值放入一个迭代器</li>
</ul>
</li>
<li><p>filter</p>
<ul>
<li>按照一定的规则，对RDD中的元素进行过滤</li>
</ul>
</li>
<li><p>sample</p>
<ul>
<li><p>对RDD中的元素进行抽样</p>
</li>
<li><p>参数一：是否抽象放回   true放回，false不放回</p>
</li>
<li><p>参数二 ：参数一以为true时，放回抽样，参数二代表期望元素出现的次数   参数大于0</p>
</li>
<li><p>参数二：参数一为false时，不放回抽样，参数二代表每一个元素出现的概率[0,1]</p>
</li>
<li><p>参数三：随机算法的初始种子</p>
</li>
<li><p>takeSample（行动算子）</p>
</li>
</ul>
</li>
<li><p>distinct</p>
<ul>
<li>去重</li>
<li>底层是通过map+reduceByKey完成去重操作</li>
</ul>
</li>
<li><p>改变分区</p>
<ul>
<li><p>def coalesce(numPartitions: Int, shuffle: Boolean = false,</p>
<pre><code>           partitionCoalescer: Option[PartitionCoalescer] = Option.empty)
          (implicit ord: Ordering[T] = null) : RDD[T]
</code></pre>
</li>
<li><p>coalesce   一般用于缩减分区，默认不执行shuffle</p>
</li>
<li><p>reparation  一般用于扩大分区，默认执行shuffle，底层调用的就是coalesce</p>
</li>
</ul>
</li>
<li><p>sortBy</p>
<ul>
<li>按照指定规则，对RDD中的元素进行排序，默认升序</li>
<li>该操作用于排序数据，在排序之前，可以将数据通过f函数进行处理，之后按照f函数处理的结果进行排序，默认为正排序。排序后新产生的RDD分区数与原RDD的分区数一致。</li>
</ul>
</li>
<li><p>pipe()</p>
<ul>
<li>对于RDD中的每一个分区，都会执行pipe 算子中指定的脚本</li>
</ul>
</li>
</ul>
<h4 id="双Value类型"><a href="#双Value类型" class="headerlink" title="双Value类型"></a>双Value类型</h4><ul>
<li>两个RDD之间进行操作：对源RDD和参数RDD进行操作，返回一个新的RDD</li>
<li>union()<ul>
<li>并集</li>
</ul>
</li>
<li>intersection<ul>
<li>交集</li>
</ul>
</li>
<li>subtract<ul>
<li>差集</li>
</ul>
</li>
<li>zip<ul>
<li>拉链，该操作可以将两个RDD中的元素，以键值对的形式进行合并。其中，键值对中的key为第一个RDD中的元素，value为第二个RDD中的元素。</li>
<li>注意必须要保证分区数以及每一个分区中元素的个数一致</li>
</ul>
</li>
</ul>
<h4 id="Key-Value类型"><a href="#Key-Value类型" class="headerlink" title="Key-Value类型"></a>Key-Value类型</h4><ul>
<li><p>PartitionBy</p>
<ul>
<li>按照指定的分区其，通过key对RDD中的元素进行分区</li>
<li>默认分区器  HashPartitioner</li>
</ul>
</li>
<li><p>reduceByKey</p>
<ul>
<li>将相同的key放在一起，对value进行聚合操作</li>
</ul>
</li>
<li><p>groupByKey</p>
<ul>
<li>按照key对RDD中的元素进行分组。对每个key进行操作，但只生成一个seq ,并不进行聚合。</li>
</ul>
</li>
<li><p>reduceByKey和groupByKey的区别</p>
<ul>
<li>reduceByKey：按照key进行聚合，在shuffle之前有combine（预聚合）操作，返回结果是RDD[k,v]</li>
<li>groupByKey: 按照key进行分组，直接进行shuffle</li>
<li>在不影响业务逻辑的前提下，优先选用reduceByKey。求和操作不影响业务逻辑，求平均值影响业务逻辑。</li>
</ul>
</li>
<li><p>aggregateByKey[(zeroValue)(分区内计算规则，分区间计算规则)]</p>
<ul>
<li>（1）zeroValue（初始值）：给每一个分区中的每一种key一个初始值；<br>（2）seqOp（分区内）：函数用于在每一个分区中用初始值逐步迭代value；<br>（3）combOp（分区间）：函数用于合并每个分区中的结果。</li>
</ul>
</li>
<li><p>foldByKey(zeroValue)（分区间计算规则）</p>
<ul>
<li>是aggregateBykey的简化，分区内和分区间计算规则相同</li>
</ul>
</li>
<li><p>combineByKey (对当前key的value进行转换,分区内计算规则,分区间计算规则)</p>
</li>
<li><p>几种聚合算子对比</p>
<ul>
<li><p>上面四个聚合算子底层都是调用</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala">&gt;reduceByKey(_+_)<br>	combineByKeyWithClassTag[<span class="hljs-type">V</span>]((v: <span class="hljs-type">V</span>) =&gt; v, func, func)<br>    <br>&gt;aggregateByKey(zeroValue)(cleanedSeqOp,combOp)<br>	combineByKeyWithClassTag[<span class="hljs-type">U</span>]((v: <span class="hljs-type">V</span>) =&gt; cleanedSeqOp(createZero(), v),cleanedSeqOp, combOp)<br>    <br>&gt;foldByKey<br>	combineByKeyWithClassTag[<span class="hljs-type">V</span>]((v: <span class="hljs-type">V</span>) =&gt; cleanedFunc(createZero(), v),cleanedFunc, cleanedFunc)<br>    <br>&gt;combineByKey<br>	combineByKeyWithClassTag(createCombiner, mergeValue, mergeCombiners)	<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>sortByKey</p>
<ul>
<li>按照RDD的中的key对元素进行排序</li>
</ul>
</li>
<li><p>mapValues</p>
<ul>
<li>只对RDD中的value进行操作</li>
</ul>
</li>
<li><p>join&amp;cogroup</p>
<ul>
<li>连接操作</li>
</ul>
</li>
</ul>
<h3 id="行动算子（Action）"><a href="#行动算子（Action）" class="headerlink" title="行动算子（Action）"></a>行动算子（Action）</h3><ul>
<li><p>行动算子执行后，才会触发计算</p>
</li>
<li><p>reduce</p>
<ul>
<li>对RDD中的元素进行聚合</li>
</ul>
</li>
<li><p>collect.foreach和foreach</p>
<ul>
<li><p>collect.foreach：将每一个Excutor中的数据收集到Driver，形成一个新的数组<br>.foreach不是一个算子，是集合的方法，是对数组中的元素进行遍历</p>
</li>
<li><p>foreach：对RDD中的元素进行遍历</p>
</li>
</ul>
</li>
<li><p>count</p>
<ul>
<li>获取RDD中元素的个数</li>
</ul>
</li>
<li><p>countByKey</p>
<ul>
<li>获取RDD中每个key对应的元素个数</li>
</ul>
</li>
<li><p>first</p>
<ul>
<li>获取RDD中的第一个元素</li>
</ul>
</li>
<li><p>take</p>
<ul>
<li>获取RDD中的前几个元素</li>
</ul>
</li>
<li><p>takeOrdered</p>
<ul>
<li>获取排序后的RDD中的前几个元素</li>
</ul>
</li>
<li><p>aggregate&amp;fold</p>
<ul>
<li>aggregateByKey  处理kv类型的RDD，并且在进行分区间聚合的时候，初始值不参与运算</li>
<li>fold 是aggregate的简化版</li>
</ul>
</li>
<li><p>save相关的算子</p>
<ul>
<li>saveAsTextFile</li>
<li>saveAsObjectFile</li>
<li>saveAsSequenceFile(只针对KV类型RDD)</li>
</ul>
</li>
</ul>
<h3 id="RDD序列化"><a href="#RDD序列化" class="headerlink" title="RDD序列化"></a>RDD序列化</h3><ul>
<li>为什么要序列化：因为在spark程序中，算子相关的操作在Excutor上执行，算子之外的代码在Driver端执行，在执行有些算子时，需要使用Driver里面定义的数据，这就涉及到了跨进程或者跨节点之间的通讯，所以这就涉及到了跨进程或者跨节点之间的通讯。所以要求传递给Excutor中的数组所属的类型必须实现Serializable接口。</li>
<li>如何判断是否实现了序列化接口：在作业job提交之前，其中有一行代码 val cleanF = sc.clean(f)，用于进行闭包检查之所以叫闭包检查，是因为在当前函数的内部访问了外部函数的变量，属于闭包的形式。如果算子的参数是函数的形式，都会存在这种情况。</li>
</ul>
<h3 id="RDD的血缘关系以及依赖关系"><a href="#RDD的血缘关系以及依赖关系" class="headerlink" title="RDD的血缘关系以及依赖关系"></a>RDD的血缘关系以及依赖关系</h3><ul>
<li>血缘关系<ul>
<li>toDebugString</li>
</ul>
</li>
<li>依赖关系<ul>
<li>dependencies</li>
<li>窄依赖：父RDD一个分区中的数据，还是交给子RDD的一个分区处理</li>
<li>宽依赖：父RDD一个分区中的数据，交给子RDD的多个分区处理。分区中数据打乱了，进行了shuffle操作</li>
</ul>
</li>
</ul>
<h3 id="Spark的Job调度（重点）"><a href="#Spark的Job调度（重点）" class="headerlink" title="Spark的Job调度（重点）"></a>Spark的Job调度（重点）</h3><ul>
<li>集群(Standalone|Yarn)<ul>
<li>一个Spark集群可以同时运行多个spark应用</li>
</ul>
</li>
<li>应用<ul>
<li>我们所编写完成某些功能的程序</li>
<li>一个应用可以并发的运行多个Job</li>
</ul>
</li>
<li>Job<ul>
<li>Job对应着应用中的行动算子，每次执行一个行动算子，都会提交一个Job</li>
<li>一个Job由多个stage组成</li>
</ul>
</li>
<li>Stage<ul>
<li>一个宽依赖做一次阶段的划分</li>
<li>阶段的个数=宽依赖的个数+1</li>
<li>一个Stage由多个Task组成</li>
</ul>
</li>
<li>Task<ul>
<li>每一个阶段最后一个RDD的分区数，就是当前阶段的Task个数</li>
</ul>
</li>
</ul>
<h3 id="数据读取与保存"><a href="#数据读取与保存" class="headerlink" title="数据读取与保存"></a>数据读取与保存</h3><h4 id="RDD的持久化"><a href="#RDD的持久化" class="headerlink" title="RDD的持久化"></a>RDD的持久化</h4><ul>
<li>cache   底层调用persist，默认存储在内存中  相当于缓存，当有多个行动算子时，前面相同的操作部分可以进行缓存，减少重复计算。</li>
<li>persist  可以通过参数指定存储级别   内存，磁盘</li>
<li>checkpoint   检查点会切断血缘关系，会把中间结果记录下来，一般存储在高可用的存储系统中（如HDFS）<ul>
<li>作用：为了避免容错执行时间过长</li>
<li>一般和缓存搭配使用，因为在切断血缘关系后，为保证中间结果的正确性，会将前面的操作再运行一遍，加上缓存后，就不用再重复计算一遍。</li>
</ul>
</li>
</ul>
<h4 id="文件保存"><a href="#文件保存" class="headerlink" title="文件保存"></a>文件保存</h4><ul>
<li>textFile</li>
<li>sequenceFile   SequenceFile文件是Hadoop用来存储二进制形式的key-value对而设计的一种平面文件(Flat File)</li>
<li>objectFile        对象文件是将对象序列化后保存的文件，采用Java的序列化机制。</li>
<li>Json   本质还是通过textFile读取文本，对读到的内容进行处理</li>
<li>HDFS</li>
<li>MySQL<ul>
<li>map———mapPartition</li>
<li>foreach——-foreachPartion</li>
</ul>
</li>
</ul>
<h3 id="累加器-广播变量"><a href="#累加器-广播变量" class="headerlink" title="累加器 广播变量"></a>累加器 广播变量</h3><ul>
<li>Spark三大结构<ul>
<li>RDD   弹性分布式数据集</li>
<li>累加器   分布式共享只写变量</li>
<li>广播变量  分布式共享只读变量</li>
</ul>
</li>
<li>累加器    Driver端的变量会复制到Excutor端的Task中去，但是Driver端不能读到Excutor中的变量。累加器可以实现将EXcutor端数据的改变传回到Driver端去<ul>
<li>自定义累加器：继承AccumulatorV2，设定输入、输出泛型     重写方法</li>
</ul>
</li>
<li>广播变量<ul>
<li>在多个并行操作中（Executor）使用同一个变量，Spark默认会为每个任务(Task)分别发送，这样如果共享比较大的对象，会占用很大工作节点的内存。</li>
<li>广播变量用来高效分发较大的对象。向所有工作节点发送一个较大的只读值，以供一个或多个Spark操作使用。</li>
<li>实现Excutor端Task之间共享变量，节省内存</li>
</ul>
</li>
</ul>
<h2 id="Spark-SQL"><a href="#Spark-SQL" class="headerlink" title="Spark SQL"></a>Spark SQL</h2><h3 id="Spark-SQL概述"><a href="#Spark-SQL概述" class="headerlink" title="Spark SQL概述"></a>Spark SQL概述</h3><ul>
<li><p>Spark SQL是Spark用于结构化数据（structured data）处理Spark模块</p>
</li>
<li><p>与Hive类似，将Spark SQL转换成RDD，然后提交到集群执行，执行效率非常快</p>
</li>
<li><p>Spark Sql提供了2个编程抽象，类似Spark Core中的RDD</p>
<ul>
<li>DataFrame</li>
<li>DataSet</li>
</ul>
</li>
<li><p>DataFrame</p>
<ul>
<li>在Spark中，<font color=red>DataFrame是一种以RDD为基础的分布式数据集，类似于传统数据中的二维表格。</font></li>
<li>DataFrame与RDD的主要区别在于，前者带有schema元信息，即DataFrame所表示的二维表数据集的每一列都带有名称和类型。</li>
<li>这使得Spark SQL得以洞察更多的结构信息，从而对藏于DataFrame背后的数据源以及作用于DataFrame之上的变换进行了针对性的优化，最终达到大幅提升运行时效率的目标。反观RDD，由于无从得知所存数据元素的具体内部结构，Spark Core只能在stage层面进行简单、通用的流水线优化。</li>
</ul>
</li>
<li><p>DataSet</p>
<ul>
<li>DataSet是分布式数据集合。</li>
<li>是DataFrame的一个扩展。它提供了RDD的优势（强类型，使用强大的lambda函数的能力）以及Spark SQL优化执行引擎的优点。DataSet也可以使用功能性的转换（操作map，flatMap，filter等等）。</li>
<li>DataFrame是DataSet的特例</li>
</ul>
</li>
</ul>
<h3 id="Spark-SQL编程"><a href="#Spark-SQL编程" class="headerlink" title="Spark SQL编程"></a>Spark SQL编程</h3><ul>
<li>SparkSession是spark最新的SQL查询起始点</li>
</ul>
<h4 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h4><ul>
<li>创建DataFrame<ul>
<li>通过spark的数据源进行创建<ul>
<li>如果从内存中读取数据，spark可以知道是什么数据类型，如果是数字，默认做Int处理；但是从文件中读取的数字，不能确定是什么类型，所以用bigint接收，可以和Long类型转换，但是和Int不能进行转换。</li>
</ul>
</li>
<li>从一个存在的RDD进行转换</li>
<li>从hive Table进行查询返回</li>
</ul>
</li>
<li>SQL风格语法：是指我们查询数据的时候使用SQL语句来查询，这种风格的查询必须要有临时视图或者全局视图来辅助。</li>
<li>DSL风格语法：DataFrame提供一个特定领域语言（domain-specific language,DSL）去管理结构化的数据，可以在Scala，Java，Python和R中使用DSL，使用DSL语法风格不必再创建视图了。</li>
</ul>
<h4 id="DataSet"><a href="#DataSet" class="headerlink" title="DataSet"></a>DataSet</h4><ul>
<li>DataSet是具有强类型的数据集合，需要提供对应的类型信息。它是和类对应起来的。</li>
<li>创建方式<ul>
<li>使用样例类序列创建DataSet</li>
<li>使用基本类型的序列创建DataSet</li>
<li>RDD，DataFrame转换为DataSet</li>
</ul>
</li>
</ul>
<h4 id="RDD，DataFrame，DataSet三者之间的关系"><a href="#RDD，DataFrame，DataSet三者之间的关系" class="headerlink" title="RDD，DataFrame，DataSet三者之间的关系"></a>RDD，DataFrame，DataSet三者之间的关系</h4><ul>
<li>三者的共性<ul>
<li>都是spark平台下的分布式弹性数据集，为处理超大型数据提供便利</li>
<li>三者都有惰性，再创建，转换，等操作时不会立即执行，只有再遇到Action操作时，才会开始运算。</li>
</ul>
</li>
<li>三者的区别<ul>
<li>RDD不支持SparkSQL操作</li>
<li>DataFrame每一行的类型固定为Row,每一列的值没法直接访问，只有通过解析才能获取各个字段的值。</li>
<li>DataFrame是DataSet的一个特例  type DataFrame=Dataset[Row]</li>
<li>DataFrame也可以叫DataSet[Row],每一行的类型Row，不解析，每一行究竟有哪些字段，各个字段又是什么类型都无法得知，只能用getAS方法或者共性中的第七条提到的模式匹配拿出特定字段。而DataSet中，每一行是什么类型是不一定的，在自定义了case  class之后可以很方便的获取每一行的信息。</li>
</ul>
</li>
<li>三者之间的转换关系图<ul>
<li><a href="https://imgtu.com/i/4Dw8YQ"><img src="https://z3.ax1x.com/2021/09/24/4Dw8YQ.png" alt="4Dw8YQ.png"></a></li>
<li>速记<ul>
<li>转换成RDD都是rdd</li>
<li>转换成DataFrame都是toDF。RDD到DF是toDF(“列名”)</li>
<li>RDD转换成DataSet是：转换样例类.toDS;DataFrame转换成是:as[类型]</li>
</ul>
</li>
<li>如果需要RDD与DF或者DS之间操作，那么需要引入<font color=red>import spark.implicits._ (spark不是包名，而是sparkSession对象的名称，所以必须先创建SparkSession再导入对象，.implicits是一个内部的object)</font></li>
</ul>
</li>
</ul>
<h3 id="Spark-sql-任务优化"><a href="#Spark-sql-任务优化" class="headerlink" title="Spark sql 任务优化"></a>Spark sql 任务优化</h3><h4 id="spark-sql-任务中小文件的优化"><a href="#spark-sql-任务中小文件的优化" class="headerlink" title="spark sql 任务中小文件的优化"></a>spark sql 任务中小文件的优化</h4><ul>
<li><p>描述：在数栈开发过程中如果任务选择的是spark sql引擎，一定要注意减少小文件的输出。spark sql中  spark.spl.shuffle.partitions=200 ,即会在shuffle结果中产生200个文件，设置的是RDD1做shuffle处理后生成的结果RDD2的分区数。这样产生的影响有：<strong>大部分时间都花费在调度</strong>，任务执行本身花费时间较小；最终产生的小文件数过多，会对后续任务的使用造成资源浪费，<strong>且严重影响namenode的性能</strong>。如果结果数据不多且预计增量不会太大（例如缓慢变化维表，码值表等），可以将此参数数值设低。</p>
</li>
<li><p>解决：针对数据量变化较大的任务，可以通过以下参数动态调节shuffle.partition 的个数产生及小文件个数的产生。</p>
</li>
<li><p>针对数据量变化较大的任务，可以通过以下参数动态调节shuffle.partition的个数产生及小文件个数的产生。spark sql 小文件合并参数。</p>
<ul>
<li>spark.sql.adaptive.enabled=true</li>
<li>spark.sql.adaptive.shuffle.targetPostShuffleInputSize=256000000  #hdfs中block大小的倍数。</li>
</ul>
</li>
<li><p>以上参数只对宽依赖产生作用（join,groupby ,distribute by,order by 等），如果没有用到宽依赖的关键字，比如只用了union all,可以在sql代码最后添加distribute by 关键字，如：distribute by 1</p>
</li>
<li><p>任务中是否产生了小文件信息可以通过以下方法查看：</p>
<ul>
<li><p>通过hdfs_namenode的web页面进行查看，默认端口为50070</p>
</li>
<li><p>登录namenode节点，通过类似命令查看：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">hdfs dfs -du -h <span class="hljs-regexp">/dtInsight/</span>hive<span class="hljs-regexp">/warehouse/</span><span class="hljs-variable">$&#123;项目名称.db&#125;</span><span class="hljs-regexp">/$&#123;表名&#125;/</span>pt=<span class="hljs-variable">$&#123;分区&#125;</span>/<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="用户自定函数"><a href="#用户自定函数" class="headerlink" title="用户自定函数"></a>用户自定函数</h4><ul>
<li>UDF（User-Defined-Function)   用户自定义函数  （一进一出）</li>
<li>UDAF（User-Defined Aggregation Function）用户自定义聚合函数（多进一出）如 count()，countDistinct()，avg()，max()，min()<ul>
<li>实现：通过继承UserDefinedAggregateFunction来实现用户自定义聚合函数</li>
</ul>
</li>
<li>UDTF（User-Defined Table-Generating Functions）用户自定义表生成函数 （一进多出） Spark中没有UDTF，spark中使用flatMap实现UDTF的功能</li>
</ul>
<h3 id="数据加载与保存"><a href="#数据加载与保存" class="headerlink" title="数据加载与保存"></a>数据加载与保存</h3><ul>
<li>spark.read.load 是加载数据的通用方法</li>
<li>df.write.save 是保存数据的通用方法</li>
</ul>
<h2 id="Spark-Streaming"><a href="#Spark-Streaming" class="headerlink" title="Spark Streaming"></a>Spark Streaming</h2><h3 id="Spark-Streaming概述"><a href="#Spark-Streaming概述" class="headerlink" title="Spark Streaming概述"></a>Spark Streaming概述</h3><ul>
<li>离线计算：就是在计算开始前就已知所有输入数据，输入数据不会产生变化，一般数据量大，计算时间也较长。最经典的就是Hadoop的MapReduce方式。</li>
<li>实时计算：输入数据是可以以序列化的方式一个个输入并进行处理的，也就是说在开始的时候不需要知道所有数据，与离线计算相比，运行时间短，计算量级相对较小。强调计算过程的时间要短，即所查当下给出结果。</li>
<li>数据处理的方式<ul>
<li>批：处理离线数据，冷数据。单个处理数据量大，处理速度比流慢。</li>
<li>流：在线，实时产生的数据。单次处理的数据量小，但处理速度更快。</li>
</ul>
</li>
<li>Spark Streaming 用于流式数据的处理。</li>
<li>Spark Streaming使用了一个高级抽象离散化流（discretized stream），叫做DStream。</li>
<li><font color=red>DStreams是随时间推移而收到的数据的序列。在内部，每个时间区间收到的数据都作为RDD存在，而DStream是由这些RDD所组成的序列（因此得名“离散化”）</font></li>
<li>Spark Streaming 是一种“微量批处理”架构，和其他基于”一次处理一条记录”架构的系统相比，他的延迟会相对高一些。</li>
<li>背压机制：根据JobScheduler反馈作业的执行信息来动态调整Receiver数据接收率。</li>
</ul>
<h3 id="DStream"><a href="#DStream" class="headerlink" title="DStream"></a>DStream</h3><ul>
<li>DataFrame创建<ul>
<li>使用ssc.queueStream(queueOfRDDs)来创建DStream，每一个推送到这个队列中的RDD，都会作为一个DStream处理。</li>
<li>自定义数据源：继承Receiver，并实现onStart,onStop方法来自定义数据源采集。</li>
<li>Kafaka数据源<ul>
<li>kafka 0-10 Direct模式<ul>
<li>Executor读取数据并计算</li>
<li>增加Executor个数来增加消费的并行度</li>
<li>offset存储<ul>
<li>_consumer_offsets系统主题中，Kafka中的内部主题</li>
<li>手动维护（有事务的存储系统）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>DStream转换<ul>
<li>与RDD类似，分为Transformations（转换）和Output Operations(输出)两种</li>
</ul>
</li>
<li>Transformations（转换）<ul>
<li>无状态转换操作就是把简单的RDD转化操作应用到每个批次上，也就是转化DStream 中的每一个RDD。不会记录历史结果</li>
<li>有状态转换操作：<ul>
<li>UpdateStateByKey  算子用于将历史结果应用到当前批次，该操作允许在使用新信息不断更新的同时能保留它的状态。保留历史结果到下一次计算。</li>
<li>window 窗口操作。 窗口时长：计算内容的时间范围。滑动时长：间隔多久触发一次计算。这两者都必须为采集周期的整数倍。</li>
</ul>
</li>
</ul>
</li>
<li>DStream输出<ul>
<li>print() 在运行流程序的驱动结点上打印DStream中每一批次数据的最开始10个元素。这用于开发和调试。</li>
<li>foreachRDD(func) 即将函数func用产生于stream的每一个RDD，其中参数传入的函数func应该实现将每一个RDD中数据推送到外部系统。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title>Scala</title>
    <url>/2021/08/10/Scala/</url>
    <content><![CDATA[<h1 id="Scala"><a href="#Scala" class="headerlink" title="Scala"></a>Scala</h1><h2 id="Scala简介"><a href="#Scala简介" class="headerlink" title="Scala简介"></a>Scala简介</h2><ul>
<li>Scala是一门多范式的编程语言，Scala支持面向对象和函数式编程。（多范式，就是多种编程方法的意思。有面向过程，面向对象，泛型，函数式四种程序设计方式。）</li>
</ul>
<h3 id="class和object说明"><a href="#class和object说明" class="headerlink" title="class和object说明"></a>class和object说明</h3><ul>
<li>object：从语法的角度上讲，上面的语法表示声明了一个伴生对象，但是还会生成一个伴生类。Scala是纯面向对象的，去除了java中的static关键字，通过伴生对象模拟static效果</li>
<li>伴生对象：伴随类产生的一个对象</li>
<li>对scala源文件进行编译后，默认会生成两个字节码文件，一个是伴生类另一个是伴生对象所属类（类名+一个$符号）</li>
<li>真正的伴生对象是伴生对象所属类中创建的单例对象</li>
<li>如果不想生成伴生类，可以手动生成，要求伴生类名称和伴生对象名称一致。</li>
<li>运行原理：<ul>
<li>java运行原理：先编译，再解释。.java源文件—&gt;编译器(javac)—&gt;.class字节码文件—&gt;JVM(java 不同平台)—&gt;机器指令</li>
<li>scala运行原理：先编译，再解释。.scala源文件—&gt;编译器(scalac)—&gt;.class字节码文件—&gt;JVM(scala 不同平台)—&gt;机器指令</li>
</ul>
</li>
</ul>
<h2 id="变量和数据类型"><a href="#变量和数据类型" class="headerlink" title="变量和数据类型"></a>变量和数据类型</h2><ul>
<li><p>注释和java规则一样。</p>
</li>
<li><p>变量 var 变量名[:变量类型]=初始值</p>
</li>
<li><p>常量 val 变量名[:变量类型]=初始值</p>
</li>
<li><p>声明变量时必须要有初始指</p>
</li>
<li><p>标识符业余java基本一致。特殊情况：（1）以字母或者下划线开头，后接字母、数字、下划线</p>
<p>（2）以操作符开头，且只包含操作符（+ - * / # !等）</p>
<p>（3）用反引号<code>....</code>包括的任意字符串，即使是Scala关键字（39个）也可以</p>
</li>
<li><p>键盘输入输出：</p>
</li>
<li><p>输出：（1）字符串，通过+号连接</p>
<p>（2）printf用法：字符串，通过%传值。</p>
<p>（3）字符串模板（插值字符串）：通过”$”获取变量值。</p>
<p>${}</p>
</li>
<li><p>输入：StdIn.readLine()、StdIn.readShort()、StdIn.readDouble()</p>
</li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li>Any：所有类的父类</li>
<li>AnyVal:(值类型)<ul>
<li>Byte,Short,Int,Long,Float,Double,Boolean,Char</li>
<li>Unit:表示返回值类型为空，相当于Java中的 void  关键字</li>
<li>StringOps:对自负床功能的 增强</li>
</ul>
</li>
<li>AnyRef（引用类型 ）<ul>
<li>所有java语言中的类</li>
<li>Scala  语言中的类</li>
<li>集合</li>
<li>Null：表示变量声明后，没有指向任何对象，相当于java中的null关键字</li>
</ul>
</li>
<li>Nothing :所有类的子类</li>
</ul>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul>
<li>char在java中是没有符号位的。char占两个字节。</li>
</ul>
<h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><ul>
<li><p>面向对象编程：</p>
<ul>
<li>Scala是一个完全面向对象的编程语言，万物皆对象。</li>
<li>对象的本质：对数据和行为的一个封装。</li>
</ul>
</li>
<li><p>函数式编程：</p>
<ul>
<li>将问题分解成一个一个的步骤，将每一个步骤进行封装，通调用这些封装好的步骤。</li>
<li>Scala是一个完全函数式编程语言，万物皆函数。</li>
</ul>
</li>
<li><p>函数的本质：函数可以当做一个值进行传递。</p>
</li>
</ul>
<h4 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h4><ul>
<li><p>函数与方法的区别</p>
<ul>
<li>为完成某一功能的程序语句的集合，称为函数。</li>
<li>类中的函数称为方法</li>
<li>函数没有重载和重写的概念；方法可以进行重载和重写</li>
<li>Scala中函数可以嵌套定义</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">TestFunction</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>        <span class="hljs-comment">// （1）函数定义</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span></span>(arg: <span class="hljs-type">String</span>): <span class="hljs-type">Unit</span> = &#123;<br>            println(arg)<br>        &#125;<br>        <span class="hljs-comment">// （2）函数调用</span><br>        <span class="hljs-comment">// 函数名（参数）</span><br>        f(<span class="hljs-string">&quot;hello world&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>函数至简原则</p>
<ul>
<li><p>（1）return可以省略，Scala会使用函数体的最后一行代码作为返回值</p>
<p>（2）如果函数体只有一行代码，可以省略花括号</p>
<p>（3）返回值类型如果能够推断出来，那么可以省略（:和返回值类型一起省略）</p>
<p>（4）如果有return，则不能省略返回值类型，必须指定</p>
<p>（5）如果函数明确声明unit，那么即使函数体中使用return关键字也不起作用</p>
<p>（6）Scala如果期望是无返回值类型，可以省略等号</p>
<p>（7）如果函数无参，但是声明了参数列表，那么调用时，小括号，可加可不加</p>
<p>（8）如果函数没有参数列表，那么小括号可以省略，调用时小括号必须省略</p>
<p>（9）如果不关心名称，只关心逻辑处理，那么函数名（def）可以省略</p>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> com.zt.spark.day01<br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">FunctionTest</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-comment">//(0)函数标准写法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span></span>(s:<span class="hljs-type">String</span>): <span class="hljs-type">String</span>=&#123;<br>      <span class="hljs-keyword">return</span> s+<span class="hljs-string">&quot;hello world&quot;</span><br>    &#125;<br>    println(f(<span class="hljs-string">&quot;hi,&quot;</span>))<br>    <span class="hljs-comment">//至简原则</span><br>    <span class="hljs-comment">//(1)return可以省略，Scala会使用函数体的最后一行代码作为返回值</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f1</span></span>(s:<span class="hljs-type">String</span>):<span class="hljs-type">String</span>=&#123;<br>      s+<span class="hljs-string">&quot;hello&quot;</span><br>    &#125;<br>    println(f1(<span class="hljs-string">&quot;world &quot;</span>))<br>    <span class="hljs-comment">//(2)如果函数只有一行代码，可以省略花括号</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f2</span></span>(s:<span class="hljs-type">String</span>):<span class="hljs-type">String</span>=s+<span class="hljs-string">&quot; hello&quot;</span><br>    println(f2(<span class="hljs-string">&quot;world&quot;</span>))<br>    <span class="hljs-comment">//(3)返回值类型如果能推断出来，那么可以省略（：和返回值类型一起省略）</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f3</span></span>(s:<span class="hljs-type">String</span>)=s+<span class="hljs-string">&quot; wocao&quot;</span><br>    println(f3(<span class="hljs-string">&quot;aaaa&quot;</span>))<br>    <span class="hljs-comment">//(4)如果return,则不能省略返回值类型，必须指定。</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f4</span></span>():<span class="hljs-type">String</span>=<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span><br>    println(f4)<br>    <span class="hljs-comment">//(5)如果函数明确声明unit，那么即使函数体中使用return关键字也不起作用</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f5</span></span>():<span class="hljs-type">Unit</span>=<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;xxxx&quot;</span><br>    println(f5)<br>    <span class="hljs-comment">//(6)Scala如果期望是无返回值类型，可以省略等号</span><br>    <span class="hljs-comment">//将无返回值的函数称为&quot;过程&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f6</span></span>() &#123;<br>      <span class="hljs-string">&quot;dadadada&quot;</span><br>    &#125;<br>    println(f6())<br>    <span class="hljs-comment">//(7)如果函数无参，但是声明了参数列表，那么调用时，小括号可加可不加</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f7</span></span>()=<span class="hljs-string">&quot;xxx&quot;</span><br>    println(f7())<br>    println(f7)<br>    <span class="hljs-comment">//(8)如果函数没有参数列表，那么小括号可以省略，调用时小括号必须省略</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f8</span> </span>=<span class="hljs-string">&quot;xxx&quot;</span><br>    println(f8)<br>    <span class="hljs-comment">//(9)如果不关心名称，只关心逻辑处理，那么函数名(def)可以省略</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f9=</span></span>(x:<span class="hljs-type">String</span>)=&gt;&#123;println(<span class="hljs-string">&quot;wode&quot;</span>)&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f10</span></span>(f:<span class="hljs-type">String</span>=&gt;<span class="hljs-type">Unit</span>): <span class="hljs-type">Unit</span> =&#123;<br>      f(<span class="hljs-string">&quot;&quot;</span>)<br>    &#125;<br>    f10(f9)<br>    println(f10((x:<span class="hljs-type">String</span>)=&gt;&#123;println(<span class="hljs-string">&quot;dadada&quot;</span>)&#125;))<br>  &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><ul>
<li><p>函数可以作为值进行传递</p>
<ul>
<li>var f = 函数名 _</li>
<li>如果明确了变量的数据类型，那么下划线可以省略</li>
</ul>
</li>
<li><p>函数可以作为参数进行传递</p>
<ul>
<li>通过匿名函数</li>
<li>扩展函数的功能</li>
<li>提高函数的灵活度</li>
</ul>
</li>
<li><p>函数可以作为返回值进行传递</p>
<ul>
<li>函数的嵌套</li>
<li>函数链式调用，通过参数传递数据，在执行过程中，函数始终占据栈内存，容易导致内存溢出</li>
<li>闭包：内层函数访问外层函数的局部变量，会自动延长外层函数局部变量的生命周期，与内层函数形成一个闭合的效果，我们称之为闭包</li>
<li>柯里化：将一个参数列表中的多个参数，拆分为多个参数列表</li>
</ul>
</li>
<li><p>匿名函数：</p>
<ul>
<li><p>(x:Int)=&gt;{函数体}</p>
</li>
<li><p>x：表示输入参数类型；Int：表示输入参数类型；函数体：表示具体代码逻辑</p>
</li>
<li><p>参数的类型可以省略，会根据形参进行自动的推导</p>
</li>
<li><p>类型省略之后，发现只有一个参数，则圆括号可以省略；其他情况：没有参数和参数超过1的永远不能省略圆括号。</p>
</li>
<li><p>匿名函数如果只有一行，则大括号也可以省略</p>
</li>
<li><p>如果参数只出现一次，则参数省略且后面参数可以用_代替</p>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br><br>        <span class="hljs-comment">// （1）定义一个函数：参数包含数据和逻辑函数</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">operation</span></span>(arr: <span class="hljs-type">Array</span>[<span class="hljs-type">Int</span>], op: <span class="hljs-type">Int</span> =&gt; <span class="hljs-type">Int</span>) = &#123;<br>            <span class="hljs-keyword">for</span> (elem &lt;- arr) <span class="hljs-keyword">yield</span> op(elem)<br>        &#125;<br><br>        <span class="hljs-comment">// （2）定义逻辑函数</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">op</span></span>(ele: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = &#123;<br>            ele + <span class="hljs-number">1</span><br>        &#125;<br><br>        <span class="hljs-comment">// （3）标准函数调用</span><br>        <span class="hljs-keyword">val</span> arr = operation(<span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>), op)<br>        println(arr.mkString(<span class="hljs-string">&quot;,&quot;</span>))<br><br>        <span class="hljs-comment">// （4）采用匿名函数</span><br>        <span class="hljs-keyword">val</span> arr1 = operation(<span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>), (ele: <span class="hljs-type">Int</span>) =&gt; &#123;<br>            ele + <span class="hljs-number">1</span><br>        &#125;)<br>        println(arr1.mkString(<span class="hljs-string">&quot;,&quot;</span>))<br><br>        <span class="hljs-comment">// （4.1）参数的类型可以省略，会根据形参进行自动的推导;</span><br>        <span class="hljs-keyword">val</span> arr2 = operation(<span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>), (ele) =&gt; &#123;<br>            ele + <span class="hljs-number">1</span><br>        &#125;)<br>        println(arr2.mkString(<span class="hljs-string">&quot;,&quot;</span>))<br><br>        <span class="hljs-comment">// （4.2）类型省略之后，发现只有一个参数，则圆括号可以省略；其他情况：没有参数和参数超过1的永远不能省略圆括号。</span><br>        <span class="hljs-keyword">val</span> arr3 = operation(<span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>), ele =&gt; &#123;<br>            ele + <span class="hljs-number">1</span><br>        &#125;)<br>        println(arr3.mkString(<span class="hljs-string">&quot;,&quot;</span>))<br><br>        <span class="hljs-comment">// (4.3) 匿名函数如果只有一行，则大括号也可以省略</span><br>        <span class="hljs-keyword">val</span> arr4 = operation(<span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>), ele =&gt; ele + <span class="hljs-number">1</span>)<br>        println(arr4.mkString(<span class="hljs-string">&quot;,&quot;</span>))<br><br>        <span class="hljs-comment">//（4.4）如果参数只出现一次，则参数省略且后面参数可以用_代替</span><br>        <span class="hljs-keyword">val</span> arr5 = operation(<span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>), _ + <span class="hljs-number">1</span>)<br>        println(arr5.mkString(<span class="hljs-string">&quot;,&quot;</span>))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h3><ul>
<li><p>在自然界中，只要是客观存在的都是对象（万物皆对象）</p>
</li>
<li><p>对大量对象共性的抽象，抽取为类</p>
<ul>
<li>有什么         属性</li>
<li>能做什么     方法</li>
</ul>
</li>
<li><p>在面向对象语言中，类是创建对象的模板</p>
</li>
<li><p>类是客观事务在人脑中的主观反映</p>
</li>
<li><p>Scala的属性：</p>
<ul>
<li>在Scala语言中，类，方法，属性，默认修饰符都是public，但是没有public关键字</li>
<li>对于Scala中的属性，底层会用private修饰，同时提供公开的设置以及获取属性的方法—-面向封装</li>
<li>如果要生成满足JavaBean规范的get和set方法的话，需要在属性上加@BeanProperty注解</li>
</ul>
</li>
<li><p>访问权限</p>
<ul>
<li><p>Java</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">private		私有的，只能在本类中被访问<br>default		默认的，可以在本类以及同包的其它类中被访问<br>protected	受保护的，可以在本类、同包的其它类以及非同包的子类中被访问<br>public 		公开的，所有类<br></code></pre></td></tr></table></figure></li>
<li><p>Scala</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">private</span>		      私有的，只能在本类中被访问<br><span class="hljs-keyword">public</span>(默认)	     公开的，所有类<br><span class="hljs-keyword">protected</span>		  比Java设置的更严格，只能在本类以及子类中被访问，同包其他类访问不了<br><span class="hljs-keyword">private</span>[包名] 	 可以让指定的包进行访问<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h3><ul>
<li><p>构造器</p>
<ul>
<li><p>主构造方法</p>
<ul>
<li>在声明类的同时，主构造方法也被声明</li>
<li>主构造方法只能有一个</li>
<li>如果主构造方法没有参数，那么声明以及调用的时候，小括号可以省略。</li>
</ul>
</li>
<li><p>辅助构造方法</p>
<ul>
<li>方法名必修叫this</li>
<li>辅助构造方法可以重载</li>
<li>辅助构造方法中的第一行代码必须直接或者间接调用主构造方法</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">//（1）如果主构造器无参数，小括号可省略</span><br><span class="hljs-comment">//class Person ()&#123;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> = _<br><br>    <span class="hljs-keyword">var</span> age: <span class="hljs-type">Int</span> = _<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">this</span></span>(age: <span class="hljs-type">Int</span>) &#123;<br>        <span class="hljs-keyword">this</span>()<br>        <span class="hljs-keyword">this</span>.age = age<br>        println(<span class="hljs-string">&quot;辅助构造器&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">this</span></span>(age: <span class="hljs-type">Int</span>, name: <span class="hljs-type">String</span>) &#123;<br>        <span class="hljs-keyword">this</span>(age)<br>        <span class="hljs-keyword">this</span>.name = name<br>    &#125;<br><br>    println(<span class="hljs-string">&quot;主构造器&quot;</span>)<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br><br>        <span class="hljs-keyword">val</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>(<span class="hljs-number">18</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>继承</p>
<ul>
<li>class 子类名 extends 父类名  { 类体 }</li>
<li>Scala是单继承</li>
</ul>
</li>
<li><p>创建对象的方式</p>
<ul>
<li><p>new   底层调用的是构造方法</p>
</li>
<li><p>类名()  底层调用的是伴生对象中apply方法</p>
</li>
<li><p>实现单例设计模式</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Test</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br><br>        <span class="hljs-comment">//（1）通过伴生对象的apply方法，实现不使用new关键字创建对象。</span><br>        <span class="hljs-keyword">val</span> p1 = <span class="hljs-type">Person</span>()<br>        println(<span class="hljs-string">&quot;p1.name=&quot;</span> + p1.name)<br><br>        <span class="hljs-keyword">val</span> p2 = <span class="hljs-type">Person</span>(<span class="hljs-string">&quot;bobo&quot;</span>)<br>        println(<span class="hljs-string">&quot;p2.name=&quot;</span> + p2.name)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//（2）如果想让主构造器变成私有的，可以在()之前加上private</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-title">private</span>(<span class="hljs-params">cName: <span class="hljs-type">String</span></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> = cName<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(): <span class="hljs-type">Person</span> = &#123;<br>        println(<span class="hljs-string">&quot;apply空参被调用&quot;</span>)<br>        <span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>(<span class="hljs-string">&quot;xx&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(name: <span class="hljs-type">String</span>): <span class="hljs-type">Person</span> = &#123;<br>        println(<span class="hljs-string">&quot;apply有参被调用&quot;</span>)<br>        <span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>(name)<br>&#125;<br><span class="hljs-comment">//注意：也可以创建其它类型对象，并不一定是伴生类对象</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="特质和抽象类"><a href="#特质和抽象类" class="headerlink" title="特质和抽象类"></a>特质和抽象类</h3><ul>
<li><p>使用abstract关键字定义抽象类</p>
<ul>
<li>定义抽象类：abstract class Person{} //通过abstract关键字标记抽象类</li>
</ul>
</li>
<li><p>抽象类一般和抽象属性以及抽象方法配合使用</p>
</li>
<li><p>抽象属性</p>
<ul>
<li>属性只有声明，但是没有赋值</li>
<li>定义抽象属性：val|var name:String //一个属性没有初始化，就是抽象属性</li>
</ul>
</li>
<li><p>抽象方法</p>
<ul>
<li>方法只有声明，没有实现</li>
<li>定义抽象方法：def hello():String //只声明而没有实现的方法，就是抽象方法</li>
</ul>
</li>
<li><p>抽象类总结</p>
<ul>
<li>在一个类中，如果存在抽象属性或者抽象方法，那么这个类一定是抽象类</li>
<li>如果一个类是抽象类，那么它不一定包含抽象属性和抽象方法</li>
<li>如果一个类中存在抽象属性或者抽象方法，那么具体的实现应该交给子类完成</li>
<li>如果子类也实现不了抽象内容，那么子类也应该声明为抽象类</li>
<li>如果重写(实现)抽象属性或者方法，那么override关键字可以省略</li>
<li>如果重写(覆盖)非抽象属性或者方法，那么override关键字不能省略，必须得加</li>
<li>如果对非抽象属性进行覆盖，要求属性必须得用val修饰</li>
<li>可以通过super关键字调用父类的方法，但是不能super调用父类的属性</li>
</ul>
</li>
<li><p>在Scala中，属性和方法都是动态绑定</p>
<ul>
<li>静态绑定（编译器绑定）<ul>
<li>在编译阶段，确定属性或者方法所属类型，多态的时候根据这个来看。（编译看左，运行看右）</li>
</ul>
</li>
<li>动态绑定<ul>
<li>在运行阶段，根据实际创建的对象类型来决定属性或者方法所属类型</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="特质（Trait）"><a href="#特质（Trait）" class="headerlink" title="特质（Trait）"></a>特质（Trait）</h4><ul>
<li><p>Scala中采用特质trait来代替接口的概念。</p>
</li>
<li><p>Scala中的trait中即<strong>可以有抽象属性和方法，也可以有具体的属性和方法</strong>，<strong>一个类可以混入（mixin）多个特质</strong>。这种感觉类似于Java中的抽象类。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">PersonTrait</span> </span>&#123;<br><br>    <span class="hljs-comment">// 声明属性</span><br>    <span class="hljs-keyword">var</span> name:<span class="hljs-type">String</span> = _<br><br>    <span class="hljs-comment">// 声明方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">eat</span></span>():<span class="hljs-type">Unit</span>=&#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">// 抽象属性</span><br>    <span class="hljs-keyword">var</span> age:<span class="hljs-type">Int</span><br>    <br>    <span class="hljs-comment">// 抽象方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">say</span></span>():<span class="hljs-type">Unit</span><br>&#125;<br><span class="hljs-comment">//通过查看字节码，可以看到特质=抽象类+接口</span><br></code></pre></td></tr></table></figure></li>
<li><p>基本语法</p>
<ul>
<li><strong>没有父类</strong>：class  类名 <em><strong>extends</strong></em> 特质1  <em><strong>with</strong></em>  特质2  <em><strong>with</strong></em>  特质3 …</li>
<li><strong>有父类</strong>：class  类名  <em><strong>extends</strong></em> 父类  <em><strong>with</strong></em> 特质1  <em><strong>with</strong></em>  特质2  <em><strong>with</strong></em> 特质3…</li>
</ul>
</li>
<li><p>特质（trait）叠加：</p>
<ul>
<li><p>由于一个类可以混入（mixin）多个trait，且trait中可以有具体的属性和方法，若混入的特质中具有相同的方法（方法名，参数列表，返回值均相同），必然会出现继承冲突问题。冲突分为以下两种：</p>
<ul>
<li>第一种，一个类（Sub）混入的两个trait（TraitA，TraitB）中具有相同的具体方法，且两个trait之间没有任何关系，解决这类冲突问题，直接在类（Sub）中重写冲突方法。</li>
<li>第二种，一个类（Sub）混入的两个trait（TraitA，TraitB）中具有相同的具体方法，且两个trait继承自相同的trait（TraitC），及所谓的“钻石问题”，解决这类冲突问题，Scala采用了<em><strong>特质叠加</strong></em>的策略。</li>
</ul>
</li>
<li><p>特质叠加顺序</p>
<ul>
<li>第一步：列出第一个混入特质的继承关系，作为临时叠加的顺序</li>
<li>第二步：列出第二个混入特质的继承关系,并且该顺序放到临时叠加顺序的前面，已经出现的特质不在出现   </li>
<li>第三步：将子类放到临时叠加顺序的第一个</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Ball</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">describe</span></span>(): <span class="hljs-type">String</span> = &#123;<br>      <span class="hljs-string">&quot;ball&quot;</span><br>   &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Color</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Ball</span> </span>&#123;<br>   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">describe</span></span>(): <span class="hljs-type">String</span> = &#123;<br>      <span class="hljs-string">&quot;blue-&quot;</span> + <span class="hljs-keyword">super</span>.describe()<br>   &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Category</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Ball</span> </span>&#123;<br>   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">describe</span></span>(): <span class="hljs-type">String</span> = &#123;<br>      <span class="hljs-string">&quot;foot-&quot;</span> + <span class="hljs-keyword">super</span>.describe()<br>   &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBall</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Category</span> <span class="hljs-keyword">with</span> <span class="hljs-title">Color</span> </span>&#123;<br>   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">describe</span></span>(): <span class="hljs-type">String</span> = &#123;<br>      <span class="hljs-string">&quot;my ball is a &quot;</span> + <span class="hljs-keyword">super</span>.describe()<br>   &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">TestTrait</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>      println(<span class="hljs-keyword">new</span> <span class="hljs-type">MyBall</span>().describe())<br>   &#125;<br>&#125;<br><span class="hljs-comment">//注意：这个时候super不是调用父类中的方法了，而是调用特质叠加顺序上下一个节点的方法</span><br><span class="hljs-comment">//运行结果：my ball is a blue-foot-ball</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>特质和抽象类的区别</p>
<ul>
<li>优先使用特质。一个类扩展多个特质是很方便的，但却只能扩展一个抽象类。</li>
<li>如果你需要构造函数参数，使用抽象类。因为抽象类可以定义带参数的构造函数，而特质不行（有无参构造）。</li>
</ul>
</li>
<li><p>类型检查和转换</p>
<ul>
<li>obj.isInstanceOf[T]：判断obj是不是T类型。</li>
<li>obj.asInstanceOf[T]：将obj强转成T类型。</li>
<li>classOf获取对象的类名。</li>
</ul>
</li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="集合基本概述"><a href="#集合基本概述" class="headerlink" title="集合基本概述"></a>集合基本概述</h3><ul>
<li><p>存放单值类型</p>
<ul>
<li>Seq   有序，可重复</li>
<li>Set    无序，不能重复</li>
</ul>
</li>
<li><p>存放键值对</p>
<ul>
<li>Map   以k-v键值对的形式存放数据，其中key无序不能重复</li>
</ul>
</li>
<li><p>对于几乎所有的集合类，Scala都同时提供了可变和不可变的版本，分别位于以下两个包</p>
<ul>
<li>不可变集合：scala.collection.immutable<ul>
<li>对集合进行添加或者删除操作的时候，会创建新的集合对象</li>
</ul>
</li>
<li>可变集合：scala.collection.mutable<ul>
<li>对集合进行添加或者删除操作的时候，直接在原来的集合上操作，不会创建新的集合对象</li>
</ul>
</li>
</ul>
</li>
<li><p>数组</p>
<ul>
<li><p>Array</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">TestArray</span></span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br><br>        <span class="hljs-comment">//（1）数组定义</span><br>        <span class="hljs-keyword">val</span> arr01 = <span class="hljs-keyword">new</span> <span class="hljs-type">Array</span>[<span class="hljs-type">Int</span>](<span class="hljs-number">4</span>)<br>        println(arr01.length) <span class="hljs-comment">// 4</span><br>        <br>        <span class="hljs-keyword">var</span> arr02 = <span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;bobo&quot;</span>)<br>        println(arr02.length)<br>        <span class="hljs-keyword">for</span> (i &lt;- arr02) &#123;<br>            println(i)<br>        &#125;<br>        <span class="hljs-comment">//（2）数组赋值</span><br><br><br>        <span class="hljs-comment">//（2.1）修改某个元素的值</span><br>        arr01(<span class="hljs-number">3</span>) = <span class="hljs-number">10</span><br>        <span class="hljs-comment">//（2.2）采用方法的形式给数组赋值</span><br>        arr01.update(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<br><br>        <span class="hljs-comment">//（3）遍历数组</span><br>        <span class="hljs-comment">//（3.1）查看数组</span><br>        println(arr01.mkString(<span class="hljs-string">&quot;,&quot;</span>))<br><br>        <span class="hljs-comment">//（3.2）普通遍历</span><br>        <span class="hljs-keyword">for</span> (i &lt;- arr01) &#123;<br>            println(i)<br>        &#125;<br><br>        <span class="hljs-comment">//（3.3）简化遍历</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printx</span></span>(elem:<span class="hljs-type">Int</span>): <span class="hljs-type">Unit</span> = &#123;<br>            println(elem)<br>        &#125;<br>         arr01.foreach(printx)<br>        <span class="hljs-comment">// arr01.foreach((x)=&gt;&#123;println(x)&#125;)</span><br>        <span class="hljs-comment">// arr01.foreach(println(_))</span><br>        arr01.foreach(println)<br><br>        <span class="hljs-comment">//（4）增加元素（由于创建的是不可变数组，增加元素，其实是产生新的数组）</span><br>        println(arr01)<br>        <span class="hljs-keyword">val</span> ints: <span class="hljs-type">Array</span>[<span class="hljs-type">Int</span>] = arr01 :+ <span class="hljs-number">5</span><br>        println(ints)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>ArrayBuffer</p>
</li>
<li><p>多维数组</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">DimArray</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>        <br>        <span class="hljs-comment">//（1）创建了一个二维数组, 有三个元素，每个元素是，含有4个元素一维数组()</span><br>        <span class="hljs-keyword">val</span> arr = <span class="hljs-type">Array</span>.ofDim[<span class="hljs-type">Int</span>](<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br>        arr(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>) = <span class="hljs-number">88</span><br><br>        <span class="hljs-comment">//（2）遍历二维数组</span><br>        <span class="hljs-keyword">for</span> (i &lt;- arr) &#123; <span class="hljs-comment">//i 就是一维数组</span><br><br>            <span class="hljs-keyword">for</span> (j &lt;- i) &#123;<br>                print(j + <span class="hljs-string">&quot; &quot;</span>)<br>            &#125;<br><br>            println()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Seq</p>
<ul>
<li><p>List</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">TestList</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br><br>        <span class="hljs-comment">//（1）List默认为不可变集合</span><br>        <span class="hljs-comment">//（2）创建一个List（数据有顺序，可重复）</span><br>        <span class="hljs-keyword">val</span> list: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>)<br>        <br>        <span class="hljs-comment">//（7）空集合Nil</span><br>        <span class="hljs-keyword">val</span> list5 = <span class="hljs-number">1</span>::<span class="hljs-number">2</span>::<span class="hljs-number">3</span>::<span class="hljs-number">4</span>::<span class="hljs-type">Nil</span><br><br>        <span class="hljs-comment">//（4）List增加数据</span><br>        <span class="hljs-comment">//（4.1）::的运算规则从右向左</span><br>        <span class="hljs-comment">//val list1 = 5::list</span><br>        <span class="hljs-keyword">val</span> list1 = <span class="hljs-number">7</span>::<span class="hljs-number">6</span>::<span class="hljs-number">5</span>::list<br>        <span class="hljs-comment">//（4.2）添加到第一个元素位置</span><br>        <span class="hljs-keyword">val</span> list2 = list.+:(<span class="hljs-number">5</span>)<br><br>        <span class="hljs-comment">//（5）集合间合并：将一个整体拆成一个一个的个体，称为扁平化</span><br>        <span class="hljs-keyword">val</span> list3 = <span class="hljs-type">List</span>(<span class="hljs-number">8</span>,<span class="hljs-number">9</span>)<br>        <span class="hljs-comment">//val list4 = list3::list1</span><br>        <span class="hljs-keyword">val</span> list4 = list3:::list1<br><br>        <span class="hljs-comment">//（6）取指定数据</span><br>        println(list(<span class="hljs-number">0</span>))<br><br>        <span class="hljs-comment">//（3）遍历List</span><br>        <span class="hljs-comment">//list.foreach(println)</span><br>        <span class="hljs-comment">//list1.foreach(println)</span><br>        <span class="hljs-comment">//list3.foreach(println)</span><br>        <span class="hljs-comment">//list4.foreach(println)</span><br>        list5.foreach(println)<br>    &#125;<br></code></pre></td></tr></table></figure></li>
<li><p>ListBuffer</p>
</li>
</ul>
</li>
<li><p>Set</p>
</li>
<li><p>Map</p>
<ul>
<li><p>当调用map.get方法的时候，返回的Option类型数据,Option有两个子类型，一个Some，另一个None,可以帮我们避免对空值进行处理的情况，使用getOrElse函数，给空值赋默认值</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">TestMap</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>        <span class="hljs-comment">// Map</span><br>        <span class="hljs-comment">//（1）创建不可变集合Map</span><br>        <span class="hljs-keyword">val</span> map = <span class="hljs-type">Map</span>( <span class="hljs-string">&quot;a&quot;</span>-&gt;<span class="hljs-number">1</span>, <span class="hljs-string">&quot;b&quot;</span>-&gt;<span class="hljs-number">2</span>, <span class="hljs-string">&quot;c&quot;</span>-&gt;<span class="hljs-number">3</span> )<br><br>        <span class="hljs-comment">//（3）访问数据</span><br>        <span class="hljs-keyword">for</span> (elem &lt;- map.keys) &#123;<br>            <span class="hljs-comment">// 使用get访问map集合的数据，会返回特殊类型Option(选项):有值（Some），无值(None)</span><br>            println(elem + <span class="hljs-string">&quot;=&quot;</span> + map.get(elem).get)<br>        &#125;<br><br>        <span class="hljs-comment">//（4）如果key不存在，返回0</span><br>        println(map.get(<span class="hljs-string">&quot;d&quot;</span>).getOrElse(<span class="hljs-number">0</span>))<br>        println(map.getOrElse(<span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-number">0</span>))<br><br>        <span class="hljs-comment">//（2）循环打印</span><br>        map.foreach((kv)=&gt;&#123;println(kv)&#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="集合函数"><a href="#集合函数" class="headerlink" title="集合函数"></a>集合函数</h3><ul>
<li><p>基本属性和常用操作</p>
<p>（1）获取集合长度          length</p>
<p>（2）获取集合大小          size</p>
<p>（3）循环遍历                  foreach</p>
<p>（4）迭代器                      iterator</p>
<p>（5）生成字符串              mkString</p>
<p>（6）是否包含                  contains</p>
</li>
<li><p>衍生集合</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">（<span class="hljs-number">1</span>）获取集合的头<br>	head<br>（<span class="hljs-number">2</span>）获取集合的尾（不是头的就是尾）<br>	tail<br>（<span class="hljs-number">3</span>）集合最后一个数据<br>	last<br>（<span class="hljs-number">4</span>）集合初始数据（不包含最后一个）<br>	init<br>（<span class="hljs-number">5</span>）反转<br>	reverse<br>（<span class="hljs-number">6</span>）取前（后）n个元素<br>	take|takeRight<br>（<span class="hljs-number">7</span>）去掉前（后）n个元素<br>	drop|dropRight<br>（<span class="hljs-number">8</span>）并集<br>	union<br>（<span class="hljs-number">9</span>）交集<br>	<span class="hljs-built_in">int</span>ersect<br>（<span class="hljs-number">10</span>）差集<br>	diff<br>（<span class="hljs-number">11</span>）拉链<br>	zip<br>（<span class="hljs-number">12</span>）滑窗<br>	sliding<br></code></pre></td></tr></table></figure></li>
<li><p>集合计算初级，高级函数</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">		（<span class="hljs-number">1</span>）求和<br>			sum<br>		（<span class="hljs-number">2</span>）求乘积<br>			product<br>		（<span class="hljs-number">3</span>）最大值<br>			max<br>		（<span class="hljs-number">4</span>）最小值<br>			min<br>		（<span class="hljs-number">5</span>）排序<br>			sorded|sortBy|sortWith<br>			<br>集合计算高级函数：<br>		（<span class="hljs-number">1</span>）过滤 filter(函数：指定过滤条件) <br>			 遍历一个集合并从中获取满足指定条件的元素组成一个新的集合<br><br>		（<span class="hljs-number">2</span>）转换/映射  map<br>				 	<br>		（<span class="hljs-number">3</span>）扁平化 flatten   :::<br>			将集合中元素由整体转换为个体的过程<br><br>		（<span class="hljs-number">4</span>）扁平映射  flatMap  <br>			先映射再进行扁平化处理<br><br>		（<span class="hljs-number">5</span>）分组	gruopBy<br>			按照一定的分组规则，将集合中的元素放到不同的组中<br><br>		（<span class="hljs-number">6</span>）简化|规约<br>			&gt;对集合内部元素之间进行聚合 <br>			&gt;reduce   聚合的数据类型一致<br>			&gt;reduceLeft|reduceRight 	聚合的数据类型可以不一致<br><br>		（<span class="hljs-number">7</span>）折叠<br>			&gt;对外部元素和集合内部元素之间进行聚合<br>			&gt;fold 	聚合的数据类型一致<br>			&gt;foldLeft|foldRight		聚合的数据类型可以不一致<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="下划线的用法"><a href="#下划线的用法" class="headerlink" title="下划线的用法"></a>下划线的用法</h2><ul>
<li>标识符命名</li>
<li>导包<ul>
<li>导入某一个类下的”静态成员” ：import scala.util.control.Breaks._</li>
<li>导入某一包下的所有类：import java.util._</li>
<li>屏蔽类：import java.sql.{Date=&gt;<em>,Array=&gt;</em>,_}</li>
</ul>
</li>
<li>匿名函数<ul>
<li>如果在匿名函数中，参数只出现了一次，那么参数可以省略，在函数体使用参数的时候，用下划线代替</li>
</ul>
</li>
<li>在类中声明属性，如果要给属性赋默认值</li>
<li>在模式匹配中<ul>
<li>case_  表示上面所有case都没有匹配成功的情况，相当于default</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Scala</category>
      </categories>
      <tags>
        <tag>Scala</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka</title>
    <url>/2021/06/24/kafka/</url>
    <content><![CDATA[<h1 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h1><h2 id="Kafka概述"><a href="#Kafka概述" class="headerlink" title="Kafka概述"></a>Kafka概述</h2><ul>
<li><p>kafaka是一个分布式的基于发布/订阅模式的消息队列，主要应用于大数据实时处理领域。</p>
</li>
<li><p>消息队列一般分为两种模式：</p>
<ol>
<li>点对点模式（一对一，消费者主动拉取数据，消息收到后消息清除）</li>
<li>发布/订阅模式（一对多，消费者消费数据之后不会清除消息）</li>
</ol>
</li>
<li><p>基础架构</p>
<p><a href="https://imgtu.com/i/RgX9C4"><img src="https://z3.ax1x.com/2021/07/03/RgX9C4.png" alt="RgX9C4.png"></a></p>
<ul>
<li>producer:消息生产者，向Kafka broker发消息的客户端</li>
<li>consumer：消息消费者，向Kafka broker取消息的客户端</li>
<li>consumer group：消费者组，由多个consumer组成。消费者组内每个消费者负责消费不同分区的数据，一个分区只能由一个消费者消费；消费者组之间互不影响。所有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。</li>
<li>broker：一台kafka服务器就是一个broker。一个Kafak集群由多个broker组成。一个broker可以容纳多个topic。</li>
<li>topic：可以理解为一个队列，生产者和消费者面向的都是一个topic</li>
<li>partition：为了实现扩展性，一个非常大的topic可以分布到多个broker（即服务器）上，一个topic可以分为多个partition，每个partition是一个有序的队列；</li>
<li>replica：副本，为保证集群中的某个节点发生故障时，该节点上的partition数据不丢失，且kafka仍然能够继续工作，kafka提供了副本机制，一个topic的每个分区都有若干个副本，一个leader和若干个follower</li>
<li>leader：每个分区多个副本的“主”，生产者发送数据的对象，以及消费者消费数据的对象都是leader。</li>
<li>follower：每个分区多个副本中的“从”，实时从leader中同步数据，保持和leader数据的同步。leader发生故障时，某个follower会成为新的leader。</li>
</ul>
</li>
</ul>
<h2 id="架构深入"><a href="#架构深入" class="headerlink" title="架构深入"></a>架构深入</h2><h3 id="文件存储机制"><a href="#文件存储机制" class="headerlink" title="文件存储机制"></a>文件存储机制</h3><ul>
<li><p>Kafka中的消息使以topic进行分类的，生产者生产消息，消费者消费消息都是面向topic的。</p>
</li>
<li><p>topic是逻辑的一个概念，partition是物理上的一个概念，每一个partition对应一个log文件，log文件中存放生产者生产的数据。每条数据也有自己的offset，消费者组中的每一个消费者，都会实时记录自己消费到了哪个offset，以便于出错时恢复，从上次的位置继续消费。</p>
</li>
<li><p><a href="https://imgtu.com/i/RgXeUO"><img src="https://z3.ax1x.com/2021/07/03/RgXeUO.png" alt="RgXeUO.png"></a></p>
</li>
<li><p>当log文件过大时就会分成多个segment,主要是为了加快索引速度，而且一个log文件分成多个segment都是在磁盘上连续存储的，Kafka这样的设计可以大幅度提高数据读写速度。</p>
</li>
<li><p>一个segment对应三个文件，一个log文件，两个index文件，一个.index文件和一个.timeindex文件。</p>
</li>
<li><p>“.index”文件存储大量的索引信息，“.log”文件存储大量的数据，索引文件中的元数据指向对应数据文件中message的物理偏移地址。</p>
</li>
<li><p>index和log文件以当前segment的第一条消息的offset命名</p>
<p><a href="https://imgtu.com/i/RgXQxA"><img src="https://z3.ax1x.com/2021/07/03/RgXQxA.png" alt="RgXQxA.png"></a></p>
</li>
</ul>
<h3 id="Kafka生产者"><a href="#Kafka生产者" class="headerlink" title="Kafka生产者"></a>Kafka生产者</h3><ul>
<li>Kafka的数据也是类似于键值对形式的数据。例如&lt;String,String&gt;</li>
</ul>
<h4 id="分区策略"><a href="#分区策略" class="headerlink" title="分区策略"></a>分区策略</h4><ul>
<li><p>分区的原因：1.方便在集群中扩展。2.可以提高并发，以partition为单位进行读写。</p>
</li>
<li><p>分区写入策略：</p>
<ul>
<li><p>所谓轮询策略，即按顺序轮流将每条数据分配到每个分区中。</p>
<ul>
<li><p>举个例子，假设主题test有三个分区，分别是分区A，分区B和分区C。那么主题对接收到的第一条消息写入A分区，第二条消息写入B分区，第三条消息写入C分区，第四条消息则又写入A分区，依此类推。</p>
<p>轮询策略是默认的策略，故而也是使用最频繁的策略，它能最大限度保证所有消息都平均分配到每一个分区。除非有特殊的业务需求，否则使用这种方式即可。</p>
</li>
</ul>
</li>
<li><p>随机策略，也就是每次都随机地将消息分配到每个分区。其实大概就是先得出分区的数量，然后每次获取一个随机数，用该随机数确定消息发送到哪个分区。</p>
<ul>
<li>在比较早的版本，默认的分区策略就是随机策略，但其实使用随机策略也是为了更好得将消息均衡写入每个分区。但后来发现对这一需求而言，轮询策略的表现更优，所以社区后来的默认策略就是轮询策略了。</li>
</ul>
</li>
<li><p>按键保存策略，就是当生产者发送数据的时候，可以指定一个key，计算这个key的hashCode值，按照hashCode的值对不同消息进行存储。</p>
<ul>
<li>只要让生产者发送的时候指定key就行。刚刚不是说默认的是轮询策略吗？其实啊，kafka默认是实现了两个策略，没指定key的时候就是轮询策略，有的话那激素按键保存策略了。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="数据可靠性的保证"><a href="#数据可靠性的保证" class="headerlink" title="数据可靠性的保证"></a>数据可靠性的保证</h4><ul>
<li><p>producer向server发信息时是异步通信，为确保数据的可靠性，需要向producer发送ACK（acknowledgement确认收到）。如果producer收到ack，就会进行下一轮的发送，否则重新发送数据。这时会出现三种返回ack的时机：</p>
<p>1.收到后还没写立刻发送。最不安全</p>
<p>2.leader写完数据后发送ack。</p>
<p>3.ISR中所有副本都写完数据后发送ack。kafka默认的选择。优点：容忍n台节点故障，只需要n+1个副本。</p>
</li>
<li><p>根据这三种情况，将ack的值分别分为0，1，all(-1)。</p>
</li>
<li><p>在第三种情况中，会出现一种意外情况：leader收到数据，所有follower都开始同步数据，但有一个follower，因为某种故障，迟迟不能与leader进行同步，那leader就要一直等下去，直到它完成同步，才能发送ack。这个问题怎么解决呢？</p>
</li>
<li><p>Kafka引入一个Leader维护了一个动态的in-sync replica set (ISR)，解决上述问题。和leader保持同步的follower在ISR中，如果Follower长时间未向leader同步数据，该follower会被踢出ISR，实践阈值由<em><strong>replica.lag.time.max.ms</strong></em>参数设定。leader故障则会重新选举leader。</p>
<p><a href="https://imgtu.com/i/RgXWRJ"><img src="https://z3.ax1x.com/2021/07/03/RgXWRJ.png" alt="RgXWRJ.png"></a></p>
<ul>
<li>当follower故障时会被临时踢出ISR，待待该follower恢复后，follower会读取本地磁盘记录的上次的HW，并将log文件高于HW的部分截取掉，从HW开始向leader进行同步。等该<em><strong>follower的LEO大于等于该Partition的HW</strong></em>，即follower追上leader之后，就可以重新加入ISR了。</li>
<li>leader发生故障之后，会从ISR中选出一个新的leader，之后，为保证多个副本之间的数据一致性，其余的follower会先将各自的log文件高于HW的部分截掉，然后从新的leader同步数据。</li>
<li>这只能保证副本之间的数据一致性，并不能保证数据不丢失或者不重复</li>
</ul>
</li>
<li><p>exactly once语义：At Least Once + 幂等性 = Exactly Once。</p>
</li>
<li><p>幂等性就是指Producer不论向Server发送多少次重复数据，Server端都只会持久化一条。</p>
</li>
<li><p>将服务器的ACK级别设置为-1，可以保证Producer到Server之间不会丢失数据，即At Least Once语义。</p>
</li>
<li><p>要启用幂等性，只需要将Producer的参数中enable.idompotence设置为true即可。Kafka的幂等性实现其实就是将原来下游需要做的去重放在了数据上游。开启幂等性的Producer在初始化的时候会被分配一个PID，发往同一Partition的消息会附带Sequence Number。而Broker端会对&lt;PID, Partition, SeqNumber&gt;做缓存，当具有相同主键的消息提交时，Broker只会持久化一条。</p>
</li>
<li><p>局限性：但是PID重启就会变化，同时不同的Partition也具有不同主键，所以幂等性无法保证跨分区跨会话的Exactly Once。</p>
</li>
</ul>
<h3 id="Kafka消费者"><a href="#Kafka消费者" class="headerlink" title="Kafka消费者"></a>Kafka消费者</h3><h4 id="消费方式"><a href="#消费方式" class="headerlink" title="消费方式"></a>消费方式</h4><ul>
<li>消费方式：consumer采用pull(拉)模式从broker中读取数据。</li>
<li>pull模式不足之处是，如果kafka没有数据，消费者可能会陷入循环中，一直返回空数据。针对这一点，Kafka的消费者在消费数据时会传入一个时长参数timeout，如果当前没有数据可供消费，consumer会等待一段时间之后再返回，这段时长即为timeout。</li>
</ul>
<h4 id="分区分配策略"><a href="#分区分配策略" class="headerlink" title="分区分配策略"></a>分区分配策略</h4><ul>
<li><p>理想状况是一个consumergroup中每一个consumer负责拉取一个分区的数据。</p>
</li>
<li><p>roundrobin：当分区数大于consumer数量时，轮询分配，类似于斗地主一张一张的发牌。</p>
</li>
<li><p>range:类似于斗地主一次性发几张牌</p>
</li>
</ul>
<h4 id="offset维护"><a href="#offset维护" class="headerlink" title="offset维护"></a>offset维护</h4><ul>
<li>由于consumer在消费过程中可能会出现断电宕机等故障，consumer恢复后，需要从故障前的位置的继续消费，所以consumer需要实时记录自己消费到了哪个offset，以便故障恢复后继续消费。</li>
<li>将offset放在Kafka内置的一个topic中，__consumer_offsets。由50个分区。</li>
</ul>
<h4 id="Zookeeper在Kafka中作用"><a href="#Zookeeper在Kafka中作用" class="headerlink" title="Zookeeper在Kafka中作用"></a>Zookeeper在Kafka中作用</h4><ul>
<li><p>Kafka集群中有一个broker会被选举为Controller，负责管理集群broker的上下线，所有topic的分区副本分配和leader选举等工作。Controller的选举就是比谁快。</p>
</li>
<li><p>Controller的管理工作都是依赖于Zookeeper的。</p>
<p><a href="https://imgtu.com/i/RgXXzd"><img src="https://z3.ax1x.com/2021/07/03/RgXXzd.png" alt="RgXXzd.png"></a></p>
</li>
<li><p>leader挂掉之后，Controller会选举新的leader，更新永久节点state中的信息。state存放某个topic,某个分区的以些必要信息。</p>
</li>
</ul>
<h4 id="Kafka事务"><a href="#Kafka事务" class="headerlink" title="Kafka事务"></a>Kafka事务</h4><ul>
<li>为了实现跨分区跨会话的事务，需要引入一个全局唯一的Transaction ID，并将Producer获得的PID和Transaction ID绑定。这样当Producer重启后就可以通过正在进行的Transaction ID获得原来的PID。</li>
</ul>
<h3 id="KafkaAPI"><a href="#KafkaAPI" class="headerlink" title="KafkaAPI"></a>KafkaAPI</h3><ul>
<li><p>produceAPI</p>
</li>
<li><p>Kafka的Producer发送消息采用的是<em><strong>异步发送</strong></em>的方式。在消息发送的过程中，涉及到了<strong>两个线程——main线程和Sender线程</strong>，以及<em><strong>一个线程共享变量——RecordAccumulator</strong></em>。main线程将消息发送给RecordAccumulator，Sender线程不断从RecordAccumulator中拉取消息发送到Kafka broker。</p>
<p><a href="https://imgtu.com/i/RGBi1f"><img src="https://z3.ax1x.com/2021/06/26/RGBi1f.png" alt="RGBi1f.png"></a></p>
<ul>
<li><p>相关参数：</p>
<p><em><strong>batch.size</strong>***</em>：***只有数据积累到batch.size之后，sender才会发送数据。</p>
<p><em><strong>linger.ms</strong>***</em>：***如果数据迟迟未达到batch.size，sender等待linger.time之后就会发送数据。</p>
</li>
</ul>
</li>
<li><p>ConsumerAPI</p>
</li>
<li><p>Consumer消费数据时的可靠性是很容易保证的，因为数据在Kafka中是持久化的，故不用担心数据丢失问题。</p>
<p>由于consumer在消费过程中可能会出现断电宕机等故障，consumer恢复后，需要从故障前的位置的继续消费，所以consumer需要实时记录自己消费到了哪个offset，以便故障恢复后继续消费。</p>
<p>所以offset的维护是Consumer消费数据是必须考虑的问题。</p>
</li>
</ul>
<h3 id="Exactly-Once语义"><a href="#Exactly-Once语义" class="headerlink" title="Exactly Once语义"></a>Exactly Once语义</h3><ul>
<li><p>At Least Once 是Kafka默认提供的语义，它保证每条消息都能至少接收并处理一次，缺点是可能有重复数据。</p>
</li>
<li><p>At Most Once 最多一次就是保证一条消息只发送一次，这个其实最简单，异步发送一次然后不管就可以，缺点是容易丢数据，所以一般不采用。</p>
</li>
<li><p>要实现Exactly Once语义首先要弄清楚哪里会丢数据，哪里会重复数据</p>
<ul>
<li>首先是生产者丢失信息：<ul>
<li>Producer客户端有一个ack的配置，异步通信，通过ack来确定数据接收情况。要达到最严格的无消息丢失配置，应该是要将ack的参数设置为-1（all）。<strong>同时还需要使用带有回调的producer api，来发送数据</strong></li>
<li>Kafka 有一个配置参数min.insync.replicas，默认是1（也就是只有leader，实际生产应该调高），该属性规定了最小的ISR数。这意味着当acks为-1（即all）的时候，这个参数规定了必须写入的ISR集中的副本数，如果没达到，那么producer会产生异常</li>
</ul>
</li>
<li>Broker丢失数据<ul>
<li>首先是replication.factor配置参数，这个配置决定了副本的数量，默认是1。注意这个参数不能超过broker的数量</li>
<li>unclean.leader.election.enable参数设置为false，这个参数表示，当ISR集合中没有副本可以成为leader时，要不要从ISR之外的比较慢的副本选出leader，这样会导致丢失数据，虽然可以提高一些可用性，但是我们这里考虑的时精确一次消费，所以我们需要将这个参数置为false</li>
</ul>
</li>
<li>消费者丢失数据<ul>
<li>消费者丢失的情况，其实跟消费者offset处理不当有关。消费者消费的offset提交有一个参数，enable.auto.commit，默认是true，决定是否要让消费者自动提交位移。如果开启，那么consumer每次都是先提交位移，再进行消费。这样也会导致丢失数据（当消费者提交offset后，数据未消费完就挂了，但是offset的记录已经不对了，会导致重启后数据也找不到就丢失了）</li>
<li>可以将enable.auto.commit设置为false，改为手动提交offset，消费完之后再提交offset信息。但是这样又有可能导致重复消费。毕竟exactly once处理一直是一个问题呀（/摊手）。遗憾的是kafka目前没有保证consumer幂等消费的措施，如果确实需要保证consumer的幂等，可以对每条消息维持一个全局的id，每次消费进行去重，当然耗费这么多的资源来实现exactly once的消费到底值不值，那就得看具体业务了。</li>
</ul>
</li>
</ul>
</li>
<li><p>这是无消息丢失的几个主要配置</p>
<ul>
<li>producer的acks设置位-1，同时min.insync.replicas设置大于1。并且使用带有回调的producer api发生消息。</li>
<li>默认副本数replication.factor设置为大于1，或者创建topic的时候指定大于1的副本数。</li>
<li>unclean.leader.election.enable 设置为false，防止定期副本leader重选举</li>
<li>消费者端，自动提交位移enable.auto.commit设置为false。在消费完后手动提交位移。</li>
</ul>
</li>
<li><p>实现Exactly需要的几个配置</p>
<ul>
<li><p>首先是开启幂等性</p>
<ul>
<li>在kafka中，幂等性意味着一个消息无论重复多少次，都会被当作一个消息来持久化处理。</li>
<li>开启幂等性后，ack默认已经设置为-1了</li>
<li>创建producer客户端的时候，添加这一行配置 ：props.put(“enable.idempotence”, ture)</li>
<li>底层实现也很简单，就是对每条消息生成一个id值，broker会根据这个id值进行去重，从而实现幂等</li>
<li>幂等性的缺陷：幂等性只能保证单个Producer对于同一个分区的Exactly Once语义<ul>
<li>幂等性的producer只能做到单分区上的幂等性，即单分区消息不重复，多分区无法保证幂等性</li>
<li>只能保持单会话的幂等性，无法实现跨会话的幂等性，也就是说如果producer挂掉再重启，无法保证两个会话间的幂等（新会话可能会重发）。因为broker端无法获取之前的状态信息，所以无法实现跨会话的幂等。</li>
</ul>
</li>
</ul>
</li>
<li><p>在幂等性缺陷无法解决的时候就要考虑使用事务了</p>
<ul>
<li><p>事务可以支持多分区的数据完整性，原子性。并且支持跨会话的exactly once处理语义，也就是说如果producer宕机重启，依旧能保证数据只处理一次。</p>
</li>
<li><p>开启事务也很简单，首先需要开启幂等性，即设置enable.idempotence为true。然后对producer发送代码做一些小小的修改。</p>
</li>
<li><pre><code class="java">//初始化事务
producer.initTransactions();
try &#123;
    //开启一个事务
    producer.beginTransaction();
    producer.send(record1);
    producer.send(record2);
    //提交
    producer.commitTransaction();
&#125; catch (KafkaException e) &#123;
    //出现异常的时候，终止事务
    producer.abortTransaction();
&#125;
</code></pre>
</li>
<li><p>但无论开启幂等还是事务的特性，都会对性能有一定影响，这是必然的。所以kafka默认也并没有开启这两个特性，而是交由开发者根据自身业务特点进行处理。</p>
</li>
<li><p>为了实现这种效果，应用程序必须提供一个稳定的（重启后不变）唯一的ID，也即Transaction ID。Transactin ID与PID可能一一对应。区别在于Transaction ID由用户提供，而PID是内部的实现对用户透明。另外，为了保证新的Producer启动后，旧的具有相同Transaction ID的Producer即失效，每次Producer通过Transaction ID拿到PID的同时，还会获取一个单调递增的epoch。由于旧的Producer的epoch比新Producer的epoch小，Kafka可以很容易识别出该Producer是老的Producer并拒绝其请求。</p>
</li>
<li><p>跨Session的数据幂等发送。当具有相同Transaction ID的新的Producer实例被创建且工作时，旧的且拥有相同Transaction ID的Producer将不再工作。</p>
<p>跨Session的事务恢复。如果某个应用实例宕机，新的实例可以保证任何未完成的旧的事务要么Commit要么死亡，使得新实例从一个正常状态开始工作。</p>
</li>
</ul>
</li>
<li><p>需要注意的是，上述的事务保证是从Producer的角度去考虑的。从Consumer的角度来看，该保证会相对弱一些。尤其是不能保证所有被某事务Commit过的所有消息都被一起消费</p>
</li>
<li><p>原因</p>
<ul>
<li><p>对于压缩的Topic而言，同一事务的某些消息可能被其它版本覆盖</p>
<p>事务包含的消息可能分布在多个Segment中（即使在同一个Partition内），当老的Segment被删除时，该事务的部分数据可能会丢失</p>
<p>Consumer在一个事务内可能通过seek方法访问任意Offset的消息，从而可能丢失部分消息</p>
<p>Consumer可能并不需要消费某一事务内的所有Partition，因此它将永远不会读取组成该事务的所有消息</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive</title>
    <url>/2021/06/04/hive/</url>
    <content><![CDATA[<h1 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h1><h2 id="Hive基础知识"><a href="#Hive基础知识" class="headerlink" title="Hive基础知识"></a>Hive基础知识</h2><ul>
<li><p>Hive：由Facebook开源用于解决海量结构化日志的数据统计工具。</p>
<p>Hive是基于Hadoop的一个<em><strong>数据仓库工具</strong></em>，可以<em><strong>将结构化的数据文件映射为一张表</strong></em>，并<em><strong>提供类SQL查询功能</strong></em>。</p>
<p>本质是：将HQL转化成MapReduce程序</p>
</li>
<li><p>优点：1. 操作采用类SQL语法，提供快速开发的能力。</p>
</li>
<li><p>缺点： 1. 效率低</p>
</li>
<li><p>架构原理：<a href="https://imgtu.com/i/2YmPaT"><img src="https://z3.ax1x.com/2021/06/04/2YmPaT.png" alt="2YmPaT.png"></a></p>
</li>
<li><p>大致流程：Hive通过给用户提供的一系列交互接口，接收到用户的指令(SQL)，使用自己的Driver，结合元数据(MetaStore)，将这些指令翻译成MapReduce，提交到Hadoop中执行，最后，将执行返回的结果输出到用户交互接口。</p>
</li>
<li><p>hiveserver2，如果使用beeline，需要开启hiveserver2</p>
</li>
<li><p>架构解析：</p>
<ol>
<li><p>用户接口：Client.CLI（command-line interface）、JDBC/ODBC(jdbc访问hive)、WEBUI（浏览器访问hive）</p>
</li>
<li><p>元数据：Meta store .元数据包括：表名、表所属的数据库（默认是default）、表的拥有者、列/分区字段、表的类型（是否是外部表）、表的数据所在目录等；</p>
<p>默认存储在自带的derby数据库中（只支持但客户端访问），推荐使用MySQL存储Metastore（支持多客户端访问）</p>
<p>Metastore的作用是：客户端连接metastore服务，metastore再去连接MySQL数据库来存取元数据。有了metastore服务，就可以有多个客户端同时连接，而且这些客户端不需要知道MySQL数据库的用户名和密码，只需要连接metastore 服务即可。</p>
<ul>
<li>内嵌模式使用的是内嵌的Derby数据库来存储元数据，也不需要额外起Metastore服务。这个是默认的，配置简单，但是一次只能一个客户端连接，适用于用来实验，不适用于生产环境。</li>
<li>本地元存储和远程元存储都采用外部数据库来存储元数据，目前支持的数据库有：MySQL、Postgres、Oracle、MS SQL Server.在这里我们使用MySQL。</li>
<li>本地元存储和远程元存储的区别是：本地元存储不需要单独起metastore服务，用的是跟hive在同一个进程里的metastore服务。远程元存储需要单独起metastore服务，然后每个客户端都在配置文件里配置连接到该metastore服务。远程元存储的metastore服务和hive运行在不同的进程里。</li>
</ul>
</li>
<li><p>Hadooop.使用HDFS进行存储，使用MapReduce进行计算。</p>
</li>
<li><p>驱动器：Driver.</p>
<ol>
<li>包括解析器（SQL Parser）:将SQL字符串转换成抽象语法树AST</li>
<li>编译器（Physical Plan）：将AST编译生成逻辑执行计划。</li>
<li>优化器（Query Optimizer）：对逻辑执行计划进行优化。</li>
<li>执行器（Execution）：把逻辑执行计划转换成可以运行的物理计划。对于Hive来说，就是MR/Spark。</li>
</ol>
</li>
</ol>
</li>
<li><p>Tez引擎</p>
<ul>
<li>可以理解为一个加强版的MapReduce。比MapReduce更快，但是消耗更多的内存</li>
</ul>
</li>
<li><p>hive的数据类型</p>
<table>
<thead>
<tr>
<th>Hive数据类型</th>
<th>Java数据类型</th>
<th>长度</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>TINYINT</td>
<td>byte</td>
<td>1byte有符号整数</td>
<td>20</td>
</tr>
<tr>
<td>SMALINT</td>
<td>short</td>
<td>2byte有符号整数</td>
<td>20</td>
</tr>
<tr>
<td>INT</td>
<td>int</td>
<td>4byte有符号整数</td>
<td>20</td>
</tr>
<tr>
<td>BIGINT</td>
<td>long</td>
<td>8byte有符号整数</td>
<td>20</td>
</tr>
<tr>
<td>BOOLEAN</td>
<td>boolean</td>
<td>布尔类型，true或者false</td>
<td>TRUE  FALSE</td>
</tr>
<tr>
<td>FLOAT</td>
<td>float</td>
<td>单精度浮点数</td>
<td>3.14159</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>double</td>
<td>双精度浮点数</td>
<td>3.14159</td>
</tr>
<tr>
<td>STRING</td>
<td>string</td>
<td>字符系列。可以指定字符集。可以使用单引号或者双引号。</td>
<td>‘now is the time’ “for all good men”</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td></td>
<td>时间类型</td>
<td></td>
</tr>
<tr>
<td>BINARY</td>
<td></td>
<td>字节数组</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<p>集合数据类型：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
<th>语法示例</th>
</tr>
</thead>
<tbody><tr>
<td>STRUCT</td>
<td>和c语言中的struct类似，都可以通过“点”符号访问元素内容。例如，如果某个列的数据类型是STRUCT{first STRING, last STRING},那么第1个元素可以通过字段.first来引用。</td>
<td>struct()例如struct&lt;street:string, city:string&gt;</td>
</tr>
<tr>
<td>MAP</td>
<td>MAP是一组键-值对元组集合，使用数组表示法可以访问数据。例如，如果某个列的数据类型是MAP，其中键-&gt;值对是’first’-&gt;’John’和’last’-&gt;’Doe’，那么可以通过字段名[‘last’]获取最后一个元素</td>
<td>map()例如map&lt;string, int&gt;</td>
</tr>
<tr>
<td>ARRAY</td>
<td>数组是一组具有相同类型和名称的变量的集合。这些变量称为数组的元素，每个数组元素都有一个编号，编号从零开始。例如，数组值为[‘John’, ‘Doe’]，那么第2个元素可以通过数组名[1]进行引用。</td>
<td>Array()例如array<string></td>
</tr>
</tbody></table>
<ul>
<li>数据类型转化<ul>
<li>隐式转化   与java类似。1.所有整数类型、FLOAT和STRING类型都可以隐式地转换成DOUBLE</li>
<li>强制转化 CAST(‘1’ AS INT)将把字符串’1’ 转换成整数1；如果强制类型转换失败，如执行CAST(‘X’ AS INT)，表达式返回空值 NULL。</li>
</ul>
</li>
</ul>
<h2 id="SQL语言的分类"><a href="#SQL语言的分类" class="headerlink" title="SQL语言的分类"></a>SQL语言的分类</h2><p><strong>SQL语言的分类</strong></p>
<p>SQL语言共分为四大类：数据查询语言DQL，数据操纵语言DML，数据定义语言DDL，数据控制语言DCL。</p>
<p><strong>1. 数据查询语言DQL</strong><br>数据查询语言DQL基本结构是由SELECT子句，FROM子句，WHERE<br>子句组成的查询块：<br>SELECT &lt;字段名表&gt;<br>FROM &lt;表或视图名&gt;<br>WHERE &lt;查询条件&gt;</p>
<p><strong>2 .数据操纵语言DML</strong><br>数据操纵语言DML主要有三种形式：</p>
<ol>
<li>插入：INSERT</li>
<li>更新：UPDATE</li>
<li>删除：DELETE</li>
</ol>
<p><strong>3. 数据定义语言DDL</strong><br>数据定义语言DDL用来创建数据库中的各种对象—–表、视图、<br>索引、同义词、聚簇等如：<br>CREATE TABLE/VIEW/INDEX/SYN/CLUSTER<br>| | | | |<br>表 视图 索引 同义词 簇</p>
<p>DDL操作是隐性提交的！不能rollback </p>
<p><strong>4. 数据控制语言DCL</strong><br>数据控制语言DCL用来授予或回收访问数据库的某种特权，并控制<br>数据库操纵事务发生的时间及效果，对数据库实行监视等。如：</p>
<ol>
<li>GRANT：授权。</li>
</ol>
<ol start="2">
<li>ROLLBACK [WORK] TO [SAVEPOINT]：回退到某一点。<br>回滚—ROLLBACK<br>回滚命令使数据库状态回到上次最后提交的状态。其格式为：<br>SQL&gt;ROLLBACK;</li>
</ol>
<ol start="3">
<li>COMMIT [WORK]：提交。</li>
</ol>
<p>  在数据库的插入、删除和修改操作时，只有当事务在提交到数据<br>库时才算完成。在事务提交前，只有操作数据库的这个人才能有权看<br>到所做的事情，别人只有在最后提交完成后才可以看到。<br>提交数据有三种类型：显式提交、隐式提交及自动提交。下面分<br>别说明这三种类型。</p>
<p>(1) 显式提交<br>用COMMIT命令直接完成的提交为显式提交。其格式为：<br>SQL&gt;COMMIT；</p>
<p>(2) 隐式提交<br>用SQL命令间接完成的提交为隐式提交。这些命令是：<br>ALTER，AUDIT，COMMENT，CONNECT，CREATE，DISCONNECT，DROP，<br>EXIT，GRANT，NOAUDIT，QUIT，REVOKE，RENAME。</p>
<p>(3) 自动提交<br>若把AUTOCOMMIT设置为ON，则在插入、修改、删除语句执行后，<br>系统将自动进行提交，这就是自动提交。其格式为：<br>SQL&gt;SET AUTOCOMMIT ON；</p>
<h2 id="DDL语句"><a href="#DDL语句" class="headerlink" title="DDL语句"></a>DDL语句</h2><ul>
<li><p>库的DDL</p>
</li>
<li><p>创建语句，location就相当于数据库，他们之间是有映射关系的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE DATABASE [IF NOT EXISTS] database_name<br>[COMMENT database_comment]<br>[LOCATION hdfs_path]<br>[WITH DBPROPERTIES (property_name&#x3D;property_value, ...)];<br><br>--显示数据库<br>show databases;<br>hive&gt; show databases like &#39;db_hive*&#39;;<br>OK<br>db_hive<br>db_hive_1<br><br>--显示数据库详细信息<br>desc database extended db_hive;<br><br>--删除数据库<br>drop database db_hive2;<br><br>--如果数据库不为空，可以采用cascade命令，强制删除<br>drop database db_hive cascade;<br></code></pre></td></tr></table></figure></li>
<li><p>表的DDL</p>
</li>
<li><p>创建表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE [EXTERNAL] TABLE [IF NOT EXISTS] table_name <br>[(col_name data_type [COMMENT col_comment], ...)] <br>[COMMENT table_comment] <br>[PARTITIONED BY (col_name data_type [COMMENT col_comment], ...)] <br>[CLUSTERED BY (col_name, col_name, ...) <br>[SORTED BY (col_name [ASC|DESC], ...)] INTO num_buckets BUCKETS] <br>[ROW FORMAT row_format] <br>[STORED AS file_format] <br>[LOCATION hdfs_path]<br>[TBLPROPERTIES (property_name&#x3D;property_value, ...)]<br>[AS select_statement]<br><br>--（7）ROW FORMAT <br>DELIMITED [FIELDS TERMINATED BY char] [COLLECTION ITEMS TERMINATED BY char]<br>        [MAP KEYS TERMINATED BY char] [LINES TERMINATED BY char] <br>   | SERDE serde_name [WITH SERDEPROPERTIES (property_name&#x3D;property_value, property_name&#x3D;property_value, ...)]<br>用户在建表的时候可以自定义SerDe或者使用自带的SerDe。如果没有指定ROW FORMAT 或者ROW FORMAT DELIMITED，将会使用自带的SerDe。在建表的时候，用户还需要为表指定列，用户在指定表的列的同时也会指定自定义的SerDe，Hive通过SerDe确定表的具体的列的数据。<br><br></code></pre></td></tr></table></figure></li>
<li><p>内部表</p>
<ul>
<li>默认创建的是内部表，也叫管理表。当我们删除一个管理表时，Hive也会删除这个表中数据。管理表不适合和其他工具共享数据。</li>
</ul>
</li>
<li><p>外部表</p>
<ul>
<li>创建时加上 external</li>
<li>以Hive并非认为其完全拥有这份数据。删除该表并不会删除掉这份数据，不过描述表的元数据信息会被删除掉。</li>
<li><strong>结论: 外部表的数据不由hive自身负责管理，虽然数据会被加载到/user/hive/warehouse/，但是不由hive管理。</strong></li>
<li><strong>指定location：指定加载数据的位置，不再是默认加载到/user/hive/warehouse/目录下了。</strong></li>
</ul>
</li>
<li><p>内部表外部表转化</p>
<ul>
<li><p>修改内部表student2为外部表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">修改内部表student2为外部表<br>alter table student2 set tblproperties(&#39;EXTERNAL&#39;&#x3D;&#39;TRUE&#39;);<br><br>--查询表的类型<br>desc formatted student2;<br>--转换为内部表<br>alter table student2 set tblproperties(&#39;EXTERNAL&#39;&#x3D;&#39;FALSE&#39;);<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>分区表</p>
</li>
<li><p><font color=red>Hive中的分区就是分目录</font>，把一个大的数据集根据业务需要分割成小的数据集。</p>
<ul>
<li>````mysql<br>create table dept_partition(deptno int, dname string, loc string<br>)<br>partitioned by (month string)<br>row format delimited fields terminated by ‘\t’;<br>–分区字段不能是表中已经存在的数据，可以将分区字段看作表的伪列。<br>– 查询分区表的分区<br>show partitions dept_partition<br>–如果提前准备数据，但是没有元数据<br>–把数据直接上传到分区目录上，让分区表和数据产生关联的三种方式<br>–1.添加分区<br>alter table dept_partition add partition(class=”03”)<br>–2.直接修复<br>msck repair table stu_par;<br>–3.上传带分区–同时创建分区<br>alter table dept_partition add partition(month=’201705’), partition(month=’201704’);<br>–删除多个分区<br> alter table dept_partition drop partition (month=’201705’), partition (month=’201706’);<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">  <br>- 分区表不能转换，只能在建表时就建好<br><br>- 支持二级分区<br><br>  ````mysql<br>  <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> dept_partition2(<br>                 deptno <span class="hljs-built_in">int</span>, dname <span class="hljs-keyword">string</span>, loc <span class="hljs-keyword">string</span><br>                 )<br>                 partitioned <span class="hljs-keyword">by</span> (<span class="hljs-keyword">month</span> <span class="hljs-keyword">string</span>, <span class="hljs-keyword">day</span> <span class="hljs-keyword">string</span>)<br>                 <span class="hljs-keyword">row</span> <span class="hljs-keyword">format</span> <span class="hljs-keyword">delimited</span> <span class="hljs-keyword">fields</span> <span class="hljs-keyword">terminated</span> <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;\t&#x27;</span>;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>修改表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">ALTER TABLE table_name RENAME TO new_table_name<br>--更新列<br>ALTER TABLE table_name CHANGE [COLUMN] col_old_name col_new_name column_type [COMMENT col_comment] [FIRST|AFTER column_name]<br>--增加和替换列<br>ALTER TABLE table_name ADD|REPLACE COLUMNS (col_name data_type [COMMENT col_comment], ...) <br>--删除表<br>drop table dept_partition;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h2><ul>
<li><p>数据导入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">--创建语句<br>create table student(id string, name string) row format delimited fields terminated by &#39;\t&#39;;<br>--1.load导入数据<br>load data [local] inpath &#39;&#x2F;opt&#x2F;module&#x2F;datas&#x2F;student.txt&#39; [overwrite] into table student [partition (partcol1&#x3D;val1,…)];<br>--本地数据导入<br>load data local inpath &#39;&#x2F;opt&#x2F;module&#x2F;datas&#x2F;student.txt&#39; into table default.student;<br>--hdfs数据导入<br>load data inpath &#39;&#x2F;user&#x2F;zt&#x2F;hive&#x2F;student.txt&#39; into table default.student;<br>--加载数据覆盖表中已有的数据<br>load data inpath &#39;&#x2F;user&#x2F;zt&#x2F;hive&#x2F;student.txt&#39; overwrite into table default.student;<br>--hdfs的导入是移动，本地导入是复制<br></code></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">--2.通过查询语句向表中插入数据（Insert）<br> create table student_par(id int, name string) partitioned by (month string) row format delimited fields terminated by &#39;\t&#39;;<br> <br>insert overwrite table student partition(month&#x3D;&#39;201708&#39;)<br>             select id, name from student where month&#x3D;&#39;201709&#39;;<br>             <br>--insert into：以追加数据的方式插入到表或分区，原有数据不会删除<br>--insert overwrite：会覆盖表或分区中已存在的数据<br><br>--3.建表时用as select<br>create table if not exists student3<br>as select id, name from student;<br><br>--4.创建表时通过Location指定加载数据路径<br>create external table if not exists student5(<br>              id int, name string<br>              )<br>              row format delimited fields terminated by &#39;\t&#39;<br>              location &#39;&#x2F;student;&#39;<br><br><br>-- 5.Import数据到指定Hive表中<br>import table student2 partition(month&#x3D;&#39;201709&#39;) from<br> &#39;&#x2F;user&#x2F;hive&#x2F;warehouse&#x2F;export&#x2F;student&#39;;<br></code></pre></td></tr></table></figure></li>
<li><p>数据导出(不重要)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">--1. Insert导出<br>--将查询结果导出到本地<br>insert overwrite local directory &#39;&#x2F;opt&#x2F;module&#x2F;datas&#x2F;export&#x2F;student&#39;<br>            select * from student;<br>            <br>--将查询的结果格式化导出到本地<br>insert overwrite local directory &#39;&#x2F;opt&#x2F;module&#x2F;datas&#x2F;export&#x2F;student1&#39;<br>           ROW FORMAT DELIMITED FIELDS TERMINATED BY &#39;\t&#39;             select * from student;<br>           <br>--将查询的结果导出到HDFS上(没有local)<br>insert overwrite directory &#39;&#x2F;user&#x2F;zt&#x2F;student2&#39;<br>ROW FORMAT DELIMITED FIELDS TERMINATED BY &#39;\t&#39; <br>select * from student;<br>--整张表export 到处到HDFS<br>export table default.student to<br> &#39;&#x2F;user&#x2F;hive&#x2F;warehouse&#x2F;export&#x2F;student&#39;;<br></code></pre></td></tr></table></figure></li>
<li><p>清除数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">--Truncate只能删除管理表（内部表），不能删除外部表中数据<br>--只删除数据，不删除本身<br>truncate table student;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h2><h3 id="数据查询语言"><a href="#数据查询语言" class="headerlink" title="数据查询语言"></a>数据查询语言</h3><h4 id="1-基本查询（select…-from…-）"><a href="#1-基本查询（select…-from…-）" class="headerlink" title="1. 基本查询（select…..from…..）"></a>1. 基本查询（select…..from…..）</h4><p>（1）SQL 语言大小写不敏感。 </p>
<p>（2）SQL 可以写在一行或者多行</p>
<p>（3）关键字不能被缩写也不能分行</p>
<p>（4）各子句一般要分行写。</p>
<p>（5）使用缩进提高语句的可读性。</p>
<ul>
<li><p>别名</p>
<ul>
<li><p>紧跟列名，也可以在列名和别名之间加入关键字‘AS’</p>
</li>
<li><p>select ename AS name, deptno dn from emp;</p>
</li>
</ul>
</li>
<li><p>算数运算符</p>
<ul>
<li>select sal +1 from emp;</li>
</ul>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>A+B</td>
<td>A和B 相加</td>
</tr>
<tr>
<td>A-B</td>
<td>A减去B</td>
</tr>
<tr>
<td>A*B</td>
<td>A和B 相乘</td>
</tr>
<tr>
<td>A/B</td>
<td>A除以B</td>
</tr>
<tr>
<td>A%B</td>
<td>A对B取余</td>
</tr>
<tr>
<td>A&amp;B</td>
<td>A和B按位取与</td>
</tr>
<tr>
<td>A|B</td>
<td>A和B按位取或</td>
</tr>
<tr>
<td>A^B</td>
<td>A和B按位取异或</td>
</tr>
<tr>
<td>~A</td>
<td>A按位取反</td>
</tr>
</tbody></table>
</li>
<li><p>常用函数</p>
<ul>
<li>UDF函数：一个输入一个输出 select substring(ename,1,1) from emp;（从ｅname的1开始，取一个字符）用户定义（普通）函数，只对单行数值产生作用。实现：继承UDF，实现evaluate()方法</li>
<li>UDAF函数：多个输入，一个输出 select count(*) cnt from emp;用户定义聚合函数，可对多行数据产生作用；等同与SQL中常用的SUM()，AVG()，也是聚合函数；</li>
<li>UDTF函数：一个输入，多个输出。用户定义表生成函数。用来解决输入一行输出多行；实现：继承GenericUDTF，实现close(),initialize(),process()方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">--1．求总行数（count）<br>select count(*) cnt from emp;<br>--2．求工资的最大值（max）<br>select max(sal) max_sal from emp;<br>--3．求工资的最小值（min）<br>select min(sal) min_sal from emp;<br>--4．求工资的总和（sum）<br>select sum(sal) sum_sal from emp; <br>--5．求工资的平均值（avg）<br>select avg(sal) avg_sal from emp;<br></code></pre></td></tr></table></figure></li>
<li><p>LIMIT子句用于限制返回的行数</p>
<ul>
<li>select * from emp limit 5;</li>
</ul>
</li>
</ul>
<h4 id="2-条件过滤"><a href="#2-条件过滤" class="headerlink" title="2.条件过滤"></a>2.条件过滤</h4><ol>
<li><p>使用where子句，将不满足条件的行过滤掉</p>
<p>select * from emp where sal =5000;</p>
</li>
<li><p>比较运算符：下面表中描述了谓词操作符，这些操作符同样可以用于JOIN…ON和HAVING语句中</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>支持的数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>A=B</td>
<td>基本数据类型</td>
<td>如果A等于B则返回TRUE，反之返回FALSE</td>
</tr>
<tr>
<td>A&lt;=&gt;B</td>
<td>基本数据类型</td>
<td>如果A和B都为NULL，则返回TRUE，其他的和等号（=）操作符的结果一致，如果任一为NULL则结果为NULL</td>
</tr>
<tr>
<td>A&lt;&gt;B, A!=B</td>
<td>基本数据类型</td>
<td>A或者B为NULL则返回NULL；如果A不等于B，则返回TRUE，反之返回FALSE</td>
</tr>
<tr>
<td>A&lt;B</td>
<td>基本数据类型</td>
<td>A或者B为NULL，则返回NULL；如果A小于B，则返回TRUE，反之返回FALSE</td>
</tr>
<tr>
<td>A&lt;=B</td>
<td>基本数据类型</td>
<td>A或者B为NULL，则返回NULL；如果A小于等于B，则返回TRUE，反之返回FALSE</td>
</tr>
<tr>
<td>A&gt;B</td>
<td>基本数据类型</td>
<td>A或者B为NULL，则返回NULL；如果A大于B，则返回TRUE，反之返回FALSE</td>
</tr>
<tr>
<td>A&gt;=B</td>
<td>基本数据类型</td>
<td>A或者B为NULL，则返回NULL；如果A大于等于B，则返回TRUE，反之返回FALSE</td>
</tr>
<tr>
<td>A [NOT] BETWEEN B AND C</td>
<td>基本数据类型</td>
<td>如果A，B或者C任一为NULL，则结果为NULL。如果A的值大于等于B而且小于或等于C，则结果为TRUE，反之为FALSE。如果使用NOT关键字则可达到相反的效果。</td>
</tr>
<tr>
<td>A IS NULL</td>
<td>所有数据类型</td>
<td>如果A等于NULL，则返回TRUE，反之返回FALSE</td>
</tr>
<tr>
<td>A IS NOT NULL</td>
<td>所有数据类型</td>
<td>如果A不等于NULL，则返回TRUE，反之返回FALSE</td>
</tr>
<tr>
<td>IN(数值1, 数值2)</td>
<td>所有数据类型</td>
<td>使用 IN运算显示列表中的值</td>
</tr>
<tr>
<td>A [NOT] LIKE B</td>
<td>STRING 类型</td>
<td>B是一个SQL下的简单正则表达式，也叫通配符模式，如果A与其匹配的话，则返回TRUE；反之返回FALSE。B的表达式说明如下：‘x%’表示A必须以字母‘x’开头，‘%x’表示A必须以字母’x’结尾，而‘%x%’表示A包含有字母’x’,可以位于开头，结尾或者字符串中间。如果使用NOT关键字则可达到相反的效果。</td>
</tr>
<tr>
<td>A RLIKE B, A REGEXP B</td>
<td>STRING 类型</td>
<td>B是基于java的正则表达式，如果A与其匹配，则返回TRUE；反之返回FALSE。匹配使用的是JDK中的正则表达式接口实现的，因为正则也依据其中的规则。例如，正则表达式必须和整个字符串A相匹配，而不是只需与其字符串匹配。</td>
</tr>
</tbody></table>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">--通配符字符串匹配　% _<br>--%匹配任意串，_匹配任意字符<br>--查询以A开头的员工<br>select * from emp where ename like &quot;A%&quot;;<br><br>--正则匹配<br>--查询以A开头的员工<br>select * from emp where ename rlike &quot;^A&quot;; <br></code></pre></td></tr></table></figure>

<ul>
<li><p>rlike匹配正则表达式</p>
</li>
<li><p>正则表达式</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><code class="hljs powershell">一般字符匹配自己<br>^ 匹配一行开头 ^R 以<span class="hljs-built_in">R</span>开头<br><span class="hljs-variable">$</span> 匹配一行结束 <span class="hljs-built_in">R</span><span class="hljs-variable">$</span> 以<span class="hljs-built_in">R</span>结尾<br>. 匹配任意字符 ^.<span class="hljs-variable">$</span> 一行只有一个字符<br>* 前一个子式匹配零次或多次<br>.*匹配任意字符<br>[] 匹配一个范围内的任意字符<br>\ 转义<br></code></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li><p>逻辑运算符（AND，OR，NOT）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">select * from emp where sal&gt;1000 and deptno&#x3D;30;<br>select * from emp where sal&gt;1000 or deptno&#x3D;30;<br>select * from emp where deptno not IN(30, 20);<br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="3-分组"><a href="#3-分组" class="headerlink" title="3. 分组"></a>3. 分组</h4><ul>
<li><p>GROUP BY语句通常会和聚合函数一起使用，按照一个或者多个列队结果进行分组，然后对每个组执行聚合操作。</p>
</li>
<li><p>（1）where后面不能写分组函数，而having后面可以使用分组函数。</p>
<p>（2）having只用于group by分组统计语句。</p>
</li>
<li><p>````mysql<br>–计算emp表每个部门的平均工资<br>select t.deptno, avg(t.sal) avg_sal from emp t group by t.deptno<br>–求每个部门的平均薪水大于2000的部门<br>select deptno, avg(sal) avg_sal from emp group by deptno having<br> avg_sal &gt; 2000;</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"><br>#### 4.连接<br><br>* Hive支持通常的SQL JOIN语句，但是只支持等值连接，不支持非等值连接。<br><br>  - 内连接<br>  - 左外连接<br>  - 右外连接<br>  - 满外连接<br><br>  ````mysql<br>  <span class="hljs-keyword">select</span><br>      <span class="hljs-built_in">e</span>.empno,<br>      <span class="hljs-built_in">e</span>.ename,<br>      d.deptno, <br>      d.dname <br>  <span class="hljs-keyword">from</span> <br>      emp <span class="hljs-built_in">e</span> <br>  <span class="hljs-keyword">join</span><br>      dept d <br>  <span class="hljs-keyword">on</span><br>      <span class="hljs-built_in">e</span>.deptno = d.deptno;<br>      <br></code></pre></td></tr></table></figure></li>
<li><p>表的别名：好处：1.简化查询，使用表名前缀可以提高执行效率</p>
</li>
<li><p>多表连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT <br>    e.ename,<br>    d.dname, <br>    l.loc_name<br>FROM<br>	emp e <br>JOIN<br>	dept d<br>ON<br>	d.deptno &#x3D; e.deptno <br>JOIN<br>	location l<br>ON<br>	d.loc &#x3D; l.loc;<br></code></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p><strong>hive join目前不支持在on子句中使用谓词or(hive1 不支持)</strong></p>
<p>select e.empno, e.ename, d.deptno from emp e join dept d on e.deptno</p>
<p>= d.deptno or e.ename=d.deptno;  在hive1错误的,hive3支持</p>
</li>
</ul>
<h4 id="5-排序"><a href="#5-排序" class="headerlink" title="5.排序"></a>5.排序</h4><ul>
<li>order by:全局排序，只有一个Reducer(极易造成数据倾斜)</li>
<li>ASC（ascend）: 升序（默认）</li>
<li>DESC（descend）: 降序</li>
<li>sort by:局部排序（sort by 为每个reduce产生一个排序文件。每个Reduce内部进行排序，对全局结果来说不是排序）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">--一般需求不会要求给所有的数据排序，而要求知道前几<br>--求工资前10的人，Map会先求局部前10<br>select *<br>from emp<br>order by sal desc<br>limit 10;<br><br>--还有一种可能，我们只需要看大概的数据趋势，不需要全排序<br>--Hive的局部排序 sort by<br>select *<br>from emp<br>sort by empno desc;<br><br>--多条件排序，先按部门排序，再按工资排序<br>select *<br>from emp<br>order by<br>deptno asc,<br>sal desc;<br><br>--limit,offset<br>limit X,Y 跳过X条数据，取Y条数据<br>offset X 跳过X条数据<br></code></pre></td></tr></table></figure>

<ul>
<li><p>分区排序 （Distribute By）</p>
</li>
<li><p><em><strong>distribute by</strong></em>类似MR中partition（自定义分区），进行分区，结合sort by使用。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">--指定局部排序的分区字段<br>select * from emp<br>distribute by empno<br>sort by sal desc;<br><br>--如果分区和排序的字段一样，我们可以用cluster by代替<br>select * from emp distribute by empno sort by empno;<br>select * from emp cluster by empno;<br></code></pre></td></tr></table></figure></li>
<li><p>当distribute by和sorts by字段相同时，可以使用cluster by方式。</p>
</li>
</ul>
<h4 id="6-分桶"><a href="#6-分桶" class="headerlink" title="6.分桶"></a>6.分桶</h4><ul>
<li><p>分区提供一个隔离数据和优化查询的便利方式。不过，并非所有的数据集都可形成合理的分区。对于一张表或者分区，Hive 可以进一步组织成桶，也就是更为细粒度的数据范围划分。</p>
</li>
<li><p>分区针对的是数据的存储路径；分桶针对的是数据文件。</p>
</li>
<li><p>分桶：针对某一个区的数据，把它的数据进一步组织成多个文件</p>
</li>
<li><p>分区：把多个数据，分成文件夹管理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">create table stu_buck(id int, name string)<br>clustered by(id) <br>into 4 buckets<br>row format delimited fields terminated by &#39;\t&#39;;<br><br><br></code></pre></td></tr></table></figure></li>
<li><p>分桶抽样查询</p>
</li>
<li><p>对于非常大的数据集，有时用户需要使用的是一个具有代表性的查询结果而不是全部结果。Hive可以通过对表进行抽样来满足这个需求。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">select * from stu_buck tablesample(bucket 1 out of 4 on id);<br>--tablesample是抽样语句，语法：TABLESAMPLE(BUCKET x OUT OF y) <br>--y必须是table总bucket数的倍数或者因子。hive根据y的大小，决定抽样的比例<br>把数据按照bucket分成y份，取其中的第x份<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="常用查询函数"><a href="#常用查询函数" class="headerlink" title="常用查询函数"></a>常用查询函数</h3><h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">hive中查询函数<br>show functions<br>show functions like &quot;collect*&quot;<br>查看函数的描述<br>desc function 函数名<br>--nvl空字段赋值<br>select comm, nvl(comm, -1) from emp;<br></code></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">--case when<br>--统计不同部门男女各有多少人<br>select<br>    dept_id,<br>    count(*) total,<br>    sum(case sex when &#39;男&#39; then 1 else 0 end) male,<br>    sum(case sex when &#39;女&#39; then 1 else 0 end) female<br>from<br>    emp_sex<br>group by<br>    dept_id;<br></code></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">在 Group by 子句中，Select 查询的列，要么需要是 Group by 中的列，要么得是用聚合函数（比如 sum、count 等）加工过的列。不支持直接引用非 Group by 的列。这一点和 MySQL 有所区别。Hive 错误 Expression not in GROUP BY key的原因。<br>--行转列<br>collect_list(x),聚合成一个数组，聚合函数<br>concat_ws(&quot;分隔符&quot;，数组)，把数组按分割符拼成一个字符串<br>contact(str1,str2......,strn)拼接几列在一起<br><br>select<br>    concat(constellation,&quot;,&quot;,blood_type) xzxx,<br>    concat_ws(&quot;|&quot;, collect_list(name)) rentou<br>from<br>    person_info<br>group by<br>    constellation,blood_type;<br></code></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">--列转行<br>--explode(a)函数<br>--如果传入的是一个数组，则将其分成多行<br>--如果传入一个map,按照key,value分成两列<br>--split(str,regrex)函数<br>--将一个字符串按照正则表达式规则划分成一个数组<br>lateral view 后面接一个表名，起一个列名，列名取决于explode()炸开后的效果。<br>select<br>    m.movie,<br>    tbl.cate<br>from<br>    movie_info m<br>lateral view<br>    explode(split(category, &quot;,&quot;)) tbl as cate;<br></code></pre></td></tr></table></figure>

<h4 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h4><ul>
<li><p>相关函数说明</p>
<p>OVER()：指定分析函数工作的数据窗口大小，这个数据窗口大小可能会随着行的变而变化。</p>
<p>CURRENT ROW：当前行</p>
<p>n PRECEDING：往前n行数据</p>
<p>n FOLLOWING：往后n行数据</p>
<p>UNBOUNDED：起点，UNBOUNDED PRECEDING 表示从前面的起点， UNBOUNDED FOLLOWING表示到后面的终点</p>
<p>LAG(col,n,default_val)：往前第n行数据</p>
<p>LEAD(col,n, default_val)：往后第n行数据</p>
<p>NTILE(n)：把有序窗口的行分发到指定数据的组中，各个组有编号，编号从1开始，对于每一行，NTILE返回此行所属的组的编号。注意：n必须为int类型。</p>
<p>percent_rank()将数据按百分比分</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">--聚合<br>select name,count(*) over () <br>from business <br>where substring(orderdate,1,7) &#x3D; &#39;2017-04&#39; <br>group by name;<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">--各种聚合<br>select name,orderdate,cost, <br>sum(cost) over() as sample1,--所有行相加 <br>sum(cost) over(partition by name) as sample2,--按name分组，组内数据相加 <br>sum(cost) over(partition by name order by orderdate) as sample3,--按name分组，组内数据累加 <br>sum(cost) over(partition by name order by orderdate rows between UNBOUNDED PRECEDING and current row ) as sample4 ,--和sample3一样,由起点到当前行的聚合 <br>sum(cost) over(partition by name order by orderdate rows between 1 PRECEDING and current row) as sample5, --当前行和前面一行做聚合 <br>sum(cost) over(partition by name order by orderdate rows between 1 PRECEDING AND 1 FOLLOWING ) as sample6,--当前行和前边一行及后面一行 <br>sum(cost) over(partition by name order by orderdate rows between current row and UNBOUNDED FOLLOWING ) as sample7 --当前行及后面所有行 <br>from business;<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">--结合其他函数使用<br>select<br>    name, orderdate, cost, <br>    lag(orderdate, 1) <br>    over(partition by name order by orderdate) last_order,<br>    lead(orderdate, 1) <br>    over(partition by name order by orderdate) next_order<br>from<br>    business;<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">--ntile<br>Ntile(group_num) 将所有记录分成group_num个组，每组序号一样<br>SELECT<br>	*<br>FROM<br>	(<br>		select name,<br>		orderdate,<br>		cost,<br>		ntile(5) over(<br>		order by orderdate) n<br>	from<br>		business) t1<br>WHERE<br>	n &#x3D; 1;<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">--percent_rank<br>select<br>	name,<br>	orderdate,<br>	cost,<br>	PERCENT_RANK() over(<br>	order by orderdate) pr<br>from<br>	business;<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">--rank<br>rank()排序，相同的一样排名，数字按照实际的来，类似于高考排名<br>dense_rank() 相同的一样排名，数字按照排名的数字来<br>row_number() 直接排名，相同的排名也不一样<br>SELECT<br>	*,<br>	rank() OVER(partition by subject<br>order by<br>	score desc) r,<br>	DENSE_RANK() OVER(partition by subject<br>order by<br>	score desc) dr,<br>	ROW_NUMBER() OVER(partition by subject<br>order by<br>	score desc) rn<br>from<br>	score;<br></code></pre></td></tr></table></figure>

<h4 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">--current_date 返回当前日期<br>select current_date();<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">--日期的加减<br>--今天开始90天以后的日期<br>select date_add(current_date(), 90);<br>--今天开始90天以前的日期<br>select date_sub(current_date(), 90);<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">--日期差<br>SELECT datediff(CURRENT_DATE(), &quot;1990-06-04&quot;);<br></code></pre></td></tr></table></figure>

<p>习题：有哪些顾客连续两天来过我的店，数据是business表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">--习题<br>selec<br><br>--time1下一次购买商品的时间<br>select<br>name,cost,orderdate,<br>lead(orderdate,1,&quot;2021-09-01&quot;) over(partition by name order by orderdate) time1<br>from<br>business<br><br>--时间差<br>select<br>name,cost,orderdate,time1,<br>datediff(time1,orderdate) difftime<br>from<br>    (select<br>name,cost,orderdate,<br>lead(orderdate,1,&quot;2021-09-01&quot;) over(partition by name order by orderdate) time1<br>from<br>business) tab;<br><br>--找到时间差为1的人<br>select<br>name,corderdate,time1,difftime<br>from<br>(select<br>name,cost,orderdate,time1,<br>datediff(time1,orderdate) difftime<br>from<br>    (select<br>name,cost,orderdate,<br>lead(orderdate,1,&quot;2021-09-01&quot;) over(partition by name order by orderdate) time1<br>from<br>business) tab) tab1<br>where<br>difftime&#x3D;1;<br><br></code></pre></td></tr></table></figure>

<ul>
<li>hive重点：写sql,熟练使用函数，尤其是开窗函数</li>
</ul>
<h3 id="SQL一般执行顺序"><a href="#SQL一般执行顺序" class="headerlink" title="SQL一般执行顺序"></a>SQL一般执行顺序</h3><ol>
<li>from 确定基表</li>
<li>join 如果一张基表不够, 再联接其他表</li>
<li>on 如果有联接表 必须要有on</li>
<li>where 过滤总基表中的行</li>
<li>group by 分组, 分组依据的列.</li>
<li>select 把分组依据的列放在select后, 再考虑要选择哪些列, 及进行哪些函数调用….</li>
<li>having 进一步把分组后的虚表行过滤</li>
<li><em><strong>窗口函数</strong></em></li>
<li>order by 最终表的一个排序显示.</li>
<li>limit</li>
</ol>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Hive</category>
      </categories>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>warehouse-project</title>
    <url>/2021/07/29/warehouse-project/</url>
    <content><![CDATA[<h1 id="离线数仓项目"><a href="#离线数仓项目" class="headerlink" title="离线数仓项目"></a>离线数仓项目</h1><h2 id="数仓分层"><a href="#数仓分层" class="headerlink" title="数仓分层"></a>数仓分层</h2><ul>
<li><p>为什么要分层</p>
<p><a href="https://imgtu.com/i/WHSDoQ"><img src="https://z3.ax1x.com/2021/07/29/WHSDoQ.png" alt="WHSDoQ.png"></a></p>
<ul>
<li>ODS层（Operation Data Store）原始数据层，将前端日志数据，后端业务数据直接导入，不做处理</li>
<li>DWD层 (Data Warehouse Detail) 明细数据层，对ODS层数据进行数据清洗，维度退化，脱敏等。</li>
<li>DWS层 （Data Warehouse Service）服务数据层，以DWD层为基础，按天进行轻度汇总。</li>
<li>DWT层 （Data Warehouse Topic）主题数据层，以DWS层为基础，按主题进行汇总。</li>
<li>ADS层 （Application Data Store）应用数据层，为各种统计报表提供数据。</li>
</ul>
</li>
<li><p>为什么要分层：</p>
<ul>
<li>把复杂问题简单化：将复杂的任务分解成多层来完成，每一层只处理简单的任务，方便定位问题。</li>
<li>减少重复开发：规范数据分层，通过中间数据层，能够减少极大的重复计算，增加一次计算结果的复用性。</li>
<li>隔离原始数据：不论是数据的异常还是数据的敏感性，使真实数据与统计数据解耦开。</li>
</ul>
</li>
</ul>
<h2 id="数仓理论"><a href="#数仓理论" class="headerlink" title="数仓理论"></a>数仓理论</h2><h3 id="范式概念"><a href="#范式概念" class="headerlink" title="范式概念"></a>范式概念</h3><ul>
<li>范式可以理解为设计一张数据表的表结构应符合的标准级别。</li>
<li>按照范式理论建表目的在于<font color=red>降低数据的冗余性</font></li>
<li>范式的缺点是查询数据时需要进行大量的join操作。</li>
</ul>
<h4 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h4><ul>
<li>完全函数依赖：简单来说：就是AB能推出C，但是AB单独时不能推出C，那么说C完全依赖于AB。</li>
<li>部分函数依赖：AB能推出C,AB单独也能推出C，即C部分依赖于AB。</li>
<li>传递函数依赖：通过A推出B，通过B推出C，但是C推不出A，但是A能推出C，那么C传递函数依赖于A。</li>
</ul>
<h4 id="范式区别"><a href="#范式区别" class="headerlink" title="范式区别"></a>范式区别</h4><ul>
<li>第一范式：属性不可切割</li>
<li>第二范式：不能存在部分函数依赖</li>
<li>第三范式：不能存在传递函数依赖</li>
</ul>
<h3 id="关系建模和维度建模"><a href="#关系建模和维度建模" class="headerlink" title="关系建模和维度建模"></a>关系建模和维度建模</h3><ul>
<li><p>当今的数据处理大致可以分成两大类：联机事务处理OLTP（on-line transaction processing）、联机分析处理OLAP（On-Line Analytical Processing）。OLTP是传统的关系型数据库的主要应用，主要是基本的、日常的事务处理，例如银行交易。OLAP是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。</p>
</li>
<li><table>
<thead>
<tr>
<th><em><strong>对比属性</strong></em></th>
<th><em><strong>OLTP</strong></em></th>
<th><em><strong>OLAP</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>读特性</strong></em></td>
<td>每次查询只返回少量记录</td>
<td>对大量记录进行汇总</td>
</tr>
<tr>
<td><em><strong>写特性</strong></em></td>
<td>随机、低延时写入用户的输入</td>
<td>批量导入</td>
</tr>
<tr>
<td><em><strong>使用场景</strong></em></td>
<td>用户，Java EE项目</td>
<td>内部分析师，为决策提供支持</td>
</tr>
<tr>
<td><em><strong>数据表征</strong></em></td>
<td>最新数据状态</td>
<td>随时间变化的历史状态</td>
</tr>
<tr>
<td><em><strong>数据规模</strong></em></td>
<td>GB</td>
<td>TB到PB</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="关系建模"><a href="#关系建模" class="headerlink" title="关系建模"></a>关系建模</h4><ul>
<li>关系建模，严格遵循第三范式。表较为松散，零碎，物理表数量多，而数据冗余程度低。由于数据分布于众多的表中，这些数据可以更为灵活地被应用，功能性较强。</li>
</ul>
<h4 id="维度建模"><a href="#维度建模" class="headerlink" title="维度建模"></a>维度建模</h4><ul>
<li><p>维度模型主要应用在OLAP系统中，通常以某一个事实表为中心进行表的组织，主要面向业务。特征可能是存在数据的冗余，但是能方便得到数据。</p>
</li>
<li><p>关系模型虽然冗余少，但是在大规模数据，跨表分析统计查询过程中，会造成多表关联，这会大大降低执行效率。所以通常我们采用维度模型建模，把相关各种表整理成两种：事实表和维度表两种。</p>
</li>
<li><p>维度建模分成三种模型：</p>
<ul>
<li>星型模型<ul>
<li>标准的星型模型维度只有一层</li>
</ul>
</li>
<li>雪花模型<ul>
<li>比较靠近3NF，但是无法完全遵循，雪花模型的维度会设计多层。</li>
</ul>
</li>
<li>雪花模型和星型模型的主要区别在于维度的层级。</li>
<li>选择星型模型还是雪花模型，取决于性能优先还是灵活更优先。在实际开发中，不会绝对选择一种，会根据情况灵活组合甚至并存，但是从整体上看<font color=red>更倾向与维度更少的星型模型,尤其对于Hadoop 体系，减少join就是减少Shuffle，性能差距很大</font>.星型模型性能更高一些，减少了join过程。雪花模型维度表表设计多层，更加灵活,减少了数据冗余，时间换空间。</li>
<li><a href="https://imgtu.com/i/WzGEEd"><img src="https://z3.ax1x.com/2021/08/01/WzGEEd.png" alt="WzGEEd.png"></a></li>
<li>星座模型</li>
<li>星座模型与星型模型和雪花模型的区别是<font color=red>事实表的数量，星座模型是基于多个事实表。</font></li>
<li>星座模型基本上是很多数据仓库的常态，因为很多数据仓库都是多个事实表的，所以看是否为星座模型要看是否有多个事实表，他们之间是否共享一些维度表。</li>
<li><img src="C:\Users\Hasee\AppData\Roaming\Typora\typora-user-images\image-20210801175519654.png" alt="image-20210801175519654"></li>
</ul>
</li>
</ul>
<h3 id="维度表与事实表（重点）"><a href="#维度表与事实表（重点）" class="headerlink" title="维度表与事实表（重点）"></a>维度表与事实表（重点）</h3><h4 id="维度表"><a href="#维度表" class="headerlink" title="维度表"></a>维度表</h4><ul>
<li>维度表：一般是对事实的<font color=red>描述信息</font>。每一张维度表对应现实世界中的一个对象或者概念。例如：用户，商品，时间，地区等。就像是对事物描述的一个角度。</li>
<li>维度表的特征：<ul>
<li>维度表范围很宽（具有多个属性，列比较多）</li>
<li>与事实表相比，行数相对较小</li>
<li>内容相对固定：编码表，地区表</li>
</ul>
</li>
</ul>
<h4 id="事实表"><a href="#事实表" class="headerlink" title="事实表"></a>事实表</h4><ul>
<li><p>事实表中的每行数据代表一个业务事件（下单，支付，退款等），事实这个术语表示的是业务事件的<font color=red>度量值（可以统计次数，个数，金额等）</font></p>
</li>
<li><p>事实表的行包括：</p>
<ul>
<li>具有可加性的数值型的度量值</li>
<li>与维度表相连接的外键（通常具有两个和两个以上的外键，外键之间表示维度表之间多对多的关系）</li>
</ul>
</li>
<li><p>事实表的特征：</p>
<ul>
<li>非常大</li>
<li>列数较少</li>
<li>经常变化，每天会新增很多</li>
</ul>
</li>
<li><p>事实表分类：</p>
<ul>
<li>事务型事实表：以每个<font color=red>事务或事件为单位</font>，例如一个销售订单记录，一比支付数据，作为事实表里一行数据。<font color=red>一旦事务被提交，事实表数据被插入，数据就不再进行更改，其更新方式为增量更新</font></li>
<li>周期型快照事实表：周期型快照事实表中<font color=red>不会保留所有数据，只保留固定时间间隔的数据</font>，例如月销售，加购物车事实表，收藏事实表额等。</li>
<li>累积型快照事实表：<font color=red>累积型快照事实表用于跟踪业务事实的变化</font>。例如，数据仓库中可能需要累积或存储订单从下订单开始，到订单商品被打包、运输、和签收的各个业务阶段的时间点数据来跟踪订单声明周期的进展情况。当这个业务过程进行时，事实表的记录也要不断更新。</li>
</ul>
</li>
</ul>
<h3 id="数据仓库建模"><a href="#数据仓库建模" class="headerlink" title="数据仓库建模"></a>数据仓库建模</h3><h4 id="ODS层"><a href="#ODS层" class="headerlink" title="ODS层"></a>ODS层</h4><ul>
<li>保持数据原貌不做任何修改，起到数据备份的作用</li>
<li>数据进行压缩，减少磁盘存储空间</li>
<li>创建分区表（按照天进行分区），避免全表扫描</li>
</ul>
<h4 id="DWD层"><a href="#DWD层" class="headerlink" title="DWD层"></a>DWD层</h4><ul>
<li><p>DWD层采用维度建模，采用星型模型，有多个事实表，事实表之间共享一些维度表。构成星座模型</p>
</li>
<li><p>维度建模步骤：<font color=red>选择业务过程–&gt;声明粒度–&gt;确认维度–&gt;确认事实</font></p>
<ul>
<li>选择业务过程：一条业务线对应一张事实表。比如下单业务，支付业务，退款业务，物流业务，一条业务线对应一张事实表。</li>
<li>声明粒度：声明粒度指数据仓库中<font color=red>保存数据的细化程度或综合程度的级别。</font>声明粒度意味着精确定义事实表中的一行数据表示什么，应该尽可能选择最小粒度，以此来应对各种各样的需求。<ul>
<li>典型的粒度声明：<ul>
<li>订单中，每个商品项作为下单事实表中的一行</li>
<li>每周的订单次数作为一行，粒度就是每周下单</li>
<li>每月的订单次数作为一行，粒度就是每月下单</li>
</ul>
</li>
</ul>
</li>
<li>确定维度：维度的主要作用是描述业务事实。会将业务系统中的表进行一些合并，即维度退化。</li>
<li>确定事实：此处事实指业务中的度量值（事实表中数值型的度量值）。在DWD层中，以业务过程为建模驱动，基于每个具体以业务过程的特点，构建最细粒度的明细层事实表。</li>
</ul>
</li>
<li><p><a href="https://imgtu.com/i/fpvuSf"><img src="https://z3.ax1x.com/2021/08/02/fpvuSf.png" alt="fpvuSf.png"></a></p>
</li>
</ul>
<ul>
<li><table>
<thead>
<tr>
<th></th>
<th><em><strong>时间</strong></em></th>
<th><em><strong>用户</strong></em></th>
<th><em><strong>地区</strong></em></th>
<th><em><strong>商品</strong></em></th>
<th><em><strong>优惠券</strong></em></th>
<th><em><strong>活动</strong></em></th>
<th><em><strong>编码</strong></em></th>
<th><em><strong>度量值</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>订单</strong></em></td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td>件数/金额</td>
</tr>
<tr>
<td><em><strong>订单详情</strong></em></td>
<td>√</td>
<td></td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td>件数/金额</td>
</tr>
<tr>
<td><em><strong>支付</strong></em></td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>金额</td>
</tr>
<tr>
<td><em><strong>加购</strong></em></td>
<td>√</td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td>件数/金额</td>
</tr>
<tr>
<td><em><strong>收藏</strong></em></td>
<td>√</td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td>个数</td>
</tr>
<tr>
<td><em><strong>评价</strong></em></td>
<td>√</td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td>个数</td>
</tr>
<tr>
<td><em><strong>退款</strong></em></td>
<td>√</td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td>件数/金额</td>
</tr>
<tr>
<td><em><strong>优惠券领用</strong></em></td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td>个数</td>
</tr>
</tbody></table>
</li>
<li><p>至此，数仓的维度建模完成。DWS，DWT和ADS层和维度建模已经没有关系了。DWS和DWT都是建宽表，宽表(通常是指业务主题相关的指标、维度、属性关联在一起的一张数据库表。由于把不同的内容都放在同一张表存储，宽表已经不符合三范式的模型设计规范，随之带来的主要坏处就是数据的大量冗余，与之相对应的好处就是查询性能的提高与便捷。)都是按照主题去建。主题相当于观察问题得到角度。对应着维度表。</p>
</li>
</ul>
<h4 id="DWS层，DWT层"><a href="#DWS层，DWT层" class="headerlink" title="DWS层，DWT层"></a>DWS层，DWT层</h4><ul>
<li>DWS层统计各个主题对象的当天行为，服务于DWT层的主题宽表。<ul>
<li>每日设备行为</li>
<li>每日会员行为</li>
<li>每日商品行为</li>
<li>每日地区统计</li>
<li>每日活动统计</li>
</ul>
</li>
<li>DWT层：以分析的主题对象为建模驱动，基于上层的应用和产品的指标需求，构建主题对象的全量宽表。<ul>
<li>设备主题</li>
<li>用户主题</li>
<li>商品主题</li>
<li>地区主题</li>
<li>营销活动主题</li>
</ul>
</li>
</ul>
<h4 id="ADS"><a href="#ADS" class="headerlink" title="ADS"></a>ADS</h4><ul>
<li>对电商系统各大主题指标分别进行分析。</li>
</ul>
<h3 id="Hive环境准备"><a href="#Hive环境准备" class="headerlink" title="Hive环境准备"></a>Hive环境准备</h3><ul>
<li>安装配置Spark<ul>
<li>spark需要重新编译（spark本身就有hive依赖，不需要hive的相关依赖，防止与hive冲突）</li>
</ul>
</li>
<li>Hive on spark</li>
<li>配置多队列，yarn默认容量调度器且默认只有一个default队列，再配置一个hive队列。在capacity-scheduler.xml中进行配置。</li>
<li>set mapreduce.job.queuename=hive;</li>
</ul>
<h2 id="数仓搭建"><a href="#数仓搭建" class="headerlink" title="数仓搭建"></a>数仓搭建</h2><h3 id="ODS层-1"><a href="#ODS层-1" class="headerlink" title="ODS层"></a>ODS层</h3><ul>
<li>业务数据根据不同的数据同步策略，通过脚本将数据写入到ODS层。日志数据先按字符串处理，再到DWD层将数据解析出来。</li>
</ul>
<ul>
<li><p>保持数据源码不做修改，起到备份数据的作用，采用LZO压缩。</p>
</li>
<li><p>创建分区表，防止全表扫描</p>
</li>
<li><p>创建外部表</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">STORED</span> <span class="hljs-keyword">AS</span><br>  INPUTFORMAT <span class="hljs-string">&#x27;com.hadoop.mapred.DeprecatedLzoTextInputFormat&#x27;</span><br>  OUTPUTFORMAT <span class="hljs-string">&#x27;org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat&#x27;</span><br></code></pre></td></tr></table></figure></li>
<li><p>创建输入数据是LZO输出是text，支持json解析的分区表。采用LZO压缩的外部表</p>
</li>
</ul>
<h3 id="DWD层（重点）"><a href="#DWD层（重点）" class="headerlink" title="DWD层（重点）"></a>DWD层（重点）</h3><ul>
<li><p>列式压缩存储。有些表指定采用LZO压缩。优点：查询速度快，占用磁盘空间少（压缩比非常高）</p>
</li>
<li><p>采用列式存储后会有默认的压缩方式。</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><code class="hljs delphi">PARTITIONED BY (dt <span class="hljs-keyword">string</span>)<br><span class="hljs-keyword">stored</span> <span class="hljs-keyword">as</span> parquet<br>location <span class="hljs-string">&#x27;/warehouse/gmall/dwd/dwd_start_log/&#x27;</span><br>TBLPROPERTIES(<span class="hljs-string">&#x27;parquet.compression&#x27;</span>=<span class="hljs-string">&#x27;lzo&#x27;</span>);<br></code></pre></td></tr></table></figure></li>
<li><p>分区表，外部表</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><code class="hljs delphi">PARTITIONED BY (dt <span class="hljs-keyword">string</span>)<br><span class="hljs-keyword">stored</span> <span class="hljs-keyword">as</span> parquet<br>location <span class="hljs-string">&#x27;/warehouse/gmall/dwd/dwd_start_log/&#x27;</span><br>TBLPROPERTIES(<span class="hljs-string">&#x27;parquet.compression&#x27;</span>=<span class="hljs-string">&#x27;lzo&#x27;</span>);<br></code></pre></td></tr></table></figure></li>
<li><p>主要操作</p>
<ul>
<li>对用户行为数据进行解析，对核心数据进行判空过滤</li>
<li>维度建模（维度退化）</li>
</ul>
</li>
</ul>
<h4 id="日志数据"><a href="#日志数据" class="headerlink" title="日志数据"></a>日志数据</h4><ul>
<li>启动日志解析<ul>
<li>get_json_object函数使用，使用get_json_object函数将启动日志的字段解析出来</li>
</ul>
</li>
<li>事件日志解析<ul>
<li><p>先创建事件日志基础明细表</p>
</li>
<li><p><a href="https://imgtu.com/i/4oW8YR"><img src="https://z3.ax1x.com/2021/09/30/4oW8YR.png" alt="4oW8YR.png"></a></p>
</li>
<li><p>自定义UDF函数，解析公共字段(一进一出)</p>
<ul>
<li><p>定义类继承UDF，重写evaluate() 方法</p>
</li>
<li><p>UDF函数的返回值是什么evaluate()方法的返回值就是什么</p>
</li>
<li><p>函数的输入参数是什么evaluate()方法的参数就是什么</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zt.gmall.hive;<br><br><span class="hljs-keyword">import</span> org.apache.commons.lang.StringUtils;<br><span class="hljs-keyword">import</span> org.apache.hadoop.hive.ql.exec.UDF;<br><span class="hljs-keyword">import</span> org.json.JSONObject;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogUDF</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">UDF</span> </span>&#123;<br>    <span class="hljs-comment">//UDF函数的返回值与evaluate方法的返回值类型相同</span><br>    <span class="hljs-comment">//UDF函数的参数和evaluat方法的参数相同</span><br>    <span class="hljs-comment">//line指事件日志，key指需要的数据，</span><br>    <span class="hljs-comment">// 如果是&quot;st&quot;，返回servertime;</span><br>    <span class="hljs-comment">//如果是&quot;et&quot;,返回事件数组</span><br>    <span class="hljs-comment">//如果是公共字段的值,返回各个公共字段的值</span><br>    <span class="hljs-comment">//去除空数据</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">evaluate</span><span class="hljs-params">(String line, String key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (StringUtils.isBlank(line)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-comment">//split中的参数为一个正则表达式，</span><br>        <span class="hljs-comment">// 而|在正则表示中有含义需要\转义，</span><br>        <span class="hljs-comment">// 而\在java中也有特殊含义，所以又需要转义</span><br>        String[] split = line.split(<span class="hljs-string">&quot;\\|&quot;</span>);<br>        <span class="hljs-keyword">if</span> (split.length != <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        String serverTime = split[<span class="hljs-number">0</span>];<br>        String jsonStr = split[<span class="hljs-number">1</span>];<br>        JSONObject jsonObject = <span class="hljs-keyword">new</span> JSONObject(jsonStr);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;st&quot;</span>.equals(key))&#123;<br>            <span class="hljs-keyword">return</span> serverTime;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;et&quot;</span>.equals(key))&#123;<br>            <span class="hljs-keyword">if</span>(jsonObject.has(<span class="hljs-string">&quot;et&quot;</span>)) &#123;<br>                <span class="hljs-keyword">return</span> jsonObject.getString(<span class="hljs-string">&quot;et&quot;</span>);<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//获取到cm子JSON对象，公共字段解析</span><br>            JSONObject cm = jsonObject.getJSONObject(<span class="hljs-string">&quot;cm&quot;</span>);<br>            <span class="hljs-keyword">if</span>(cm.has(key))&#123;<br>                <span class="hljs-keyword">return</span> cm.getString(key);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>自定义UDTF函数解析具体事件（解析json数组）</p>
<ul>
<li><p>定义类继承抽象类GenericUDTF，实现initialize()（自定义输出的列名和类型）；process() （具体的处理，将结果返回forward(result)）；close()</p>
</li>
<li><p>输出事件名和事件json 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zt.gmall.hive;<br><br><span class="hljs-keyword">import</span> org.apache.hadoop.hive.ql.exec.UDFArgumentException;<br><span class="hljs-keyword">import</span> org.apache.hadoop.hive.ql.metadata.HiveException;<br><span class="hljs-keyword">import</span> org.apache.hadoop.hive.ql.udf.generic.GenericUDTF;<br><span class="hljs-keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;<br><span class="hljs-keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorFactory;<br><span class="hljs-keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.StructField;<br><span class="hljs-keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.StructObjectInspector;<br><span class="hljs-keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorFactory;<br><span class="hljs-keyword">import</span> org.json.JSONArray;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogUDTF</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GenericUDTF</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> HiveException </span>&#123;<br>    &#125;<br>    <span class="hljs-comment">//initialize方法可以校验传入参数类型是否合法</span><br>    <span class="hljs-comment">//ObjectInspector对象检查器  封装了数据类型（封装了输出类型）</span><br>    <span class="hljs-comment">//处理时间数组</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> StructObjectInspector <span class="hljs-title">initialize</span><span class="hljs-params">(StructObjectInspector argOIs)</span> <span class="hljs-keyword">throws</span> UDFArgumentException </span>&#123;<br>        List&lt;? extends StructField&gt; allStructFieldRefs = argOIs.getAllStructFieldRefs();<br>        <span class="hljs-comment">//入参的校验</span><br>        <span class="hljs-keyword">if</span>(allStructFieldRefs.size()!=<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UDFArgumentException(<span class="hljs-string">&quot;参数个数只能为1&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//这里返回的类型是hive的数据类型</span><br>        <span class="hljs-keyword">if</span>(!<span class="hljs-string">&quot;string&quot;</span>.equals(allStructFieldRefs.get(<span class="hljs-number">0</span>).getFieldObjectInspector().getTypeName()))&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UDFArgumentException(<span class="hljs-string">&quot;参数类型只能为string&quot;</span>);<br>        &#125;<br>        ArrayList&lt;String&gt; fieldNames = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        ArrayList&lt;ObjectInspector&gt; fieldOIs = <span class="hljs-keyword">new</span> ArrayList&lt;ObjectInspector&gt;();<br>        <span class="hljs-comment">//返回回去的两个列</span><br>        fieldNames.add(<span class="hljs-string">&quot;event_name&quot;</span>);<br>        fieldNames.add(<span class="hljs-string">&quot;event_json&quot;</span>);<br>        fieldOIs.add(PrimitiveObjectInspectorFactory.javaStringObjectInspector);<br>        fieldOIs.add(PrimitiveObjectInspectorFactory.javaStringObjectInspector);<br>        <span class="hljs-keyword">return</span> ObjectInspectorFactory.getStandardStructObjectInspector(fieldNames,<br>                fieldOIs);<br>    &#125;<br>    <span class="hljs-comment">//完成initialize方法后，将每一行交给process()方法，每一行经过处理变成多行，传递给forward()，forward将结果带出</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(Object[] args)</span> <span class="hljs-keyword">throws</span> HiveException </span>&#123;<br>        String eventArray = args[<span class="hljs-number">0</span>].toString();<br>        JSONArray jsonArray = <span class="hljs-keyword">new</span> JSONArray(eventArray);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;jsonArray.length() ; i++) &#123;<br>            String[] result=<span class="hljs-keyword">new</span> String[<span class="hljs-number">2</span>];<br>            result[<span class="hljs-number">0</span>]=jsonArray.getJSONObject(i).getString(<span class="hljs-string">&quot;en&quot;</span>);<br>            result[<span class="hljs-number">1</span>]=jsonArray.getString(i);<br>            forward(result);<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>把jar包打包上传到HDFS上的user/hive/jars路径下，创建永久函数与开发好的Java class关联</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">function</span> base_analizer <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;com.zt.udf.BaseFieldUDF&#x27;</span> <span class="hljs-keyword">using</span> jar <span class="hljs-string">&#x27;hdfs://hadoop100:9000/user/hive/jars/hivefunction-1.0-SNAPSHOT.jar&#x27;</span>;<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">function</span> flat_analizer <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;com.zt.udtf.EventJsonUDTF&#x27;</span> <span class="hljs-keyword">using</span> jar <span class="hljs-string">&#x27;hdfs://hadoop100:9000/user/hive/jars/hivefunction-1.0-SNAPSHOT.jar&#x27;</span>; <br></code></pre></td></tr></table></figure></li>
<li><p>通过处理得到事件解析日志基础表，再在事件日志解析基础表的基础上，创建具体的事件日志表。用get_json_object获取数据。</p>
</li>
</ul>
</li>
</ul>
<h4 id="业务数据"><a href="#业务数据" class="headerlink" title="业务数据"></a>业务数据</h4><ul>
<li><p>事实表分类</p>
<ul>
<li><p>事实表也可以做适当的宽表化处理。</p>
</li>
<li><p>事务型事实表（增量同步）</p>
<ul>
<li>订单详情事实表<ul>
<li>以订单业务作为具体的业务过程（订单详情表与订单表（提供省份ID字段）连接），与<font color=red>时间，地区，商品</font>维度表相关联。以<font color=red>商品数量，商品金额</font>作为度量值。</li>
</ul>
</li>
<li>支付事实表<ul>
<li>以支付业务为具体的业务过程（支付流水表与订单表（提供省份ID字段）连接），与<font color=red>时间，地区</font>维度表关联，以<font color=red>支付金额</font>作为度量值。</li>
</ul>
</li>
<li>退款事实表<ul>
<li>以退款业务为具体的业务过程（退款表），与<font color=red>时间，用户，商品</font>维度表关联，以<font color=red>退款数量，退款金额</font>作为度量值。</li>
</ul>
</li>
<li>评价事实表<ul>
<li>以评价业务为具体的业务过程（商品评论表），与<font color=red>时间，用户，商品</font>维度表关联，以<font color=red>数量</font>作为度量值</li>
</ul>
</li>
<li>只会新增，不会修改</li>
</ul>
</li>
<li><p>周期型快照事实表（全量同步）</p>
<ul>
<li><p>周期型快照事实表的劣势：存储的数据量会比较大。解决办法：周期型快照事实表存储的数据比较讲究时效性，时间太久了的意义不大，可以删除以前的数据。</p>
</li>
<li><p>加购事实表</p>
<ul>
<li>由于购物车的数量会发生变化，不适合导入增量。每天做一次快照，全量导入</li>
<li>以加购物车为具体的业务过程（商品加购物车表），与<font color=red>时间，用户，商品</font>维度表关联，以<font color=red>数量，金额</font>作为度量值，。</li>
</ul>
</li>
<li><p>收藏事实表</p>
<ul>
<li>以收藏为具体业务过程（商品收藏表），与<font color=red>时间，用户，商品</font>维度表关联。以<font color=red>数量</font>作为度量值。</li>
</ul>
</li>
<li><p>数据周期性变化，可能增加，也可能删除（但是并不关心变化的过程，只关心周期性的一个数据结果）。所以选择全量同步。</p>
</li>
</ul>
</li>
<li><p>累积型快照事实表（新增及变化同步）</p>
<ul>
<li>优惠卷领用事实表<ul>
<li>优惠卷的生命周期：领取优惠卷–&gt;使用优惠卷下单–&gt;优惠卷参与支付</li>
<li>累积型快照事实表的使用：统计优惠卷领取次数，优惠卷下单次数，优惠卷参与支付次数。</li>
<li>以优惠卷为具体业务过程，与<font color=red>时间，用户，优惠卷</font>维度表关联，以<font color=red>数量</font>为度量值。</li>
</ul>
</li>
<li>订单事实表<ul>
<li>订单生命周期：创建时间–&gt;支付时间–&gt;取消时间–&gt;完成时间–&gt;退款时间–&gt;退款完成时间</li>
<li>以订单业务为具体的业务过程，与<font color=red>时间，用户，地区，活动</font>维度表关联，以<font color=red>数量，金额</font>为度量值。</li>
</ul>
</li>
<li>数据是会累积的，适用于随时间变化的。适用于周期性的业务。比如优惠卷领取时间，使用时间（下单），使用时间（支付）。如订单事实表中的创建时间，支付时间，取消时间，完成时间，退款时间，退款完成时间。</li>
</ul>
</li>
</ul>
</li>
<li><p>维度表</p>
<ul>
<li>全量同步<ul>
<li>商品维度表<ul>
<li>维度退化：以SKU表为主体，与商品三级，二级，一级分类表和SPU表，品牌表连接选择相应字段加入SKU表中，形成商品维度表</li>
</ul>
</li>
<li>优惠卷维度表<ul>
<li>以优惠卷表为主体建立优惠卷维度表</li>
</ul>
</li>
<li>活动维度表<ul>
<li>维度退化：以活动表为主体，与活动规则表连接选择相应字段建立活动维度表。</li>
</ul>
</li>
</ul>
</li>
<li>特殊同步（导一次）<ul>
<li>地区维度表<ul>
<li>一般不会更改，将数据一次导入</li>
<li>维度退化：将省份表和地区表合并作为地区维度表</li>
</ul>
</li>
<li>时间维度表<ul>
<li>可以设计将时间数据一次性导入（将很多年的时间都导入，后续就不用再导表了）</li>
</ul>
</li>
</ul>
</li>
<li>拉链表<ul>
<li>用户维度表<ul>
<li>以用户表为主体，<font color= red>最好有”有效开始日期“，”有效结束日期”</font>,拉链表根据这两个日期判断更新，用户最新状态等信息。</li>
</ul>
</li>
<li>用户表中的数据每日既有可能新增，也有可能修改，但修改频率并不高，属于缓慢变化维度，此处采用拉链表存储用户维度数据。</li>
<li>拉链表，记录每条信息的生命周期，一旦一条记录的生命周期结束，就重新开始一条新的记录，并把当前日期放入生效开始日期，结束日期设为最大值，再将上一条修改的结束日期改为当前日期-1。</li>
<li>拉链表适合于数据会发生变化，但是大部分是不变的。（即缓慢变化）</li>
<li>拉链表的更新：用户<strong>当天</strong>全部数据和MySQL中每天变化的数据拼接在一起，然后insert overwrite回旧的拉链表。insert overwrite会形成一个临时的拉链表。用临时的拉链表覆盖旧的拉链表数据。</li>
<li><a href="https://imgtu.com/i/4TkIpj"><img src="https://z3.ax1x.com/2021/09/30/4TkIpj.png" alt="4TkIpj.png"></a></li>
</ul>
</li>
</ul>
</li>
<li><p><a href="https://imgtu.com/i/fpvuSf"><img src="https://z3.ax1x.com/2021/08/02/fpvuSf.png" alt="fpvuSf.png"></a></p>
</li>
</ul>
<h3 id="DWS层"><a href="#DWS层" class="headerlink" title="DWS层"></a>DWS层</h3><ul>
<li>列式存储</li>
<li>宽表：字面意思就是说字段比较多的数据库表，通常是指业务主题的指标，维度，属性关联在一起的一张数据库表。由于把不同的内容都放在同一张表存储，宽表已经不符合三范式的模式设计规范，随之带来的坏处就是大量冗余，与之相应的好处就是查询性能的提高与便捷。</li>
<li>DWS层的宽表字段，是站在不同维度的视角去看事实表。重点关注事实表的度量值。</li>
<li>业务<ul>
<li>每日会员行为</li>
<li>每日商品行为</li>
<li>每日活动统计</li>
<li>每日地区统计</li>
</ul>
</li>
<li>用户行为<ul>
<li>每日设备行为</li>
</ul>
</li>
</ul>
<h3 id="DWT层"><a href="#DWT层" class="headerlink" title="DWT层"></a>DWT层</h3><ul>
<li>列式存储</li>
</ul>
<ul>
<li>设备主题宽表</li>
<li>会员主题宽表</li>
<li>商品主题宽表</li>
<li>活动主题宽表</li>
<li>地区主题宽表</li>
</ul>
<h3 id="ADS层"><a href="#ADS层" class="headerlink" title="ADS层"></a>ADS层</h3><ul>
<li>对电商系统各大主题指标分别进行分析。</li>
<li>设备主题：<ul>
<li>活跃设备数（日，周，月）</li>
<li>每日新增设备</li>
<li>流失用户数</li>
<li>留存率</li>
<li>最近连续三周活跃用户数</li>
<li>最近七天内连续三天活跃用户数</li>
</ul>
</li>
<li>会员主题<ul>
<li>会员主题信息</li>
</ul>
</li>
<li>商品主题<ul>
<li>商品销量排行</li>
<li>商品差评率</li>
<li>商品退款率排名（最近30天）</li>
</ul>
</li>
<li>营销主题（活动主题）<ul>
<li>下单数目统计</li>
<li>支付信息统计</li>
</ul>
</li>
<li>地区主题<ul>
<li>地区主题信息</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>项目</category>
        <category>离线数仓搭建</category>
      </categories>
      <tags>
        <tag>数据仓库</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop重要知识点</title>
    <url>/2021/05/26/Hadoop/</url>
    <content><![CDATA[<h1 id="Hadoop重要知识点理解"><a href="#Hadoop重要知识点理解" class="headerlink" title="Hadoop重要知识点理解"></a>Hadoop重要知识点理解</h1><h2 id="Hadoop核心组件"><a href="#Hadoop核心组件" class="headerlink" title="Hadoop核心组件"></a>Hadoop核心组件</h2><ul>
<li><p>MapReduce（计算框架）</p>
</li>
<li><p>yarn （资源调度）</p>
</li>
<li><p>HDFS（hadoop的分布式文件系统，主要用于数据存储）</p>
</li>
<li><p>Common(辅助工具，包含一些依赖，jar包)</p>
</li>
<li><p>常用端口号</p>
<p>分类                             应用                                   端口<br>namenode                rpc-address                    8020<br>namenode                http-address                  9870<br>namenode                https-address                9871<br>datanode                  address                           9866<br>datanode                  http-address                  9864<br>datanode                   https-address               9865<br>resourcemanager    http-address                 8088</p>
</li>
</ul>
<h2 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h2><ul>
<li><p>定义</p>
<ul>
<li>HDFS（Hadoop Distributed File System）是一个分布式文件系统</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>高容错性:多副本机制</li>
<li>适合处理大数据，可构建在廉价机器上</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>不适合低延时数据访问</li>
<li>无法高效的对大量小文件进行存储</li>
<li>只支持数据的追加，不支持文件的随机修改</li>
<li>一个文件只能有一个写，不允许多个线程同时写</li>
</ul>
</li>
<li><p>HDFS组成架构</p>
<ul>
<li><a href="https://imgtu.com/i/g2T94P"><img src="https://z3.ax1x.com/2021/05/17/g2T94P.png" alt="g2T94P.png"></a></li>
</ul>
</li>
</ul>
<h3 id="HDFS文件块大小"><a href="#HDFS文件块大小" class="headerlink" title="HDFS文件块大小"></a>HDFS文件块大小</h3><ul>
<li>hdfs中的文件在物理上是分块（BLOCK) 存储的</li>
<li>问题：为什么块大小不能设置太大，也不能设置太小？<ul>
<li>设置太大：增加数据的传输时间。从磁盘传输数据的时间会明显大于定位这个块开始位置所用的时间。导致程序处理这块数据时非常慢。</li>
<li>设置太小：分块太多，查找第一个块时会消耗大量时间。寻址时间增加。造成元数据增多，而元数据存储在namenode中，会消耗更多的namenode内存。</li>
</ul>
</li>
</ul>
<h2 id="HDFS的Shell操作"><a href="#HDFS的Shell操作" class="headerlink" title="HDFS的Shell操作"></a>HDFS的Shell操作</h2><ul>
<li>hadoop fs + (-命令)</li>
<li>hdfs dfs + (-命令)</li>
<li>dfs是fs的实现类</li>
</ul>
<ul>
<li><p>Hadoop fs 命令分类</p>
</li>
<li><p>本地-&gt;HDFS</p>
<pre><code>put #上传文件到HDFS
copyFromLocal#与put相似，支持多线程
moveFromLocal将本地文件移动到HDFS上
appendToFile#追加文件信息,只能追加本地文件信息
</code></pre>
</li>
<li><p>HDFS-&gt;HDFS(命令与linux类似)</p>
<p>​    cp<br>​    mv<br>​    chown<br>​    chgrp<br>​    chmod<br>​    mkdir<br>​    du<br>​    df<br>​    cat<br>​    rm</p>
</li>
<li><p>HDFS-&gt;本地</p>
<pre><code>get#从HDFS上下载文件到本地
getmerge#合并下载，符合条件的全部下载到本地
copyToLocal#与get完全一样
</code></pre>
</li>
</ul>
<h2 id="HDFS的API操作"><a href="#HDFS的API操作" class="headerlink" title="HDFS的API操作"></a>HDFS的API操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testCopyFromLocalFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException, URISyntaxException </span>&#123;<br><br>		<span class="hljs-comment">// 1 获取文件系统</span><br>		Configuration configuration = <span class="hljs-keyword">new</span> Configuration();<br>		configuration.set(<span class="hljs-string">&quot;dfs.replication&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>);<br>		FileSystem fs = FileSystem.get(<span class="hljs-keyword">new</span> URI(<span class="hljs-string">&quot;hdfs://hadoop100:8020&quot;</span>), configuration, <span class="hljs-string">&quot;zt&quot;</span>);<br><br>		<span class="hljs-comment">// 2 上传文件</span><br>		fs.copyFromLocalFile(<span class="hljs-keyword">new</span> Path(<span class="hljs-string">&quot;e:/banzhang.txt&quot;</span>), <span class="hljs-keyword">new</span> Path(<span class="hljs-string">&quot;/banzhang.txt&quot;</span>));<br><br>		<span class="hljs-comment">// 3 关闭资源</span><br>		fs.close();<br><br>		System.out.println(<span class="hljs-string">&quot;over&quot;</span>);<br></code></pre></td></tr></table></figure>

<h2 id="HDFS的数据读写流程"><a href="#HDFS的数据读写流程" class="headerlink" title="HDFS的数据读写流程"></a>HDFS的数据读写流程</h2><ul>
<li><p>HDFS写数据流程</p>
<p><a href="https://imgtu.com/i/gWkJxS"><img src="https://z3.ax1x.com/2021/05/17/gWkJxS.md.png" alt="gWkJxS.md.png"></a></p>
</li>
</ul>
<ul>
<li>步骤：<ol>
<li>客户端通过DistributedFileSystem模块向NameNode请求上传文件，NameNode检查目标文件是否已经存在，父目录是否存在。</li>
<li>NameNode返回是否可以上传的一个响应。</li>
<li>客户端向NameNode请求第一个BLock应该上传到那几个DataNode节点上</li>
<li>NameNode返回副本个数个DataNode节点，例如dn1,dn2,dn3</li>
<li>客户端通过FSDataOutputStream模块请求建立Block传输通道</li>
<li>dn1,dn2,dn3，等副本逐级应答客户端</li>
<li>应答成功后，开始传输数据（以Packet（一般为64kb）的形式），dn1收到一个Packet就会传给dn2,dn2传给dn3。dn1每传一个Packet会放入一个应答队列等待应答</li>
<li>第一个Block上传完成后，客户端再请求NameNode上传第二个Block的服务器。</li>
</ol>
</li>
</ul>
<ul>
<li><p>DataNode的选择</p>
<ul>
<li>每一块数据存到哪些DataNode节点上，NameNode会进行选择。</li>
<li>在HDFS写数据的过程中，NameNode会选择距离待上传数据最近距离的DataNode接收数据。</li>
<li>HDFS会通过机架感知技术，得到网络拓扑图，根据网络拓扑图选择最近的节点</li>
<li>那其他的副本是怎样选择的呢？：1.第一个副本再Client所处的节点上（自己距离自己最近），如果客户端在集群外面，随机选择一个。2.第二个副本和第一个副本位于相同机架上，随即节点。3.第三个副本位于不同机架，随机节点。</li>
</ul>
</li>
<li><p>HDFS读数据流程</p>
<p> <a href="https://imgtu.com/i/gWpZv9"><img src="https://z3.ax1x.com/2021/05/17/gWpZv9.md.png" alt="gWpZv9.md.png"></a></p>
</li>
</ul>
<ul>
<li>步骤：<ul>
<li>客户端通过Distributed FileSystem向NameNode请求下载文件，NameNode通过查询元数据，找到文件块所在的DataNode地址。</li>
<li>挑选一台DataNode（就近原则，然后随机）服务器，请求读取数据</li>
<li>DataNode开始传输数据给客户端（从磁盘里面读取数据输入流，以Packet为单位来做校验）。</li>
<li>客户端以Packet为单位接收，先在本地缓存，然后写入目标文件。</li>
</ul>
</li>
</ul>
<h2 id="NameNode和SecondaryNameNode"><a href="#NameNode和SecondaryNameNode" class="headerlink" title="NameNode和SecondaryNameNode"></a>NameNode和SecondaryNameNode</h2><ul>
<li><p>namenode中一个元数据占150个字节的空间。</p>
</li>
<li><p>思考：NameNode中的元数据是存储在哪里的？</p>
<p>首先，我们做个假设，如果存储在NameNode节点的磁盘中，因为经常需要进行随机访问，还有响应客户请求，必然是效率过低。因此，元数据需要存放在内存中。但如果只存在内存中，一旦断电，元数据丢失，整个集群就无法工作了。因此产生在磁盘中备份元数据的FsImage。</p>
<p>这样又会带来新的问题，当在内存中的元数据更新时，如果同时更新FsImage，就会导致效率过低，但如果不更新，就会发生一致性问题，一旦NameNode节点断电，就会产生数据丢失。因此，引入Edits文件(只进行追加操作，效率很高)。每当元数据有更新或者添加元数据时，修改内存中的元数据并追加到Edits中。这样，一旦NameNode节点断电，可以通过FsImage和Edits的合并，合成元数据。</p>
<p>但是，如果长时间添加数据到Edits中，会导致该文件数据过大，效率降低，而且一旦断电，恢复元数据需要的时间过长。因此，需要定期进行FsImage和Edits的合并，如果这个操作由NameNode节点完成，又会效率过低。因此，引入一个新的节点SecondaryNamenode，专门用于FsImage和Edits的合并。</p>
</li>
<li><p>工作机制</p>
<p><a href="https://imgtu.com/i/gW92Se"><img src="https://z3.ax1x.com/2021/05/17/gW92Se.md.png" alt="gW92Se.md.png"></a></p>
</li>
<li><p>具体步骤：</p>
<ul>
<li>第一阶段：NameNode<ul>
<li>第一次启动NameNode，格式化后，创建Fsimage和Edits文件。如果不是第一次启动，直接加载日志文件和镜像文件到内存中去</li>
<li>客户端对元数据的增删改请求</li>
<li>NameNode记录操作日志到Edits文件，更新滚动日志（当这一份日志已满，或者定时时间到了，重新创建一份新的日志文件（增删改记录写在新文件中），将旧的日志文件写到SecondaryNameNode中去）。</li>
<li>NameNode在内存中进行增删改操作</li>
</ul>
</li>
<li>第二阶段：SecondaryNameNode<ul>
<li>2nn询问nn是否需要CheckPoint，直接带回返回结果</li>
<li>请求执行CheckPoint（触发条件：1.2nn每隔一小时执行一次。2.当操作次数达到1百万时）</li>
<li>nn滚动正在写的Edits日志</li>
<li>将滚动前的日志文件和镜像文件拷贝到SecondaryNameNode中</li>
<li>2nn将从nn拷贝过来的日志文件和镜像文件在内存中合并</li>
<li>生成新的镜像文件fsimage.chkpoint</li>
<li>将新生成的镜像文件fsimage.chkpoint写到NameNode中</li>
<li>NameNode将fsimage.chkpoint重新命名成fsimage。</li>
</ul>
</li>
</ul>
</li>
<li><p>集群安全模式</p>
</li>
<li><p>集群在安全模式下，不能执行写操作，读操作会被延迟</p>
</li>
<li><p>在集群刚刚启动，或者集群的存储快要到达上限时会进入集群安全模式。</p>
</li>
<li><p>HDFS架构-联邦架构</p>
<ul>
<li><img src="C:\Users\Hasee\AppData\Roaming\Typora\typora-user-images\image-20211220153640114.png" alt="image-20211220153640114"></li>
<li>解决namenode的压力过大的问题。</li>
</ul>
</li>
</ul>
<h2 id="DataNode"><a href="#DataNode" class="headerlink" title="DataNode"></a>DataNode</h2><ul>
<li><p>DataNode工作机制</p>
<p><a href="https://imgtu.com/i/gWkiU1"><img src="https://z3.ax1x.com/2021/05/17/gWkiU1.md.png" alt="gWkiU1.md.png"></a></p>
</li>
</ul>
<ul>
<li>一个数据块在DataNode上以文件形式存储在磁盘上，包括两个文件，一个是数据本身，一个是元数据包括数据块的长度，块数据的校验和（保证数据完整性），以及时间戳。</li>
<li>DataNode启动后向NameNode注册，通过后，周期性（1小时）的向NameNode上报所有的块信息。</li>
<li>心跳是每3秒一次，心跳返回结果带有NameNode给该DataNode的命令如复制块数据到另一台机器，或删除某个数据块。如果超过10分钟没有收到某个DataNode的心跳，则认为该节点不可用。</li>
<li>集群运行中可以安全加入和退出一些机器。（通过配置黑白名单）<ul>
<li>添加到白名单的主机节点，都允许访问NameNode，不在白名单的主机节点，都会被退出。</li>
<li>在黑名单上面的主机都会被强制退出。（进入黑名单那后状态变为不可用10分钟+30s 后退役）</li>
<li>不允许白名单和黑名单中同时出现同一个主机名称</li>
</ul>
</li>
</ul>
<h2 id="MapReduce概述"><a href="#MapReduce概述" class="headerlink" title="MapReduce概述"></a>MapReduce概述</h2><ul>
<li><p>MapReduce是一个分布式运算程序的编程框架，是用户开发“基于Hadoop的数据分析应用”的核心框架。</p>
<p>MapReduce核心功能是将用户编写的业务逻辑代码和自带默认组件整合成一个完整的分布式运算程序，并发运行在一个Hadoop集群上。</p>
</li>
<li><p>一个完整的MapReduce程序在分布式运行时有三类实例进程：</p>
<p>（1）<strong>MrAppMaster</strong>：负责整个程序的过程调度及状态协调。</p>
<p>（2）<strong>MapTask</strong>：负责Map阶段的整个数据处理流程。</p>
<p>（3）<strong>ReduceTask</strong>：负责Reduce阶段的整个数据处理流程。</p>
</li>
<li><p>WC实例：</p>
<p>Mapper代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zt3019.wordcount;<br><br><span class="hljs-keyword">import</span> org.apache.hadoop.io.IntWritable;<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.LongWritable;<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.Text;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.Mapper;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">//（输入类型：框架会将数据分成一行一行的，LongWritable表示这一行的第一个字符的索引,Text表示这一行内容）KEYIN,VALUEIN,(输出类型：单词，1)KEYOUT,VALUEOUT</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WordCountMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mapper</span>&lt;<span class="hljs-title">LongWritable</span>,<span class="hljs-title">Text</span>,<span class="hljs-title">Text</span>, <span class="hljs-title">IntWritable</span>&gt; </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 框架将数据拆成一行一行输入进来，我们把数据变成（单词，1）的形式</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 行号</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 行内容</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> context 任务本身</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> InterruptedException</span><br><span class="hljs-comment">     */</span><br>    Text word=<span class="hljs-keyword">new</span> Text();<br>    IntWritable one=<span class="hljs-keyword">new</span> IntWritable(<span class="hljs-number">1</span>);<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">map</span><span class="hljs-params">(LongWritable key, Text value, Context context)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;<br>        <span class="hljs-comment">//拿到一行数据</span><br>        String line=value.toString();<br>        <span class="hljs-comment">//将一行拆成很多单词</span><br>        String[] words = line.split(<span class="hljs-string">&quot; &quot;</span>);<br><br>        <span class="hljs-comment">//将（单词，1）写回框架</span><br>        <span class="hljs-keyword">for</span> (String word : words) &#123;<br>            <span class="hljs-keyword">this</span>.word.set(word);<br>            context.write(<span class="hljs-keyword">this</span>.word,<span class="hljs-keyword">this</span>.one);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
<li><p>Redecer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zt3019.wordcount;<br><br><span class="hljs-keyword">import</span> org.apache.hadoop.io.IntWritable;<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.Text;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.Reducer;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">//输入为map的输出，输出为（单词，单词出现的次数）</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WordCountReducer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Reducer</span>&lt;<span class="hljs-title">Text</span>, <span class="hljs-title">IntWritable</span>,<span class="hljs-title">Text</span>,<span class="hljs-title">IntWritable</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;<br>    IntWritable value=<span class="hljs-keyword">new</span> IntWritable();<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 框架把数据按照单词分好组输入给我们，我们将同一个单词的次数相加</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 单词</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> values 这个单词所有的1</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> context 任务本身</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> InterruptedException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reduce</span><span class="hljs-params">(Text key, Iterable&lt;IntWritable&gt; values, Context context)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;<br>        <span class="hljs-comment">//累加单词出现的次数</span><br>        <span class="hljs-keyword">for</span> (IntWritable value : values) &#123;<br>            sum+=value.get();<br>        &#125;<br>        <span class="hljs-comment">//封装结果</span><br>        value.set(sum);<br>        <span class="hljs-comment">//将结果写回框架</span><br>        context.write(key,value);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
<li><p>Driver(本地集群模式)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zt3019.wordcount;<br><br><span class="hljs-keyword">import</span> org.apache.hadoop.conf.Configuration;<br><span class="hljs-keyword">import</span> org.apache.hadoop.fs.Path;<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.IntWritable;<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.Text;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.Job;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WordCountDriver</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException, InterruptedException </span>&#123;<br>        Configuration configuration = <span class="hljs-keyword">new</span> Configuration();<br>        <span class="hljs-comment">//配置yarn集群运行</span><br>        <span class="hljs-comment">//core-site.xml配置文件</span><br>        configuration.set(<span class="hljs-string">&quot;fs.defaultFS&quot;</span>, <span class="hljs-string">&quot;hdfs://hadoop100:8020&quot;</span>);<br>        <span class="hljs-comment">//MapRedece-site.xml配置文件</span><br>        configuration.set(<span class="hljs-string">&quot;mapreduce.framework.name&quot;</span>,<span class="hljs-string">&quot;yarn&quot;</span>);<br>        <span class="hljs-comment">//是否允许向linux提交任务</span><br>        configuration.set(<span class="hljs-string">&quot;mapreduce.app-submission.cross-platform&quot;</span>,<span class="hljs-string">&quot;true&quot;</span>);<br>        configuration.set(<span class="hljs-string">&quot;yarn.resourcemanager.hostname&quot;</span>,<span class="hljs-string">&quot;hadoop102&quot;</span>);<br>        <span class="hljs-comment">//1.获取job实例</span><br>        Job job= Job.getInstance(configuration);<br>        <span class="hljs-comment">//2.设置jar包</span><br>        job.setJarByClass(WordCountDriver.class);<br>        <span class="hljs-comment">//3.设置Mapper和Reducer</span><br>        job.setMapperClass(WordCountMapper.class);<br>        job.setReducerClass(WordCountReducer.class);<br>        <span class="hljs-comment">//4.设置Map和Reduce的输出类型</span><br>        <span class="hljs-comment">//设置Map的输出类型</span><br>        job.setMapOutputKeyClass(Text.class);<br>        job.setMapOutputValueClass(IntWritable.class);<br>        <span class="hljs-comment">//设置Reduce的输出类型</span><br>        job.setOutputKeyClass(Text.class);<br>        job.setOutputValueClass(IntWritable.class);<br>        <span class="hljs-comment">//5.设置输入输出文件</span><br>        FileInputFormat.setInputPaths(job,<span class="hljs-keyword">new</span> Path(args[<span class="hljs-number">0</span>]));<br>        FileOutputFormat.setOutputPath(job,<span class="hljs-keyword">new</span> Path(args[<span class="hljs-number">1</span>]));<br>        <span class="hljs-comment">//6.提交job</span><br>        <span class="hljs-comment">//提交任务得到运行结果，成功或者失败</span><br>        <span class="hljs-comment">//提交流程都在这个方法中，一些job的配置都可以在上面设置。</span><br>        <span class="hljs-keyword">boolean</span> b = job.waitForCompletion(<span class="hljs-keyword">true</span>);<br>        System.exit(b ? <span class="hljs-number">0</span>:<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
<li><p>提交到集群上运行，先maven打包，</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">yarn jar 包名 主类引用(reference) args[<span class="hljs-string">0</span>](<span class="hljs-link">输入路径</span>) args[<span class="hljs-string">1</span>](<span class="hljs-link">s</span>)<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="Hadoop压缩"><a href="#Hadoop压缩" class="headerlink" title="Hadoop压缩"></a>Hadoop压缩</h3><ul>
<li><table>
<thead>
<tr>
<th>压缩格式</th>
<th>hadoop自带？</th>
<th>算法</th>
<th>文件扩展名</th>
<th>是否可切分</th>
<th>换成压缩格式后，原来的程序是否需要修改</th>
</tr>
</thead>
<tbody><tr>
<td>DEFLATE</td>
<td>是，直接使用</td>
<td>DEFLATE</td>
<td>.deflate</td>
<td>否</td>
<td>和文本处理一样，不需要修改</td>
</tr>
<tr>
<td>Gzip</td>
<td>是，直接使用</td>
<td>DEFLATE</td>
<td>.gz</td>
<td>否</td>
<td>和文本处理一样，不需要修改</td>
</tr>
<tr>
<td>bzip2</td>
<td>是，直接使用</td>
<td>bzip2</td>
<td>.bz2</td>
<td>是</td>
<td>和文本处理一样，不需要修改</td>
</tr>
<tr>
<td>LZO</td>
<td>否，需要安装</td>
<td>LZO</td>
<td>.lzo</td>
<td>是</td>
<td>需要建索引，还需要指定输入格式</td>
</tr>
<tr>
<td>Snappy</td>
<td>否，需要安装</td>
<td>Snappy</td>
<td>.snappy</td>
<td>否</td>
<td>和文本处理一样，不需要修改</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="Hadoop序列化"><a href="#Hadoop序列化" class="headerlink" title="Hadoop序列化"></a>Hadoop序列化</h3><ul>
<li><p>序列化就是把内存中的对象，转换成字节序列（或其它数据传输协议）以便于存储到磁盘（持久化）和网络传输。</p>
</li>
<li><p>反序列化就是将收到的字节序列（或其它数据传输协议）或者是磁盘中持久化的数据，转换成内存中的对象。</p>
</li>
<li><p>为什么要序列化：一般来说，“活的”对象只存储在内存中，关机断电就没有了，而且“活的”对象只能由本地进程使用，不能被发送到网络上的另外一台计算机。而序列化可以存储“活的”对象，可以将“活的”对象发送到远程计算机。</p>
</li>
<li><p>自定义的数据类型要实现Writable接口实现序列化，反序列功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zt3019.flow;<br><br><span class="hljs-keyword">import</span> org.apache.hadoop.io.Writable;<br><br><span class="hljs-keyword">import</span> java.io.DataInput;<br><span class="hljs-keyword">import</span> java.io.DataOutput;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlowBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Writable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> upFlow;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> downFlow;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> sumFlow;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">long</span> upFlow,<span class="hljs-keyword">long</span> downFlow)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.upFlow=upFlow;<br>        <span class="hljs-keyword">this</span>.downFlow=downFlow;<br>        <span class="hljs-keyword">this</span>.sumFlow=upFlow+downFlow;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;FlowBean&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;upFlow=&quot;</span> + upFlow +<br>                <span class="hljs-string">&quot;, downFlow=&quot;</span> + downFlow +<br>                <span class="hljs-string">&quot;, sumFlow=&quot;</span> + sumFlow +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUpFlow</span><span class="hljs-params">(<span class="hljs-keyword">long</span> upFlow)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.upFlow = upFlow;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDownFlow</span><span class="hljs-params">(<span class="hljs-keyword">long</span> downFlow)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.downFlow = downFlow;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSumFlow</span><span class="hljs-params">(<span class="hljs-keyword">long</span> sumFlow)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.sumFlow = sumFlow;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getDownFlow</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> downFlow;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getSumFlow</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> sumFlow;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getUpFlow</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> upFlow;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 序列化</span><br><span class="hljs-comment">     * 将对象数据写出到框架指定的地方</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dataOutput 数据的容器</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(DataOutput dataOutput)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        dataOutput.writeLong(upFlow);<br>        dataOutput.writeLong(downFlow);<br>        dataOutput.writeLong(sumFlow);<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 反序列化</span><br><span class="hljs-comment">     *从框架指定地方读取数填充对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dataInput 数据的容器</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readFields</span><span class="hljs-params">(DataInput dataInput)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">this</span>.upFlow=dataInput.readLong();<br>        <span class="hljs-keyword">this</span>.downFlow=dataInput.readLong();<br>        <span class="hljs-keyword">this</span>.sumFlow=dataInput.readLong();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="MapReduce框架原理"><a href="#MapReduce框架原理" class="headerlink" title="MapReduce框架原理"></a>MapReduce框架原理</h2><h3 id="MapReduce的数据流"><a href="#MapReduce的数据流" class="headerlink" title="MapReduce的数据流"></a>MapReduce的数据流</h3><p><a href="https://imgtu.com/i/g72oxx"><img src="https://z3.ax1x.com/2021/05/21/g72oxx.md.png" alt="g72oxx.md.png"></a></p>
<h3 id="InputFormat"><a href="#InputFormat" class="headerlink" title="InputFormat"></a>InputFormat</h3><ul>
<li><p>InputFormat实现数据变成K,V值</p>
</li>
<li><p>数据切片与MapTask并行度决定机制</p>
</li>
</ul>
<p><a href="https://imgtu.com/i/gHPDHK"><img src="https://z3.ax1x.com/2021/05/21/gHPDHK.md.png" alt="gHPDHK.md.png"></a></p>
<ul>
<li></li>
<li><p>job提交流程源码重要流程（客户端向集群提交的作业）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">waitForCompletion()<span class="hljs-comment">//等待提交任务</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">submit</span><span class="hljs-params">()</span></span>&#123;<br>    ensureState()<span class="hljs-comment">//1.确认job状态是定义的</span><br>    setUserNewAPI()<span class="hljs-comment">//2.设置新的API</span><br>    connect()<span class="hljs-comment">//获取连接</span><br>&#125;<br><br><span class="hljs-comment">// 1建立连接</span><br>	connect();	<br>		<span class="hljs-comment">// 1）创建提交Job的代理</span><br>		<span class="hljs-keyword">new</span> Cluster(getConfiguration());<br>			<span class="hljs-comment">// （1）判断是本地yarn还是远程</span><br>			initialize(jobTrackAddr, conf); <br><br><span class="hljs-comment">// 2 提交job</span><br>submitter.submitJobInternal(Job.<span class="hljs-keyword">this</span>, cluster)<br>	<span class="hljs-comment">// 1）创建给集群提交数据的Stag路径</span><br>	Path jobStagingArea = JobSubmissionFiles.getStagingDir(cluster, conf);<br><br>	<span class="hljs-comment">// 2）获取jobid ，并创建Job路径</span><br>	JobID jobId = submitClient.getNewJobID();<br><br>	<span class="hljs-comment">// 3）拷贝jar包到集群</span><br>copyAndConfigureFiles(job, submitJobDir);	<br>	rUploader.uploadFiles(job, jobSubmitDir);<br><br><span class="hljs-comment">// 4）计算切片，生成切片信息，数据那一块给哪一个MapTask处理</span><br>writeSplits(job, submitJobDir);<br>		maps = writeNewSplits(job, jobSubmitDir);<br>		input.getSplits(job);<br><br><span class="hljs-comment">// 5）向Stag路径写XML配置文件</span><br>writeConf(conf, submitJobFile);<br>	conf.writeXml(out);<br><br><span class="hljs-comment">// 6）提交Job,返回提交状态</span><br>status = submitClient.submitJob(jobId, submitJobDir.toString(), job.getCredentials());<br></code></pre></td></tr></table></figure></li>
<li><p>InputFormat两个重要过程</p>
<ul>
<li>切片：将文件切片，逻辑上的划分。默认是FileInputFormat，默认就是分块大小。在客户端完成，切几个片就有几个MapTask</li>
<li>RecordReader:对于给定的一个切片得到一个RecordReader，将数据划分成指定的K,V值，传到Map中，作为Map的输入。发生在MapTask中。</li>
</ul>
</li>
<li><p>自定义InputFormat方法</p>
<ul>
<li>自定义一个类继承FileInputFormat</li>
<li>Split：重写isSplitable()，将文件切片，可以自己定义切片规则，返回false 表示不切割</li>
<li>RecordReader：重写createRecordReader()，实现自定义输入到Map的K,V值</li>
</ul>
</li>
<li><p>Map阶段</p>
<ul>
<li>MapTask: Map阶段实际执行MapTask.run()方法，MapTask是一个Map的实现类</li>
<li>Mapper：在MapTask.run方法中会调用Mapper对象的map方法</li>
<li>map: 定义在Mapper中的方法</li>
</ul>
</li>
</ul>
<h3 id="Shuffle机制"><a href="#Shuffle机制" class="headerlink" title="Shuffle机制"></a>Shuffle机制</h3><ul>
<li>shuffle负责整理数据</li>
<li>shuffle流程<ul>
<li><a href="https://imgtu.com/i/gLfma6"><img src="https://z3.ax1x.com/2021/05/22/gLfma6.md.png" alt="gLfma6.md.png"></a><ol>
<li>MapTask收集map()方法输出的KV对，放到环形内存缓冲区中</li>
<li>在内存缓冲区中会进行快速排序，不断溢写到本地磁盘文件</li>
<li>多个溢出的文件会被合成大的溢出文件(溢写到磁盘耗时间，耗资源)</li>
<li>在溢出过程和合并过程中，都调用Partitiner进行分区和针对Key 进行排序，在环形缓冲区中溢出时进行快速排序，在合并时进行归并排序。</li>
<li>ReduceTask根据自己的分区号，去各个MapTask机器上取相应的结果分区数据</li>
<li>ReduceTask 会取到同一个分区的来自不同MapTask 的结果文件，ReduceTask会将这些文件再进行合并（归并排序）</li>
<li>合并成大文件后，shuffle过程结束，后面进入ReduceTask的逻辑运算过程（从文件中取出一个一个的键值对Gruop，调用用户自定义的reduce()方法）</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>Partition分区</p>
<ul>
<li><p>当设置多个ReduceTask时，需要对MapTask输出来的数据进行分区。若ReduceTask数量为1，不执行分区过程。ReduceTask数量默认为1</p>
</li>
<li><p>适应于将将结果按照条件输出到不同分区文件中（分区）。例如：词频统计中分连个区A-M一个分区，M-Z一个分区</p>
</li>
<li><p>当数据量太大时，将多个MapTask得到的结果放到一个Reduce中合并时会非常慢，为了提高效率，需要并行处理，即设置多个ReduceTask处理。ReduceTask需要设置，估算数据业务的量</p>
</li>
<li><p>分区在环形缓冲区时就已经开始进行了</p>
</li>
<li><p>默认分区是根据key的hashCode对ReduceTasks个数取模得到的。用户没法控制哪个key存储到哪个分区。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashPartitioner</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Partitioner</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getPartition</span><span class="hljs-params">(K key, V value, <span class="hljs-keyword">int</span> numReduceTasks)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (key.hashCode() &amp; Integer.MAX_VALUE) % numReduceTasks;<br>  &#125;<br><span class="hljs-comment">//&amp;的目的是去负号</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><a href="https://imgtu.com/i/gzRSkn"><img src="https://z3.ax1x.com/2021/05/25/gzRSkn.md.png" alt="gzRSkn.md.png"></a></p>
</li>
</ul>
</li>
<li><p><a href="https://imgtu.com/i/gzRmkR"><img src="https://z3.ax1x.com/2021/05/25/gzRmkR.md.png" alt="gzRmkR.md.png"></a></p>
</li>
<li><p>三次排序</p>
<ul>
<li>一次快排，两次归并排序</li>
<li> 对于MapTask，它会将处理的结果暂时放到环形缓冲区中，<em><strong>当环形缓冲区使用率达到一定阈值后，再对缓冲区中的数据进行一次快速排序</strong></em>，并将这些有序数据溢写到磁盘上，<em><strong>而当数据处理完毕后，它会对磁盘上所有文件进行归并排序。</strong></em></li>
<li>对于ReduceTask，它从每个MapTask上远程拷贝相应的数据文件，如果文件大小超过一定阈值，则溢写磁盘上，否则存储在内存中。如果磁盘上文件数目达到一定阈值，则进行一次归并排序以生成一个更大文件；如果内存中文件大小或者数目超过一定阈值，则进行一次合并后将数据溢写到磁盘上。<em><strong>当所有数据拷贝完毕后，ReduceTask统一对内存和磁盘上的所有数据进行一次归并排序。</strong></em></li>
</ul>
</li>
<li><p>三个比较器（一个排序比较器，两个分组比较器）</p>
<ul>
<li>排序比较器</li>
<li>Reducer分组比较器</li>
<li>Combiner分组比较器</li>
</ul>
</li>
<li><p>Hadoop中所有比较器默认都是WritableComparator（默认调用key的compareTo()方法）</p>
</li>
<li><p>自定义排序的两种方法</p>
<ul>
<li>实现接口WritableComparable（该接口继承Writable,Comparable）</li>
<li>自定义一个类的专用比较器，在Job中覆盖Comparator，自定义的比较器要继承WritableComparator</li>
</ul>
</li>
<li><p>Combiner合并</p>
<ul>
<li>Combiner与Reducer的区别：Combiner是在每一个MapTask所在节点运行，Reducer是接受全局所有Mapper的输出结果。</li>
<li>Combiner对每一个MapTask的输出进行局部汇总，以减少IO（网络IO，和本地IO）。</li>
<li>Combiner默认不开启，要根据情况使用。能够应用的前提是不影响最终的业务逻辑。</li>
</ul>
</li>
<li><p>GroupComparator分组</p>
<ul>
<li>分组比较器，根据排好顺序的数据，根据Key值进行分组</li>
<li>对Reduce阶段的数据根据某一个或几个字段进行分组。</li>
<li>分组比较器默认也是WritableComparator（默认调用key的compareTo()方法），当排序和分组比较方案不同时，需要自定义其中的一个比较器。</li>
<li>自定义分组比较器步骤：（1）自定义类继承WritableComparator（2）重写compare()方法  （3）创建一个构造将比较对象的类传给父类</li>
</ul>
</li>
<li><p>MapReduce传输数据的方式</p>
<ul>
<li>为了提高传输效率，传输的是用Writable序列化好的序列化数据</li>
<li>数据在从Map出来进入到到环形缓冲区时进行序列化，进入环形缓冲区的数据已经完成了序列化。之后的数据流动都是序列化的数据的流动</li>
<li>之后的排序先反序列化再实现排序</li>
</ul>
</li>
<li><p>环形缓冲区</p>
<ul>
<li>一边写索引，一边写数据</li>
<li>在环形缓冲区进行排序时，不改变数据的位置，改变索引的位置</li>
</ul>
</li>
</ul>
<h3 id="OutputFormat"><a href="#OutputFormat" class="headerlink" title="OutputFormat"></a>OutputFormat</h3><ul>
<li><p>将Reduce处理完的K，V值持久化到文件</p>
</li>
<li><p>几种实现</p>
<ul>
<li>默认的文本输出TextOutputFormat，把每条记录写为文本行，利用K，V的toString()方法将其转为字符串。</li>
<li>SequenceFileOutputFormat:将K，V值序列化成文件放到磁盘上</li>
<li>自定义OutputFormat</li>
</ul>
</li>
<li><p>源码重要方法</p>
<ul>
<li>checkOutputSpecs()检查输出参数</li>
<li>getOutputCommitter()获取outputformat提交器（保证output被正确提交）</li>
<li>自定义outputformat主要实现RecordWriter()。实现接收K,V值并将K,V值处理</li>
</ul>
</li>
</ul>
<h3 id="MapReduce工作机制"><a href="#MapReduce工作机制" class="headerlink" title="MapReduce工作机制"></a>MapReduce工作机制</h3><ul>
<li><p>MapReduce哪些阶段可以进行压缩</p>
<ul>
<li>map的输入端（主要看数据大小和切片，lzo,bzip2）</li>
<li>map的输出端(主要考虑速度，snappy，Lzo)</li>
<li>reduce的输出端(看需求，是要继续做mapreduce的输出，还是直接做分析的数据等)</li>
</ul>
</li>
<li><p>MapTask工作机制</p>
<ul>
<li><p><a href="https://imgtu.com/i/gzWpHH"><img src="https://z3.ax1x.com/2021/05/25/gzWpHH.md.png" alt="gzWpHH.md.png"></a></p>
</li>
<li></li>
<li><p>（1）Read阶段：MapTask通过用户编写的RecordReader，从输入InputSplit中解析出一个（2）Map阶段：该节点主要是将解析出的key/value交给用户编写map()函数处理，并产生一系列新的key/value。</p>
<p>​    （3）Collect收集阶段：在用户编写map()函数中，当数据处理完成后，一般会调用OutputCollector.collect()输出结果。在该函数内部，它会将生成的key/value分区（调用Partitioner），并写入一个环形内存缓冲区中。</p>
<p>​    （4）Spill阶段：即“溢写”，当环形缓冲区满后，MapReduce会将数据写到本地磁盘上，生成一个临时文件。需要注意的是，将数据写入本地磁盘之前，先要对数据进行一次本地排序，并在必要时对数据进行合并、压缩等操作。</p>
<p>个key/value。</p>
<p>​    溢写阶段详情：</p>
<p>​    步骤1：利用快速排序算法对缓存区内的数据进行排序，排序方式是，先按照分区编号Partition进行排序，然后按照key进行排序。这样，经过排序后，数据以分区为单位聚集在一起，且同一分区内所有数据按照key有序。</p>
<p>​    步骤2：按照分区编号由小到大依次将每个分区中的数据写入任务工作目录下的临时文件output/spillN.out（N表示当前溢写次数）中。如果用户设置了Combiner，则写入文件之前，对每个分区中的数据进行一次聚集操作。</p>
<p>​    步骤3：将分区数据的元信息写到内存索引数据结构SpillRecord中，其中每个分区的元信息包括在临时文件中的偏移量、压缩前数据大小和压缩后数据大小。如果当前内存索引大小超过1MB，则将内存索引写到文件output/spillN.out.index中。</p>
<p>​    （5）Combine阶段：当所有数据处理完成后，MapTask对所有临时文件进行一次合并，以确保最终只会生成一个数据文件。</p>
<p>​    当所有数据处理完后，MapTask会将所有临时文件合并成一个大文件，并保存到文件output/file.out中，同时生成相应的索引文件output/file.out.index。</p>
<p>​    在进行文件合并过程中，MapTask以分区为单位进行合并。对于某个分区，它将采用多轮递归合并的方式。每轮合并io.sort.factor（默认10）个文件，并将产生的文件重新加入待合并列表中，对文件排序后，重复以上过程，直到最终得到一个大文件。</p>
<p>​    让每个MapTask最终只生成一个数据文件，可避免同时打开大量文件和同时读取大量小文件产生的随机读取带来的开销。</p>
<ul>
<li><p>ReduceTask阶段</p>
<p><a href="https://imgtu.com/i/gzWxGq"><img src="https://z3.ax1x.com/2021/05/25/gzWxGq.md.png" alt="gzWxGq.md.png"></a></p>
<p>（1）Copy阶段：ReduceTask从各个MapTask上远程拷贝一片数据，并针对某一片数据，如果其大小超过一定阈值，则写到磁盘上，否则直接放到内存中。</p>
<p>​    （2）Merge阶段：在远程拷贝数据的同时，ReduceTask启动了两个后台线程对内存和磁盘上的文件进行合并，以防止内存使用过多或磁盘上文件过多。</p>
<p>​    （3）Sort阶段：按照MapReduce语义，用户编写reduce()函数输入数据是按key进行聚集的一组数据。为了将key相同的数据聚在一起，Hadoop采用了基于排序的策略。由于各个MapTask已经实现对自己的处理结果进行了局部排序，因此，ReduceTask只需对所有数据进行一次归并排序即可。</p>
<p>​    （4）Reduce阶段：reduce()函数将计算结果写到HDFS上。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>​    </p>
<pre><code>### Join多种应用

* Reducejoin：

  - Map段主要工作：为来自不同表或文件的key/value对，***打标签以区别不同来源的记录***。然后用连接字段作为key ,其余部分和新加的标志作为value，最后进行输出。
  - Reduce端主要工作：在Reduce端以连接字段作为key的分组已经完成，我们只需要在每一个分组中将***来源不同文件的记录（在Map阶段已经打标签）分开***，最后进行合并。
  - 缺点：这种方式中，合并操作是在Reduce阶段完成，Reduce端的处理压力太大，Map节点的运算负载很低，资源利用率不高，且在Reduce阶段容易产生数据倾斜。

* Mapjoin

  1．使用场景

  Map Join适用于一张表十分小、一张表很大的场景。

  2．优点

  思考：在Reduce端处理过多的表，非常容易产生数据倾斜。怎么办？

  在Map端缓存多张表，提前处理业务逻辑，这样增加Map端业务，减少Reduce端数据的压力，尽可能的减少数据倾斜。

  3．具体办法：采用DistributedCache 

  ​    （1）在Mapper的setup阶段，将文件读取到缓存集合中。

  ​    （2）在驱动函数中加载缓存。

  // 缓存普通文件到Task运行节点。

  job.addCacheFile(new URI(&quot;file://e:/cache/pd.txt&quot;));
</code></pre>
<p>​      </p>
<p>​    </p>
<h2 id="Yarn资源调度器"><a href="#Yarn资源调度器" class="headerlink" title="Yarn资源调度器"></a>Yarn资源调度器</h2><h3 id="Yarn基本架构和工作机制"><a href="#Yarn基本架构和工作机制" class="headerlink" title="Yarn基本架构和工作机制"></a>Yarn基本架构和工作机制</h3><ul>
<li><p>基本架构</p>
</li>
<li><p><a href="https://imgtu.com/i/2iAWPf"><img src="https://z3.ax1x.com/2021/05/27/2iAWPf.png" alt="2iAWPf.png"></a></p>
</li>
<li><p>Yarn工作流程</p>
<ul>
<li><a href="https://imgtu.com/i/2ieAJ0"><img src="https://z3.ax1x.com/2021/05/27/2ieAJ0.png" alt="2ieAJ0.png"></a></li>
</ul>
</li>
<li><p>Yarn工作步骤</p>
<ul>
<li><ol start="0">
<li>客户端执行程序job.waitForCompletion</li>
</ol>
</li>
<li><ol>
<li>申请一个Application</li>
</ol>
</li>
<li><ol start="2">
<li>返回Application资源提交临时路径和job_Id</li>
</ol>
</li>
<li><ol start="3">
<li>客户端提交job运行必要资源Job.split(分片信息)，Job.xml（配置信息），Wc.jar(所需的必要Jar包)</li>
</ol>
</li>
<li><ol start="4">
<li>资源提交完毕，申请运行AppMaster</li>
<li>ResourceManager将用户的请求初始化成一个Task资源申请,放入资源调度器等待调度</li>
<li> 资源调度器中的任务会分配到一个NodeManager中</li>
<li>NodeManager会根据任务创建一个容器，在容器中运行对应的AppMaster</li>
<li>AppMaster获取必要资源到本地</li>
<li>AppMaster再向ResourceManager请求运行MapTask资源申请</li>
<li>ResourceManager指定一个NodeManager领取MapTask任务，创建容器，运行MapTask</li>
<li>AppMaster向执行MapTask的NodeManager发送程序启动脚本</li>
<li>同理AppMaster向RM请求运行ReduceTask资源申请，创建容器运行ReduceTask</li>
<li>Reduce向Map获取相应的分区数据</li>
</ol>
</li>
</ul>
</li>
<li><p>资源调度器：FIFO、Capacity Scheduler和Fair Scheduler。Hadoop3.1.3默认的资源调度器是Capacity Scheduler。</p>
<ul>
<li><p>FIFO，队列形式。基本不用</p>
</li>
<li><p>Capacity Scheduler，几个并行的FIFO。当集群资源不紧张时，采用此方式</p>
<p><a href="https://imgtu.com/i/2iGrQA"><img src="https://z3.ax1x.com/2021/05/27/2iGrQA.png" alt="2iGrQA.png"></a></p>
</li>
<li><p>Fair Scheduler　公平调度器。能最大程度利用集群的资源</p>
<p><a href="https://imgtu.com/i/2ilY4J"><img src="https://z3.ax1x.com/2021/05/27/2ilY4J.png" alt="2ilY4J.png"></a></p>
</li>
</ul>
</li>
</ul>
<h2 id="Hadoop常见优化"><a href="#Hadoop常见优化" class="headerlink" title="Hadoop常见优化"></a>Hadoop常见优化</h2><ul>
<li><p>数据倾斜问题:某个区域的数据量远远大于其它区域例如Map端和Reduce端的数据倾斜</p>
<ul>
<li>自定义分区，基于对原始数据的认知进行自定义分区。</li>
<li>Combine:Combine可以大量地减少数据倾斜。</li>
<li>采用Mapjoin，因为Reducejoin对Reduce端的压力非常大</li>
</ul>
</li>
<li><p>参数优化提升MapReduce 性能</p>
<ul>
<li><p>容错相关参数(MapReduce性能优化)</p>
<table>
<thead>
<tr>
<th>配置参数</th>
<th>参数说明</th>
</tr>
</thead>
<tbody><tr>
<td>mapreduce.map.maxattempts</td>
<td>每个Map Task最大重试次数，一旦重试参数超过该值，则认为Map Task运行失败，默认值：4。</td>
</tr>
<tr>
<td>mapreduce.reduce.maxattempts</td>
<td>每个Reduce Task最大重试次数，一旦重试参数超过该值，则认为Map Task运行失败，默认值：4。</td>
</tr>
<tr>
<td>mapreduce.task.timeout</td>
<td>Task超时时间，经常需要设置的一个参数，该参数表达的意思为：如果一个Task在一定时间内没有任何进入，即不会读取新的数据，也没有输出数据，则认为该Task处于Block状态，可能是卡住了，也许永远会卡住，为了防止因为用户程序永远Block住不退出，则强制设置了一个该超时时间（单位毫秒），默认是600000。如果你的程序对每条输入数据的处理时间过长（比如会访问数据库，通过网络拉取数据等），建议将该参数调大，该参数过小常出现的错误提示是“AttemptID:attempt_14267829456721_123456_m_000224_0 Timed out after 300 secsContainer killed by the ApplicationMaster.”。</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>小文件优化方法</p>
<ul>
<li>小文件的缺点：1.会占用namenode大量的内存资源。2.索引文件过大使得检索速度变慢。</li>
<li>优化：1.Sequence File:Sequence File由一系列的二进制key/value组成，Input如果key为文件名，value为文件内容，则可以将大批小文件合并成一个大文件。<ol start="2">
<li>CombineFileInputFormat:用于将多个文件合并成一个单独的split。</li>
</ol>
</li>
</ul>
</li>
<li><p>MapReduce 优化</p>
<ul>
<li>InputFormat阶段 ：1. 合并小文件</li>
<li>Map阶段：1.减少溢写（Spill）次数。2.减少合并（Merge）次数</li>
<li>Reduce阶段<ol>
<li>合理设置Map和Reduce数：两个都不能设置太少，也不能设置太多。太少，会导致Task等待，延长处理时间；太多，会导致Map,Reduce任务竞争资源，造成处理超时等待。</li>
<li>设置Map,Reduce共存，调整slowstart.completedmaps参数，使Map运行到一定程度后，Reduce也开始运行，减少Reduce的等待时间。</li>
<li>规避使用Reduce，因为Reduce在用于连接数据集的时候会产生大量的网络消耗。</li>
<li>合理设置Reduce端的Buffer</li>
</ol>
</li>
<li>OutputFormat阶段<ol>
<li>采用数据压缩</li>
<li>使用SequenceFile二进制文件</li>
</ol>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>conclusion</title>
    <url>/2021/09/29/conclusion/</url>
    <content><![CDATA[<h1 id="重点知识点总结"><a href="#重点知识点总结" class="headerlink" title="重点知识点总结"></a>重点知识点总结</h1><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><ul>
<li><p>linux常用命令</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>命令解释</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>top</td>
<td>查看内存</td>
</tr>
<tr>
<td>2</td>
<td>df -h</td>
<td>查看磁盘存储情况</td>
</tr>
<tr>
<td>3</td>
<td>iotop</td>
<td>查看磁盘IO读写情况，要root权限</td>
</tr>
<tr>
<td>4</td>
<td>iotop -o</td>
<td>直接查看比较高的磁盘读写程序</td>
</tr>
<tr>
<td>5</td>
<td>netstat -tunlp | grep 端口号</td>
<td>查看端口占用情况</td>
</tr>
<tr>
<td>6</td>
<td>uptime</td>
<td>查看报告系统运行时长及平均负载</td>
</tr>
<tr>
<td>7</td>
<td>ps  -aux</td>
<td>查看进程</td>
</tr>
</tbody></table>
<p>ifconfig   查看IP地址</p>
<p>ps -aux    显示USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND</p>
<p>ps -ef | grep flume    查看进程和父进程的ID（flume进程的关闭就可以通过此方式查看进程号）</p>
<p>ps -ef 显示 UID    PID PPID C STIME TTY     TIME CMD</p>
<p><font color=red>PID是程序被操作系统加载到内存成为进程后动态分配的资源，</font>每次程序执行的时候，操作系统都会重新加载，PID在每次加载都是不同的。</p>
<p>PPID 是程序的父进程号</p>
</li>
</ul>
<h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><ul>
<li><p>框架启动关闭脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><br>case $1 in<br>&quot;start&quot;)&#123;<br>	for i in hadoop100 hadoop101 hadoop102<br>	do<br>		ssh $i &quot;启动命令，用绝对路径&quot;<br>	done<br>&#125;;;<br>&quot;stop&quot;)&#123;<br><br>&#125;;;<br>esac<br><br></code></pre></td></tr></table></figure></li>
<li><p>单引号和双引号的区别</p>
<ul>
<li>单引号：’$do_date’,在引号内部的变量不能解释里面变量对应的值</li>
<li>双引号：”$do_date”,在引号内部，能够取出变量的值</li>
<li>单引号，双引号嵌套：看谁在最外面</li>
<li>``号表示，执行引号中的命令</li>
</ul>
</li>
</ul>
<h2 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ul>
<li>Hadoop3.x常用端口<ul>
<li>namenode rpc 端口 8020    2.x是9000</li>
<li>namenode http 端口 9870    2.x是50070</li>
<li>resourcemanager webapp.address  端口8088</li>
<li>19888 历史服务器</li>
</ul>
</li>
<li>安装配置文件<ul>
<li>core-site.xml</li>
<li>yarn-site.xml</li>
<li>mapred-site.xml</li>
<li>hdfs.site.xml     zk信息在此配置</li>
<li>workers(3.x)                       slaves(2.x)</li>
</ul>
</li>
</ul>
<h3 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h3><ul>
<li>HDFS块大小2.x，3.x，默认都是128M   本地模式32M<ul>
<li>块大小主要看服务器之间的传输速率</li>
</ul>
</li>
<li>HDFS读写流程<ul>
<li>写数据流程（8步）<ul>
<li>客户端向NameNode请求写入数据</li>
<li>NameNode响应是否上传文件</li>
<li>客户端上传第一个Block的信息</li>
<li>namenode返回datanode节点（dn1,dn2,dn3）</li>
<li>客户端与datanode建立连接通道</li>
<li>datanode逐级应答</li>
<li>客户端向dn1传输数据（以Packet的形式64kb），dn1再向dn2传输，依次传输。<font color=red>dn1每传输一个packet会放入一个应答队列等待应答.</font></li>
<li>重复3-7步，传输block2</li>
</ul>
</li>
<li>读数据流程（4步）<ul>
<li>客户端向Namenode请求读数据</li>
<li>namenode返回元数据信息</li>
<li>找最近的datanode</li>
<li>datanode向客户端传输信息，以packet  的形式。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h3><ul>
<li>shuffle流程以及优化<ul>
<li>map方法之后，redece方法之前的数据处理过程</li>
<li>大致流程<ul>
<li>MapTask收集map()方法的K,V对，并将这些数据放入环形缓冲区中</li>
<li>当环形缓冲区(默认100m）达到80%后，会进行溢写操作，将数据反向溢写到磁盘。在环形缓冲区中会进行快速排序。如果数据阻塞了，会暂停向环形缓冲区写数据。</li>
<li>会将溢写到磁盘的文件进行归并排序，在溢写和归并的过程中，都要调用Partitioner进行分区和针对key进行排序。框架调用Partitioner分区器分区（指定分区规则），WritableComparable排序器排序（指定排序规则）。</li>
<li>ReduceTask 会根据分区号，去各个MapTask上取相应的结果分区数据。将数据写入内存</li>
<li>ReduceTask会取到同一分区来自不同MapTask的结果文件，内存不够时，也会触发溢写操作，将数据写入磁盘。</li>
<li>ReduceTask会将这些文件进行合并（归并排序）还可以将归并完成的文件看需求是否进行分组操作（GroupingComparator分组），合并成大文件后，shuffle过程结束。之后将数据按reduce 方法去处理。</li>
</ul>
</li>
<li>优化：<ul>
<li>自定义分区（减少数据倾斜）</li>
<li>可以设置环形缓冲区到90%，95%之后再进行溢写，减少溢写文件，提升速度</li>
<li>再不影响业务逻辑的情况下（如求和），可以进行Combiner操作。对MapTask的输出进行一个局部汇总</li>
<li>在MapTask中，默认一次归并10个文件，可以设置更多提高性能</li>
<li>MapTask输出可以进行压缩（snappy ,lzo），减少数据传输量,提升速度</li>
<li>ReduceTask一次默认拉取5个MapTask同一分区的数据，可以根据集群性能调整</li>
<li>ReduceTask从MapTask中拉取数据先放入内存中，可以适当提高内存，减少溢写，也增加传输速度</li>
</ul>
</li>
</ul>
</li>
<li>一般情况下1g内存   对应128M数据   比较合理</li>
<li>NM默认内存：8g（服务器调整到100g左右）</li>
<li>单个任务默认内存:8g</li>
<li>MapTask默认内存：1g</li>
<li>ReduceTask默认内存:1g</li>
<li>MapJoin:在Map端缓存多张表，提前处理业务逻辑，这样增加Map端业务，减少Reduce端数据的压力，尽可能的减少数据倾斜。mapjoin适合一张表很大，一张表很小的场景。将小表缓存<ul>
<li>在Mapper的setup阶段(重写setup方法)，将文件读取到缓存集合中</li>
<li>在驱动函数中加载缓存，缓存普通文件到Task运行节点</li>
<li>job.addCacheFile(new URL(“file://e:/cache/xxx.txt”))</li>
</ul>
</li>
</ul>
<h3 id="YARN"><a href="#YARN" class="headerlink" title="YARN"></a>YARN</h3><ul>
<li><p>Yarn是一个资源调度平台，负责为运算程序提供服务运算资源，相当于一个<font color=red>分布式的操作系统平台，</font>而MapReduce等运算则相当于运行于操作系统之上的程序。</p>
</li>
<li><p>yarn工作调度流程(8步)</p>
<ul>
<li><p>客户端执行job.waitForCompletion</p>
</li>
<li><p>客户端向RM申请运行一个Application</p>
</li>
<li><p>RM向client 返回Application的资源提交路径和job_id</p>
</li>
<li><p>client将资源(切片信息，配置信息，所需jar包)提交到HDFS上</p>
</li>
<li><p>资源提交完成，Application向RM申请运行AppMaster</p>
</li>
<li><p>AppMaster下载Client提交的资源到本地</p>
</li>
<li><p>APPMaster向RM申请多个任务资源，运行MapReduce程序</p>
</li>
<li><p>运行完成后，MR会向RM申请注销自己。</p>
</li>
</ul>
</li>
<li><p>yarn资源调度器</p>
<ul>
<li>FIFO<ul>
<li>队列形式，先进先出</li>
</ul>
</li>
<li>容量调度器(默认的资源调度器)<ul>
<li>几个并行的FIFO，当资源不紧张时，采用此方式</li>
<li>优先满足先进入的任务</li>
</ul>
</li>
<li>公平调度器 （能最大限度的利用集群资源）<ul>
<li>最大限度的利用集群资源</li>
<li>每个任务都公平的享有资源，并发度高</li>
<li>同一队列的作业按照其优先级分享整个队列的资源，并发执行</li>
<li>每个作业可以设置最小资源值，调度器会保证作业获得其以上的资源</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="优化问题"><a href="#优化问题" class="headerlink" title="优化问题"></a>优化问题</h3><ul>
<li>优化问题<ul>
<li>小文件问题<ul>
<li>har归档</li>
<li>使用CombineTextInputformat</li>
<li>JVM重用</li>
</ul>
</li>
<li>数据倾斜问题<ul>
<li>启用combiner ,减少数据的传输量</li>
<li>根据数据分布情况，自定义分区，将key 均匀分配到Reducer</li>
<li>重新设计key，有一种方案是在map阶段时给key加上一个随机数,有了随机数的key就不会被大量的分配到同一节点(小几率),待到reduce后再把随机数去掉即可。</li>
<li>增加Reducer，提升并行度</li>
<li>增加JVM内存</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><ul>
<li><p>Zookeeper从设计模式的角度理解，是一个基于观察者模式设计的分布式服务管理框架，<font color=red>它负责存储和管理大家都关心的数据，然后接受观察者的注册，一旦这些数据的状态发生变化，Zookeeper就将负责通知已经在Zookeeper上注册的那些观察者做出相应的反应</font></p>
</li>
<li><p>Zookeeper=文件系统+通知机制</p>
</li>
<li><p>选举机制</p>
<ul>
<li><p>奇数台</p>
<p>10台服务器：3台</p>
<p>20台服务器：5台</p>
<p>100台服务器：11台</p>
</li>
<li><p>台数不是越多越好，太多选举时间过长影响性能。</p>
</li>
<li><p>zk半数以上可以正常运行</p>
</li>
<li><p>ZooKeeper是一个开源的分布式的，为分布式应用提供协调服务的Apache项目</p>
</li>
</ul>
</li>
<li><p>常用命令</p>
<ul>
<li>ls path 查看当前znode中所包含的内容</li>
<li>create 普通创建 -s含有序列  -e 临时（重启或超时消失）</li>
<li>get path 获得节点的值</li>
<li>set 设置节点的具体值</li>
<li>stat 查看节点状态</li>
</ul>
</li>
<li><p>HA</p>
<p><a href="https://imgtu.com/i/2lA1SS"><img src="https://z3.ax1x.com/2021/06/02/2lA1SS.png" alt="2lA1SS.png"></a></p>
</li>
</ul>
<h2 id="Flume"><a href="#Flume" class="headerlink" title="Flume"></a>Flume</h2><ul>
<li><p>架构</p>
<ul>
<li><p>flume是一个分布式的海量日志采集，聚合，和传输的系统</p>
</li>
<li><p>Flume agent 内部原理</p>
<ul>
<li><p>source接收数据，数据以event的形式传给ChannelProcessor</p>
</li>
<li><p>ChannelProcessor将事件传递给拦截器，在拦截器中可以对event数据进行更改</p>
</li>
<li><p>经过拦截器后，数据返回到ChannelProcessor，ChannelProcessor将每个event交给ChannelSelector，ChannelSelector的作用就是选出Event将要发往哪个Channel，有两种选择：分别是Replicating(复制)和Multiplexing（多路复用）</p>
</li>
<li><p>数据再返回到ChannelProcessor，根据选择器的选择，进入不同的Channel</p>
</li>
<li><p>SinkProcessor再决定channel中的event 的走向</p>
<ul>
<li><p>SinkProcessor共有三种类型，分别是DefaultSinkProcessor、LoadBalancingSinkProcessor和FailoverSinkProcessor</p>
<p>DefaultSinkProcessor对应的是单个的Sink，LoadBalancingSinkProcessor和FailoverSinkProcessor对应的是Sink Group，LoadBalancingSinkProcessor可以实现负载均衡的功能，FailoverSinkProcessor可以错误恢复的功能（故障转移）。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>event:flume传输数据的基本单位，由Header和Body组成，Header用来存放该event的一些属性，为K，V结构（Header不设置的话为空）；Body用来存放该条数据，形式为字节数组。</p>
</li>
<li><p>source</p>
<ul>
<li>Taildir Source:适用于监听多个实时追加的文件，并且能够实现断点续传。（可能会出现数据重复）</li>
<li>batchSize参数决定Source一次批量运输到Channel的event条数，适当调大这个参数可以提高Source搬运Event到Channel时的性能。</li>
</ul>
</li>
<li><p>channel</p>
<ul>
<li>File Channel  基于磁盘  可以存100万个event</li>
<li>Memory Channel 基于内存  可以存100个event</li>
<li>KafkaChannel  数据存储在Kafka里面 基于磁盘的  KafkaChannel传输性能大于MemoryChannel+KafkaSink</li>
</ul>
</li>
<li><p>sink</p>
<ul>
<li>hdfs sink<ul>
<li>针对小文件 hdfs sink 有优化的参数</li>
</ul>
</li>
</ul>
</li>
<li><p>拦截器</p>
<ul>
<li>自定义拦截器<ul>
<li>定义类实现Interceptor接口，重写四个方法（初始化，单event修改，多event修改，关闭资源） 还需要一个Builder静态内部类，实现Interceptor.Builder,在里面new一个自定义的拦截器返回。</li>
</ul>
</li>
</ul>
</li>
<li><p>选择器(Channel Selector)</p>
<ul>
<li>Multiplexing（多路复用）可以选择传到指定的Channel 上</li>
<li>Replicating(复制) event传到每个Channel上</li>
</ul>
</li>
<li><p>监控器</p>
<ul>
<li>监控资源的读写情况</li>
</ul>
</li>
<li><p>调优</p>
<ul>
<li>filechannel  能多磁盘就配置多磁盘（数据保存到不同磁盘） 能提高吞吐量</li>
<li>hdfs sink 小文件问题        设置  每个文件的滚动大小（128m）多久创建一个新的文件（1-2小时） event个数（0）设置为0表示文件的滚动与event 数量无关</li>
</ul>
</li>
</ul>
<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><ul>
<li><p>基本信息</p>
<ul>
<li><p>Kafka是一个分布式的基于发布/订阅模式的消息队列</p>
</li>
<li><p>架构</p>
<ul>
<li>producer:  消息生产者,向Kafak集群发消息的客户端</li>
<li>Kafka Cluster：Kafka集群</li>
<li>consumer: 消息消费者，向Kafka Broker取消息的客户端</li>
<li>consumer group:消费者组，每个消费者组由多个consumer组成。消费者组内每个消费者负责消费不同分区的数据，一个分区只能由一个消费者消费。消费者组之间互不影响，所有消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。</li>
<li>broker ：Kafka集群中的每一台机器就是一个broker ，一个Kafka集群由多个broker 组成。</li>
<li>topic: 可以理解为一个消息队列，生产者和消费者面向的都是一个个topic。一台broker 可以容纳多个topic</li>
<li>partition：一个topic可以分为多个partition，每个partition都是一个有序的队列。可以实现很好的扩展性，一个非常大的topic可以分布到多个broker上。</li>
<li>replica：副本，保证数据的可靠性。即当集群中的某个节点发生故障时，为保证数据的完整性，kfak提供了副本机制，一个topic的每个partition都有若干个副本，一个leader和若干个follower</li>
<li>leader:副本的”主“，生产者发送数据的对象，以及消费者消费数据的对象都是leader </li>
<li>follower: 副本中的”从“，实时从leader中同步数据，保持和leader数据的同步，leader发生故障时，会选出某个follower成为新的leader</li>
</ul>
</li>
<li><p>分区策略</p>
<ul>
<li>分区原因（为什么将一个topic分为多个partition）：1. 方便在集群中扩展。2. 以partition为单位进行读写，可以提高并发。</li>
</ul>
</li>
<li><p>分区分配策略</p>
<ul>
<li>确定哪个partition由哪个consumer来消费</li>
<li>round-robin：当分区数大于consumer数量时，轮询分配，类似于斗地主一张一张的发牌。</li>
<li>range:类似于斗地主一次性发几张牌</li>
</ul>
</li>
</ul>
</li>
<li><p>挂了</p>
<ul>
<li>短时间  会存储在flume channel里</li>
<li>长时间  日志服务器有30天数据</li>
</ul>
</li>
<li><p>丢了</p>
<ul>
<li>ack  的几种情况（三种）</li>
<li>producer向Kafka集群发送信息是异步通信，为保证数据的可靠性，需要向producer发送ACK（acknowledgement 回信），如果producer收到ack，就进行下一轮的发送，否则重新发送数据。此时会出现三种情况</li>
<li>0  收到后还没开始写就发送，最不安全</li>
<li>1 leader写完后发送</li>
<li>all(-1) ISR中所有副本都写完后发送ack </li>
<li>ISR队列（在第三中情况下，为了防止某个follower长时间未向leader同步数据，该follower会被踢出ISR，leader故障则会重选leader）<ul>
<li>和leader保持同步的follower在ISR中,一定时间不同步会被提出ISR，时间阈值由replica.lag.time.max.ms参数设定，leader故障则重新选举leader。（Leader选举由Zookeeper来完成）</li>
<li><a href="https://imgtu.com/i/RgXWRJ"><img src="https://z3.ax1x.com/2021/07/03/RgXWRJ.png" alt="RgXWRJ.png"></a></li>
<li>当follower故障时会被临时踢出ISR，待待该follower恢复后，follower会读取本地磁盘记录的上次的HW，并将log文件高于HW的部分截取掉，从HW开始向leader进行同步。等该<em><strong>follower的LEO大于等于该Partition的HW</strong></em>，即follower追上leader之后，就可以重新加入ISR了。</li>
<li>leader发生故障之后，会从ISR中选出一个新的leader，之后，为保证多个副本之间的数据一致性，其余的follower会先将各自的log文件高于HW的部分截掉，然后从新的leader同步数据。</li>
<li>这只能保证副本之间的数据一致性，并不能保证数据不丢失或者不重复</li>
<li>At Least Once可以保证数据不丢失，但是不能保证数据不重复</li>
</ul>
</li>
</ul>
</li>
<li><p>重复了</p>
<ul>
<li>（自己解决）幂等性，事务，ack=-1</li>
<li>（其它框架帮忙解决）数仓里面处理，</li>
</ul>
</li>
<li><p>积压了</p>
<ul>
<li>如果是Kafka消费能力不足，则可以考虑增加Topic的分区数，并且同时提升消费者组的消费者数量，消费者数=分区数。</li>
<li>增加下一级的消费速度</li>
</ul>
</li>
<li><p>优化</p>
<ul>
<li>由于consumer在消费过程中可能会出现断电宕机等故障，consumer恢复后，需要从故障前的位置的继续消费，所以consumer需要实时记录自己消费到了哪个offset，以便故障恢复后继续消费。</li>
<li>将offset放在Kafka内置的一个topic中，__consumer_offsets。由50个分区。</li>
<li>Broker 参数配置，保留三天，也可以更短</li>
<li>Replica相关配置 ，默认副本一个</li>
<li>网络不稳定时，可以将网络通信延时</li>
<li>producer优化 采用压缩</li>
<li>增加kafka内存 生产环境下尽量不要超过6G</li>
</ul>
</li>
<li><p>其它</p>
<ul>
<li><p>Exactly once语义：At Least Once + 幂等性 = Exactly Once。</p>
</li>
<li><p>幂等性就是指Producer不论向Server发送多少次重复数据，Server端都只会持久化一条。</p>
</li>
<li><p>将服务器的ACK级别设置为-1，可以保证Producer到Server之间不会丢失数据，即At Least Once语义。</p>
</li>
<li><p>要启用幂等性，只需要将Producer的参数中enable.idompotence设置为true即可。Kafka的幂等性实现其实就是将原来下游需要做的去重放在了数据上游。开启幂等性的Producer在初始化的时候会被分配一个PID，发往同一Partition的消息会附带Sequence Number。而Broker端会对&lt;PID, Partition, SeqNumber&gt;做缓存，当具有相同主键的消息提交时，Broker只会持久化一条。</p>
</li>
<li><p>局限性：但是PID重启就会变化，同时不同的Partition也具有不同主键，所以幂等性无法保证跨分区跨会话的Exactly Once。</p>
</li>
<li><p>要实现跨分区的Exactly Once，需要Transaction Coordinator，用于管理produce发送的信息的事务型。</p>
<ul>
<li>该<code>Transaction Coordinator</code>维护<code>Transaction Log</code>，该log存于一个内部的Topic内。由于Topic数据具有持久性，因此事务的状态也具有持久性。</li>
<li>应用程序必须提供一个稳定的（重启后不变）唯一的ID，也即<code>Transaction ID</code>。<code>Transactin ID</code>与<code>PID</code>可能一一对应。区别在于<code>Transaction ID</code>由用户提供，而<code>PID</code>是内部的实现对用户透明。</li>
<li>有了<code>Transaction ID</code>后，Kafka可保证：<ul>
<li>跨Session的数据幂等发送。当具有相同<code>Transaction ID</code>的新的Producer实例被创建且工作时，旧的且拥有相同<code>Transaction ID</code>的Producer将不再工作。</li>
<li>跨Session的事务恢复。如果某个应用实例宕机，新的实例可以保证任何未完成的旧的事务要么Commit要么Abort，使得新实例从一个正常状态开始工作。</li>
</ul>
</li>
</ul>
</li>
<li><p>Kafka高效读写的原因</p>
<ul>
<li><p>Kafka是分布式，还可以设置分区，并发度高</p>
</li>
<li><p>采用顺序读写，topic在磁盘中顺序存储</p>
</li>
<li><p>零拷贝技术</p>
<p><a href="https://imgtu.com/i/4fbbm8"><img src="https://z3.ax1x.com/2021/09/28/4fbbm8.png" alt="4fbbm8.png"></a></p>
</li>
<li><p>直接将文件从内核层拷贝到目标地址。速度更快</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Zookeeper在Kafka中的作用</p>
<ul>
<li>Kafka集群中有一个broker会被选举为Controller，<font color=red>负责管理集群broker的上下线，所有topic的分区副本分配和leader选举等工作。</font>Controller的管理工作是依赖于Zookeeper的。</li>
</ul>
</li>
</ul>
<h2 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h2><ul>
<li><p>组成</p>
</li>
<li><p>数据类型转换</p>
<ul>
<li><p>CAST： CAST ( expression AS data_type )</p>
</li>
<li><p>````sql<br>select</p>
<pre><code>cast(1000 as varchar(10))
cast(1000 as varchar)
cast(&#39;1000&#39; as int)
</code></pre>
<figure class="highlight mel"><table><tr><td class="code"><pre><code class="hljs mel"><br>- CONVERT： CONVERT (data_type[(length)], <span class="hljs-keyword">expression</span> [, style])<br><br>  <span class="hljs-string">``</span><span class="hljs-string">``</span>sqlite<br>  <span class="hljs-keyword">select</span> convert(datetime,<span class="hljs-string">&#x27;2017-01-01&#x27;</span>)<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>与Mysql的区别</p>
<ul>
<li>数据量   hive擅长大数据场景     mysql擅长小数据场景（数据超过一千万条后速度就不行了）</li>
<li>速度      大数据场景下 hive快       小数据场景下  mysql 快</li>
</ul>
</li>
<li><p>内部表和外部表的区别</p>
<ul>
<li>内部表  删除后，元数据和表中的数据（原始数据）都删除了</li>
<li>外部表  删除后，只删除了元数据</li>
</ul>
</li>
<li><p>插入数据</p>
<ul>
<li>insert into :以追加数据的方式插入到表或分区，原有数据不会删除</li>
<li>insert overwrite:会覆盖表或分区中已经存在的数据</li>
</ul>
</li>
<li><p>4个by</p>
<ul>
<li>order by  全局排序（都会进入一个Reduce）很容易造成数据倾斜</li>
<li>sort by   局部排序（对每个reduce排序）</li>
<li>distribute  by   分区，按照分区进入不同的reduce</li>
<li>cluster by  当sort by 和distribute by  排序的字段相同时可以使用 cluster by 代替（默认只能是升序）</li>
</ul>
</li>
<li><p>系统函数</p>
<ul>
<li><p>常用内置函数</p>
</li>
<li><p>date_add</p>
<ul>
<li>返回日期的后n天的日期</li>
<li>select date_sub(‘2015-04-09’,4)；输出2015-04-13</li>
</ul>
</li>
<li><p>date_sub  </p>
<ul>
<li>返回日期前n天的日期</li>
<li>select date_sub(‘2015-04-09’,4);输出：2015-04-05；</li>
</ul>
</li>
<li><p>next_day </p>
<ul>
<li>返回当前时间的下一个星期几对应的日期</li>
<li>select next_day(‘2018-02-27 10:03:01’, ‘TU’); –2018-03-06</li>
<li>说明，输入日期为2-27，下个星期的周二为03-06，如果想要知道下周一的日期就是MO，周日就是SU，以此类推。</li>
<li>注意：西方都是任务周日是每周的第一天</li>
</ul>
</li>
<li><p>date_format</p>
<ul>
<li><p>‘yyyy-MM-dd HH:mm:ss’ 日期格式：年月日 时分秒</p>
</li>
<li><p>日期格式化，把字符串或者日期转成指定格式的日期</p>
</li>
<li><p>date_format(“2016-06-22”,”yyyy-MM-dd”)=2016-06-22</p>
</li>
</ul>
</li>
<li><p>last_day</p>
<ul>
<li>返回这个月的最后一天的日期</li>
<li>select last_day(“2021-10-04”);=2021-10-31</li>
</ul>
</li>
<li><p>解析json(get_json_object)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> get_json_object(<span class="hljs-string">&#x27;[&#123;&quot;name&quot;:&quot;大郎&quot;,&quot;sex&quot;:&quot;男&quot;,&quot;age&quot;:&quot;25&quot;&#125;,&#123;&quot;name&quot;:&quot;西门庆&quot;,&quot;sex&quot;:&quot;男&quot;,&quot;age&quot;:&quot;47&quot;&#125;]&#x27;</span>,<span class="hljs-string">&quot;$[0].age&quot;</span>);<br><br>- 结果：25<br><span class="hljs-keyword">select</span> get_json_object(<span class="hljs-string">&#x27;[&#123;&quot;name&quot;:&quot;大郎&quot;,&quot;sex&quot;:&quot;男&quot;,&quot;age&quot;:&quot;25&quot;&#125;,&#123;&quot;name&quot;:&quot;西门庆&quot;,&quot;sex&quot;:&quot;男&quot;,&quot;age&quot;:&quot;47&quot;&#125;]&#x27;</span>,<span class="hljs-string">&#x27;$[0]&#x27;</span>);<br><br>- 结果：&#123;&quot;name&quot;:&quot;大郎&quot;,&quot;sex&quot;:&quot;男&quot;,&quot;age&quot;:&quot;25&quot;&#125;<br><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>自定义函数</p>
<ul>
<li>UDF  解析公共字段（定义类  继承UDF，重写evaluate 方法）</li>
<li>UDTF  解析事件字段  （定义类  继承UDTF，重写3个方法，分别是初始化（定义返回值的名称和类型），process,关闭）</li>
</ul>
</li>
<li><p>窗口函数</p>
<ul>
<li>窗口函数：指定分析函数工作的数据窗口大小，这个数据窗口大小可能会随着行的变化变化。（查询的数据会随着where,gruopby,having等条件的加入过滤掉一些数据）</li>
<li>rank()排名会重复，重复数据的话，排名数不会连续，排名数和总数一样，dense_rank() 相同的排名一样，数据重复的话排名数会比总数少。row_number() 直接排名，相同排名也不一样，排名数和总数一样。</li>
<li>over((partition by xxx order by xxx)</li>
<li>手写topn</li>
</ul>
</li>
<li><p>优化</p>
<ul>
<li><p>sql优化</p>
<ul>
<li>大表对大表：尽量减少数据集，可以通过分区表，避免扫描全表或者全字段</li>
<li>大表对小表：设置自动识别小表，将小表放入内存中去执行</li>
</ul>
</li>
<li><p>mapjoin  默认打开 ，不要关闭</p>
</li>
<li><p>先执行where再执行join,可以通过先where过滤一部分数据，再进行连接</p>
</li>
<li><p>创建分区表（天）</p>
</li>
<li><p>小文件相关处理</p>
<ul>
<li>CombinehiveInputformat ===&gt;减少切片个数，减少maptask个数</li>
<li>JVM重用</li>
<li>使用concatenate命令   alter table B partition(day=20201224) concatenate;</li>
<li>ALTER TABLE A ARCHIVE PARTITION(dt=’2021-05-07’, hr=’12’);</li>
</ul>
</li>
<li><p>不影响业务逻辑的情况下可以开启map端combiner</p>
</li>
<li><p>merge 如果是map only任务，默认打开，执行完任务后，会产生大量小文件，默认会帮你开启一个job，将小于16M的文件，合并到256M。如果是mapreduce任务，需要将该功能开启</p>
</li>
<li><p>压缩</p>
</li>
<li><p>列式存储</p>
</li>
<li><p>替换引擎</p>
<ul>
<li>MR</li>
<li>TEZ</li>
<li>SPARK</li>
</ul>
</li>
<li><p>union，union all会去重</p>
</li>
<li><p>hive数据倾斜</p>
<ul>
<li><pre><code class="kotlin">set hive.groupby.skewindata=true
生成两个MRJOB，第一个MR，先随机打散key，减少数据倾斜。第二个MR，再根据预处理的数据结果按照Group By Key分布到reduce中，最终完成z
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Java-SE"><a href="#Java-SE" class="headerlink" title="Java SE"></a>Java SE</h2><ul>
<li>HashMap的底层源码，数据结构<ul>
<li>在JDK1.8中，HashMap由数组+链表+红黑树实现</li>
<li>链表长度大于8，且表的长度大于64的时候将链表转化为红黑树</li>
<li><a href="https://imgtu.com/i/4b4dAK"><img src="https://z3.ax1x.com/2021/10/02/4b4dAK.png" alt="4b4dAK.png"></a></li>
<li>红黑树其实就是一种<strong>自平衡</strong>的二叉查找树。</li>
</ul>
</li>
<li>HashMap和HashTable<ul>
<li>线程安全性不同<ul>
<li>HashMap是线程不安全的，HashTable是线程安全的，其中的方法是Synchronize的，在多线程并发的情况下，可以直接使用HashTable，但是使用HashMap是必须自己增加同步处理。</li>
</ul>
</li>
<li>key和value是否允许null值<ul>
<li>HashTable中，key和value都不允许出现null值。HashMap中，null可以作为键，这样的键只有一个，可以有一个或多个value值为null。</li>
</ul>
</li>
<li>数组初始化和扩容机制<ul>
<li>HashTable在不指定容量的情况下默认容量为11，而HashMap为16。</li>
<li>HashTable扩容时，将容量变为原来的2倍加1，而HashMap扩容时，将容量变为原来的两倍。</li>
</ul>
</li>
</ul>
</li>
<li>StringBuffer和StingBuilder的区别<ul>
<li>StringBuffer是线程安全的，而StringBuilder是线程不安全的</li>
<li>单线程程序下，StringBuilder效率更快，因为它不需要加锁，而StringBuffer则每次都需要判断锁，效率相对更低。</li>
</ul>
</li>
<li>String和StringBuffer的区别<ul>
<li>String类是final修饰的，它是一个字符串常量，因此它一旦创建，其内容和长度不可改变，StringBuffer类它的内容和长度都是可变的。</li>
<li>String类重写了equals()方法，StringBuffer没有</li>
<li>String类对象之间可以用“+”号连接，StringBuffer对象之间不能。</li>
</ul>
</li>
<li>Final，Finally，Finalize<ul>
<li>final：修饰符（关键字）有三种用法：修饰类，变量和方法。修饰类时，意味着它不能被继承。修饰变量时，该变量使用中不被改变，必须在声明时给定初值。修饰方法时，同样只能使用，不能在子类中被重写。</li>
<li>finally：通常放在try{}catch 的后面构造最终的执行代码块。这就意味着程序无论正常执行还是发生异常，这里的代码只要JVM不关闭都能执行。</li>
<li>finalize：Object类中定义的方法，Java中允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写finalize()方法可以整理系统资源或者执行其它清理工作。</li>
</ul>
</li>
<li>==和equals的区别<ul>
<li>==：如果是比较基本数据类型，那么比较的是变量的值。如果比较的是引用数据类型，那么比较的是地址值（两个对象是否指向同一块内存）</li>
<li>equals：如果类没重写equals方法比较的是两个对象的地址值，如果类重写了equals方法后我们往往比较的是对象中属性的内容。</li>
<li>equals方法是从Object类中继承的，默认的实现就是使用==</li>
</ul>
</li>
<li>常见执行顺序<ul>
<li>父类静态代码块——&gt;子类静态代码块——&gt;父类代码块——&gt;父类构造方法——&gt;子类代码块——&gt;子类构造方法</li>
</ul>
</li>
<li>ArrayList,HashMap扩容机制<ul>
<li>ArrayList初始化大小为0（第一次调用add 方法后长度变为10），当节点不够用时，就会扩容。扩容后的大小=原始大小*1.5</li>
<li>HashMap:初始化大小是16，扩容因子默认为0.75（可以指定初始化大小，和扩容因子）<ul>
<li>扩容机制：当前大小和当前容量的比例超过了扩容因子，就会扩容，扩容大小增大一倍。</li>
</ul>
</li>
</ul>
</li>
<li>Java接口和抽象类<ul>
<li>含有抽象方法的类必须定义为抽象类，但抽象类中可以不包含任何抽象方法。抽象类不能被实例化，只能通过子类来实现。</li>
<li>接口将抽象进行的更加彻底，在JDK1.8中，接口中除了可以有抽象方法外，还可以有常量，默认方法和静态方法（类方法），默认方法用default修饰，静态方法用static修饰，且这两种方法都允许有方法体。</li>
</ul>
</li>
<li>volatile关键字能否保证线程安全<ul>
<li>单纯使用volatile关键字是不能保证线程安全的</li>
<li>volatile只提供了一种弱的同步机制，用来确保将变量的更新操作通知到其他线程</li>
</ul>
</li>
</ul>
<h2 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h2><ul>
<li><p>Spark架构与作业提交流程</p>
<ul>
<li><p><a href="https://imgtu.com/i/5EtOoR"><img src="https://z3.ax1x.com/2021/10/10/5EtOoR.png" alt="5EtOoR.png"></a></p>
</li>
<li><p>Yarn Cluster模式</p>
<p><a href="https://imgtu.com/i/5ENNlT"><img src="https://z3.ax1x.com/2021/10/10/5ENNlT.png" alt="5ENNlT.png"></a></p>
<ul>
<li>脚本启动执行</li>
<li>调用Client类中的main方法并执行</li>
<li>向RM申请资源运行ApplicationMaster</li>
<li>选择一台NodeManager启动AM</li>
<li>AM启动Driver线程执行用户的作业</li>
<li>Driver向RM申请资源</li>
<li>在NM中创建Excutor对象</li>
</ul>
</li>
</ul>
</li>
<li><p>常见算子</p>
<ul>
<li>ReduceByKey和GroupByKey的区别<ul>
<li>ReduceByKey按照Key进行聚合，会在shuffle之前有combine（预聚合）操作，返回结果是RDD[k,v]</li>
<li>GroupByKey：按照Key进行分组，直接进行shuffle</li>
<li>ReduceByKey会有预聚合的操作，所以在不影响业务逻辑的情况下优先使用ReduceByKey。</li>
</ul>
</li>
<li>Repartition和Coalesce的关系与区别<ul>
<li>关系：两者都是用来改变RDD的partition数量的，Repartition底层调用coalesce((numPartitions, shuffle = true)</li>
<li>区别：Repartition一定会发生shuffle，coalesce根据传入的参数来判断是否发生shuffle。</li>
<li>一般增大RDD的partition数量时使用repartition，减少partition数量时使用coalesce</li>
</ul>
</li>
</ul>
<h3 id="Shuffle"><a href="#Shuffle" class="headerlink" title="Shuffle"></a>Shuffle</h3><ul>
<li><a href="https://imgtu.com/i/5Eyca8"><img src="https://z3.ax1x.com/2021/10/10/5Eyca8.png" alt="5Eyca8.png"></a></li>
<li>在划分stage时，最后一个stage称为finalStage，它本质上是一个ResultStage对象，前面的所有stage被称为ShuffleMapStage。</li>
<li>ShuffleMapStage的结束伴随着shuffle文件的写磁盘</li>
<li>ResultStage基本上对应代码中的action算子，即将一个函数应用在RDD的各个partition的数据集上，意味着一个job的运行结束。</li>
</ul>
</li>
<li><p>Task个数：</p>
<ul>
<li>map端的task个数等于分区数</li>
<li>reduce端的stage默认取spark.default.parallelism这个配置项的值作为分区数，如果没有配置，则以map端的最后一个RDD的分区数作为其分区数（也就是N），那么分区数就决定了reduce端的task的个数。</li>
</ul>
</li>
<li><p>Reduce端读取数据</p>
<ol>
<li><p>map task 执行完毕后会将计算状态以及磁盘小文件位置等信息封装到MapStatus对象中，然后由本进程中的MapOutPutTrackerWorker对象将mapStatus对象发送给Driver进程的MapOutPutTrackerMaster对象；</p>
</li>
<li><p><font color=red>在reduce task开始执行之前会先让本进程中的MapOutputTrackerWorker向Driver进程中的MapoutPutTrakcerMaster发动请求，请求磁盘小文件位置信息；</font></p>
</li>
<li><p><font color=red>当所有的Map task执行完毕后，Driver进程中的MapOutPutTrackerMaster就掌握了所有的磁盘小文件的位置信息。</font>此时MapOutPutTrackerMaster会告诉MapOutPutTrackerWorker磁盘小文件的位置信息；</p>
</li>
<li><p>完成之前的操作之后，由BlockTransforService去Executor0所在的节点拉数据，默认会启动五个子线程。每次拉取的数据量不能超过48M（reduce task每次最多拉取48M数据，将拉来的数据存储到Executor内存的20%内存中）。</p>
</li>
</ol>
</li>
<li><p>HashShuffle（已经弃用了）</p>
<ul>
<li>未经优化的HashShuffle<ul>
<li>对相同的key执行hash算法，从而将相同的key写入同一个文件中，而每一个磁盘文件都只属于下游stage的一个task。在将数据写入磁盘之前，会先将数据写入内存缓冲中，当内存缓冲填满之后，再溢写到磁盘文件中去。</li>
<li>下一个stage的task有多少个，当前Excutor的每个task就要创建多少份磁盘文件。如果分区数很多，则会造成大量的文件</li>
<li><a href="https://imgtu.com/i/5Ecfun"><img src="https://z3.ax1x.com/2021/10/10/5Ecfun.png" alt="5Ecfun.png"></a></li>
</ul>
</li>
<li>优化的HashShuffle<ul>
<li><a href="https://imgtu.com/i/5EgrrR"><img src="https://z3.ax1x.com/2021/10/10/5EgrrR.png" alt="5EgrrR.png"></a></li>
<li>优化后的HashShuffle，会将一个Excutor上所有task的文件都根据key分别写入到几个磁盘文件中。几个磁盘文件取决于下层task的数量。</li>
<li>优化后的Hashshuffle减少了大量的磁盘文件。</li>
</ul>
</li>
<li>不管是不是优化的hashShuffle都产生了大量的磁盘文件。所以在高版本的spark中已经被弃用。</li>
</ul>
</li>
<li><p>SortShuffle</p>
<ul>
<li><p>SortShuffle</p>
<ul>
<li><p><a href="https://imgtu.com/i/5EfCdI"><img src="https://z3.ax1x.com/2021/10/10/5EfCdI.png" alt="5EfCdI.png"></a></p>
</li>
<li><p>在该模式下，<font color=red>数据会先写入一个内存数据结构中，</font>此时根据不同的shuffle算子，可能选用不同的数据结构。如果是reduceByKey这种聚合类的shuffle算子，那么会选用Map数据结构，一边通过Map进行聚合，一边写入内存；如果是join这种普通的shuffle算子，那么会选用Array数据结构，直接写入内存。接着，<font color=red>每写一条数据进入内存数据结构之后，就会判断一下，是否达到了某个临界阈值。如果达到临界阈值的话，那么就会尝试将内存数据结构中的数据溢写到磁盘，然后清空内存数据结构。</font></p>
</li>
<li><p><font color=red>在溢写到磁盘文件之前，会先根据key对内存数据结构中已有的数据进行排序。排序过后，会分批将数据写入磁盘文件。</font>默认的batch数量是10000条，也就是说，排序好的数据，会以每批1万条数据的形式分批写入磁盘文件。写入磁盘文件是通过Java的BufferedOutputStream实现的。BufferedOutputStream是Java的缓冲输出流，首先会将数据缓冲在内存中，当内存缓冲满溢之后再一次写入磁盘文件中，这样可以减少磁盘IO次数，提升性能。</p>
</li>
<li><p><font color=red>一个task将所有数据写入内存数据结构的过程中，会发生多次磁盘溢写操作，也就会产生多个临时文件。最后会将之前所有的临时磁盘文件都进行合并，这就是merge过程，此时会将之前所有临时磁盘文件中的数据读取出来，然后依次写入最终的磁盘文件之中。</font>此外，由于一个task就只对应一个磁盘文件，也就意味着该task为下游stage的task准备的数据都在这一个文件中，因此还会单独写一份索引文件，其中标识了下游各个task的数据在文件中的start offset与end offset。</p>
</li>
<li><p>SortShuffleManager由于有一个磁盘文件merge的过程，因此大大减少了文件数量。比如第一个stage有50个task，总共有10个Executor，每个Executor执行5个task，而第二个stage有100个task。由于每个task最终只有一个磁盘文件，因此此时每个Executor上只有5个磁盘文件，所有Executor只有50个磁盘文件</p>
</li>
</ul>
</li>
<li><p>ByPassSortShuffle</p>
<ul>
<li><a href="https://imgtu.com/i/5VFM7j"><img src="https://z3.ax1x.com/2021/10/11/5VFM7j.png" alt="5VFM7j.png"></a></li>
<li>ByPassSortShuffle运行机制的触发条件<ul>
<li>map端没有预聚合（比如GroupByKey）</li>
<li>shuffle上一个阶段的最后一个RDD的分区数小于参数spark.shuffle.sort.bypassMergeThreshold（默认为200）</li>
</ul>
</li>
<li>此时，每个task会为每个下游task都创建一个临时磁盘文件，并将数据按key进行hash然后根据key的hash值，将key写入对应的磁盘文件中。写入磁盘文件也都是先写到内存缓存中，缓存写满后再溢写到磁盘文件中去。最后，会将所有的临时文件进行合并，合并成一个磁盘文件，并创建一个单独的索引文件。<font color=red>该过程的磁盘写机制其实跟未经优化的HashShuffleManager是一模一样的，因此都要创建数量惊人的磁盘文件，只是在最后会做一个磁盘文件的合并而已。</font>因此，该机制比未经优化的HashShuffle来说shuffle read的性能会更好。</li>
<li>与普通的SortShuffle比较：<ul>
<li>磁盘写机制不一样。ByPassSortShuffle每个Task会为下游都创建一个临时磁盘文件。普通的SortShuffle临时文件是溢写出来的，与下游task数量无关。</li>
<li>不会进行排序。(因此，该机制的好处就是shuffle write过程中，不需要进行数据的排序的操作，也就节省掉了这部分的性能开销。)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Spark优化"><a href="#Spark优化" class="headerlink" title="Spark优化"></a>Spark优化</h3><ul>
<li>常规优化<ul>
<li>增加资源。增加Excutor个数，增加每个Excutor的CPU core个数，增加每个Excutor的内存量。</li>
<li>RDD持久化，RDD序列化。RDD尽可能早的filter操作。</li>
<li>并行度的调节，Spark官方推荐，task数量应该设置为Spark作业总CPU core数量的2~3倍。</li>
<li>使用广播变量，序列化</li>
</ul>
</li>
<li>算子调优<ul>
<li>mapPartitions算子对RDD中的每个分区进行操作。提高了并行度。</li>
<li>在生产环境中，通常使用foreachPartition算子来完成数据库的写入，通过foreachPartition算子的特性，可以优化写数据库的性能。</li>
<li>ReduceByKey算子map端预聚合</li>
</ul>
</li>
<li>shuffle调优<ul>
<li>调节map端内存缓冲区的大小</li>
<li>调节Reduce端拉取数据内存缓冲区大小</li>
<li>调节sortshuffle排序操作阈值，如果确定业务不需要进行排序操作，可以将此参数调大一些，大于shuffle read task的数量，那么此时map端就不会进行排序了。</li>
</ul>
</li>
<li>故障排除<ul>
<li>控制reduce端缓冲区大小避免OOM,如果缓冲区过大，导致运算的内存不足，可能会出现OOM</li>
<li>checkpoint+cache同时使用。</li>
</ul>
</li>
</ul>
<h3 id="数据倾斜"><a href="#数据倾斜" class="headerlink" title="数据倾斜"></a>数据倾斜</h3><ul>
<li><p>定位数据倾斜问题：</p>
<ul>
<li>查看代码中的shuffle算子，例如：distinct，reparation, reduceByKey,countByKey,GroupByKey,join等算子，根据代码逻辑判断此处是否会出现数据倾斜。</li>
<li>查看Spark作业的log文件</li>
</ul>
</li>
<li><p>解决数据倾斜：</p>
<ul>
<li><p>聚合原数据</p>
<ul>
<li>避免shuffle过程，如果避免了shuffle过程，那么就从根本上消除了发生数据倾斜问题的可能。</li>
<li>增大key粒度，比如，原来是统计每个区的一个统计量，现在将粒度增大，变成统计一个省的某些数据。</li>
</ul>
</li>
<li><p>提高reduce的并行度</p>
</li>
<li><p>使用随机key实现双重聚合</p>
<ul>
<li>当使用了类似于groupByKey，reduceByKey这样的算子时，可以考虑使用随机key实现双重聚合。</li>
<li>首先，<font color=red>通过map算子给每个数据的key添加随机前缀，对key进行打散，将原先一样的key变成不一样的key，然后进行第一次聚合，这样就可以让原本被一个task处理的数据分散到多个task上去做局部聚合，随后，去掉每个key的前缀，再次进行聚合。</font></li>
<li>此方法仅适用于聚合类的shuffle操作</li>
<li><a href="https://imgtu.com/i/5V0IgI"><img src="https://z3.ax1x.com/2021/10/11/5V0IgI.png" alt="5V0IgI.png"></a></li>
</ul>
</li>
<li><p>将reduce join转换成map join</p>
<ul>
<li>采用广播小RDD全量数据+map算子。（RDD是不能进行广播的，只能将RDD内部的数据通过collect拉取到Driver内存然后再进行广播）</li>
<li>核心思路：<font color=red>将较小RDD中的数据直接通过collect算子拉取到Driver端的内存中来，然后对其创建一个Broadcast变量；接着对另外一个RDD执行map类算子，在算子函数内，从Broadcast变量中获取较小RDD的全量数据，与当前RDD的每一条数据按照连接key比较，如果连接key相同，那么就将两个RDD根据需求连接起来。</font></li>
<li><a href="https://imgtu.com/i/5VrVj1"><img src="https://z3.ax1x.com/2021/10/11/5VrVj1.png" alt="5VrVj1.png"></a></li>
<li>此方法适合小RDD和大RDD之间的join操作。与MapReduce中的mapjoin操作类似。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="数仓项目分层"><a href="#数仓项目分层" class="headerlink" title="数仓项目分层"></a>数仓项目分层</h2><ul>
<li>ODS<ul>
<li>保持数据原貌，（数据备份的作用）</li>
<li>采用压缩    LZO  ==》减少磁盘空间  100g ==&gt;10g</li>
<li>创建分区表  ：==》防止后续计算时的全表扫描</li>
</ul>
</li>
<li>DWD<ul>
<li>数据清洗   <ul>
<li>解析数据</li>
<li>核心字段不能为空</li>
<li>过期数据清除</li>
<li>重复数据，进行过滤</li>
</ul>
</li>
<li>采用压缩，创建分区表，采用列式存储</li>
<li><strong>维度退化</strong></li>
<li><strong>维度建模</strong><ul>
<li>选择业务过程<ul>
<li>关心的事实表（下单，支付，点赞，收藏）</li>
</ul>
</li>
<li>声明粒度<ul>
<li>一行信息表示什么含义：1次，1h ,1day…..</li>
<li>根据实际情况选择，最小粒度可以统计所有指标</li>
</ul>
</li>
<li>确定维度<ul>
<li>维度：时间，地区，用户，商品，活动，优惠卷</li>
<li>维度退化（维度建模当中的星型模型，让事实表周围只有一级维度）</li>
<li>商品表+商品SPU表+商品SKU表+三级分类+二级分类+一级分类==》商品表</li>
<li>省份表+地区表==》地区表</li>
<li>时间表+假期表==》时间表</li>
<li>活动表+活动规则表==》活动表</li>
</ul>
</li>
<li>确定事实<ul>
<li>确定事实表的度量值（次数，个数，金额之类的可累加的统计值）</li>
<li>度量值的特点就是可以累加</li>
</ul>
</li>
<li>通过上面的四步，结合数仓的业务事实，得出业务总线矩阵图</li>
</ul>
</li>
</ul>
</li>
<li>DWS<ul>
<li>站在维度表的角度去看待事实，主要看事实表的度量值</li>
</ul>
</li>
<li>DWT<ul>
<li>站在维度表的角度去看待事实</li>
<li>主要关心事实表的度量值的累加值、和累积一段时间的值，还有行为的开始时间，结束时间</li>
</ul>
</li>
<li>ADS<ul>
<li>一些结果指标</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>Hive</tag>
        <tag>Flume</tag>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>java8新特性</title>
    <url>/2021/04/23/java8-new-features/</url>
    <content><![CDATA[<h1 id="Java8新特性"><a href="#Java8新特性" class="headerlink" title="Java8新特性"></a>Java8新特性</h1><h2 id="Lambda表达式与函数式接口"><a href="#Lambda表达式与函数式接口" class="headerlink" title="Lambda表达式与函数式接口"></a>Lambda表达式与函数式接口</h2><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><blockquote>
<ol>
<li>Consumer<T> 消费器, 作用是消费一个T类型的对象, 并没有返回.</li>
</ol>
<ul>
<li>void accept(T t) : 有输入无输出</li>
</ul>
</blockquote>
<hr>
<blockquote>
<ol start="2">
<li>Supplier<T> 供给器, 作用是供给一个T类型的对象, 不需要参数.</li>
</ol>
<ul>
<li>T get() : 无输入有输出</li>
</ul>
</blockquote>
<hr>
<blockquote>
<ol start="3">
<li>Function&lt;T, R&gt; 转换器, 作用是输入一个T类型对象, 经过处理, 返回的是R类型对象.</li>
</ol>
<ul>
<li>R apply(T t) : 有输入有输出</li>
</ul>
</blockquote>
<hr>
<blockquote>
<ol start="4">
<li>Predicate<T> 判定器, 作用是输入一个T类型对象, 经过某种判断, 返回true或false</li>
</ol>
<ul>
<li>boolean test(T t) : 有输入有固定输出布尔</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> java8;<br><br><span class="hljs-keyword">import</span> java.util.function.Consumer;<br><span class="hljs-keyword">import</span> java.util.function.Function;<br><span class="hljs-keyword">import</span> java.util.function.Predicate;<br><span class="hljs-keyword">import</span> java.util.function.Supplier;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> javabean.Student;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 函数式接口</span><br><span class="hljs-comment"> * 		只有一个抽象方法的接口, 可以用<span class="hljs-doctag">@FunctionalInterface</span>修饰</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * Consumer&lt;T&gt; 消费器, 作用是消费一个T类型的对象, 并没有返回.</span><br><span class="hljs-comment"> * 		void accept(T t) : 有输入无输出</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * Supplier&lt;T&gt; 供给器, 作用是供给一个T类型的对象, 不需要参数.</span><br><span class="hljs-comment"> * 		T get() : 无输入有输出</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * Function&lt;T, R&gt; 转换器, 作用是输入一个T类型对象, 经过处理, 返回的是R类型对象.</span><br><span class="hljs-comment"> * 		R apply(T t) : 有输入有输出</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * Predicate&lt;T&gt; 判定器, 作用是输入一个T类型对象, 经过某种判断, 返回true或false</span><br><span class="hljs-comment"> * 		boolean test(T t) : 有输入有固定输出布尔</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 方法引用 : 接口中的抽象方法的模式(输入和输出) 和 Lambda体中的方法调用是一致时, 就可以简化写法.</span><br><span class="hljs-comment"> * 类或对象 :: 方法名</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FunctionTest</span> </span>&#123;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exer22</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">//Supplier&lt;Student&gt; supplier2 = () -&gt; new Student();</span><br>		Supplier&lt;Student&gt; supplier2 = Student::<span class="hljs-keyword">new</span>;<br>		System.out.println(supplier2.get());<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test42</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">//Function&lt;Integer, String&gt; function2 = t -&gt; String.valueOf(t);</span><br>		Function&lt;Integer, String&gt; function2 = String::valueOf;<br>		System.out.println(function2.apply(<span class="hljs-number">1112</span>));<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test32</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">//Supplier&lt;Double&gt; supplier2 = () -&gt; Math.random();</span><br>		Supplier&lt;Double&gt; supplier2 = Math::random;<br>		System.out.println(supplier2.get());<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test12</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">//Consumer&lt;String&gt; consumer2 = t -&gt; System.out.println(t);</span><br>		Consumer&lt;String&gt; consumer2 = System.out::println;<br>		consumer2.accept(<span class="hljs-string">&quot;lkjxlkcjccc&quot;</span>);<br>	&#125;<br>	<br>	<span class="hljs-comment">// 写一个判定器, 判断一个学生是否及格</span><br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exer4</span><span class="hljs-params">()</span> </span>&#123;<br>		Predicate&lt;Integer&gt; predicate1 = <span class="hljs-keyword">new</span> Predicate&lt;Integer&gt;() &#123;<br>			<span class="hljs-meta">@Override</span><br>			<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(Integer t)</span> </span>&#123;<br>				<span class="hljs-keyword">return</span> t&gt;= <span class="hljs-number">60</span>;<br>			&#125;<br>		&#125;;<br>		<span class="hljs-keyword">boolean</span> test = predicate1.test(<span class="hljs-number">100</span>);<br>		System.out.println(test);<br>		<br>		Predicate&lt;Integer&gt; predicate2 = t -&gt; t &gt;= <span class="hljs-number">60</span>;<br>		System.out.println(predicate2.test(<span class="hljs-number">100</span>));<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span> </span>&#123;<br>		Predicate&lt;Integer&gt; predicate1 = <span class="hljs-keyword">new</span> Predicate&lt;Integer&gt;() &#123;<br>			<span class="hljs-meta">@Override</span><br>			<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(Integer t)</span> </span>&#123;<br>				<span class="hljs-keyword">return</span> t % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<br>			&#125;<br>		&#125;;<br>		<span class="hljs-keyword">boolean</span> test = predicate1.test(<span class="hljs-number">83</span>);<br>		System.out.println(test);<br>		<br>		Predicate&lt;Integer&gt; predicate2 = t -&gt; t % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<br>		System.out.println(predicate2.test(<span class="hljs-number">20</span>));<br>	&#125;<br>	<br>	<span class="hljs-comment">// 写一个转换器, 把学生对象转换成字符串, 内容是姓名+分数</span><br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exer3</span><span class="hljs-params">()</span> </span>&#123;<br>		Function&lt;Student, String&gt; function1 = <span class="hljs-keyword">new</span> Function&lt;Student, String&gt;() &#123;<br>			<span class="hljs-meta">@Override</span><br>			<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">apply</span><span class="hljs-params">(Student t)</span> </span>&#123;<br>				<span class="hljs-keyword">return</span> t.getName() + <span class="hljs-string">&quot;:&quot;</span> + t.getScore();<br>			&#125;<br>		&#125;;<br>		String apply = function1.apply(<span class="hljs-keyword">new</span> Student(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;小刚&quot;</span>, <span class="hljs-number">5</span>, <span class="hljs-number">80</span>));<br>		System.out.println(apply);<br>		<br>		Function&lt;Student, String&gt; function2 = t -&gt; t.getName() + <span class="hljs-string">&quot;:&quot;</span> + t.getScore();<br>		System.out.println(function2.apply(<span class="hljs-keyword">new</span> Student(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;小花&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">100</span>)));<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>&#123;<br>		Function&lt;Integer, String&gt; function1 = <span class="hljs-keyword">new</span> Function&lt;Integer, String&gt;() &#123;<br>			<span class="hljs-meta">@Override</span><br>			<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">apply</span><span class="hljs-params">(Integer t)</span> </span>&#123;<br>				<span class="hljs-keyword">return</span> String.valueOf(t);<br>			&#125;<br>		&#125;;<br>		<br>		String apply = function1.apply(<span class="hljs-number">9238</span>);<br>		System.out.println(apply);<br>		<br>		Function&lt;Integer, String&gt; function2 = t -&gt; String.valueOf(t);<br>		System.out.println(function2.apply(<span class="hljs-number">1112</span>));<br>	&#125;<br>	<br>	<span class="hljs-comment">// 写一个供给器, 每调用一次供给一个学生对象</span><br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exer2</span><span class="hljs-params">()</span> </span>&#123;<br>		Supplier&lt;Student&gt; supplier1 = <span class="hljs-keyword">new</span> Supplier&lt;Student&gt;() &#123;<br>			<span class="hljs-meta">@Override</span><br>			<span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>				<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Student();<br>			&#125;<br>		&#125;;<br>		Student student = supplier1.get();<br>		System.out.println(student);<br>		<br>		Supplier&lt;Student&gt; supplier2 = () -&gt; <span class="hljs-keyword">new</span> Student();<br>		System.out.println(supplier2.get());<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;<br>		Supplier&lt;Double&gt; supplier = <span class="hljs-keyword">new</span> Supplier&lt;Double&gt;() &#123;<br>			<span class="hljs-meta">@Override</span><br>			<span class="hljs-function"><span class="hljs-keyword">public</span> Double <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>				<span class="hljs-keyword">return</span> Math.random();<br>			&#125;<br>		&#125;;<br>		System.out.println(supplier.get());<br>		<br>		Supplier&lt;Double&gt; supplier2 = () -&gt; Math.random();<br>		System.out.println(supplier2.get());<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br>		Supplier&lt;Integer&gt; supplier1 = <span class="hljs-keyword">new</span> Supplier&lt;Integer&gt;() &#123;<br>			<span class="hljs-meta">@Override</span><br>			<span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>				<span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>			&#125;<br>		&#125;;<br>		Integer integer = supplier1.get();<br>		System.out.println(integer);<br>		<br>		Supplier&lt;Integer&gt; supplier2 = () -&gt; <span class="hljs-number">100</span>;<br>		Integer integer2 = supplier2.get();<br>		System.out.println(integer2);<br>	&#125;<br>	<br>	<span class="hljs-comment">// 写一个消费器, 消费一个Student对象.</span><br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exer1</span><span class="hljs-params">()</span> </span>&#123;<br>		Consumer&lt;Student&gt; consumer1 = <span class="hljs-keyword">new</span> Consumer&lt;Student&gt;() &#123;<br>			<span class="hljs-meta">@Override</span><br>			<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Student t)</span> </span>&#123;<br>				System.out.println(t);<br>			&#125;<br>		&#125;;<br>		consumer1.accept(<span class="hljs-keyword">new</span> Student());<br>		<br>		Consumer&lt;Student&gt; consumer2 = t -&gt; System.out.println(t);<br>		consumer2.accept(<span class="hljs-keyword">new</span> Student(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;小花&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">50</span>));<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br>		Consumer&lt;String&gt; consumer1 = <span class="hljs-keyword">new</span> Consumer&lt;String&gt;() &#123;<br>			<span class="hljs-meta">@Override</span><br>			<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(String t)</span> </span>&#123;<br>				System.out.println(t);<br>			&#125;<br>		&#125;;<br>		consumer1.accept(<span class="hljs-string">&quot;alsdkjfalksdjf&quot;</span>);<br>		<br>		Consumer&lt;String&gt; consumer2 = t -&gt; System.out.println(t);<br>		consumer2.accept(<span class="hljs-string">&quot;lkjxlkcjccc&quot;</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> java8;<br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.stream.Collectors;<br><span class="hljs-keyword">import</span> java.util.stream.Stream;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> javabean.Student;<br><span class="hljs-keyword">import</span> javabean.StudentTest;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Stream : </span><br><span class="hljs-comment"> * 	1) 不保存数据, 只负责处理数据</span><br><span class="hljs-comment"> * 	2) 处理数据不会造成原始数据的变化 , 每次处理都会产生新的流</span><br><span class="hljs-comment"> * 	3) 所有操作都是延迟执行的, 只有终止操作执行时才执行中间操作</span><br><span class="hljs-comment"> * 	4) 每个流只能&quot;消费&quot;一次, 消费过后就作废.</span><br><span class="hljs-comment"> * 	5) 单向, 一次性使用, 可以支持高并发...</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 典型的操作 :</span><br><span class="hljs-comment"> * 	1) 创建流(获取流) </span><br><span class="hljs-comment"> * 		1) 从集合获取流, 集合.stream();</span><br><span class="hljs-comment"> * 		2) 从数组获取流, Arrays.stream(Xxx[] arr);</span><br><span class="hljs-comment"> * 		3) 基于散数据, Stream.of(T... objs)</span><br><span class="hljs-comment"> * 		4) 使用供给器, 无限流</span><br><span class="hljs-comment"> * 	2) 中间操作, 多个中间操作就形成流水线, 是延迟执行的, 中间操作可以省略</span><br><span class="hljs-comment"> * 		***filter(Predicate p) : 让流中的每个对象都经过判定器, 如果结果为true留下, 如果是false丢弃. 产生新流</span><br><span class="hljs-comment"> * 		distinct(); 把流中的数据去重并产生新流, 依据对象的hashCode和equals</span><br><span class="hljs-comment"> * 		limit(long maxSize) 限制流中的最大数据量</span><br><span class="hljs-comment"> * 		skip(long n) 跳过前n个元素</span><br><span class="hljs-comment"> * 		***map(Function f) 让流中的每个对象都转换为新对象, 所以它的结果的流全变了.</span><br><span class="hljs-comment"> * 		sorted() 把流中的对象排序 , 自然排序</span><br><span class="hljs-comment"> * 		*sorted(Comparator c) 定制排序</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 	3) 终止操作, 一旦中止, 所有的中间操作就开始执行, 终止操作是必须的.</span><br><span class="hljs-comment"> * 		***forEach(Consumer c) : 让流中的每个对象都经过消费器消费一下.</span><br><span class="hljs-comment"> * 		findFirst() 返回流中的第一个对象</span><br><span class="hljs-comment"> * 		**count() 计数</span><br><span class="hljs-comment"> * 		**collect(采集器) 可以把结果集采集到一个新的容器中.</span><br><span class="hljs-comment"> * 		***reduce(BinaryOperator op) 把流中的对象两两处理最后产生一个结果</span><br><span class="hljs-comment"> *	</span><br><span class="hljs-comment"> *	Optional是一容器, 里面放一个引用, 如果引用为空, 获取时直接抛异常.</span><br><span class="hljs-comment"> *	防止空指针.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamTest</span> </span>&#123;<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exer6</span><span class="hljs-params">()</span> </span>&#123;<br>		List&lt;Student&gt; collect = StudentTest.getList()<br>					.stream()<br>					.distinct()<br>					.filter(t -&gt; t.getGrade() == <span class="hljs-number">3</span>)<br>					.filter(t -&gt; t.getScore() &lt; <span class="hljs-number">60</span>).sorted((o1, o2) -&gt; -(<span class="hljs-keyword">int</span>)(o1.getScore() - o2.getScore()))<br>					.collect(Collectors.toList());<br>		<span class="hljs-keyword">for</span> (Student student : collect) &#123;<br>			System.out.println(student);<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-comment">// 找出全校最高分</span><br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exer5</span><span class="hljs-params">()</span> </span>&#123;<br>		Optional&lt;Double&gt; reduce = StudentTest.getList().stream().distinct().map(t -&gt; t.getScore()).reduce((d1, d2) -&gt; d1 &gt; d2 ? d1 : d2);<br>		Double orElse = reduce.orElse((<span class="hljs-keyword">double</span>) <span class="hljs-number">999</span>);<br>		System.out.println(orElse);<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exer4</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">long</span> count = StudentTest.getList().stream().distinct().count();<br>		System.out.println(count);<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exer3</span><span class="hljs-params">()</span> </span>&#123;<br>		Optional&lt;Student&gt; findFirst = StudentTest.getList()<br>												.stream()<br>												.distinct()<br>												.filter(t -&gt; t.getGrade() == <span class="hljs-number">4</span>)<br>												.filter(t -&gt; t.getScore() &lt; <span class="hljs-number">60</span>).sorted((o1, o2) -&gt; -(<span class="hljs-keyword">int</span>)(o1.getScore() - o2.getScore()))<br>												.limit(<span class="hljs-number">2</span>).findFirst();<br>		<span class="hljs-comment">//Student student = findFirst.get();</span><br>		Student student = findFirst.orElse(<span class="hljs-keyword">new</span> Student()); <span class="hljs-comment">// 最大化减少空指针</span><br>		System.out.println(student);<br>	&#125;<br>		<br>	<span class="hljs-comment">// 3年级没有及格的同学倒序, 取出前2个.</span><br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exer2</span><span class="hljs-params">()</span> </span>&#123;<br>		StudentTest.getList()<br>					.stream()<br>					.distinct()<br>					.filter(t -&gt; t.getGrade() == <span class="hljs-number">3</span>)<br>					.filter(t -&gt; t.getScore() &lt; <span class="hljs-number">60</span>).sorted((o1, o2) -&gt; -(<span class="hljs-keyword">int</span>)(o1.getScore() - o2.getScore()))<br>					.limit(<span class="hljs-number">2</span>).forEach(System.out::println);<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test9</span><span class="hljs-params">()</span> </span>&#123;<br>		StudentTest.getList().stream().distinct().sorted((t1, t2) -&gt; (<span class="hljs-keyword">int</span>)(t1.getScore() - t2.getScore())).forEach(System.out::println);<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test8</span><span class="hljs-params">()</span> </span>&#123;<br>		StudentTest.getList().stream().distinct().map(t -&gt; t.getScore()).forEach(System.out::println);<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test7</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">// 第6个到第10个</span><br>		StudentTest.getList().stream().distinct().skip(<span class="hljs-number">10</span>).limit(<span class="hljs-number">5</span>).forEach(System.out::println);<br>	&#125;<br>	<br>	<span class="hljs-comment">// 找出5年级姓张的同学</span><br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exer1</span><span class="hljs-params">()</span> </span>&#123;<br>		List&lt;Student&gt; list = StudentTest.getList();<br>		list.stream().filter(t -&gt; t.getGrade() == <span class="hljs-number">5</span>).filter(t -&gt; t.getName().startsWith(<span class="hljs-string">&quot;张&quot;</span>)).forEach(System.out::println);<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test62</span><span class="hljs-params">()</span> </span>&#123;<br>		List&lt;Student&gt; list = StudentTest.getList();<br>		list.stream().filter(t -&gt; t.getGrade() == <span class="hljs-number">3</span>).filter(t -&gt; t.getScore() &gt;= <span class="hljs-number">60</span>).forEach(System.out::println);<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test6</span><span class="hljs-params">()</span> </span>&#123;<br>		List&lt;Student&gt; list = StudentTest.getList();<br>		Stream&lt;Student&gt; stream = list.stream();<br>		Stream&lt;Student&gt; stream2 = stream.filter(t -&gt; t.getGrade() == <span class="hljs-number">3</span>);<br>		Stream&lt;Student&gt; stream3 = stream2.filter(t -&gt; t.getScore() &gt;= <span class="hljs-number">60</span>);<br>		stream3.forEach(System.out::println);<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span> </span>&#123;<br>		Stream.generate(Math::random).limit(<span class="hljs-number">10</span>).forEach(System.out::println);<span class="hljs-comment">// 无限流</span><br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>&#123;<br>		Stream&lt;Integer&gt; generate = Stream.generate(() -&gt; <span class="hljs-number">200</span>); <span class="hljs-comment">// 无限流</span><br>		generate.forEach(System.out::println);<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;<br>		Stream&lt;Number&gt; of = Stream.of(<span class="hljs-number">3.22</span>, <span class="hljs-number">9.33</span>, <span class="hljs-number">4.88</span>, <span class="hljs-number">4.2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>		of.forEach(System.out::println);<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br>		String[] arr = &#123;<span class="hljs-string">&quot;kjsf&quot;</span>, <span class="hljs-string">&quot;qqa&quot;</span>, <span class="hljs-string">&quot;cv&quot;</span>, <span class="hljs-string">&quot;XXX&quot;</span>&#125;;<br>		Stream&lt;String&gt; stream = Arrays.stream(arr);<br>		stream.forEach(System.out::println);<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br>		List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>			list.add((<span class="hljs-keyword">int</span>)(Math.random() * <span class="hljs-number">20</span>));<br>		&#125;<br>		System.out.println(list);<br>		<br>		Stream&lt;Integer&gt; stream = list.stream();<br>		stream.forEach(System.out::println);<br>		<br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/2021/04/25/mysql/</url>
    <content><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="https://pic2.zhimg.com/9bb3acbba65f349299df27a93286ffb1_r.jpg" alt="Mysql架构"></p>
<ul>
<li><p>连接层：最上层是一些客户端和连接服务。主要完成一些类似于连接处理，授权认证以及相关的安全方案。</p>
</li>
<li><p>服务层：</p>
<table>
<thead>
<tr>
<th>Management Serveices &amp; Utilities</th>
<th>系统管理和控制工具</th>
</tr>
</thead>
<tbody><tr>
<td>SQL Interface:</td>
<td>SQL接口。接受用户的SQL命令，并且返回用户需要查询的结果。比如select from就是调用SQL Interface</td>
</tr>
<tr>
<td>Parser</td>
<td>解析器。 SQL命令传递到解析器的时候会被解析器验证和解析</td>
</tr>
<tr>
<td>Optimizer</td>
<td>查询优化器。  SQL语句在查询之前会使用查询优化器对查询进行优化，比如有where条件时，优化器来决定先投影还是先过滤。</td>
</tr>
<tr>
<td>Cache和Buffer</td>
<td>查询缓存。如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等</td>
</tr>
</tbody></table>
</li>
<li><p>引擎层：存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的实际需求进行选取。</p>
</li>
<li><p>存储层：数据存储层，主要是将数据存储在运行与裸设备的文件系统之上，并完成与存储引擎的交互。</p>
</li>
</ul>
<h2 id="大致的查询流程"><a href="#大致的查询流程" class="headerlink" title="大致的查询流程"></a>大致的查询流程</h2><ul>
<li>MySQL客户端通过协议与MySQL服务器建立连接，发送查询语句，先检查缓存，如果命中直接返回结果。</li>
<li>语法解析器和预处理：首先MySQL通过关键字将SQL语句进行解析，并生成一颗对应的“解析树”。MySQL解析器使用MySQL语法规则验证和解析查询，预处理器则根据一些MySQL规则进一步检查解析树是否合法。</li>
<li>查询优化器当解析树被认为是合法的了，并且由优化器将其转化成执行计划。一条查询可以有很多种执行方式，最后都返回相同的结果。查询优化器会找出其中最好的执行计划。</li>
<li>MySQL使用默认的B+树索引</li>
</ul>
<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><ul>
<li><p>InnoDB:默认使用</p>
<ul>
<li>InnoDB自增主键：InnoDB表如果没有指定主键，InnoDB会自动从表中选择合适的字段作为主键，如果没有合适的字段，InnoDB会创建一个不可见的，长度为6个字节的row_id。InnoDB维护了一个全局的dict_sys.row_id值，所有无主键的InnoDB表，每插入一行数据，都将当前的dict_sys.row_id值作为要插入数据的row_id，然后把dict_sys.row_id的值加1。</li>
</ul>
</li>
<li><p>MyISAM：自带系统表使用</p>
</li>
<li><p>InnoDB的数据文件自己就是索引文件。MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。</p>
</li>
<li><p>由于InnoDB的数据文件自己要按主键汇集，因此InnoDB要求必须有主键（MyISAM能够没有），若是没有显示指定，则MySQL系统会自动选择一个能够唯一标识数据记录的列作为主键，若不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。</p>
<table>
<thead>
<tr>
<th>对比项</th>
<th>MyISAM</th>
<th>InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td>外键</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>事务</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>行表锁</td>
<td>表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td>
<td>行锁,操作时只锁某一行，不对其它行有影响，,<font color=red>适合高并发的操作</font></td>
</tr>
<tr>
<td>缓存</td>
<td>只缓存索引，不缓存真实数据</td>
<td>不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响</td>
</tr>
<tr>
<td>关注点</td>
<td>节省资源、消耗少、简单业务</td>
<td>并发写、事务、更大资源</td>
</tr>
<tr>
<td>默认安装</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>默认使用</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>自带系统表使用</td>
<td>Y</td>
<td>N</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul>
<li><p>创建索引的方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs sqlite">--直接创建索引<br>create index index_name on table (column(length))<br>--修改表结构的方式添加索引<br>alter table table_name add index index_name on (column(length))<br>--创建表的时候同时创建索引<br>CREATE TABLE &#96;table&#96; (<br>	&#96;id&#96; int(11) NOT NULL AUTO_INCREMENT ,<br>	&#96;title&#96; char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,<br>	&#96;content&#96; text CHARACTER SET utf8 COLLATE utf8_general_ci NULL ,<br>	&#96;time&#96; int(10) NULL DEFAULT NULL ,<br>	PRIMARY KEY (&#96;id&#96;),<br>	INDEX index_name (title(length))<br>)<br>-- 删除索引<br>ALTER TABLE table_name DROP INDEX index_name<br>DROP INDEX index_name ON table_name<br></code></pre></td></tr></table></figure></li>
<li><p>Btree索引：</p>
<p><a href="https://imgtu.com/i/4qdvuQ"><img src="https://z3.ax1x.com/2021/10/03/4qdvuQ.png" alt="4qdvuQ.png"></a></p>
<ul>
<li>查找过程：<ul>
<li>如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。</li>
</ul>
</li>
</ul>
</li>
<li><p>B+tree索引：MySQL默认索引</p>
<p><a href="https://imgtu.com/i/4qwF3T"><img src="https://z3.ax1x.com/2021/10/03/4qwF3T.png" alt="4qwF3T.png"></a></p>
</li>
<li><p>b树和b+树的区别：</p>
<ul>
<li>b树索引，关键字，记录是放在一起的。b+树的非叶子节点只有指向下一个节点的索引和关键字，记录只存放在叶子节点中。</li>
<li>b树中越靠近根节点的记录查的越快。而b+树每个记录的查找时间都是一样的，都需要从根节点走到叶子节点，并在叶子节点中查找关键字。</li>
<li>b+树的性能更好。因为b+树的非叶子节点不存放实际的数据，因此可以容纳的元素的更多，同样的数据下，树高比b树小，这样带来的好处是减少磁盘访问次数（例如，同样的数据量，b树三层，b+树两层，这样的话b+树就少一次IO操作，会快很多）。尽管B+树找到一个记录所需的比较次数要比b树多，但是一次磁盘访问的时间远远比内存比较的时间长。实际中，b+树的性能更好一些，而且b+树的叶子节点使用指针连接在一起，方便顺序遍历（例如查看一个目录下的所有文件，一个表中的所有记录等），这也是很多数据库和文件系统使用b+树的缘故。</li>
</ul>
</li>
<li><p>为什么B+树更适合在实际应用中做操作系统的文件索引和数据库索引？</p>
<ul>
<li>b+树的磁盘读写代价更低</li>
<li>b+树的查询效率更稳定。每个数据的查询效率相当。</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>C/S 架构</li>
<li>服务器程序是 mysqld.exe</li>
<li>客户端程序是 mysql.exe</li>
<li>cmd的打开方式：</li>
</ul>
</blockquote>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">mysql -uroot -p123456 -h127.0.0.1 -P3306<br>长选项：<br>mysql <span class="hljs-attribute">--host</span>=主机地址 <span class="hljs-attribute">--port</span>=端口 <span class="hljs-attribute">--user</span>=用户名 <span class="hljs-attribute">--password</span>=密码 默认数据库<br></code></pre></td></tr></table></figure>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><blockquote>
<ul>
<li>查看服务器中的所有数据库</li>
</ul>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">databases</span>;<br></code></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>创建新的数据库</li>
<li>数据库以目录的形式保存在服务器<br>安装目录/data目录下</li>
</ul>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">databases</span>;<br></code></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>切换当前工作数据库<br>mysql&gt; use company;</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>查看当前数据库中的所有表<br>show tables;</li>
<li>跨库查看表<br>show tables from 其他库</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>把.sql文件中数据导入数据库<br>source e:sql/company.sql;</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>查看表中的所有数据<br>select * from employees;</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>创建world数据库, 并导入 world.sql , 查看表中的数据</li>
<li>create database world;</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>use world;</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>source d:/mywork/mysql/world.sql;</li>
<li>查看当前数据库<br>select database();</li>
<li>创建表</li>
</ul>
</blockquote>
<figure class="highlight crystal"><table><tr><td class="code"><pre><code class="hljs crystal">create table customer(<br>	id int,<br>	name varchar(<span class="hljs-number">20</span>),<br>	age int,<br>	email varchar(<span class="hljs-number">50</span>),<br>	gender <span class="hljs-class"><span class="hljs-keyword">enum</span>(&#x27;男&#x27;, &#x27;女&#x27;)</span><br>);<br></code></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>丢弃表<br>drop table customer;</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>查看表结构<br>describe customer;</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>desc 表名</li>
<li>查看表的建表语句<br>show create table 表名;</li>
<li>插入数据</li>
<li>存储引擎 : InnoDB(支持事务, 外键等高级特性), MyISAM(不支持事务, 不支持外键)</li>
<li>show engines;显示支持的引擎</li>
<li>``号专门用于包围数据库对象的名称(数据库, 表, 列, 主键, 外键, 索引, 函数, 存储过程, 触发器)<br>查询表中的所有数据</li>
<li>select * from 表名; from关键字可以省略</li>
</ul>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">插入数据<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> customer(<br>	<span class="hljs-keyword">id</span>,<br>	<span class="hljs-keyword">name</span>,<br>	age,<br>	email,<br>	gender <br>) <span class="hljs-keyword">values</span> (<br>	<span class="hljs-number">1</span>,<br>	<span class="hljs-string">&#x27;张三&#x27;</span>,<br>	<span class="hljs-number">30</span>,<br>	<span class="hljs-string">&#x27;zhang3@qq.com&#x27;</span>,<br>	<span class="hljs-string">&#x27;男&#x27;</span><br>);<br></code></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>修改数据, 如果没有where 语句会导致修改所有记录</li>
</ul>
</blockquote>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">update<span class="hljs-built_in"> customer </span><span class="hljs-builtin-name">set</span> <br>	age = 3,<br>	email = <span class="hljs-string">&#x27;QQQ&#x27;</span><br>where <br>	id = 1;<br></code></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>删除数据, 如果没有where语句会导致删除所有记录</li>
</ul>
</blockquote>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">delete <span class="hljs-keyword">from</span> customer<br>where id = 3;<br></code></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>针对数据的操作.</li>
</ul>
</blockquote>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">C insert into  <span class="hljs-regexp">//</span>Create <br>R select 		<span class="hljs-regexp">//</span>Retrieve<br>U update 		<span class="hljs-regexp">//</span>Update<br>D <span class="hljs-keyword">delete</span> 		<span class="hljs-regexp">//</span>Delete<br></code></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>查看表结构 :<br>desc 表名;</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>SQL注意 :<blockquote>
<ul>
<li>SQL 语言大小写不敏感。 </li>
<li>SQL 可以写在一行或者多行</li>
<li>关键字不能被缩写也不能分行</li>
<li>各子句一般要分行写。</li>
<li>使用缩进提高语句的可读性。</li>
</ul>
</blockquote>
</li>
<li>给列起别名, 可以省略as关键字, 别名中如果有特殊符号, 可以使用””包围.</li>
</ul>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <br>	population <span class="hljs-keyword">as</span> pop,<br>	<span class="hljs-keyword">name</span> <span class="hljs-string">&quot;国家 名称&quot;</span>,<br>	code<br><span class="hljs-keyword">from</span> <br>	country;<br></code></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>where 条件布尔(一个表达式，返回结果永远是一个布尔值)</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>执行顺序SQL：先from, 再where 最后select </li>
</ul>
</blockquote>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">SELECT</span> <span class="hljs-string"></span><br>	<span class="hljs-attr">employee_id</span> <span class="hljs-string">empId, </span><br>	<span class="hljs-attr">last_name</span> <span class="hljs-string">name, </span><br>	<span class="hljs-attr">job_id</span> <span class="hljs-string">job, </span><br>	<span class="hljs-attr">department_id</span> <span class="hljs-string">deptId</span><br><span class="hljs-attr">FROM</span>   <span class="hljs-string"></span><br>	<span class="hljs-attr">employees</span><br><span class="hljs-attr">WHERE</span>  <span class="hljs-string"></span><br>	<span class="hljs-attr">department_id</span> = <span class="hljs-string">90 ;</span><br>	<br><span class="hljs-meta">--</span> <span class="hljs-string">错误!! where中不可以使用列的别名, 因为此时虚表的列还没有生成好.</span><br></code></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>Between a and b 都包含</li>
<li>like <blockquote>
<ul>
<li>% 表示任意个任意字符</li>
<li>_ 表示一个任意字符</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">查询姓名中第2个字母是o其他无所谓<br><span class="hljs-keyword">SELECT</span> last_name<br><span class="hljs-keyword">FROM</span>   employees<br><span class="hljs-keyword">WHERE</span>  last_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;_o%&#x27;</span>;<br></code></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>只要有null参与比较运算, 结果一定是false</li>
</ul>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">查询哪些国家没有首都<br>只要有null参与比较运算, 结果一定是false<br><span class="hljs-comment">--错误!!</span><br><span class="hljs-keyword">select</span> <br>	<span class="hljs-keyword">name</span>,<br>	continent,<br>	capital<br><span class="hljs-keyword">from</span> <br>	country <br><span class="hljs-keyword">where</span> <br>	capital = <span class="hljs-literal">null</span>;<br>	<br>查询哪些国家没有首都<br><span class="hljs-keyword">select</span> <br>	<span class="hljs-keyword">name</span>,<br>	continent,<br>	capital<br><span class="hljs-keyword">from</span> <br>	country <br><span class="hljs-keyword">where</span> <br>	capital <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span>;<br><br>查询哪些国家有首都<br><span class="hljs-keyword">select</span> <br>	<span class="hljs-keyword">name</span>,<br>	continent,<br>	capital<br><span class="hljs-keyword">from</span> <br>	country <br><span class="hljs-keyword">where</span> <br>	capital <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>where 也支持算术运算, 结果为0表示假非0表示真</li>
<li>distinct 去重, 要求列真的有重复的</li>
</ul>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span><br>	<span class="hljs-keyword">distinct</span><br>		continent,<br>		<span class="hljs-keyword">name</span><br><span class="hljs-keyword">from</span><br>	country;<br></code></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>order by  可以排序, 只是给结果集虚表排序</li>
<li>默认是升充(asc)    </li>
<li>降序必须指定(desc)</li>
<li>order by 可以使用列的别名.</li>
<li>order by  列1, 列2 先以列1排序, 再在相同的列1数据中, 再依据列2再微排.</li>
</ul>
</blockquote>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> <br>	last_name, <br>	department_id, <br>	salary<br><span class="hljs-keyword">FROM</span>   <br>	employees<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <br>	department_id, <br>	salary <span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>写SQL的步骤 : <blockquote>
<ul>
<li>(1) from 基表</li>
<li>(2) where 过滤哪些行</li>
<li>(3) select 选择哪些列</li>
<li>(4) order by 以哪些列为排序依据. </li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h3 id="表联接"><a href="#表联接" class="headerlink" title="表联接"></a>表联接</h3><figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql">表联接<br><span class="hljs-keyword">select</span> <br>	* <br><span class="hljs-keyword">from</span> <br>	city2,<br>	country2;<br>笛卡尔集中的数据绝大多数都是垃圾, 必须使用行过滤.<br></code></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>笛卡尔集中的数据绝大多数都是垃圾, 必须使用行过滤.</li>
<li>解决列名冲突可以使用表名限定</li>
</ul>
</blockquote>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">--表名也可以起别名, 而且是如果多表联接, 最好起别名.</span><br><span class="hljs-keyword">select</span> <br>	ci.name cityName,<br>	ci.population cityPop,<br>	co.name countryName,<br>	co.population countryPop,<br>	co.continent<br><span class="hljs-keyword">from</span> <br>	city2 ci,<br>	country2 co <br><span class="hljs-keyword">where</span> <br>	ci.countrycode = co.code;<br>	<br><span class="hljs-comment">--一旦给表起了别名, 原名不可以使用, 必须使用别名. 原因是from最先执行, 它把原始表名变了.</span><br><span class="hljs-keyword">select</span> <br>	city2.name cityName,<br>	city2.population cityPop,<br>	country2.name countryName,<br>	country2.population countryPop,<br>	country2.continent<br><span class="hljs-keyword">from</span> <br>	city2 ci,<br>	country2 co <br><span class="hljs-keyword">where</span> <br>	city2.countrycode = country2.code;<br></code></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>复习 :<blockquote>
<ul>
<li>C/S </li>
<li>Server : mysqld.exe </li>
<li>Clinet : mysql.exe </li>
<li>必须通过客户端才能使用服务器</li>
<li>需要提供IP, 端口, 用户名, 密码.</li>
<li>mysql -h127.0.0.1 -P3306 -uroot -p123456</li>
<li>mysql –host=127.0.0.1 –port=3306 –user=root –password=123456 默认数据库</li>
<li>mysql –host=主机地址 –port=端口 –user=用户名 –password=密码 默认数据库</li>
<li>查看所有库<br>show databases;</li>
<li>切换成当前工作数据库<br>use 数据库;</li>
<li>查看库中的表<br>show tables;</li>
<li>跨库查看表<br>show tables from 其他库</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<blockquote>
<blockquote>
<ul>
<li>查看表结构<br>desc 表名;</li>
</ul>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<ul>
<li>查看表的建表语句<br>show create table 表名;</li>
</ul>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<ul>
<li>存储引擎 : InnoDB(支持事务, 外键等高级特性), MyISAM(不支持事务, 不支持外键)</li>
</ul>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<ul>
<li>``专门用于包围数据库对象的名称(数据库, 表, 列, 主键, 外键, 索引, 函数, 存储过程, 触发器)</li>
<li>查询表中的所有数据<br>select * from 表名; from关键字可以省略</li>
</ul>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<ul>
<li>相看当前数据库<br>select<br>  database(), – 函数<br>  now(),<br>  version()</li>
</ul>
</blockquote>
</blockquote>
<p>select<br>    100, – 常量<br>    ‘abc’<br>from<br>    dual;</p>
<blockquote>
<blockquote>
<ul>
<li>使用用户变量<br>set @var1 = 100, @var2 = ‘abc’;</li>
</ul>
</blockquote>
</blockquote>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">--SQL99标准, 用内联代替逗号联接.</span><br><span class="hljs-keyword">select</span> <br>	ci.name cityName,<br>	ci.population cityPop,<br>	co.name countryName,<br>	co.population countryPop,<br>	co.continent<br><span class="hljs-keyword">from</span> <br>	city2 ci<br><span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> <br>	country2 co <br><span class="hljs-keyword">on</span><br>	ci.countrycode = co.code <span class="hljs-comment">-- 联接条件</span><br><span class="hljs-keyword">where</span>  <br>	ci.population &gt; <span class="hljs-number">5000000</span> <span class="hljs-comment">-- 普通过滤</span><br>	<br><br><span class="hljs-comment">-- where 和 on在内联时可以混用, 但是千万不要.</span><br><span class="hljs-keyword">select</span> <br>	ci.name cityName,<br>	ci.population cityPop,<br>	co.name countryName,<br>	co.population countryPop,<br>	co.continent<br><span class="hljs-keyword">from</span> <br>	city2 ci<br><span class="hljs-keyword">join</span> <br>	country2 co <br><span class="hljs-keyword">on</span><br>	ci.countrycode = co.code <span class="hljs-comment">-- 联接条件</span><br><span class="hljs-keyword">where</span>  <br>	ci.population &gt; <span class="hljs-number">5000000</span> <span class="hljs-comment">-- 普通过滤</span><br></code></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>注意：<blockquote>
<ul>
<li>内联接的逻辑是从笛尔集中取出来的是满足联接条件的记录. 有可能会导致某张表的数据不完整.</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <br>	co.name countryName,<br>	ci.name capitalName,<br>	co.capital<br><span class="hljs-keyword">from</span> <br>	country2 co <br><span class="hljs-keyword">left</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> <span class="hljs-comment">-- 左外联接, 保证左表数据完整</span><br>	city2 ci <br><span class="hljs-keyword">on</span> <br>	co.capital = ci.id ;<br>	<br><span class="hljs-keyword">select</span> <br>	co.name countryName,<br>	ci.name capitalName,<br>	co.capital<br><span class="hljs-keyword">from</span> <br>	country2 co <br><span class="hljs-keyword">right</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> <span class="hljs-comment">-- 左外联接, 保证左表数据完整</span><br>	city2 ci <br><span class="hljs-keyword">on</span> <br>	co.capital = ci.id ;<br>	<br><span class="hljs-comment">--外联时可以省略outer关键字	</span><br><span class="hljs-keyword">select</span> <br>	co.name countryName,<br>	ci.name capitalName,<br>	co.capital<br><span class="hljs-keyword">from</span> <br>	country2 co <br><span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span><br>	city2 ci <br><span class="hljs-keyword">on</span> <br>	co.capital = ci.id ;<br></code></pre></td></tr></table></figure>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h4><figure class="highlight oxygene"><table><tr><td class="code"><pre><code class="hljs oxygene">单行函数 -- 作用于结果集中的每一条记录的.<br><span class="hljs-keyword">select</span> <br>	upper(name),<br>	now(),<br>	<span class="hljs-keyword">concat</span>(continent, code2)<br><span class="hljs-keyword">from</span> <br>	country;<br>	<br>查询国家表中的数据, 把国家名称,大洲, 国家代码 连接起来, 中间使用<span class="hljs-string">&#x27;=&gt;&#x27;</span>连接.<br>--<span class="hljs-keyword">concat</span>(<span class="hljs-keyword">concat</span>(<span class="hljs-keyword">concat</span>(<span class="hljs-keyword">concat</span>(name, <span class="hljs-string">&#x27;=&gt;&#x27;</span>), continent), <span class="hljs-string">&#x27;=&gt;&#x27;</span>), code)<br><span class="hljs-keyword">select</span> <br>	<span class="hljs-keyword">concat</span>(name, <span class="hljs-string">&#x27;=&gt;&#x27;</span>, continent, <span class="hljs-string">&#x27;=&gt;&#x27;</span>, code)<br><span class="hljs-keyword">from</span> <br>	country;<br></code></pre></td></tr></table></figure>
<h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">组函数（聚合函数） -- 作用于一组数据, 最终针对一组只有一个结果. 也称为统计处理<br><span class="hljs-function"><span class="hljs-title">avg</span><span class="hljs-params">()</span></span> 平均<br><span class="hljs-function"><span class="hljs-title">max</span><span class="hljs-params">()</span></span> 最大<br><span class="hljs-function"><span class="hljs-title">min</span><span class="hljs-params">()</span></span> 最小<br><span class="hljs-function"><span class="hljs-title">count</span><span class="hljs-params">()</span></span> 计数<br><span class="hljs-function"><span class="hljs-title">sum</span><span class="hljs-params">()</span></span>求和<br></code></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>获取表中的记录数, 使用count(*)最好.</li>
<li>如果有group by , 必须让分组依据的列放在select中.</li>
</ul>
</blockquote>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">select <br>	-- name, 代表个体信息的列<br>	continent,<br>	max(population)<br><span class="hljs-keyword">from</span> <br>	country <br>group by <br>	continent;<br></code></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>对分组的虚表进行过滤, 必须使用having</li>
<li>having的执行晚于select, 所以可以使用列的别名</li>
</ul>
</blockquote>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">select <br>	GovernmentForm,<br>	count(*) ct<br><span class="hljs-keyword">from</span> <br>	country<br>group by <br>	GovernmentForm<br>having<br>	ct &gt; 10<br>order by <br>	ct;<br></code></pre></td></tr></table></figure>
<p>sql语句一般的执行顺序：</p>
<ol>
<li>from         确定基表</li>
<li>join         如果一张基表不够, 再联接其他表</li>
<li>on             如果有联接表 必须要有on</li>
<li>where         过滤总基表中的行</li>
<li>group by     分组, 分组依据的列.</li>
<li>select         把分组依据的列放在select后, 再考虑要选择哪些列, 及进行哪些函数调用….</li>
<li>having         进一步把分组后的虚表行过滤</li>
<li>order by     最终表的一个排序显示.</li>
</ol>
<h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><blockquote>
<ul>
<li>子查询 : 通常需要多步执行的简单查询</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>针对表中的数据进行的操作, 这样的语言称DML(数据操纵语句)<blockquote>
<ul>
<li>select R</li>
<li>update U </li>
<li>delete D </li>
<li>insert C</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>针对数据库中的对象的操作, 这样的语言称DDL(数据定义语言)</li>
<li>数据库 </li>
<li>表</li>
<li>列 </li>
<li>约束 </li>
<li>索引 </li>
<li>预编译</li>
<li>函数</li>
<li>存储过程 </li>
<li>触发器</li>
<li>事件…..</li>
</ul>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">创建数据库 <br><span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> 数据库名 <span class="hljs-keyword">charset</span> 字符集;<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> school <span class="hljs-keyword">charset</span> utf8;<br><br>修改数据库 <br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">database</span> school <span class="hljs-keyword">charset</span> gbk;<br><br>丢弃数据库. 数据库中的所有内容全部丢弃. 慎重!!!!<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">database</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">exists</span> school;<br><br>常用数据类型<br>int 			4字节整数<br>bigint			8字节整数<br>char(长度)		定长字符串<br>varchar(字符数) // 最多65535字节<br>double			8字节双精度浮点<br>decimal			定点数<br>date 			日期<br>datetime		日期时间<br>longtext 		长文本<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> teacher(<br>	<span class="hljs-keyword">id</span> <span class="hljs-built_in">int</span> auto_increment,<br>	<span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>),<br>	age <span class="hljs-built_in">int</span>,<br>	phone <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>),<br>	address <span class="hljs-built_in">varchar</span>(<span class="hljs-number">100</span>),<br>	gender enum(<span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>) <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;男&#x27;</span>,<br>	primary <span class="hljs-keyword">key</span>(<span class="hljs-keyword">id</span>)<br>) <span class="hljs-keyword">engine</span> <span class="hljs-keyword">innodb</span> <span class="hljs-keyword">charset</span> gbk;<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> classes(<br>	<span class="hljs-keyword">id</span> <span class="hljs-built_in">int</span> auto_increment,<br>	<span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">30</span>),<br>	student_count <span class="hljs-built_in">int</span>,<br>	room <span class="hljs-built_in">char</span>(<span class="hljs-number">3</span>),<br>	<span class="hljs-keyword">master</span> <span class="hljs-built_in">int</span>, <span class="hljs-comment">-- 班主任</span><br>	begindate <span class="hljs-built_in">date</span>,<br>	primary <span class="hljs-keyword">key</span>(<span class="hljs-keyword">id</span>)<br>);<br></code></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>子查询题目例子</li>
</ul>
</blockquote>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-number">5</span> 查询所有国家的首都和使用率最高的官方语言(选做)<br><span class="hljs-keyword">select</span> <br>	co.name,<br>	ci.name,<br>	cl3.<span class="hljs-keyword">language</span>,<br>	cl3.percentage<br><span class="hljs-keyword">from</span> <br>	country co <br><span class="hljs-keyword">left join</span> <br>	city ci <br><span class="hljs-keyword">on</span> <br>	co.capital = ci.id <br><span class="hljs-keyword">left join</span> <br>	(<span class="hljs-keyword">select</span> <br>		cl.countrycode,<br>		cl.<span class="hljs-keyword">language</span>,<br>		cl.percentage,<br>		cl.isofficial<br>	<span class="hljs-keyword">from</span> <br>		countrylanguage cl <br>	<span class="hljs-keyword">join</span>  <br>		(<span class="hljs-keyword">select</span> countrycode, max(Percentage) maxPer <span class="hljs-keyword">from</span> countrylanguage <span class="hljs-keyword">where</span> isofficial = <span class="hljs-string">&#x27;T&#x27;</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> countrycode) cl2<br>	<span class="hljs-keyword">on</span> <br>			cl.countrycode = cl2.countrycode <br>		<span class="hljs-keyword">and</span> <br>			cl.percentage = cl2.maxPer<br>	<span class="hljs-keyword">where</span> <br>		cl.isofficial = <span class="hljs-string">&#x27;T&#x27;</span><br>	) cl3<br><span class="hljs-keyword">on</span> <br>	co.code = cl3.countrycode <br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <br>	cl3.percentage;<br></code></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">创建数据库 <br><span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> 数据库名 <span class="hljs-keyword">charset</span> utf8;<br><br>修改数据库 只能修改字符集<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">database</span> 数据库名 <span class="hljs-keyword">charset</span> 新字符集;<br><br>丢弃数据库<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">database</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">exists</span> 数据加名;<br><br>查看库或表<br><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span>(<span class="hljs-keyword">table</span>) 数据库名或表名<br><br><span class="hljs-keyword">SQL</span>语言分类<br>	<span class="hljs-number">1</span>) DML 数据操纵语言, 主要处理数据<br>		<span class="hljs-keyword">insert</span> <span class="hljs-keyword">select</span> <span class="hljs-keyword">update</span> <span class="hljs-keyword">delete</span> <br>		<br>	<span class="hljs-number">2</span>) <span class="hljs-keyword">DDL</span> 数据定义语言, 主要处理数据库对象<br>		<span class="hljs-keyword">create</span> <span class="hljs-keyword">show</span> <span class="hljs-keyword">alter</span> <span class="hljs-keyword">drop</span> <br>		<br>	<span class="hljs-number">3</span>) DCL 数据控制语句, 主要用于控制事务<br>		<span class="hljs-keyword">commit</span> <span class="hljs-keyword">rollback</span><br><br></code></pre></td></tr></table></figure>
<h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><blockquote>
<ul>
<li>全新方式创建表</li>
</ul>
</blockquote>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">1) 全新方式建表<br>create table <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> exists 表名(<br>	列1 数据类型1(长度) 其他选项,<br>	列2 数据类型2(长度) 其他选项,<br>	<span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>,<br>	primary key(列) -- 表级主键<br>) engine 数据库引擎 charset 字符集;<br><br>数据库引擎 : <br>	InnoDB : 缺省引擎, 支持事务, 外键等高级特性, 速度慢<br>	MyIsam : 速度快, 早期的缺省引擎, 不支持事务,外键等高级特性<br><br>其他选项 : auto_increment,<span class="hljs-built_in"> default </span>缺省值, <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>, unique.<br></code></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>基于子查询, 可以复制数据，不能复制各种约束（key）…</li>
</ul>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> 表名 <br>子查询 <br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> country3 <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> world.country <span class="hljs-keyword">where</span> continent = <span class="hljs-string">&#x27;asia&#x27;</span>;<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> country4 <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> world.country;<br></code></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>完全复制表结构，不能复制数据</li>
</ul>
</blockquote>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> 表名 <span class="hljs-keyword">like</span> 已有表名<br></code></pre></td></tr></table></figure>
<h3 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">表结构的修改<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <br><span class="hljs-comment">--子句</span><br><br>添加新列<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <br><span class="hljs-keyword">add</span> 新列名 数据类型 其他选项;<br><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> teacher <br><span class="hljs-keyword">add</span> gender enum(<span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>) <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;男&#x27;</span>;<br><br>修改列<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <br><span class="hljs-keyword">modify</span> 列名 新数据类型 新其他选项;<br><br>修改列名<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <br><span class="hljs-keyword">change</span> 老列名 新列名 新数据类型 新其他选项;<br>丢弃一个列, 此列对应的所有数据都会删除<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">column</span> 列名 <br><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> teacher<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">column</span> address;<br>丢弃表 <br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">exists</span> 表名<span class="hljs-number">1</span>, 表名<span class="hljs-number">2</span>, ....;<br><br>清空表数据<br><span class="hljs-keyword">truncate</span> <span class="hljs-keyword">table</span> 表名; <span class="hljs-comment">-- 它是一个DDL语句, 一旦清除,就不能回滚, 效率高.</span><br><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> 表名; <span class="hljs-comment">-- 它是一个DML语句, 意味着是可以回滚的. 效率低.</span><br><br>修改表名<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名<br><span class="hljs-keyword">rename</span> <span class="hljs-keyword">to</span> 新表名<br></code></pre></td></tr></table></figure>
<h3 id="插入数据的方式"><a href="#插入数据的方式" class="headerlink" title="插入数据的方式"></a>插入数据的方式</h3><ol>
<li>全新方式插入<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">insert <span class="hljs-built_in">int</span>o 表名 (<br>	列<span class="hljs-number">1</span>,<br>	列<span class="hljs-number">2</span>,<br>	列<span class="hljs-number">3</span>,<br>	.....<br>) values (<br>	值<span class="hljs-number">1</span>,<br>	值<span class="hljs-number">2</span>,<br>	值<span class="hljs-number">3</span>,<br>	....<br>)<br></code></pre></td></tr></table></figure></li>
<li>使用子查询插入<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> students(<br>	<span class="hljs-keyword">name</span>,<br>	age,<br>	mobile,<br>	gender,<br>	address<br>) <span class="hljs-keyword">select</span> <br>	<span class="hljs-keyword">name</span>,<br>	age, <br>	mobile,<br>	gender,<br>	<span class="hljs-string">&#x27;北京&#x27;</span><br><span class="hljs-keyword">from</span> <br>	teachers <br><span class="hljs-keyword">where</span> <br>	<span class="hljs-keyword">id</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><span class="hljs-comment">-- 克隆表</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 新表 <span class="hljs-keyword">like</span> 旧表;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> 新表 <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> 旧表 <br>克隆城市表到当前库下新成中国城市表 (chinaCity)<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> chinaCity <span class="hljs-keyword">like</span> world.city; <br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> chinacity <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> world.city <span class="hljs-keyword">where</span> countrycode = <span class="hljs-string">&#x27;chn&#x27;</span>;<br></code></pre></td></tr></table></figure></li>
<li> 插入一条数据 insert into 表名 set 数据<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <br>	teachers <br><span class="hljs-keyword">set</span> <br>	<span class="hljs-keyword">name</span> = <span class="hljs-string">&#x27;丁老师&#x27;</span>,<br>	age = <span class="hljs-number">25</span>,<br>	mobile = <span class="hljs-string">&#x27;123234234&#x27;</span>;<br>修改数据 <br><span class="hljs-keyword">update</span> 表名 <span class="hljs-keyword">set</span> <br>	列<span class="hljs-number">1</span> = 值<span class="hljs-number">1</span>,<br>	列<span class="hljs-number">2</span> = 值<span class="hljs-number">2</span>,<br>	列<span class="hljs-number">3</span> = 值<span class="hljs-number">3</span>,<br>	....<br><span class="hljs-keyword">where</span> <br>	行过滤<br>	<br><span class="hljs-keyword">update</span> teachers <span class="hljs-keyword">set</span> <br>	age = <span class="hljs-number">40</span>,<br>	mobile = <span class="hljs-string">&#x27;135342342&#x27;</span><br><span class="hljs-keyword">where</span> <br>	<span class="hljs-keyword">id</span> = <span class="hljs-number">1</span>;<br>	<br>删除数据 <br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> 表名 <br><span class="hljs-keyword">where</span> 行过滤<br><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> teachers <br><span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> &gt; <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>
<h3 id="数据库事物"><a href="#数据库事物" class="headerlink" title="数据库事物"></a>数据库事物</h3><blockquote>
<ul>
<li>定义：让数据从一种状态到另一种状态</li>
<li>ACID特性</li>
<li>让一组逻辑操作单元当成一个单个的命令来执行.<blockquote>
<ul>
<li>A 原子性 : 不可分割 </li>
<li>C 一致性 : 数据前后是一致</li>
<li>I 独立性 : 事务间, (独立性有等级)</li>
<li>D 持久性 : 事务一旦提交, 数据持久化.</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">设置提交状态：<span class="hljs-keyword">SET</span> AUTOCOMMIT = <span class="hljs-literal">FALSE</span>;<br>或者显式的执行 <span class="hljs-keyword">start</span> <span class="hljs-keyword">transaction</span><br>            或 <span class="hljs-keyword">begin</span><br>			<br>以第一个 DML 语句的执行作为开始<br><br>以下面的其中之一作为结束:<br><span class="hljs-keyword">COMMIT</span> 或 <span class="hljs-keyword">ROLLBACK</span> 语句<br><span class="hljs-keyword">DDL</span> 语句（自动提交）<br>用户会话正常结束, 提交<br>系统异常终止      回滚<br><br><span class="hljs-keyword">SET</span> AUTOCOMMIT = <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">set</span> autocommit = <span class="hljs-literal">false</span>;<br><br>用一个客户端在事务中删除表数据, 另一个客户端查询??<br><br>预编译 : 提前把SQL编译成可执行的, 在执行时只需要调用它即可.<br><span class="hljs-keyword">prepare</span> 预编译名 <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;SQL&#x27;</span>; <br><br><span class="hljs-keyword">prepare</span> p1 <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;select * from teachers&#x27;</span><br><br>执行预编译 <br><span class="hljs-keyword">execute</span> p1; <br><br>丢弃预编译<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">prepare</span> p1;<br></code></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">prepare</span> p2 <br><span class="hljs-keyword">from</span> <br>	<span class="hljs-string">&#x27;insert into teachers(</span><br><span class="hljs-string">		name, </span><br><span class="hljs-string">		age, </span><br><span class="hljs-string">		mobile</span><br><span class="hljs-string">	) values (</span><br><span class="hljs-string">		?,</span><br><span class="hljs-string">		?,</span><br><span class="hljs-string">		?</span><br><span class="hljs-string">	)&#x27;</span>;<br>	<br><span class="hljs-keyword">prepare</span> p3 <span class="hljs-keyword">from</span> <br><span class="hljs-string">&#x27;delete from teachers </span><br><span class="hljs-string"> where id = ?&#x27;</span>;<br><br>在执行时预编译时, 代替?的实参必须要用用户变量<br><br><span class="hljs-keyword">set</span> @变量名 = 值, @变量名<span class="hljs-number">2</span> = 值<span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">execute</span> 预编译 <span class="hljs-keyword">using</span> @变量名, @变量名<span class="hljs-number">2</span>;<br><br>? 只能代替值的部分, 表名, 列名绝不可以.<br>下面是错误!!<br><span class="hljs-keyword">prepare</span> p4 <span class="hljs-keyword">from</span> <br><span class="hljs-string">&#x27;insert into teachers(</span><br><span class="hljs-string">	?, </span><br><span class="hljs-string">	?, </span><br><span class="hljs-string">	?</span><br><span class="hljs-string">) values (</span><br><span class="hljs-string">	?,</span><br><span class="hljs-string">	?,</span><br><span class="hljs-string">	?</span><br><span class="hljs-string">)&#x27;</span>;<br><br>在SQL中要想使用&#x27;, 必须再加一个&#x27;, 起到转义的作用<br><span class="hljs-keyword">prepare</span> p2 <span class="hljs-keyword">from</span> <br><span class="hljs-string">&#x27;insert into teachers(</span><br><span class="hljs-string">	name, </span><br><span class="hljs-string">	age, </span><br><span class="hljs-string">	mobile,</span><br><span class="hljs-string">	gender</span><br><span class="hljs-string">) values (</span><br><span class="hljs-string">	?,</span><br><span class="hljs-string">	?,</span><br><span class="hljs-string">	?,</span><br><span class="hljs-string">	?</span><br><span class="hljs-string">)&#x27;</span>;<br></code></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>有以下六种约束:<blockquote>
<ul>
<li>NOT NULL 非空约束，规定某个字段不能为空, 必须列级约束 </li>
<li>UNIQUE  唯一约束，规定某个字段在整个表中是唯一的</li>
<li>PRIMARY KEY  主键(非空且唯一)</li>
<li>FOREIGN KEY  外键</li>
<li>DEFAULT  默认值, 必须是列级</li>
<li>check</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">test</span>(<br>	<span class="hljs-keyword">id</span> <span class="hljs-built_in">int</span> auto_increment,<br>	<span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>),<br>	phone <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>, <span class="hljs-comment">-- 必须列级约束</span><br>	<span class="hljs-keyword">unique</span>(<span class="hljs-keyword">name</span>), <span class="hljs-comment">-- 可以表级约束</span><br>	primary <span class="hljs-keyword">key</span>(<span class="hljs-keyword">id</span>)<br>);<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">test</span>(<br>	<span class="hljs-keyword">name</span>,<br>	phone<br>) <span class="hljs-keyword">values</span> (<br>	<span class="hljs-string">&#x27;aaa&#x27;</span>,<br>	<span class="hljs-string">&#x27;234234&#x27;</span><br>);<br><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">test</span> <br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">key</span> <span class="hljs-keyword">name</span>; <span class="hljs-comment">-- 丢弃唯一键约束</span><br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test2(<br>	<span class="hljs-keyword">id</span> <span class="hljs-built_in">int</span> auto_increment,<br>	<span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>),<br>	phone <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>, <span class="hljs-comment">-- 必须列级约束</span><br>	<span class="hljs-keyword">constraint</span> myunique <span class="hljs-keyword">unique</span>(<span class="hljs-keyword">name</span>, phone), <span class="hljs-comment">-- 可以表级约束, 联合键</span><br>	primary <span class="hljs-keyword">key</span>(<span class="hljs-keyword">id</span>)<br>);<br><br></code></pre></td></tr></table></figure>
<h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><blockquote>
<ul>
<li>外键 : 让一个表中的记录的值要引用到另一张表中的数据…</li>
<li>一旦有了外键, 子表中插入数据必须要引用到真实的父表中数据</li>
<li>一旦父表中的记录被子表引用, 当删除父表中的相关记录时, 不允许删除.</li>
</ul>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">foreign key(本表的外键列) references 父表(父表主键)<br><br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">exists</span> classes;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> classes(<br>	<span class="hljs-keyword">id</span> <span class="hljs-built_in">int</span> auto_increment,<br>	<span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">30</span>),<br>	student_count <span class="hljs-built_in">int</span>,<br>	room <span class="hljs-built_in">char</span>(<span class="hljs-number">3</span>),<br>	<span class="hljs-keyword">master</span> <span class="hljs-built_in">int</span>, <br>	begindate <span class="hljs-built_in">date</span>,<br>	primary <span class="hljs-keyword">key</span>(<span class="hljs-keyword">id</span>),<br>	<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">key</span>(<span class="hljs-keyword">master</span>) <span class="hljs-keyword">references</span> teachers(<span class="hljs-keyword">id</span>)<br>);<br></code></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>丢弃外键, 必须要知道外键名.</li>
</ul>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> classes <br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">foreign</span> <span class="hljs-keyword">key</span> classes_ibfk_1;<br></code></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>添加外键</li>
<li>on delete do nothing, 是默认选项, 在删除父表被引用的记录时不允许</li>
<li>on delete cascade 级联删除, 当删除父表中的相关记录时, 子表中引用此记录的所有记录也会被删除.</li>
<li>on delete set null 级联置空.当删除父表中的相关记录时, 子表中引用此记录的所有记录会被置为空.</li>
</ul>
</blockquote>
<h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><blockquote>
<ul>
<li>limit n, 把结果集截断成n条记录.</li>
</ul>
</blockquote>
</li>
</ol>
<blockquote>
<ul>
<li><p>limit m, n 把结果集中的m条略过, 再截断成n条记录</p>
</li>
<li><p>limit子句必须放在整个查询语句的最后！</p>
</li>
<li><p>offset n 表示去掉n个值</p>
</li>
<li><p>一般用法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> hire_date <span class="hljs-keyword">DESC</span>      <span class="hljs-comment">-- 倒序</span><br><span class="hljs-keyword">LIMIT</span> <span class="hljs-number">1</span> <span class="hljs-keyword">offset</span> <span class="hljs-number">2</span>;       <span class="hljs-comment">-- 去掉排名倒数第一第二的时间，取倒数第三;   </span><br><br></code></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><blockquote>
<ul>
<li>重点：DML数据操纵语言，主要就是查询</li>
<li>标准SQL<blockquote>
<ul>
<li>select </li>
<li>from </li>
<li>left join </li>
<li>on </li>
<li>where </li>
<li>group by </li>
<li>having </li>
<li>order by</li>
</ul>
</blockquote>
</li>
<li>注意点<blockquote>
<ul>
<li>注意多表连接的内联，外联 </li>
<li>函数的使用，where中不能使用</li>
<li>别名的使用，从group by开始可以使用select中的别名了</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><ul>
<li><p>先找到运行慢的SQL</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查看慢SQL日志是否可用</span><br><span class="hljs-keyword">show</span> <span class="hljs-keyword">variables</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;log_slow_queries&#x27;</span>;<br><br><span class="hljs-comment">-- 查看执行慢于多少秒的SQL会记录到日志文件中</span><br><span class="hljs-keyword">show</span> <span class="hljs-keyword">variables</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;long_query_time&#x27;</span>;<br><br><span class="hljs-comment">-- 查看慢SQL存在的位置</span><br><span class="hljs-keyword">show</span> <span class="hljs-keyword">variables</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;slow_query_log_file&#x27;</span>;<br><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><ul>
<li>尽量使用 <code>TINYINT</code> 、 <code>SMALLINT</code> 、 <code>MEDIUM_INT</code> 作为整数类型而非 <code>INT</code> ，如果非负则加上 <code>UNSIGNED</code></li>
<li>varchar的长度只分配真正需要的空间</li>
<li>使用枚举或整数代替字符串类型</li>
<li>尽量使用TIMESTAMP而非DATETIME</li>
<li>单表不要有太多字段，建议在20以内</li>
<li>避免使用NULL字段，很难查询优化且占用额外索引空间</li>
<li>用整型来存IP</li>
</ul>
<h3 id="索引-1"><a href="#索引-1" class="headerlink" title="索引"></a>索引</h3><ul>
<li>索引并不是越多越好，要根据查询有针对性地创建，<font color=red>考虑在where和order by命令上涉及地列建立索引</font>，根据explain来查看是否用了索引还是全表扫描。</li>
<li>应尽量避免在where子句中对字段进行NULL值判断，否则将导致引擎放弃使用索引而进行全表扫描。</li>
<li>值分布很稀少地字段不适合建索引</li>
<li>字符串字段只建前缀索引</li>
<li>字符字段最好不要做主键</li>
<li>不用外键，由程序保证约束</li>
<li>尽量不用 <code>UNIQUE</code> ，由程序保证约束</li>
<li>使用多列索引时主意顺序和查询条件保持一致，同时删除不必要的单列索引</li>
</ul>
<h3 id="查询SQL"><a href="#查询SQL" class="headerlink" title="查询SQL"></a>查询SQL</h3><ul>
<li>可通过开启慢查询日志来找出较慢的SQL</li>
<li>不做列运算</li>
<li>sql语句尽可能简单，一条SQL只能在一个cpu运算，大语句拆小语句，减少锁时间；一条大SQL可以堵死整个库。</li>
<li>不用select *，要尽量避免使用 select *，而是查询需要的字段，这样可以提升速度，以及减少网络传输的带宽压力</li>
<li><font color=red>or改写成in</font>,or的效率是n级别，in的效率是log(n)级别，in的个数建议在200以内</li>
<li>不用函数和触发器，在应用程序实现</li>
<li>少用join</li>
<li>使用同类型进行比较</li>
<li><font color=red>尽量避免在where子句中使用!=或&lt;&gt;操作符</font>，否则引擎将放弃使用索引而进行全表扫描。</li>
<li>对于连续型数值，使用BETWEEN 不用 in</li>
<li>列表数据不要拿全表，要使用limit来分页，每页数量也不要太大</li>
<li>小表驱动大表</li>
</ul>
<h3 id="系统参数调优"><a href="#系统参数调优" class="headerlink" title="系统参数调优"></a>系统参数调优</h3><ul>
<li>wait_timeout：数据库连接闲置时间，闲置连接会占用内存资源。可以从默认的8小时减到半小时</li>
<li>max_user_connection: 最大连接数，默认为0无上限，最好设一个合理上限</li>
<li>back_log：back_log值指出在MySQL暂时停止回答新请求之前的短时间内多少个请求可以被存在堆栈中。也就是说，如果MySql的连接数据达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源。可以从默认的50升至500</li>
<li>thread_concurrency：并发线程数，设为CPU核数的两倍</li>
</ul>
<h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>如果在实现用户的某些需求时，需要编写一组复杂的SQL语句才能实现的时候，那么我们就可以将这组复杂的SQL语句集提前编写在数据库中，由JDBC调用来执行这组SQL语句。把编写在数据库中的SQL语句集称为存储过程。</li>
<li>存储过程：(procedure) 是事先经过编译并存储在数据库中的一段SQL语句的集合。调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是很有好处的。<font color=red><strong>存储过程就是数据库SQL语言层面的代码封装与重用</strong></font></li>
<li>存储过程就类似于Java中的方法，需要先定义，使用时需要调用。存储过程可以定义参数，参数分为IN，OUT，INOUT三种类型<ul>
<li>IN类型的参数表示接受调用者传入的数据</li>
<li>OUT类型的参数表示向调用者返回数据</li>
<li>INOUT类型的参数既可以接受调用者传入的参数，也可以向调用者返回数据</li>
</ul>
</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li><p>优点</p>
<ul>
<li>简化复杂操作，简化对变动的管理</li>
<li><strong>通常存储过程有助于提高应用程序的性能</strong>。当创建的存储过程被编译之后，就存储在数据库中。</li>
<li>存储过程有助于减少应用程序和数据库服务器之间的流量。</li>
<li>可重用，透明，安全的。</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><p>如果大量使用存储过程，那么使用这些存储过程的每个连接的内存使用量将大大增加。此外，如果在存储过程中过度使用大量的逻辑操作，那么CPU的使用率也在增加，因为MySQL数据库最初的设计就侧重于高效的查询，而不是逻辑运算。</p>
</li>
<li><p>开发维护，调试代码困难，<strong>对数据库依赖程度高，移植性较差</strong>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">DELIMITER $$<br><br><span class="hljs-keyword">CREATE</span><br>    <span class="hljs-comment">/*[DEFINER = &#123; user | CURRENT_USER &#125;]*/</span><br>    <span class="hljs-keyword">PROCEDURE</span> 数据库名.存储过程名([<span class="hljs-keyword">in</span>变量名 类型,<span class="hljs-keyword">out</span> 参数 <span class="hljs-number">2</span>，...])<br>    <span class="hljs-comment">/*LANGUAGE SQL</span><br><span class="hljs-comment">    | [NOT] DETERMINISTIC</span><br><span class="hljs-comment">    | &#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125;</span><br><span class="hljs-comment">    | SQL SECURITY &#123; DEFINER | INVOKER &#125;</span><br><span class="hljs-comment">    | COMMENT &#x27;string&#x27;*/</span><br>	<span class="hljs-keyword">BEGIN</span><br>		[<span class="hljs-keyword">DECLARE</span> 变量名 类型 [<span class="hljs-keyword">DEFAULT</span> 值];]<br>		存储过程的语句块;<br>	<span class="hljs-keyword">END</span>$$<br><br>DELIMITER ;<br><br></code></pre></td></tr></table></figure></li>
<li><p>in代表输入参数（默认情况下为in参数），表示该参数的值必须由调用程序指定。</p>
</li>
<li><p>out代表输出参数，表示该参数的值经过存储过程计算后，将out参数的计算结果返回给调用程序</p>
</li>
<li><p>inout代表即时输入参数，又是输出参数，表示该参数的值既可以由调用程序制定，又可以将inout参数的计算结果返回给调用程序。</p>
</li>
</ul>
</li>
<li><p>存储过程中的语句必须包含在BEGIN和END之间</p>
</li>
<li><p>DELIMITER是分割符，默认情况下DELIMITER是分号，遇到分号就执行。</p>
</li>
<li><p>DECLARE中用来声明变量，变量默认赋值使用DEFAULT，语句块中改变变量值，使用SET变量=值</p>
</li>
<li><p>例子</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">DELIMITER $$<br><br><span class="hljs-keyword">CREATE</span><br>    <span class="hljs-keyword">PROCEDURE</span> <span class="hljs-string">`demo`</span>.<span class="hljs-string">`demo1`</span>()<br>	<span class="hljs-comment">-- 存储过程体</span><br>	<span class="hljs-keyword">BEGIN</span><br>		<span class="hljs-comment">-- DECLARE声明 用来声明变量的</span><br>		<span class="hljs-keyword">DECLARE</span> de_name <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span>;<br>		<br>		<span class="hljs-keyword">SET</span> de_name = <span class="hljs-string">&quot;jim&quot;</span>;<br>		<br>		<span class="hljs-comment">-- 测试输出语句（不同的数据库，测试语句都不太一样。</span><br>		<span class="hljs-keyword">SELECT</span> de_name;<br>	<span class="hljs-keyword">END</span>$$<br><br>DELIMITER ;<br><span class="hljs-comment">-- 调用</span><br><span class="hljs-keyword">CALL</span> demo1();<br></code></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">DELIMITER $$<br><br><span class="hljs-keyword">CREATE</span><br>    <span class="hljs-keyword">PROCEDURE</span> <span class="hljs-string">`demo`</span>.<span class="hljs-string">`demo2`</span>(<span class="hljs-keyword">IN</span> s_sex <span class="hljs-built_in">CHAR</span>(<span class="hljs-number">1</span>),<span class="hljs-keyword">OUT</span> s_count <span class="hljs-built_in">INT</span>)<br>	<span class="hljs-comment">-- 存储过程体</span><br>	<span class="hljs-keyword">BEGIN</span><br>		<span class="hljs-comment">-- 把SQL中查询的结果通过INTO赋给变量</span><br>		<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">INTO</span> s_count <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> sex= s_sex;<br>		<span class="hljs-keyword">SELECT</span> s_count;<br>		<br>	<span class="hljs-keyword">END</span>$$<br>DELIMITER ;<br><span class="hljs-comment">-- 调用</span><br><span class="hljs-comment">-- @s_count表示测试出输出的参数</span><br><span class="hljs-keyword">CALL</span> demo2 (<span class="hljs-string">&#x27;男&#x27;</span>,@s_count);<br><br></code></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- if判断</span><br>DELIMITER $$<br><span class="hljs-keyword">CREATE</span><br>    <span class="hljs-keyword">PROCEDURE</span> <span class="hljs-string">`demo`</span>.<span class="hljs-string">`demo3`</span>(<span class="hljs-keyword">IN</span> <span class="hljs-string">`day`</span> <span class="hljs-built_in">INT</span>)<br>	<span class="hljs-comment">-- 存储过程体</span><br>	<span class="hljs-keyword">BEGIN</span><br>		<span class="hljs-keyword">IF</span> <span class="hljs-string">`day`</span> = <span class="hljs-number">0</span> <span class="hljs-keyword">THEN</span><br>		<span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;星期天&#x27;</span>;<br>		ELSEIF `day` = 1 THEN<br>		<span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;星期一&#x27;</span>;<br>		ELSEIF `day` = 2 THEN<br>		<span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;星期二&#x27;</span>;<br>		ELSE<br>		<span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;无效日期&#x27;</span>;<br>		<span class="hljs-keyword">END</span> <span class="hljs-keyword">IF</span>;<br>		<br>	<span class="hljs-keyword">END</span>$$<br>DELIMITER ;<br><span class="hljs-comment">-- case when判断</span><br>DELIMITER $$<br><span class="hljs-keyword">CREATE</span> <br>    <span class="hljs-keyword">PROCEDURE</span> demo5(<span class="hljs-keyword">IN</span> <span class="hljs-keyword">num</span> <span class="hljs-built_in">INT</span>)<br>	<span class="hljs-keyword">BEGIN</span><br>		<span class="hljs-keyword">CASE</span> <span class="hljs-keyword">num</span>  <span class="hljs-comment">-- 条件开始</span><br>		<span class="hljs-keyword">WHEN</span> <span class="hljs-number">1</span> <span class="hljs-keyword">THEN</span> <br>			<span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;输入为1&#x27;</span>;<br>		WHEN 0 THEN <br>			<span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;输入为0&#x27;</span>;<br>		ELSE <br>		<span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;不是1也不是0&#x27;</span>;<br>		<span class="hljs-keyword">END</span> <span class="hljs-keyword">CASE</span>; <span class="hljs-comment">-- 条件结束</span><br>	<span class="hljs-keyword">END</span>$$<br>DELIMITER;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- while循环</span><br>DELIMITER $$<br><span class="hljs-keyword">CREATE</span> <br>    <span class="hljs-keyword">PROCEDURE</span> demo6(<span class="hljs-keyword">IN</span> <span class="hljs-keyword">num</span> <span class="hljs-built_in">INT</span>,<span class="hljs-keyword">OUT</span> <span class="hljs-keyword">SUM</span> <span class="hljs-built_in">INT</span>)<br>	<span class="hljs-keyword">BEGIN</span><br>	     <span class="hljs-keyword">SET</span> <span class="hljs-keyword">SUM</span> = <span class="hljs-number">0</span>;<br>	     WHILE num&lt;10 DO -- 循环开始<br>	         <span class="hljs-keyword">SET</span> <span class="hljs-keyword">num</span> = <span class="hljs-keyword">num</span>+<span class="hljs-number">1</span>;<br>	         <span class="hljs-keyword">SET</span> <span class="hljs-keyword">SUM</span> = <span class="hljs-keyword">SUM</span>+<span class="hljs-keyword">num</span>;<br>	         <span class="hljs-keyword">END</span> <span class="hljs-keyword">WHILE</span>; <span class="hljs-comment">-- 循环结束</span><br>	<span class="hljs-keyword">END</span>$$<br>DELIMITER;<br><br><span class="hljs-comment">-- REPEAT...UNTIL语句的语法和Java中的do...while语句类似，都是先执行循环操作，再判断条件，区别就是REPEAT表达式值为false时才执行循环操作，直到表达式值为true停止</span><br><span class="hljs-comment">-- 创建过程</span><br>DELIMITER $$<br><span class="hljs-keyword">CREATE</span> <br>    <span class="hljs-keyword">PROCEDURE</span> demo7(<span class="hljs-keyword">IN</span> <span class="hljs-keyword">num</span> <span class="hljs-built_in">INT</span>,<span class="hljs-keyword">OUT</span> <span class="hljs-keyword">SUM</span> <span class="hljs-built_in">INT</span>)<br>	<span class="hljs-keyword">BEGIN</span><br>	     <span class="hljs-keyword">SET</span> <span class="hljs-keyword">SUM</span> = <span class="hljs-number">0</span>;<br>	     REPEAT<span class="hljs-comment">-- 循环开始</span><br>		<span class="hljs-keyword">SET</span> <span class="hljs-keyword">num</span> = <span class="hljs-keyword">num</span>+<span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">SET</span> <span class="hljs-keyword">SUM</span> = <span class="hljs-keyword">SUM</span>+<span class="hljs-keyword">num</span> ;<br>		UNTIL num&gt;=10<br>		<span class="hljs-keyword">END</span> <span class="hljs-keyword">REPEAT</span>; <span class="hljs-comment">-- 循环结束</span><br>	<span class="hljs-keyword">END</span>$$<br>DELIMITER;<br><br><span class="hljs-comment">-- LOOP循环语句，用来重复执行某些语句</span><br><span class="hljs-comment">-- 执行过程中可使用LEAVE语句或者ITERATE来跳出循环，也可以嵌套IF等判断语句</span><br><span class="hljs-comment">-- LEAVE语句效果对于Java中的break,用来终止循环</span><br><span class="hljs-comment">-- ITERATE语句效果相当于Java中的Continue，用来跳过此次循环。进入下一次循环，且ITERATE之下的语句将不在进行。</span><br>DELIMITER $$<br><span class="hljs-keyword">CREATE</span> <br>    <span class="hljs-keyword">PROCEDURE</span> demo8(<span class="hljs-keyword">IN</span> <span class="hljs-keyword">num</span> <span class="hljs-built_in">INT</span>,<span class="hljs-keyword">OUT</span> <span class="hljs-keyword">SUM</span> <span class="hljs-built_in">INT</span>)<br>	<span class="hljs-keyword">BEGIN</span><br>	     <span class="hljs-keyword">SET</span> <span class="hljs-keyword">SUM</span> = <span class="hljs-number">0</span>;<br>	     demo_sum:LOOP<span class="hljs-comment">-- 循环开始</span><br>		<span class="hljs-keyword">SET</span> <span class="hljs-keyword">num</span> = <span class="hljs-keyword">num</span>+<span class="hljs-number">1</span>;<br>		IF num &gt; 10 THEN<br>		    LEAVE demo_sum; <span class="hljs-comment">-- 结束此次循环</span><br>		ELSEIF num &lt; 9 THEN<br>		    ITERATE demo_sum; <span class="hljs-comment">-- 跳过此次循环</span><br>		<span class="hljs-keyword">END</span> <span class="hljs-keyword">IF</span>;<br>		<br>		<span class="hljs-keyword">SET</span> <span class="hljs-keyword">SUM</span> = <span class="hljs-keyword">SUM</span>+<span class="hljs-keyword">num</span>;<br>		<span class="hljs-keyword">END</span> <span class="hljs-keyword">LOOP</span> demo_sum; <span class="hljs-comment">-- 循环结束</span><br>	<span class="hljs-keyword">END</span>$$<br>DELIMITER;<br><br></code></pre></td></tr></table></figure>

<ul>
<li><p>使用存储过程插入信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">DELIMITER $$<br><span class="hljs-keyword">CREATE</span> <br>    <span class="hljs-keyword">PROCEDURE</span> demo9(<span class="hljs-keyword">IN</span> s_student <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">10</span>),<span class="hljs-keyword">IN</span> s_sex <span class="hljs-built_in">CHAR</span>(<span class="hljs-number">1</span>),<span class="hljs-keyword">OUT</span> s_result <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>))<br>	<span class="hljs-keyword">BEGIN</span><br>	   <span class="hljs-comment">-- 声明一个变量 用来决定这个名字是否已经存在</span><br>	   <span class="hljs-keyword">DECLARE</span> s_count <span class="hljs-built_in">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>;<br>	   <span class="hljs-comment">-- 验证这么名字是否已经存在</span><br>	   <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">INTO</span> s_count <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> <span class="hljs-string">`name`</span> = s_student;	<br>	   IF s_count = 0 THEN<br>	        <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> student (<span class="hljs-string">`name`</span>, sex) <span class="hljs-keyword">VALUES</span>(s_student, s_sex);<br>		<span class="hljs-keyword">SET</span> s_result = <span class="hljs-string">&#x27;数据添加成功&#x27;</span>;<br>	   ELSE<br>                <span class="hljs-keyword">SET</span> s_result = <span class="hljs-string">&#x27;名字已存在，不能添加&#x27;</span>;<br>                <span class="hljs-keyword">SELECT</span> s_result;<br>	   <span class="hljs-keyword">END</span> <span class="hljs-keyword">IF</span>;<br>	<span class="hljs-keyword">END</span>$$<br>DELIMITER;<br><span class="hljs-comment">-- 调用</span><br><span class="hljs-keyword">CALL</span> demo9(<span class="hljs-string">&quot;Jim&quot;</span>,<span class="hljs-string">&quot;女&quot;</span>,@s_result);<br><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>````sql<br>SHOW PROCEDURE STATUS – 显示存储过程<br>SHOW PROCEDURE STATUS WHERE db = ‘db名字’ AND NAME = ‘name名字’;– 显示特定数据库的存储过程<br>SHOW PROCEDURE STATUS WHERE NAME LIKE ‘%mo%’;– 显示特定模式的存储过程<br>SHOW CREATE PROCEDURE 存储过程名;– 显示存储过程源码<br>DROP PROCEDURE 存储过程名;– 删除存储过程</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><br><span class="hljs-comment">## MySQL函数</span><br><br><span class="hljs-comment">### 函数定义</span><br><br>* MySQL的函数定义语法如下：<br><br>  ````sql<br>      CREATE  <br>          [DEFINER = &#123;<span class="hljs-built_in"> user </span>| CURRENT_USER &#125;]<br>          FUNCTION functionName ( varName varType [, <span class="hljs-built_in">..</span>. ] )<br>          RETURNS returnVarType<br>          [characteristic <span class="hljs-built_in">..</span>.] <br>          routine_body<br></code></pre></td></tr></table></figure></li>
<li><p>参数含义：</p>
<ul>
<li>functionName：函数名，同MySQL内置函数一样，大小写不敏感</li>
<li>varName：形参类型，其与varName配对使用。形参数量不限</li>
<li>returnVarType：返回值类型。函数必须有且只能有一个返回值</li>
<li>characteristic：函数特性</li>
<li>routine_body：函数体。函数体中必须含有return 语句，当函数体为复合结构时，需要使用begin….end语句</li>
</ul>
</li>
<li><p>````sql</p>
<pre><code>create
    function myfun_getMax(num1 int, num2 int)
    returns int        
begin
    declare res int;
    if(num1 &gt; num2) then
        set res = num1;
    elseif (num1 &lt; num2) then
        set res = num2;
    else
        set res = num1;
    end if;
    return res;
end;
</code></pre>
<figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><br>### 表格值函数<br><br>* 内联表格值函数:返回一个表格<br><br>  ````<span class="hljs-selector-tag">sql</span><br>  <span class="hljs-selector-tag">create</span> <span class="hljs-selector-tag">function</span> <span class="hljs-selector-tag">tabcmess</span>(<span class="hljs-variable">@title</span> VARCHAR(<span class="hljs-number">10</span>)) <span class="hljs-selector-tag">RETURNS</span> <span class="hljs-selector-tag">TABLE</span> <span class="hljs-selector-tag">as</span> <br>  <span class="hljs-selector-tag">return</span> (select title,des from product where title like <span class="hljs-string">&#x27;%&#x27;</span>+<span class="hljs-variable">@title</span>+<span class="hljs-string">&#x27;%&#x27;</span>)<br></code></pre></td></tr></table></figure></li>
<li><p>多句表格值函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br></code></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Java杂记</title>
    <url>/2021/04/14/Java-mutirecord/</url>
    <content><![CDATA[<h1 id="Java杂记"><a href="#Java杂记" class="headerlink" title="Java杂记"></a>Java杂记</h1><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul>
<li><h3 id="异常定义"><a href="#异常定义" class="headerlink" title="异常定义"></a>异常定义</h3></li>
<li>程序在运行时有可能出现的非正常状况，会导致程序崩溃 </li>
<li><h3 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h3></li>
<li><h4 id="按程度分："><a href="#按程度分：" class="headerlink" title="按程度分："></a>按程度分：</h4></li>
<li>Error：虚拟机都无法处理的错误状况</li>
<li>Exception：一般性的问题     </li>
<li><h4 id="按照处理方式为分："><a href="#按照处理方式为分：" class="headerlink" title="按照处理方式为分："></a>按照处理方式为分：</h4></li>
<li>受检异常，在程序中必须对其进行处理的异常，如果不处理，编译出错</li>
<li>Exception及其子类，RuntimeException及其子类除外：问题程序不容忽视         </li>
<li>非受检异常 在程序中不是必须对其进行处理的异常</li>
<li>Error及其子类：太严重了 </li>
<li>RuntimeException及其子类：太轻微了</li>
<li><h3 id="异常处理："><a href="#异常处理：" class="headerlink" title="异常处理："></a>异常处理：</h3></li>
<li><h3 id="1）捕获-try-catch-try-可能抛出异常的语句-catch-可能的异常类型-引用-通过异常处理异常对象"><a href="#1）捕获-try-catch-try-可能抛出异常的语句-catch-可能的异常类型-引用-通过异常处理异常对象" class="headerlink" title="1）捕获 try catch try{ 可能抛出异常的语句 }catch(可能的异常类型 引用){ 通过异常处理异常对象 }"></a>1）捕获 try catch try{ 可能抛出异常的语句 }catch(可能的异常类型 引用){ 通过异常处理异常对象 }</h3></li>
<li><h3 id="2）异常抛出-在方法中使用throw异常对象，方法一旦执行了throw和执行return效果是一样的，都会导致方法结束"><a href="#2）异常抛出-在方法中使用throw异常对象，方法一旦执行了throw和执行return效果是一样的，都会导致方法结束" class="headerlink" title="2）异常抛出 在方法中使用throw异常对象，方法一旦执行了throw和执行return效果是一样的，都会导致方法结束"></a>2）异常抛出 在方法中使用throw异常对象，方法一旦执行了throw和执行return效果是一样的，都会导致方法结束</h3></li>
<li>return时正常结束返回，throw时异常结束返回 </li>
<li>在签名中使用throws，可能的异常类型列表，警告调用者，调用此方法有风险，请考虑清楚</li>
<li>方法中的throw作用是真的产生破环</li>
<li><h3 id="3）先捕获再抛出"><a href="#3）先捕获再抛出" class="headerlink" title="3）先捕获再抛出"></a>3）先捕获再抛出</h3></li>
<li>在方法中先尝试执行某代码，如果真的出现了异常，再把这个异常关联到自定义异常对象中，再抛出自定义异常对象       </li>
<li>异常处理的选择：</li>
<li>入口方法尽量捕获（这个方法出问题会不会影响栈）</li>
<li>普通方法尽量抛出</li>
<li>如果代码中有潜在风险，尽量先捕再抛</li>
<li>如果代码中没有风险，但是有时不满足方法继续的条件时，直接抛出<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2></li>
<li>volatile :提醒子线程，此主存中的属性不要制作副本…</li>
</ul>
<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="冒泡排序："><a href="#冒泡排序：" class="headerlink" title="冒泡排序："></a>冒泡排序：</h3> <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaopaoSort</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] data=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">20</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;data.length ; i++) &#123;<br>            data[i]=(<span class="hljs-keyword">int</span>)(Math.random()*<span class="hljs-number">20</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> d : data) &#123;<br>            System.out.print(d+<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        System.out.println();<br>        System.out.println(<span class="hljs-string">&quot;===================================&quot;</span>);<br>        maopaoSort(data);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : data) &#123;<br>            System.out.print(i+<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">maopaoSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;arr.length ; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;arr.length-i;j++)&#123;<span class="hljs-comment">//每一次循环，最大的数以及到了数组末尾，所以每一轮都可以少遍历一个数据</span><br>                <span class="hljs-keyword">if</span>(arr[j]&lt;arr[j-<span class="hljs-number">1</span>])&#123;<br>                    <span class="hljs-keyword">int</span> tmp=arr[j];<br>                    arr[j]=arr[j-<span class="hljs-number">1</span>];<br>                    arr[j-<span class="hljs-number">1</span>]=tmp;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] arr1=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;arr1.length;i++) &#123;<br>	arr1[i]=(<span class="hljs-keyword">int</span>)(Math.random()*<span class="hljs-number">20</span>);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> tmp:arr1) &#123;<br>System.out.print(tmp+<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br>System.out.println();<br><span class="hljs-comment">//选择排序</span><br><span class="hljs-keyword">int</span> minindex;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;arr1.length-<span class="hljs-number">1</span>;i++) &#123;<span class="hljs-comment">//从0开始到倒数第二个位置</span><br>	minindex=i;<span class="hljs-comment">//最小下标先默认等于i</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;arr1.length;j++) &#123;<span class="hljs-comment">//遍历从i+1开始到数组长度的所有数</span><br>		<span class="hljs-keyword">if</span>(arr1[j]&lt;arr1[minindex]) &#123;<span class="hljs-comment">//找最小值</span><br>			minindex=j;<span class="hljs-comment">//更新最小下标</span><br>		&#125;<br>	&#125;<br>	<span class="hljs-comment">//交换元素，实现最小值赋值到基准位置i</span><br>	<span class="hljs-keyword">int</span> tmp=arr1[i];<br>	arr1[i]=arr1[minindex];<br>	arr1[minindex]=tmp;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> tmp:arr1) &#123;<br>System.out.print(tmp+<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br>System.out.println();<br></code></pre></td></tr></table></figure>

<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuickSort</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//int[] data = &#123;3,18,13,3,3&#125;;</span><br>        <span class="hljs-keyword">int</span>[] data=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">20</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; data.length; i++) &#123;<br>            data[i] = (<span class="hljs-keyword">int</span>) (Math.random() * <span class="hljs-number">20</span>);<br>        &#125;<br>        <span class="hljs-comment">//排序前</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; data.length; i++) &#123;<br>            System.out.print(data[i] + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//排序后</span><br>        System.out.println();<br>        System.out.println(<span class="hljs-string">&quot;====================================&quot;</span>);<br>        quickSort(data, <span class="hljs-number">0</span>, data.length-<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : data) &#123;<br>            System.out.print(i + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (end - begin &lt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//当一直递归后只剩下一个元素了，说明不用排序了递归结束</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//分区，分三个部分，中间是键值，左边比键值小，右边比键值大</span><br>        <span class="hljs-comment">//定位索引最关键</span><br>        <span class="hljs-keyword">int</span> key = arr[begin];<span class="hljs-comment">//总是取第一个元素为键值</span><br>        <span class="hljs-keyword">int</span> keyIndex = begin;<span class="hljs-comment">//键值索引，用于动态保存比键值小的值的索引</span><br>        <span class="hljs-comment">//来找比key小的元素，放到左边</span><br>        <span class="hljs-comment">//默认取第一个元素作为键值，第一个元素不用遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = begin + <span class="hljs-number">1</span>; i &lt;= end; i++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[i] &lt; key) &#123;<br>                keyIndex++;<span class="hljs-comment">//只要找到比key小的元素，keyIndex就往右移一个，因为肯定就有一个元素在键值的左边</span><br>                <span class="hljs-comment">//交换keyIndex和i的位置</span><br>                <span class="hljs-comment">//当keyIndex和i之间有大于key时，交换位置</span><br>                <span class="hljs-keyword">if</span>(i!=keyIndex) &#123;<br>                    <span class="hljs-keyword">int</span> tmp = arr[keyIndex];<br>                    arr[keyIndex] = arr[i];<br>                    arr[i] = tmp;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//此时keyIndex处的值与begin交换，因为从keyIndex开始到begin的值肯定是比键小的值</span><br>        arr[begin] = arr[keyIndex];<br>        arr[keyIndex] = key;<br>        <span class="hljs-comment">//左递归</span><br>        quickSort(arr, begin, keyIndex - <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//右递归</span><br>        quickSort(arr, keyIndex + <span class="hljs-number">1</span>, end);<br><br>    &#125;<br></code></pre></td></tr></table></figure>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-keyword">import</span> javax.lang.model.element.Element;<br><br><span class="hljs-keyword">import</span> jdk.jfr.Registered;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 注解的处理只能通过反射，要想反射，必须使用元注解<span class="hljs-doctag">@Retention</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Hasee</span><br><span class="hljs-comment"> *注解：是一种特殊的注释，不参与程序的执行，特殊之处在于编译器和JVM都可以识别它.</span><br><span class="hljs-comment"> *<span class="hljs-doctag">@Override</span> 作用是告诉编译器，它修饰的方法要完成方法覆盖，请帮助做条件检查，只能修饰方法</span><br><span class="hljs-comment"> *<span class="hljs-doctag">@Deprecated</span> 作用是警告使用者，它修饰的目标过期了，可以修饰类，属性，方法，构造器，形参，局部变量</span><br><span class="hljs-comment"> *<span class="hljs-doctag">@SuppressWarnings</span> 作用是抑制编译器警告，并且可以传递参数，参数可以是一个值也可以是一个数组</span><br><span class="hljs-comment"> *注解：</span><br><span class="hljs-comment"> *1）没有属性的，称为标记型注解</span><br><span class="hljs-comment"> *2）有属性的，可以进一步传递数据</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-comment">//自定义注解,默认可以修饰类，属性，构造器，方法，形参，局部变量</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-comment">//只有注解的停留期定义在运行时才可以被反射</span><br><span class="hljs-meta">@interface</span> MyAnnotation&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">int</span> <span class="hljs-title">id</span><span class="hljs-params">()</span><span class="hljs-keyword">default</span> 10</span>;<br>	<span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;我是缺省值&quot;</span>;<span class="hljs-comment">//可以有缺省值</span><br>	<span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;qaq&quot;</span>;<span class="hljs-comment">//当属性名为value()时可以省略属性名</span><br>&#125;<br><span class="hljs-meta">@MyAnnotation(id = 0, name = &quot;sda&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>	<span class="hljs-keyword">private</span> String name;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>	<span class="hljs-keyword">private</span> String gender;<br>	<span class="hljs-meta">@SuppressWarnings(&quot;unused&quot;)</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span> </span>&#123;<br><br>	&#125;<br>	<span class="hljs-meta">@MyAnnotation</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, String gender)</span> </span>&#123;<br>		<span class="hljs-keyword">super</span>();<br>		<span class="hljs-keyword">this</span>.name = name;<br>		<span class="hljs-keyword">this</span>.age = age;<br>		<span class="hljs-keyword">this</span>.gender = gender;<br>	&#125;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person [name=&quot;</span> + name + <span class="hljs-string">&quot;, age=&quot;</span> + age + <span class="hljs-string">&quot;, gender=&quot;</span> + gender + <span class="hljs-string">&quot;]&quot;</span>;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> name;<br>	&#125;<br>	<span class="hljs-meta">@MyAnnotation(&quot;aqa&quot;)</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.name = name;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> age;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.age = age;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getGender</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> gender;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setGender</span><span class="hljs-params">(String gender)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.gender = gender;<br>	&#125;<br>	<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnnotationTest</span> </span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="路径问题："><a href="#路径问题：" class="headerlink" title="路径问题："></a>路径问题：</h2><blockquote>
<ul>
<li>绝对路径：以根目录为开始的路径</li>
<li>相对路径：以当前目录未开始的路径（./）</li>
</ul>
</blockquote>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 泛型要解决类型安全问题</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&lt;<span class="hljs-title">X</span>&gt; </span>&#123; <span class="hljs-comment">// X表示某种类型, X在这里称为泛型的类型参数(是一个形参)</span><br>	<span class="hljs-comment">// X类型的真实类型会在创建对象时确定下来, 隶属于对象的存在而存在.</span><br>	<br>	<span class="hljs-keyword">private</span> String name;<br>	<span class="hljs-keyword">private</span> X info;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span> </span>&#123;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, X info)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.name = name;<br>		<span class="hljs-keyword">this</span>.info = info;<br>	&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> X <span class="hljs-title">getInfo</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> info;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setInfo</span><span class="hljs-params">(X info)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.info = info;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> name;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.name = name;<br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person [name=&quot;</span> + name + <span class="hljs-string">&quot;, info=&quot;</span> + info + <span class="hljs-string">&quot;]&quot;</span>;<br>	&#125;<br>	<br>	<span class="hljs-comment">//在静态方法中不可以使用泛型类中的泛型</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(X x)</span> </span>&#123;<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">// 泛型和继承之间的关系</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&lt;<span class="hljs-title">Y</span>&gt; </span>&#123;<br>	<span class="hljs-keyword">private</span> Y y;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> Y <span class="hljs-title">getY</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> y;<br>	&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;&#125; <span class="hljs-comment">// 子类中没有处理父类的泛型. 泛型类型就是类型最模糊的Object, 这种不好</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;&#125; <span class="hljs-comment">// 子类在继承时把父类的泛型写死了 ,  这是最简单</span><br><span class="hljs-comment">//class B3 extends A&lt;Teacher&gt; &#123;&#125; // 在创建子类对象后, 其泛型是固定的.</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B4</span>&lt;<span class="hljs-title">Y</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span>&lt;<span class="hljs-title">Y</span>&gt; </span>&#123;&#125; <span class="hljs-comment">// 子类在继承时仍然继续泛型, 这是最灵活</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericMethod</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(T t)</span> </span>&#123;<br>	&#125;<br>	<br>	<span class="hljs-comment">//public Object get(Object obj) &#123;</span><br>	<span class="hljs-comment">// 泛型方法中必须传入泛型类型的参数, 如果不传泛型永远无法确定.</span><br>	<span class="hljs-comment">// 这个泛型类型由实参的类型来决定, 所以它是和方法的某次调用相关</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-function">E <span class="hljs-title">get</span><span class="hljs-params">(E e)</span> </span>&#123; <span class="hljs-comment">// E表示只可以在此方法中使用的某种类型</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>	&#125;<br>	<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericTest</span> </span>&#123;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">//Object object = GenericMethod.get();</span><br>		String string = GenericMethod.get(<span class="hljs-string">&quot;abc&quot;</span>); <span class="hljs-comment">// 泛型方法必须通过实参来告诉方法, 泛型的具体类型是什么</span><br>		Integer integer = GenericMethod.get(<span class="hljs-number">200</span>);<br>		Boolean boolean1 = GenericMethod.get(<span class="hljs-keyword">false</span>);<br>		Object object = GenericMethod.get(<span class="hljs-keyword">null</span>); <span class="hljs-comment">// 如果实参是null, 将会导致泛型类型无法感知!!! </span><br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>&#123;<br>		B1 b1 = <span class="hljs-keyword">new</span> B1();<br>		Object y = b1.getY();<br>		<br>		Integer y2 = <span class="hljs-keyword">new</span> B2().getY();<br>		Integer y3 = <span class="hljs-keyword">new</span> B2().getY();<br>		<br>		<span class="hljs-comment">//Teacher y4 = new B3().getY();</span><br>		<br>		B4 b4 = <span class="hljs-keyword">new</span> B4();<br>		Object y5 = b4.getY();<br>		Double y6 = <span class="hljs-keyword">new</span> B4&lt;Double&gt;().getY();<br>		String y7 = <span class="hljs-keyword">new</span> B4&lt;String&gt;().getY();<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;<br>		Person&lt;Integer&gt; person1 = <span class="hljs-keyword">new</span> Person&lt;Integer&gt;(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">20</span>); <span class="hljs-comment">// 使用了泛型后, 类型就安全了.</span><br>		Integer info1 = person1.getInfo(); <span class="hljs-comment">// 获取到的属性也安全了, 清晰了.</span><br>		<br>		Person&lt;Boolean&gt; person2 = <span class="hljs-keyword">new</span> Person&lt;Boolean&gt;(<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-keyword">true</span>);<br>		Boolean info2 = person2.getInfo();<br>		<br>		Person person3 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;王五&quot;</span>, <span class="hljs-number">3.22</span>);<br>		Object info3 = person3.getInfo();<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br>		Person person1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">30</span>);<br>		Object info1 = person1.getInfo();<br>		<br>		Person person2 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;女&quot;</span>);<br>		Object info2 = person2.getInfo();<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br>		List list1 = <span class="hljs-keyword">new</span> ArrayList();<br>		list1.add(<span class="hljs-number">1</span>);<br>		list1.add(<span class="hljs-string">&quot;abc&quot;</span>);<br>		<br>		Object object = list1.get(<span class="hljs-number">0</span>);<br>		<br>		List&lt;Integer&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>		list2.add(<span class="hljs-number">3</span>);<br>		<span class="hljs-comment">//list2.add(&quot;abc&quot;);</span><br>		<br>		List&lt;Object&gt; list3 = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;();<br>	&#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> collection;<br><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 	Collection 集合 : 保存一个一个的对象, 特点 : 无序可重复</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 		Set 特点 : 无序不可重复</span><br><span class="hljs-comment"> * 			HashSet : 基于数组使用哈希算法实现的Set集合, </span><br><span class="hljs-comment"> 判定重复的标准是两个对象的equals为true, 并且两个对象的hashCode一样</span><br><span class="hljs-comment"> * 				优点 : 全是优点</span><br><span class="hljs-comment"> * 				缺点 : 对内存要求高</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 			TreeSet : 基于二叉搜索树(红黑树)实现的Set集合, </span><br><span class="hljs-comment"> 判定重复的标准是两个对象的比较结果为0</span><br><span class="hljs-comment"> * 				优点 : 对内存要求低, 搜索速度快</span><br><span class="hljs-comment"> * 				缺点 : 插入和删除的速度慢，大量元素的比较和树的旋转</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 		List : 特点 : 有序可重复</span><br><span class="hljs-comment"> * 			ArrayList : 基于数组实现的List集合, 线程不安全.</span><br><span class="hljs-comment"> * 				缺点 : 对内存要求高, 因为内存必须连续, </span><br><span class="hljs-comment"> 非末端数据的插入和删除都是最慢的, 因为有大量元素的移动.</span><br><span class="hljs-comment"> * 				优点 : 末端插入删除速度快</span><br><span class="hljs-comment"> * 				适用场景 : 存档数据, 主要用于查询检索</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 			Vector : 和ArrayList一样, 是一个古老的实现. 但是线程安全</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 			LinkedList : 基于链表实现的List集合</span><br><span class="hljs-comment"> * 				优点 : 对内存要求低. 插入,删除速度非常快</span><br><span class="hljs-comment"> * 				缺点 : 检索速度慢,</span><br><span class="hljs-comment"> * 				适用场景 : 频繁修改数据, 很少检索</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> *	泛型 : 类型安全问题, 在集合中使用泛型的好处是约束中的元素的数据类型, </span><br><span class="hljs-comment"> 类型可以是确定的, 不再是类型最模糊的Object</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *	遍历 : 增强for</span><br><span class="hljs-comment"> *			for (元素数据类型 临时变量 : 集合) &#123;</span><br><span class="hljs-comment"> *			&#125;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *		  迭代器 Iterator</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> 	必须从集合对象获取迭代器</span><br><span class="hljs-comment"> 	while (迭代器.hasNext()) &#123;</span><br><span class="hljs-comment"> 		元素 = 迭代器.next();</span><br><span class="hljs-comment"> 		处理元素;</span><br><span class="hljs-comment"> 	&#125;</span><br><span class="hljs-comment"> 	</span><br><span class="hljs-comment"> 	Map集合 : 保存的是一对一对的对象. 是具有映射关系的键值对象, </span><br><span class="hljs-comment"> 	键值对象都可以是任意对象. 键到值是单向一对一映射.</span><br><span class="hljs-comment"> 	Map可以简单地看作是一个词典, 键是词条, 值是解释.</span><br><span class="hljs-comment"> 		Object put(Object key, Object value); //写入条目</span><br><span class="hljs-comment"> 		Object remove(Object key); // 根据键删除 一个条目</span><br><span class="hljs-comment"> 		Object get(Object key); // 根据键查找值, 查词典</span><br><span class="hljs-comment"> 		Set keySet(); // 获取一个保存所有键对象的Set子集合</span><br><span class="hljs-comment"> 		Set entrySet(); // 获取保存所有条件对象的Set集合</span><br><span class="hljs-comment"> 		int size() ; 条目个数</span><br><span class="hljs-comment"> 		</span><br><span class="hljs-comment"> 		</span><br><span class="hljs-comment"> 		HashMap 是典型实现, 使用哈希算法实现的Map集合</span><br><span class="hljs-comment"> 		TreeMap 是基于二叉树实现的Map集合</span><br><span class="hljs-comment"> 		Hashtable 是古老的实现, 和HashMap一样, 它是线程安全, 效率低.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span></span>&#123;<br>	<span class="hljs-keyword">private</span> String name;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> weight;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dog</span><span class="hljs-params">()</span> </span>&#123;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> name;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.name = name;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> age;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.age = age;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getWeight</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> weight;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setWeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> weight)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.weight = weight;<br>	&#125;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Dog [name=&quot;</span> + name + <span class="hljs-string">&quot;, age=&quot;</span> + age + <span class="hljs-string">&quot;, weight=&quot;</span> + weight + <span class="hljs-string">&quot;]&quot;</span>;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dog</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, <span class="hljs-keyword">int</span> weight)</span> </span>&#123;<br>		<span class="hljs-keyword">super</span>();<br>		<span class="hljs-keyword">this</span>.name = name;<br>		<span class="hljs-keyword">this</span>.age = age;<br>		<span class="hljs-keyword">this</span>.weight = weight;<br>	&#125;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>		<span class="hljs-keyword">if</span>(o <span class="hljs-keyword">instanceof</span> Dog) &#123;<br>		<span class="hljs-keyword">return</span> ((Dog)o).age-<span class="hljs-keyword">this</span>.age;<br>		&#125;<br>		<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;对象不可比&quot;</span>);<br>	&#125;<br>	 <br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollectionTest</span> </span>&#123;<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br>		<br>	&#125;<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br>		Set set=<span class="hljs-keyword">new</span> TreeSet();<br>		Dog dog1=<span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&quot;小白&quot;</span>, <span class="hljs-number">5</span>, <span class="hljs-number">25</span>);<br>		Dog dog2=<span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&quot;小黄&quot;</span>, <span class="hljs-number">6</span>, <span class="hljs-number">50</span>);<br>		Dog dog3=<span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&quot;小黑&quot;</span>, <span class="hljs-number">4</span>, <span class="hljs-number">30</span>);<br>		Dog dog4=<span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&quot;狗蛋&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">10</span>);<br>		set.add(dog1);<br>		set.add(dog2);<br>		set.add(dog3);<br>		set.add(dog4);<br>		<br>		<span class="hljs-keyword">for</span> (Object object : set) &#123;<br>			System.out.println(object);<br>		&#125;<br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> date;<br><br><span class="hljs-keyword">import</span> java.text.ParseException;<br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><span class="hljs-keyword">import</span> java.time.LocalDate;<br><span class="hljs-keyword">import</span> java.time.LocalDateTime;<br><span class="hljs-keyword">import</span> java.time.LocalTime;<br><span class="hljs-keyword">import</span> java.time.format.DateTimeFormatter;<br><span class="hljs-keyword">import</span> java.util.Calendar;<br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * LocalDate,LocalTime,LocalDateTime Java8中新提供的处理时间的类</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DateTest</span> </span>&#123;<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test6</span><span class="hljs-params">()</span> </span>&#123;<br>		LocalDateTime of = LocalDateTime.of(<span class="hljs-number">2000</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>,<span class="hljs-number">1</span>);<br>		System.out.println(of);<br>		DateTimeFormatter dtf = DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy年MM月dd天&quot;</span>);<br>		System.out.println(dtf.format(of));<br>	&#125;<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span> </span>&#123;<br>		LocalTime time=LocalTime.now();<br>		System.out.println(time);<br>		LocalDateTime now = LocalDateTime.now();<br>		System.out.println(now);<br>		DateTimeFormatter dtf = DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>		System.out.println(dtf.format(now));<br>	&#125;<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>&#123;<br>		String str1 = <span class="hljs-string">&quot;abcwerthelloyuiodef &quot;</span>;<br>		String str2 = <span class="hljs-string">&quot;cvhellobnm&quot;</span>;<br>		<span class="hljs-keyword">int</span> length = str2.length();<br>		l1: <span class="hljs-keyword">while</span> (length &gt; <span class="hljs-number">0</span>) &#123;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> begin = <span class="hljs-number">0</span>; begin + length &lt;= str2.length(); begin++) &#123;<br>				<span class="hljs-keyword">if</span> (str1.contains(str2.substring(begin, begin + length))) &#123;<br>					System.out.println(str2.substring(begin, begin + length));<br>					<span class="hljs-keyword">break</span> l1;<br>				&#125;<br>			&#125;<br>			length--;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;<br>		LocalDate date = LocalDate.now();<br>		System.out.println(date);<br>		LocalDate withYear = date.withYear(<span class="hljs-number">2000</span>).withMonth(<span class="hljs-number">8</span>).withDayOfMonth(<span class="hljs-number">10</span>);<br>		System.out.println(withYear);<br>		LocalDate plusYears = withYear.plusDays(<span class="hljs-number">100</span>);<br>		System.out.println(plusYears);<br>	&#125;<br><br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br>		Calendar instance = Calendar.getInstance();<br>		<span class="hljs-comment">//</span><br>		instance.set(Calendar.YEAR, <span class="hljs-number">2000</span>);<br>		instance.set(Calendar.MONTH, <span class="hljs-number">7</span>);<br>		instance.set(Calendar.YEAR, <span class="hljs-number">10</span>);<br>		System.out.println(instance.getTime());<br>		instance.add(Calendar.DAY_OF_MONTH, <span class="hljs-number">100</span>);<br>		System.out.println(instance.getTime());<br>	&#125;<br><br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br>		System.out.println(System.currentTimeMillis());<span class="hljs-comment">// 距离1970-01-01 00:00:00:000的毫秒数</span><br>		Date date = <span class="hljs-keyword">new</span> Date();<br>		System.out.println(date);<br>		SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>		String format = sdf.format(date);<br>		System.out.println(format);<br>		String string = <span class="hljs-string">&quot;2001-12-06 20:45:19&quot;</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			System.out.println(sdf.parse(string));<br>		&#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;<br>			<span class="hljs-comment">// TODO Auto-generated catch block</span><br>			e.printStackTrace();<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="大数"><a href="#大数" class="headerlink" title="大数"></a>大数</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> math;<br><br><span class="hljs-keyword">import</span> java.math.BigInteger;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * java中所有字符都是两个字节</span><br><span class="hljs-comment"> * C语言中汉字占两个字节，其他字符1个字节</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MathClassTest</span> </span>&#123;<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br>		System.out.println(Math.random());<br>		System.out.println(Math.round(-<span class="hljs-number">4.5</span>));<br>		BigInteger bi1=<span class="hljs-keyword">new</span> BigInteger(<span class="hljs-string">&quot;41654894789415618977465187416518948651327849816354184894561564897488465415415&quot;</span>);<br>		BigInteger bi2=<span class="hljs-keyword">new</span> BigInteger(<span class="hljs-string">&quot;41654894789415641568977465187416518948651327849816354184894561564897488465415415&quot;</span>);<br>		System.out.println(bi2.add(bi1));<br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> string;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * StringBuffer :内容可以改变的Unicode字符序列，任何修改都不会产生新对象，是内部的数据的变化，效率高</span><br><span class="hljs-comment"> * 是一个容器，是一个可以保存字符的容器，底层仍让使用数组</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * StringBuilder append(...) 在字符串末尾追加任意数据. StringBuilder insert(int index, ...)</span><br><span class="hljs-comment"> * 在指定位置处插入任意新数据 StringBuilder delete(int begin, int end) 删除指定区间的所有字符</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * StringBuffer是线程安全的, 效率低 .</span><br><span class="hljs-comment"> * StringBuilder是线程不安全的, 效率高.(优先使用)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringBuilderTest</span> </span>&#123;<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br>		String str=<span class="hljs-keyword">null</span>;<br>		StringBuffer sb=<span class="hljs-keyword">new</span> StringBuffer();<br>		sb.append(str);<span class="hljs-comment">//如果append null会把null分解成单个字符，加入到StringBuffer中，count+=4</span><br>		System.out.println(sb.length());<br>		System.out.println(sb);<br>		StringBuffer sb1=<span class="hljs-keyword">new</span> StringBuffer(str);<span class="hljs-comment">//空指针错误,无法运行</span><br>		System.out.println(sb1);<br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> string;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 字符串：内容不可改变的Unicode字符的序列，任何对自负床的修改都一定会产生新的字符串对象</span><br><span class="hljs-comment"> * 底层使用byte[]来保存字符，字符串的处理与下标密切相关</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//System.arrycopy(value,0,result,0,value.length)实现从源数组到目标数组的复制</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 字符串 : 内容不可改变的Unicode字符的序列, 任何的对字符串的修改都一定会产生新的字符串对象.</span><br><span class="hljs-comment"> * 底层使用了char[]来保存字符, 字符串的处理和下标密切相关.</span><br><span class="hljs-comment"> * 					0 2         12       17        23        29      37 39</span><br><span class="hljs-comment"> * String string = &quot;  abcABXXyy 我喜欢你,你喜欢我吗?我不喜欢你 qqyyZZ123  &quot;;</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 	*****public int length() 获取字符串长度(字符数) string.length() =&gt; 40</span><br><span class="hljs-comment">	*****public char charAt(int index) 获取参数指定的下标位置处的字符 string.charAt(10) =&gt; y. string.charAt(13) =&gt; 喜</span><br><span class="hljs-comment">	public char[] toCharArray() 获取字符串相应的字符数组, 是内部数组的一个副本</span><br><span class="hljs-comment">			System.arraycopy(value, 0, result, 0, value.length);</span><br><span class="hljs-comment">			// 第一个参数是源数组, </span><br><span class="hljs-comment">			 * 第2个参数是源数组开始下标</span><br><span class="hljs-comment">			// 第3个参数是目标数组, </span><br><span class="hljs-comment">			 * 第4个参数是目标数组的开始复制的下标, </span><br><span class="hljs-comment">			 * 第5个参数是总共要复制的元素个数.</span><br><span class="hljs-comment">			 * </span><br><span class="hljs-comment">			效果相当于 : </span><br><span class="hljs-comment">			for (int i = 0; i &lt; value.length; i++) &#123;</span><br><span class="hljs-comment">				result[i] = value[i];</span><br><span class="hljs-comment">			&#125;</span><br><span class="hljs-comment">			</span><br><span class="hljs-comment">	****public boolean equals(Object anObject)</span><br><span class="hljs-comment">	public int compareTo(String anotherString)</span><br><span class="hljs-comment">	</span><br><span class="hljs-comment"> * 					0 2         12       17        23        29      37 39</span><br><span class="hljs-comment"> * String string = &quot;  abcABXXyy 我喜欢你,你喜欢我吗?我不喜欢你 qqyyZZ123  &quot;;</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment">	***public int indexOf(String s), 获取参数中的子串在当前字符串中首次出现的下标值 string.indexOf(&quot;喜欢&quot;) =&gt; 13, 如果搜索失败返回-1</span><br><span class="hljs-comment">	public int indexOf(String s ,int startpoint) 获取第2个喜欢 : string.indexOf(&quot;喜欢&quot;, 14) =&gt; 18, </span><br><span class="hljs-comment">												  获取第3个喜欢 : string.indexOf(&quot;喜欢&quot;, 19) =&gt; 25,</span><br><span class="hljs-comment">												  </span><br><span class="hljs-comment">	public int lastIndexOf(String s) 从右向左搜索子串出现的下标, string.lastIndexOf(&quot;喜欢&quot;) =&gt; 25</span><br><span class="hljs-comment">	public int lastIndexOf(String s ,int startpoint) 获取第2个喜欢 : string.lastIndexOf(&quot;喜欢&quot;, 24) =&gt; 18</span><br><span class="hljs-comment">	</span><br><span class="hljs-comment">	// 通常获取文件列表名, 对文件名进行判断</span><br><span class="hljs-comment">	*public boolean startsWith(String prefix) 判断字符串是否以参数中的子串为开始 string.startsWith(&quot;  abc&quot;) =&gt; true</span><br><span class="hljs-comment">	*public boolean endsWith(String suffix) 判断字符串是否以参数中的子串为结束 string.endsWith(&quot;123&quot;) =&gt; false</span><br><span class="hljs-comment">	</span><br><span class="hljs-comment">	*****public String substring(int start,int end) 从当前字符串中截取子串, start表示开始下标(包含), end表示结束下标(不包含)</span><br><span class="hljs-comment">						string.substring(12, 16) =&gt; &quot;我喜欢你&quot;,  结束下标-开始下标 == 子串长度</span><br><span class="hljs-comment">	public String substring(int startpoint) 从当前字符串中取子串,从start开始到结束</span><br><span class="hljs-comment">	</span><br><span class="hljs-comment">	public String replace(char oldChar,char newChar) 替换字符串中的所有旧字符为新字符</span><br><span class="hljs-comment">	public String replaceAll(String old,String new) 全部替换老串为新串, 特殊字符 \ [ * +</span><br><span class="hljs-comment">	</span><br><span class="hljs-comment">	public String trim() 修剪字符串的首尾的空白字符(Unicode码值小于等于32的字符，都是空白字符)</span><br><span class="hljs-comment">	</span><br><span class="hljs-comment">	public String concat(String str)</span><br><span class="hljs-comment">	public String toUpperCase() 改变大小写</span><br><span class="hljs-comment">	public String toLowerCase()</span><br><span class="hljs-comment">	public String[] split(String regex) 以参数中的子串为切割器, 把字符串切割成多个部分.</span><br><span class="hljs-comment">	*****public boolean equalsIgnoreCase(String s2) 比较字符串的内容, 忽略大小写</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringClassTest</span> </span>&#123;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>&#123;<br>		String s=<span class="hljs-string">&quot;  		\r\t\n  	\r\tw 		\t\r\t\n\r&quot;</span>;<br>		<span class="hljs-keyword">int</span> begin=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++) &#123;<br>			<span class="hljs-keyword">if</span>(s.charAt(i)&gt;<span class="hljs-number">32</span>) &#123;<br>				begin=i;<br>				<span class="hljs-keyword">break</span>;<br>			&#125;<br>		&#125;<br>		System.out.println(begin);<br>		<span class="hljs-keyword">int</span> end=begin;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=s.length()-<span class="hljs-number">1</span>;i&gt;begin;i--) &#123;<br>			<span class="hljs-keyword">if</span>(s.charAt(i)&gt;<span class="hljs-number">32</span>) &#123;<br>				end=i;<br>				<span class="hljs-keyword">break</span>;<br>			&#125;<br>		&#125;<br>		System.out.println(end);<br>		System.out.println(s.substring(begin, end+<span class="hljs-number">1</span>));<br>		<br>		<br>		<br>		String string=<span class="hljs-string">&quot;PATH=C:\\Python38\\Scripts\\;C:\\Python38\\;C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\;C:\\Windows\\System32\\OpenSSH\\;C:\\Program Files (x86)\\NVIDIA Corporation\\PhysX\\Common;C:\\Program Files\\NVIDIA Corporation\\NVIDIA NGX;C:\\Program Files (x86)\\Intel\\Intel(R) Management Engine Components\\DAL;C:\\Program Files\\Intel\\Intel(R) Management Engine Components\\DAL;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\;C:\\WINDOWS\\System32\\OpenSSH\\;D:\\Program Files\\Java\\jdk-13.0.2\\bin;C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Anaconda3 (64-bit);D:\\python;D:\\python\\Scripts;D:\\python\\Library\\bin;D:\\Git\\cmd;C:\\ProgramData\\chocolatey\\bin;D:\\blog\\;C:\\Users\\Hasee\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Users\\Hasee\\AppData\\Local\\Programs\\Microsoft VS Code\\bin;D:\\python\\PyCharm Community Edition 2019.3.3\\bin;D:\\Fiddler;C:\\Users\\Hasee\\AppData\\Roaming\\npm;D:\\PyCharm Community Edition 2020.2.3\\bin;C:\\adb;C:\\Program Files\\NVIDIA Corporation\\NVIDIA NvDLISR;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\;C:\\WINDOWS\\System32\\OpenSSH\\;D:\\tomcat\\apache-tomcat-10.0.2\\bin;D:\\Program Files\\Java\\jdk-13.0.2\\bin;C:\\Users\\Hasee\\AppData\\Local\\Microsoft\\WindowsApps;;C:\\Users\\Hasee\\AppData\\Local\\Programs\\Microsoft VS Code\\bin;D:\\python\\PyCharm Community Edition 2019.3.3\\bin;D:\\Fiddler;C:\\Users\\Hasee\\AppData\\Roaming\\npm;D:\\PyCharm Community Edition 2020.2.3\\bin;;C:\\Users\\Hasee\\AppData\\Local\\Microsoft\\WindowsApps&quot;</span>;<br>		String[] splitString=string.split(<span class="hljs-string">&quot;;&quot;</span>);<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;splitString.length;i++) &#123;<br>			System.out.println(splitString[i]);<br>		&#125;<br>	&#125;<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;<br>		String s=<span class="hljs-string">&quot;abcdefghijklmn&quot;</span>;<br>		<span class="hljs-keyword">int</span> begin=<span class="hljs-number">2</span>;<br>		<span class="hljs-keyword">int</span> end=<span class="hljs-number">6</span>;<br>		String s1=s.substring(<span class="hljs-number">0</span>,begin);<br>		String s2=s.substring(begin, end);<br>		String s3=s.substring(end,s.length());<br>		System.out.println(s1);<br>		System.out.println(s2);<br>		System.out.println(s3);<br>		String news=<span class="hljs-string">&quot;&quot;</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s2.length();i++) &#123;<br>			news=s2.charAt(i)+news;<br>		&#125;<br>		System.out.println(news);<br>		news=s1+news+s3;<br>		System.out.println(news);<br>	&#125;<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">char</span>[] arr= &#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;7&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>&#125;;<br>		String s1=<span class="hljs-keyword">new</span> String(arr);<br>		System.out.println(s1);<br>		String s2=<span class="hljs-keyword">new</span> String(arr,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<span class="hljs-comment">//new String(char[],startindex,count)</span><br>		System.out.println(s2);<br>		System.out.println(s2.length());<br>		String s3=<span class="hljs-string">&quot;&quot;</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=s1.length()-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--) &#123;<br>			s3+=s1.charAt(i);<br>		&#125;<br>		System.out.println(s3);<br>	&#125;<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br>		String s=<span class="hljs-string">&quot;abkkcadkabkebfkabkskab&quot;</span>;<br>		String s1=<span class="hljs-string">&quot;ab&quot;</span>;<br>		<span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();) &#123;<br>			<span class="hljs-keyword">if</span>(s.indexOf(s1,i)!=-<span class="hljs-number">1</span>) &#123;<br>				cnt++;<br>				i=s.indexOf(s1,i)+<span class="hljs-number">1</span>;<br>			&#125;<br>			<span class="hljs-keyword">else</span> &#123;<br>				i++;<br>			&#125;<br>		&#125;<br>		System.out.println(cnt);<br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h2 id="装箱"><a href="#装箱" class="headerlink" title="装箱"></a>装箱</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> wrapper;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WrapperTest</span> </span>&#123;<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">int</span> n=<span class="hljs-number">20</span>;<br>		Integer obj1=<span class="hljs-keyword">new</span> Integer(n);<br>		Integer obj2=n;<span class="hljs-comment">//自动装箱</span><br>		System.out.println(obj1==obj2);<br>		System.out.println(obj1.equals(obj2));<br>	&#125;<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br>		Integer i=<span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);<br>		Integer j=<span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);<br>		System.out.println(i==j);<span class="hljs-comment">//false</span><br>		<span class="hljs-comment">//自动装箱，调用Integer.valueOf(n)</span><br>		<span class="hljs-comment">//在-128到127之间，自动装箱不会创建新的对象，会取缓冲对象数组中的一个，超过该范围，自动装箱会创建新对象</span><br>		Integer m=<span class="hljs-number">1</span>;<span class="hljs-comment">//自动装箱</span><br>		Integer n=<span class="hljs-number">1</span>;<br>		System.out.println(m==n);<span class="hljs-comment">// true</span><br>		<br>		<br>		Integer x=<span class="hljs-number">128</span>;<span class="hljs-comment">//自动装箱</span><br>		Integer y=<span class="hljs-number">128</span>;<br>		System.out.println(x==y);<span class="hljs-comment">//false</span><br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h2 id="JavaIo"><a href="#JavaIo" class="headerlink" title="JavaIo"></a>JavaIo</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedInputStream;<br><span class="hljs-keyword">import</span> java.io.BufferedOutputStream;<br><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.BufferedWriter;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.io.FileReader;<br><span class="hljs-keyword">import</span> java.io.FileWriter;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.io.InputStreamReader;<br><span class="hljs-keyword">import</span> java.io.ObjectInputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.io.OutputStreamWriter;<br><span class="hljs-keyword">import</span> java.io.Serializable;<br><span class="hljs-keyword">import</span> java.io.UnsupportedEncodingException;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 绝对路径：以根目录为开始的路径</span><br><span class="hljs-comment"> * 相对路径：以当前目录未开始的路径（./）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String school; <span class="hljs-comment">// 序列化不可以序列化静态属性</span><br>	<br>	<span class="hljs-comment">// 只序列化对象在GC区中的数据</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>	<span class="hljs-keyword">private</span> String name;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> grade;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">double</span> score;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span> </span>&#123;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name, <span class="hljs-keyword">int</span> grade, <span class="hljs-keyword">double</span> score)</span> </span>&#123;<br>		<span class="hljs-keyword">super</span>();<br>		<span class="hljs-keyword">this</span>.id = id;<br>		<span class="hljs-keyword">this</span>.name = name;<br>		<span class="hljs-keyword">this</span>.grade = grade;<br>		<span class="hljs-keyword">this</span>.score = score;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> id;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.id = id;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> name;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.name = name;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getGrade</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> grade;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setGrade</span><span class="hljs-params">(<span class="hljs-keyword">int</span> grade)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.grade = grade;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getScore</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> score;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setScore</span><span class="hljs-params">(<span class="hljs-keyword">double</span> score)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.score = score;<br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student [id=&quot;</span> + id + <span class="hljs-string">&quot;, name=&quot;</span> + name + <span class="hljs-string">&quot;, grade=&quot;</span> + grade + <span class="hljs-string">&quot;, score=&quot;</span> + score + <span class="hljs-string">&quot;]&quot;</span>;<br>	&#125;<br>	<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaIoTest</span> </span>&#123;<br>	<span class="hljs-comment">// 从键盘输入一些内容, 把文件保存成UTF8格式的文本文件content.txt</span><br>	<span class="hljs-comment">// 直到键盘输入over命令, 或ctrl+z </span><br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test13</span><span class="hljs-params">()</span> </span>&#123;<br>		InputStream is = System.in; <span class="hljs-comment">// 以键盘为数据源</span><br>		InputStreamReader isr = <span class="hljs-keyword">null</span>;<br>		BufferedReader bufferedReader = <span class="hljs-keyword">null</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			isr = <span class="hljs-keyword">new</span> InputStreamReader(is);<br>			bufferedReader = <span class="hljs-keyword">new</span> BufferedReader(isr);<br>			String line = bufferedReader.readLine();<br>			<span class="hljs-keyword">while</span> (line != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-comment">// 1) 处理数据 </span><br>				<span class="hljs-keyword">if</span> (line.equals(<span class="hljs-string">&quot;exit&quot;</span>)) &#123;<br>					<span class="hljs-keyword">break</span>;<br>				&#125;<br>				System.out.println(line);<br>				<span class="hljs-comment">// 2) 继续读</span><br>				line = bufferedReader.readLine(); <span class="hljs-comment">// ctrl+z 提醒流数据已经结束</span><br>			&#125;<br>		&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			<span class="hljs-keyword">if</span> (bufferedReader != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					bufferedReader.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test12</span><span class="hljs-params">()</span> </span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);<br>		System.err.println(<span class="hljs-string">&quot;Error&quot;</span>);<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test11</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">//FileWriter fileWriter = null;</span><br>		FileOutputStream fos = <span class="hljs-keyword">null</span>;<br>		OutputStreamWriter osw = <span class="hljs-keyword">null</span>;<br>		BufferedWriter bufferedWriter = <span class="hljs-keyword">null</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			<span class="hljs-comment">//fileWriter = new FileWriter(&quot;一个文本文件&quot;);</span><br>			fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;一个文本文件_UTF8&quot;</span>, <span class="hljs-keyword">true</span>); <span class="hljs-comment">// 在创建节点流时, 传入第2个参数true,表示追加</span><br>			osw = <span class="hljs-keyword">new</span> OutputStreamWriter(fos, <span class="hljs-string">&quot;utf8&quot;</span>); <span class="hljs-comment">// 在写文件时, 把字符串全部按照UTF8编码方式进行编码</span><br>			bufferedWriter = <span class="hljs-keyword">new</span> BufferedWriter(osw);<br>			bufferedWriter.write(<span class="hljs-string">&quot;abc我和你&quot;</span>);<br>			<br>			<span class="hljs-comment">//bufferedWriter.flush(); // 把数据真的从缓冲区刷入硬盘</span><br>			<br>		&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			<span class="hljs-keyword">if</span> (bufferedWriter != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					bufferedWriter.close(); <span class="hljs-comment">// 在关闭前会自动flush</span><br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test10</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">//FileReader fileReader = null; // 它太弱了, 不好用</span><br>		FileInputStream fis = <span class="hljs-keyword">null</span>;<br>		InputStreamReader isr = <span class="hljs-keyword">null</span>;<br>		BufferedReader bufferedReader = <span class="hljs-keyword">null</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			<span class="hljs-comment">//fileReader = new FileReader(&quot;HashMap.java&quot;); // 只能处理和项目一致的编码的文本文件</span><br>			fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;HashMap.java&quot;</span>);<br>			<span class="hljs-comment">//isr = new InputStreamReader(fis); // 在这里仍然使用的是默认编码方式</span><br>			isr = <span class="hljs-keyword">new</span> InputStreamReader(fis, <span class="hljs-string">&quot;utf8&quot;</span>); <span class="hljs-comment">// 指明转换流在处理字节数据时按照UTF8编码方式处理字符串</span><br>			bufferedReader = <span class="hljs-keyword">new</span> BufferedReader(isr);<br>			<br>			String line = bufferedReader.readLine(); <br>			<span class="hljs-keyword">while</span> (line != <span class="hljs-keyword">null</span>) &#123;<br>				System.out.println(line);<br>				line = bufferedReader.readLine();<br>			&#125;<br>		&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			<span class="hljs-keyword">if</span> (bufferedReader != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					bufferedReader.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unserialize</span><span class="hljs-params">()</span> </span>&#123;<br>		FileInputStream fis = <span class="hljs-keyword">null</span>;<br>		BufferedInputStream bis = <span class="hljs-keyword">null</span>;<br>		ObjectInputStream ois = <span class="hljs-keyword">null</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;对象序列化&quot;</span>);<br>			bis = <span class="hljs-keyword">new</span> BufferedInputStream(fis);<br>			ois = <span class="hljs-keyword">new</span> ObjectInputStream(bis);<br>			<br>			<span class="hljs-comment">/*</span><br><span class="hljs-comment">			Object obj1 = ois.readObject();</span><br><span class="hljs-comment">			Object obj2 = ois.readObject();</span><br><span class="hljs-comment">			Object obj3 = ois.readObject();</span><br><span class="hljs-comment">			</span><br><span class="hljs-comment">			System.out.println(obj1);</span><br><span class="hljs-comment">			System.out.println(obj2);</span><br><span class="hljs-comment">			System.out.println(obj3);</span><br><span class="hljs-comment">			</span><br><span class="hljs-comment">			System.out.println(Student.school);</span><br><span class="hljs-comment">			*/</span><br>			<br>			<span class="hljs-comment">/*</span><br><span class="hljs-comment">			Student[] arr = (Student[])ois.readObject();</span><br><span class="hljs-comment">			for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="hljs-comment">				System.out.println(arr[i]);</span><br><span class="hljs-comment">			&#125;</span><br><span class="hljs-comment">			*/</span><br>			<br>			List&lt;Student&gt; list = (List&lt;Student&gt;)ois.readObject();<br>			Iterator&lt;Student&gt; iterator = list.iterator();<br>			<span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>				System.out.println(iterator.next());<br>			&#125;<br>			<br>		&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			<span class="hljs-keyword">if</span> (ois != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					ois.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">serialize</span><span class="hljs-params">()</span> </span>&#123;<br>		FileOutputStream fos = <span class="hljs-keyword">null</span>;<br>		BufferedOutputStream bos = <span class="hljs-keyword">null</span>;<br>		ObjectOutputStream oos = <span class="hljs-keyword">null</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;对象序列化&quot;</span>);<br>			bos = <span class="hljs-keyword">new</span> BufferedOutputStream(fos);<br>			oos = <span class="hljs-keyword">new</span> ObjectOutputStream(bos);<br>			<br>			Student s1 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">90</span>);<br>			Student s2 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;小花&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">80</span>);<br>			Student s3 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;小丽&quot;</span>, <span class="hljs-number">4</span>, <span class="hljs-number">20</span>);<br>			<br>			s1.school = <span class="hljs-string">&quot;atguigu&quot;</span>;<br>			<br>			<span class="hljs-comment">//oos.writeObject(s1);</span><br>			<span class="hljs-comment">//oos.writeObject(s2);</span><br>			<span class="hljs-comment">//oos.writeObject(s3);</span><br>			<br>			<span class="hljs-comment">//Student[] arr = &#123;s1, s2, s3&#125;;</span><br>			<span class="hljs-comment">//oos.writeObject(arr);</span><br>			<br>			List&lt;Student&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Student&gt;();<br>			list.add(s1);<br>			list.add(s2);<br>			list.add(s3);<br>			oos.writeObject(list);<br>			<br>		&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			<span class="hljs-keyword">if</span> (oos != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					oos.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test8</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> UnsupportedEncodingException </span>&#123;<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * Unicoode编码每个字符占两个字节</span><br><span class="hljs-comment">		   GBK编码汉字占两个字节，其他字符一个字节</span><br><span class="hljs-comment">		   UTF-8编码汉字占三个字节，其他字符占一个字节</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-comment">// e6 88 91 可变长度编码</span><br>		<span class="hljs-keyword">int</span> n1 = <span class="hljs-number">0x6211</span>; <span class="hljs-comment">// Unicode码是国际标准委员会制定</span><br>		System.out.println(n1);<br>		System.out.println((<span class="hljs-keyword">char</span>)n1);<br>		<br>		<span class="hljs-keyword">int</span> n2 = <span class="hljs-number">0xCED2</span>; <span class="hljs-comment">// GBK码值, 是中国人自己制定</span><br>		System.out.println(n2);<br>		<br>		<span class="hljs-comment">// 编码 : 字符串 =&gt; 字节数组, string.getBytes(), 目标是把字符串保存到文件中或通过网络传输.</span><br>		String string = <span class="hljs-string">&quot;abc我和你&quot;</span>;<br>		<span class="hljs-keyword">byte</span>[] bytes1 = string.getBytes(<span class="hljs-string">&quot;gbk&quot;</span>); <span class="hljs-comment">// 按照项目默认的编码方式: GBK编码方式进行编码</span><br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; bytes1.length; i++) &#123;<br>			System.out.print(Integer.toHexString(bytes1[i]) + <span class="hljs-string">&quot; &quot;</span>);<br>		&#125;<br>		System.out.println();<br>		<br>		<span class="hljs-keyword">byte</span>[] bytes2 = string.getBytes(<span class="hljs-string">&quot;utf8&quot;</span>);<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; bytes2.length; i++) &#123;<br>			System.out.print(Integer.toHexString(bytes2[i]) + <span class="hljs-string">&quot; &quot;</span>);<br>		&#125;<br>		System.out.println();<br>		<br>		<span class="hljs-comment">// 解码 : 字节数组 =&gt; 字符串, new String(byte[]), 把文件中或从网络接收的数据还原成字符串</span><br>		String string2 = <span class="hljs-keyword">new</span> String(bytes1, <span class="hljs-string">&quot;gbk&quot;</span>); <span class="hljs-comment">// 把字节数组按照gbk编码方式进行解码 </span><br>		<span class="hljs-comment">// 每2个字节凑一个整数, 是GBK码, 再查表找到对应的Unicode码</span><br>		System.out.println(string2);<br>		<br>		String string3 = <span class="hljs-keyword">new</span> String(bytes2, <span class="hljs-string">&quot;utf8&quot;</span>);<br>		<span class="hljs-comment">// 每3个字节凑一个字符, 从3个字节中拆出数据, 拆出的数据直接就是Unicode</span><br>		System.out.println(string3);<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test9</span><span class="hljs-params">()</span> </span>&#123;<br>		FileInputStream fis = <span class="hljs-keyword">null</span>;<br>		BufferedInputStream bis = <span class="hljs-keyword">null</span>;<br>		ObjectInputStream ois = <span class="hljs-keyword">null</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;对象输出流文件2&quot;</span>);<br>			bis = <span class="hljs-keyword">new</span> BufferedInputStream(fis);<br>			ois = <span class="hljs-keyword">new</span> ObjectInputStream(bis);<br>			<br>			<span class="hljs-keyword">int</span> readInt = ois.readInt();<br>			System.out.println(readInt);<br>			<span class="hljs-keyword">boolean</span> readBoolean1 = ois.readBoolean();<br>			<span class="hljs-keyword">boolean</span> readBoolean2 = ois.readBoolean();<br>			System.out.println(readBoolean1);<br>			System.out.println(readBoolean2);<br>			<span class="hljs-keyword">long</span> readLong = ois.readLong();<br>			System.out.println(readLong);<br>			<span class="hljs-keyword">double</span> readDouble = ois.readDouble();<br>			System.out.println(readDouble);<br>			String readUTF = ois.readUTF(); <span class="hljs-comment">// 读文件要解码</span><br>			System.out.println(readUTF);<br>			<br>		&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			<span class="hljs-keyword">if</span> (ois != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					ois.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test7</span><span class="hljs-params">()</span> </span>&#123;<br>		FileOutputStream fos = <span class="hljs-keyword">null</span>;<br>		BufferedOutputStream bos = <span class="hljs-keyword">null</span>;<br>		ObjectOutputStream oos = <span class="hljs-keyword">null</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;对象输出流文件2&quot;</span>);<br>			bos = <span class="hljs-keyword">new</span> BufferedOutputStream(fos);<br>			oos = <span class="hljs-keyword">new</span> ObjectOutputStream(bos);<br>			<br>			oos.writeInt(<span class="hljs-number">10</span>); <br>			oos.writeBoolean(<span class="hljs-keyword">false</span>);<br>			oos.writeBoolean(<span class="hljs-keyword">true</span>);<br>			oos.writeLong(<span class="hljs-number">20</span>);<br>			oos.writeDouble(<span class="hljs-number">3.14</span>);<br>			oos.writeUTF(<span class="hljs-string">&quot;abc我和你xxx&quot;</span>); <span class="hljs-comment">// 写文件要编码</span><br>			<span class="hljs-comment">//oos.writeChars(&quot;abc我和你xxx&quot;); // 把字符串直接写文件</span><br>			<br>		&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			<span class="hljs-keyword">if</span> (oos != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					oos.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test6</span><span class="hljs-params">()</span> </span>&#123;<br>		FileInputStream fis = <span class="hljs-keyword">null</span>;<br>		BufferedInputStream bis = <span class="hljs-keyword">null</span>;<br>		ObjectInputStream ois = <span class="hljs-keyword">null</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;对象输出流文件&quot;</span>);<br>			bis = <span class="hljs-keyword">new</span> BufferedInputStream(fis);<br>			ois = <span class="hljs-keyword">new</span> ObjectInputStream(bis);<br>			<br>			<span class="hljs-keyword">int</span> readInt = ois.readInt();<br>			System.out.println(readInt);<br>			<span class="hljs-keyword">boolean</span> readBoolean1 = ois.readBoolean();<br>			<span class="hljs-keyword">boolean</span> readBoolean2 = ois.readBoolean();<br>			System.out.println(readBoolean1);<br>			System.out.println(readBoolean2);<br>			<span class="hljs-keyword">long</span> readLong = ois.readLong();<br>			System.out.println(readLong);<br>			<span class="hljs-keyword">double</span> readDouble = ois.readDouble();<br>			System.out.println(readDouble);<br>			<br>		&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			<span class="hljs-keyword">if</span> (ois != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					ois.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-comment">// 使用对象流写文件, 写入50个100以内的随机整数</span><br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exer1</span><span class="hljs-params">()</span> </span>&#123;<br>		FileOutputStream fos = <span class="hljs-keyword">null</span>;<br>		BufferedOutputStream bos = <span class="hljs-keyword">null</span>;<br>		ObjectOutputStream oos = <span class="hljs-keyword">null</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;50个随机数&quot;</span>);<br>			bos = <span class="hljs-keyword">new</span> BufferedOutputStream(fos);<br>			oos = <span class="hljs-keyword">new</span> ObjectOutputStream(bos);<br>			<br>			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>				oos.writeInt((<span class="hljs-keyword">int</span>)(Math.random() * <span class="hljs-number">100</span>));<br>			&#125;<br>		&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			<span class="hljs-keyword">if</span> (oos != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					oos.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-comment">// 使用对象输入流读取这50个随机整数</span><br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exer2</span><span class="hljs-params">()</span> </span>&#123;<br>		FileInputStream fis = <span class="hljs-keyword">null</span>;<br>		BufferedInputStream bis = <span class="hljs-keyword">null</span>;<br>		ObjectInputStream ois = <span class="hljs-keyword">null</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;50个随机数&quot;</span>);<br>			bis = <span class="hljs-keyword">new</span> BufferedInputStream(fis);<br>			ois = <span class="hljs-keyword">new</span> ObjectInputStream(bis);<br>			<br>			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>				System.out.println(ois.readInt());<br>			&#125;<br>			<br>		&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			<span class="hljs-keyword">if</span> (ois != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					ois.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">// ObjectInputStream和ObjectOutputStream</span><br>		FileOutputStream fos = <span class="hljs-keyword">null</span>;<br>		BufferedOutputStream bos = <span class="hljs-keyword">null</span>;<br>		ObjectOutputStream oos = <span class="hljs-keyword">null</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;对象输出流文件&quot;</span>);<br>			bos = <span class="hljs-keyword">new</span> BufferedOutputStream(fos);<br>			oos = <span class="hljs-keyword">new</span> ObjectOutputStream(bos);<br>			<br>			oos.writeInt(<span class="hljs-number">10</span>); <span class="hljs-comment">// 数据在内存中如何 保存 它就如何写入文件</span><br>			oos.writeBoolean(<span class="hljs-keyword">false</span>);<br>			oos.writeBoolean(<span class="hljs-keyword">true</span>);<br>			oos.writeLong(<span class="hljs-number">20</span>);<br>			oos.writeDouble(<span class="hljs-number">3.14</span>);<br>			<br>		&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			<span class="hljs-keyword">if</span> (oos != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					oos.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>&#123;<br>		FileWriter fileWriter = <span class="hljs-keyword">null</span>;<br>		BufferedWriter bufferedWriter = <span class="hljs-keyword">null</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			fileWriter = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;使用缓冲流写文本&quot;</span>);<br>			bufferedWriter = <span class="hljs-keyword">new</span> BufferedWriter(fileWriter);<br>			String[] content = &#123;<span class="hljs-string">&quot;来上一些字符串内容1&quot;</span>,<br>								<span class="hljs-string">&quot;来上一些字符串内容2&quot;</span>,<br>								<span class="hljs-string">&quot;来上一些字符串内容3&quot;</span>,<br>								<span class="hljs-string">&quot;来上一些字符串内容4&quot;</span>,<br>								<span class="hljs-string">&quot;来上一些字符串内容5&quot;</span>,<br>								<span class="hljs-string">&quot;来上一些字符串内容6&quot;</span>,<br>								<span class="hljs-string">&quot;来上一些字符串内容7&quot;</span>,<br>								<span class="hljs-string">&quot;来上一些字符串内容8&quot;</span>,<br>								<span class="hljs-string">&quot;1234567890123456&quot;</span>,<br>								<span class="hljs-string">&quot;asdfkjasldfjalksdjflaksjdflkasjdflkasjdff&quot;</span>,<br>								<span class="hljs-string">&quot;xcvadsfasdfasdfasdfasdf&quot;</span>&#125;;<br>			<span class="hljs-keyword">for</span> (String string : content) &#123;<br>				bufferedWriter.write(string);<br>				bufferedWriter.newLine(); <span class="hljs-comment">// 最有价值方法</span><br>			&#125;<br>		&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			<span class="hljs-keyword">if</span> (bufferedWriter != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					bufferedWriter.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">// 使用缓冲流(处理流)</span><br>		FileReader fileReader = <span class="hljs-keyword">null</span>;<br>		BufferedReader bufferedReader = <span class="hljs-keyword">null</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			<span class="hljs-comment">// 包装流, 使用对象关联, 包装流把节点流对象关联为属性.</span><br>			fileReader = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;HashMap.java&quot;</span>);<br>			bufferedReader = <span class="hljs-keyword">new</span> BufferedReader(fileReader);<br>			<span class="hljs-comment">// 最有价值方法</span><br>			String line = bufferedReader.readLine(); <span class="hljs-comment">// 读到的字符串没有换行</span><br>			<span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>;<br>			<span class="hljs-keyword">while</span> (line != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-comment">// 处理读到的行</span><br>				System.out.println(num++ + <span class="hljs-string">&quot; &quot;</span> + line);<br>				<span class="hljs-comment">// 继续读后面的行, 直到null</span><br>				line = bufferedReader.readLine();<br>			&#125;<br>		&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			<span class="hljs-comment">// 只需要关闭高级流, 因为低级流被关联, 并且会在关闭高级流时自动关闭</span><br>			<span class="hljs-keyword">if</span> (bufferedReader != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					bufferedReader.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br>		FileWriter fileWriter = <span class="hljs-keyword">null</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			fileWriter = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;写一个文件&quot;</span>);<br>			<span class="hljs-comment">// 写数组</span><br>			String[] content = &#123;<span class="hljs-string">&quot;来上一些字符串内容1&quot;</span>,<br>								<span class="hljs-string">&quot;来上一些字符串内容2&quot;</span>,<br>								<span class="hljs-string">&quot;来上一些字符串内容3&quot;</span>,<br>								<span class="hljs-string">&quot;来上一些字符串内容4&quot;</span>,<br>								<span class="hljs-string">&quot;来上一些字符串内容5&quot;</span>,<br>								<span class="hljs-string">&quot;来上一些字符串内容6&quot;</span>,<br>								<span class="hljs-string">&quot;来上一些字符串内容7&quot;</span>,<br>								<span class="hljs-string">&quot;来上一些字符串内容8&quot;</span>,<br>								<span class="hljs-string">&quot;1234567890123456&quot;</span>,<br>								<span class="hljs-string">&quot;asdfkjasldfjalksdjflaksjdflkasjdflkasjdff&quot;</span>,<br>								<span class="hljs-string">&quot;xcvadsfasdfasdfasdfasdf&quot;</span>&#125;;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; content.length; i++) &#123;<br>				<span class="hljs-keyword">char</span>[] charArray = content[i].toCharArray();<br>				<span class="hljs-comment">//fileWriter.write(charArray);// 直接把一个数组的全部内容写入到输出流中</span><br>				<span class="hljs-comment">//这是超重点方法, 把数组的一部分写入文件</span><br>				fileWriter.write(charArray, <span class="hljs-number">1</span>, charArray.length - <span class="hljs-number">1</span>); <span class="hljs-comment">// 第2个参数是offset偏移, 第3个参数是length长度</span><br>				<br>				fileWriter.write(<span class="hljs-number">13</span>); <span class="hljs-comment">// 写回车</span><br>				fileWriter.write(<span class="hljs-number">10</span>); <span class="hljs-comment">// 写换行</span><br>			&#125;<br>		&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			<span class="hljs-keyword">if</span> (fileWriter != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					fileWriter.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-comment">//使用缓冲区读文件, 要求在每一行前面加上行号</span><br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">int</span> line = <span class="hljs-number">1</span>;<br>		System.out.print(line++ + <span class="hljs-string">&quot; &quot;</span>);<br>		FileReader fileReader = <span class="hljs-keyword">null</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			fileReader = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;HashMap.java&quot;</span>);<br>			<span class="hljs-keyword">char</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">8192</span>];<br>			<span class="hljs-keyword">int</span> realCount = fileReader.read(buf);<br>			<span class="hljs-keyword">while</span> (realCount != -<span class="hljs-number">1</span>) &#123;<br>				<span class="hljs-comment">// 1) 处理已经实际读到的数据</span><br>				<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; realCount; i++) &#123;<br>					System.out.print(buf[i]);<br>					<span class="hljs-keyword">if</span> (buf[i] == <span class="hljs-number">10</span>) &#123;<br>						System.out.print(line++ + <span class="hljs-string">&quot; &quot;</span>);<br>					&#125;<br>				&#125;<br>				<span class="hljs-comment">// 2) 继续读后面的数据, 直到-1为止</span><br>				realCount = fileReader.read(buf);<br>			&#125;<br>		&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			<span class="hljs-keyword">if</span> (fileReader != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					fileReader.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>文件复制</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> javaio;<br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileCopy</span> </span>&#123;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		FileInputStream fis=<span class="hljs-keyword">null</span>;<br>		FileOutputStream fos=<span class="hljs-keyword">null</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			fis=<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;s&quot;</span>);<br>			fos=<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;s2&quot;</span>);<br>			<span class="hljs-keyword">byte</span>[] buf=<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">8192</span>];<br>			<span class="hljs-keyword">int</span> realCount=fis.read(buf);<br>			<span class="hljs-keyword">while</span>(realCount!=-<span class="hljs-number">1</span>) &#123;<br>				<span class="hljs-comment">//处理数据</span><br>				fos.write(buf, <span class="hljs-number">0</span>, realCount);<br>				<span class="hljs-comment">//继续读</span><br>				realCount=fis.read(buf);<br>			&#125;<br>		&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>			e.printStackTrace();<br>		&#125;<span class="hljs-keyword">finally</span> &#123;<br>			<span class="hljs-keyword">if</span>(fis!=<span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					fis.close();<br>				&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>					e.printStackTrace();<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">if</span>(fos!=<span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					fos.close();<br>				&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>					e.printStackTrace();<br>				&#125;<br>			&#125;<br>		&#125;<br>		<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> jdbc;<br><br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> com.mysql.jdbc.Statement;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.Driver;<br><span class="hljs-keyword">import</span> java.sql.DriverManager;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 1) 在project项目下创建目录</span><br><span class="hljs-comment"> * 2) 把相关的.jar文件复制到这个目录中</span><br><span class="hljs-comment"> * 3) 再把jar文件导入到build-path中</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * url : uniform resource locator </span><br><span class="hljs-comment"> * 统一资源定位器 jdbc:mysql://127.0.0.1:3306/test</span><br><span class="hljs-comment"> * jdbc是主协议</span><br><span class="hljs-comment"> * mysql是子协议 </span><br><span class="hljs-comment"> * 127.0.0.1是Mysql服务器主机地址</span><br><span class="hljs-comment"> * 3306是mysql服务器的端口</span><br><span class="hljs-comment"> * test是数据库名</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcTest</span> </span>&#123;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test6</span><span class="hljs-params">()</span> </span>&#123;<br>		Connection connection=<span class="hljs-keyword">null</span>;<br>		Statement statement=<span class="hljs-keyword">null</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>		 connection = JdbcUtil.getConnection();<br>		 statement=(Statement) connection.createStatement();<span class="hljs-comment">//通过连接获取执行体对象</span><br>		 System.out.println(statement);<br>		 String sql=<span class="hljs-string">&quot;create table if not exists customer(id int auto_increment,&quot;</span><br>				 										+<span class="hljs-string">&quot;name varchar(10),&quot;</span><br>				 										+<span class="hljs-string">&quot;gender char(1) default &#x27;男&#x27;,&quot;</span><br>				 										+<span class="hljs-string">&quot;age int,&quot;</span><br>				 										+<span class="hljs-string">&quot;phone char(11),&quot;</span><br>				 										+ <span class="hljs-string">&quot;primary key(id),&quot;</span><br>				 										+ <span class="hljs-string">&quot;unique(phone))&quot;</span>;<br>		 <span class="hljs-keyword">int</span> rows=statement.executeUpdate(sql);<span class="hljs-comment">//可以执行update,delete,insert,DDL，除了select的DML操作等sql操作</span><br>		 System.out.println(rows);<br>		&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125;<span class="hljs-keyword">finally</span> &#123;<br>			JdbcUtil.close(connection,statement);<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException, ClassNotFoundException, IOException </span>&#123;<br>		InputStream inputStream = <span class="hljs-keyword">this</span>.getClass().getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;jdbc.properties&quot;</span>);<br>		Properties properties = <span class="hljs-keyword">new</span> Properties();<br>		properties.load(inputStream);<br>		inputStream.close();<br>		String driverClassName = properties.getProperty(<span class="hljs-string">&quot;driverClassName&quot;</span>);<br>		String url = properties.getProperty(<span class="hljs-string">&quot;url&quot;</span>);<br>		String user = properties.getProperty(<span class="hljs-string">&quot;user&quot;</span>);<br>		String password = properties.getProperty(<span class="hljs-string">&quot;password&quot;</span>);<br>		System.out.println(driverClassName);<br>		Class.forName(driverClassName); <span class="hljs-comment">// 在类的静态语句块中完成自我注册</span><br>		Connection connection = DriverManager.getConnection(url, user, password);<br>		System.out.println(connection);<br>		connection.close();<br>	&#125;<br><br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException, ClassNotFoundException </span>&#123;<br>		Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>); <span class="hljs-comment">// 在类的静态语句块中完成自我注册</span><br>		String url = <span class="hljs-string">&quot;jdbc:mysql://127.0.0.1:3306/jdbc&quot;</span>;<br>		String user = <span class="hljs-string">&quot;root&quot;</span>;<br>		String password = <span class="hljs-string">&quot;123456&quot;</span>;<br>		Connection connection = DriverManager.getConnection(url, user, password);<br>		System.out.println(connection);<br>		connection.close();<br>	&#125;<br><br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException, ClassNotFoundException, InstantiationException, IllegalAccessException </span>&#123;<br>		Class clazz = Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>); <span class="hljs-comment">// 在类的静态语句块中完成自我注册</span><br>		<span class="hljs-comment">// Driver driver = new com.mysql.jdbc.Driver();</span><br>		Driver driver = (Driver) clazz.newInstance();<br>		DriverManager.registerDriver(driver);<br>		<span class="hljs-comment">// 通过驱动程序管理器来间接获取连接</span><br>		String url = <span class="hljs-string">&quot;jdbc:mysql://127.0.0.1:3306/jdbc&quot;</span>;<br>		String user = <span class="hljs-string">&quot;root&quot;</span>;<br>		String password = <span class="hljs-string">&quot;123456&quot;</span>;<br>		Connection connection = DriverManager.getConnection(url, user, password);<br>		System.out.println(connection);<br>		connection.close();<br>	&#125;<br><br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>		Driver driver = <span class="hljs-keyword">new</span> com.mysql.jdbc.Driver();<br>		DriverManager.registerDriver(driver);<br>		<span class="hljs-comment">// 通过驱动程序管理器来间接获取连接</span><br>		String url = <span class="hljs-string">&quot;jdbc:mysql://127.0.0.1:3306/jdbc&quot;</span>;<br>		String user = <span class="hljs-string">&quot;root&quot;</span>;<br>		String password = <span class="hljs-string">&quot;123456&quot;</span>;<br>		Connection connection = DriverManager.getConnection(url, user, password);<br>		System.out.println(connection);<br>		connection.close();<br>	&#125;<br><br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>		Driver driver = <span class="hljs-keyword">new</span> com.mysql.jdbc.Driver(); <span class="hljs-comment">// 创建子类对象, 当成接口类型的对象来使用</span><br>		String url = <span class="hljs-string">&quot;jdbc:mysql://127.0.0.1:3306/jdbc&quot;</span>; <span class="hljs-comment">// 统一资源定位器</span><br>		Properties info = <span class="hljs-keyword">new</span> Properties();<br>		info.setProperty(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>); <span class="hljs-comment">// 用户名</span><br>		info.setProperty(<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>); <span class="hljs-comment">// 密码</span><br>		Connection connection = driver.connect(url, info); <span class="hljs-comment">// 直接通过驱动程序来连接</span><br>		System.out.println(connection);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="数据修改"><a href="#数据修改" class="headerlink" title="数据修改"></a>数据修改</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> jdbc;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.PreparedStatement;<br><span class="hljs-keyword">import</span> java.sql.ResultSet;<br><span class="hljs-keyword">import</span> java.sql.ResultSetMetaData;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommonUtil</span> </span>&#123;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 通过查询操作</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@param</span> &lt;T&gt; 表示要处理的表中的数据对应的对象类型</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@param</span> connection 连接对象</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@param</span> clazz 类模板对象</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@param</span> sql 查询</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@param</span> args 代替sql中的?的实参列表</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@return</span> 一个保存了所有对象的集合</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">getList</span><span class="hljs-params">(Connection connection, Class&lt;T&gt; clazz, String sql, Object... args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>		List&lt;T&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>		PreparedStatement preparedStatement = <span class="hljs-keyword">null</span>;<br>		ResultSet resultSet = <span class="hljs-keyword">null</span>; <br>		<span class="hljs-keyword">try</span> &#123;<br>			preparedStatement = connection.prepareStatement(sql);<br>			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; args.length; i++) &#123; <span class="hljs-comment">// 替换SQL中的?</span><br>				preparedStatement.setObject(i + <span class="hljs-number">1</span>, args[i]);<br>			&#125;<br>			resultSet = preparedStatement.executeQuery(); <br>			ResultSetMetaData metaData = resultSet.getMetaData(); <span class="hljs-comment">// 获取元数据</span><br>			<span class="hljs-keyword">int</span> cols = metaData.getColumnCount(); <span class="hljs-comment">// 获取列数</span><br>			<span class="hljs-keyword">while</span> (resultSet.next()) &#123; <br>				T instance = clazz.newInstance(); <span class="hljs-comment">// 反射的方式, 通过类模板创建实体对象</span><br>				<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cols; i++) &#123;<br>					String label = metaData.getColumnLabel(i + <span class="hljs-number">1</span>); <span class="hljs-comment">// label是列标签 , 同时又是属性名</span><br>					Object value = resultSet.getObject(label); <span class="hljs-comment">// 从结果集中获取列标签对应的值, 也同时就是目标对象的属性值.</span><br>					Field field = clazz.getDeclaredField(label); <span class="hljs-comment">// 反射的方式, 根据属性名获取属性定义对象</span><br>					field.setAccessible(<span class="hljs-keyword">true</span>); <span class="hljs-comment">// 暴力反射</span><br>					field.set(instance, value); <span class="hljs-comment">// 通过反射的方式为目标对象的属性赋值.</span><br>				&#125;<br>				list.add(instance);<br>			&#125;<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			JdbcUtil.close(<span class="hljs-keyword">null</span>, preparedStatement, resultSet);<br>		&#125;<br>		<span class="hljs-keyword">return</span> list;<br>	&#125;<br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">getList</span><span class="hljs-params">(Class&lt;T&gt; clazz, String sql, Object... args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>		Connection connection = <span class="hljs-keyword">null</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			connection = JdbcUtil.getConnection();<br>			<span class="hljs-keyword">return</span> getList(connection,  clazz, sql, args);<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			JdbcUtil.close(connection);<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 通用更新操作</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@param</span> sql 需要执行的SQL语句, 可以执行除了select外的DML和所有DDL</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@param</span> args 用于代替SQL中的?的实参列表</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@return</span> 影响行数</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">update</span><span class="hljs-params">(Connection connection, String sql, Object... args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, IOException, SQLException </span>&#123;<br>		PreparedStatement preparedStatement = <span class="hljs-keyword">null</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			preparedStatement = connection.prepareStatement(sql); <span class="hljs-comment">// 根据传入 的SQL预编译</span><br>			<span class="hljs-comment">// 循环处理?</span><br>			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; args.length; i++) &#123;<br>				preparedStatement.setObject(i + <span class="hljs-number">1</span>, args[i]);<br>			&#125;<br>			<span class="hljs-keyword">int</span> rows = preparedStatement.executeUpdate(); <span class="hljs-comment">// 真正的执行</span><br>			<span class="hljs-keyword">return</span> rows;<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			JdbcUtil.close(<span class="hljs-keyword">null</span>, preparedStatement); <span class="hljs-comment">// 无论有没有发生异常,都要释放资源</span><br>		&#125;<br>	&#125; <br>	<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 通用更新操作</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@param</span> sql 需要执行的SQL语句, 可以执行除了select外的DML和所有DDL</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@param</span> args 用于代替SQL中的?的实参列表</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@return</span> 影响行数</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">update</span><span class="hljs-params">(String sql, Object... args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, IOException, SQLException </span>&#123;<br>		Connection connection = <span class="hljs-keyword">null</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			connection = JdbcUtil.getConnection(); <span class="hljs-comment">// 获取连接</span><br>			<span class="hljs-keyword">return</span> update(connection, sql, args);<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			JdbcUtil.close(connection); <span class="hljs-comment">// 无论有没有发生异常,都要释放资源</span><br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>异常</tag>
        <tag>Java关键字</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>flink</title>
    <url>/2021/10/31/flink/</url>
    <content><![CDATA[<h1 id="Flink"><a href="#Flink" class="headerlink" title="Flink"></a>Flink</h1><h2 id="Flink简介"><a href="#Flink简介" class="headerlink" title="Flink简介"></a>Flink简介</h2><ul>
<li><p>Apache Flink是为分布式，高性能，随时可用以及准确的流处理应用程序打造的开源流处理框架。</p>
<p><a href="https://imgtu.com/i/IEp9K0"><img src="https://z3.ax1x.com/2021/11/03/IEp9K0.png" alt="IEp9K0.png"></a></p>
</li>
<li><p>流处理架构的演变</p>
<ul>
<li>lambda 架构（批处理+流处理 ，由twitter提出）<ul>
<li><a href="https://imgtu.com/i/ImBDQx"><img src="https://z3.ax1x.com/2021/11/04/ImBDQx.png" alt="ImBDQx.png"></a></li>
</ul>
</li>
<li>flink 流批统一（同时保证低延迟和结果正确）</li>
</ul>
</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li><p>Flink的重要特点：</p>
<ul>
<li>事件型驱动（Event-driven）事件驱动型应用是一类具有状态的应用，它从一个或多个事件流提取数据，并根据到来的事件触发计算，状态更新或其他外部动作。比较典型的就是以Kafka为代表的消息队列几乎都是事件驱动型应用。</li>
</ul>
</li>
<li><p>与Spark对比：</p>
<ul>
<li>在spark的世界观中，一切都是由批次组成的，离线数据是一个大批次，而实时数据是由一个个无限的小批次组成的，最本质上来说还是批处理的。</li>
<li>在Flink的世界观中，一切都是由流组成的，离线数据是有界限的流，实时数据是一个没有界限的流，这就是所谓的有界流和无界流。</li>
</ul>
</li>
<li><p>分层API</p>
<p><a href="https://imgtu.com/i/IEiil9"><img src="https://z3.ax1x.com/2021/11/03/IEiil9.png" alt="IEiil9.png"></a></p>
<ul>
<li>最底层的抽象仅仅提供了有状态流，它将通过过程函数（Process Function）被嵌入到DataStream API中，底层过程函数（Process Function）与DataStream API相集成，使其可以对某些特定的操作进行底层的抽象，它允许用户可以自由地处理来自一个或多个数据流的事件，并使用一致的容错的状态。</li>
<li>目前Flink作为批处理还不是主流，不如Spark成熟，所以DataSet使用的并不是很多。Flink Table API和Flink SQL也并不完善，大多都由各大厂商自己定制。所以我们主要学习DataStream API的使用。实际上Flink作为最接近Google DataFlow模型的实现，是流批统一的观点，所以基本上使用DataStream就可以了。</li>
</ul>
</li>
</ul>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><ul>
<li><p>搭建maven工程，添加Scala框架</p>
<ul>
<li><p>参考pom文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.zt.flink<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>Flink<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.flink<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>flink-scala_2.11<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.10.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.flink/flink-streaming-scala --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.flink<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>flink-streaming-scala_2.11<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.10.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 该插件用于将Scala代码编译成class文件 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>net.alchim31.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>scala-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>                <span class="hljs-comment">&lt;!-- 声明绑定到maven的compile阶段 --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">descriptorRefs</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">descriptorRef</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">descriptorRefs</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>make-assembly<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>single<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>批处理wordcount。记得导包：import org.apache.flink.api.scala._  否则会报错no implicits found for parameter evidence</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><br><span class="hljs-keyword">import</span> org.apache.flink.api.scala._<br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">PiChuLiWordCount</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-comment">// 创建执行环境</span><br>    <span class="hljs-keyword">val</span> env = <span class="hljs-type">ExecutionEnvironment</span>.getExecutionEnvironment<br>    <span class="hljs-comment">// 从文件中读取数据</span><br>    <span class="hljs-keyword">val</span> inputPath = <span class="hljs-string">&quot;E:\\idea\\flink\\src\\main\\Scala\\word.txt&quot;</span><br>    <span class="hljs-keyword">val</span> inputDS: <span class="hljs-type">DataSet</span>[<span class="hljs-type">String</span>] = env.readTextFile(inputPath)<br>    <span class="hljs-comment">// 分词之后，对单词进行groupby分组，然后用sum进行聚合</span><br>    <span class="hljs-keyword">val</span> wordCountDS: <span class="hljs-type">AggregateDataSet</span>[(<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>)] =<br>      inputDS.flatMap(_.split(<span class="hljs-string">&quot; &quot;</span>))<br>          .map((_,<span class="hljs-number">1</span>))<br>          .groupBy(<span class="hljs-number">0</span>)<br>          .sum(<span class="hljs-number">1</span>)<br><br>    <span class="hljs-comment">// 打印输出</span><br>    wordCountDS.print()<br><br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
<li><p>流处理的wordcount</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> org.apache.flink.streaming.api.scala._<br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">StreamWordCount</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-comment">//创建流处理环境</span><br>    <span class="hljs-keyword">val</span> env: <span class="hljs-type">StreamExecutionEnvironment</span> = <span class="hljs-type">StreamExecutionEnvironment</span>.getExecutionEnvironment<br>    <span class="hljs-comment">//接收socket 文本流</span><br>    <span class="hljs-keyword">val</span> textDstream: <span class="hljs-type">DataStream</span>[<span class="hljs-type">String</span>] = env.socketTextStream(<span class="hljs-string">&quot;hadoop100&quot;</span>, <span class="hljs-number">7777</span>)<br><br>    <span class="hljs-keyword">import</span> org.apache.flink.api.scala._<br>    <span class="hljs-keyword">val</span> dataStream: <span class="hljs-type">DataStream</span>[(<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>)] = textDstream.flatMap(_.split(<span class="hljs-string">&quot;\\s&quot;</span>))<br>      .filter(_.nonEmpty)<br>      .map((_, <span class="hljs-number">1</span>))<br>      .keyBy(<span class="hljs-number">0</span>)<br>      .sum(<span class="hljs-number">1</span>)<br>    dataStream.print().setParallelism(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">//启动excutor ,执行任务</span><br>    env.execute(<span class="hljs-string">&quot;Socket stream word count&quot;</span>)<br><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="Flink部署"><a href="#Flink部署" class="headerlink" title="Flink部署"></a>Flink部署</h3><ul>
<li>standalone模式<ul>
<li>解压缩,修改flink/conf/flink-conf.yaml文件，jobmanager.rpc.address:hadoop100</li>
<li>修改flink/conf/slaves文件  加上从机器的机器名hadoop101,hadoop102</li>
<li>分发flink文件</li>
</ul>
</li>
<li>Yarn模式<ul>
<li>Session-Cluster<ul>
<li><a href="https://imgtu.com/i/IEGJHK"><img src="https://z3.ax1x.com/2021/11/03/IEGJHK.png" alt="IEGJHK.png"></a></li>
</ul>
</li>
<li>Per-Job-Cluster<ul>
<li><a href="https://imgtu.com/i/IEJSDx"><img src="https://z3.ax1x.com/2021/11/03/IEJSDx.png" alt="IEJSDx.png"></a></li>
</ul>
</li>
</ul>
</li>
<li>Kubernetes部署<ul>
<li>容器化部署是是目前业界很流行的一项技术，基于Docker镜像运行能够让用户更加方便地对应用进行管理和运维。现在最流行地就是K8s了，flink也支持k8s部署模式</li>
</ul>
</li>
</ul>
<h2 id="运行架构（重点）"><a href="#运行架构（重点）" class="headerlink" title="运行架构（重点）"></a>运行架构（重点）</h2><h3 id="运行时的组件"><a href="#运行时的组件" class="headerlink" title="运行时的组件"></a>运行时的组件</h3><ul>
<li>Flink运行时架构主要包括四个不同的组件，它们会在运行流处理应用程序时协同工作:作业管理器（JobManager），资源管理器（ResourceManager）,任务管理器（TaskManager）,以及分发器（Dispatcher）。Flink是由Java和Scala实现的，因此所有的组件都会运行在Java虚拟机中。</li>
<li>作业管理器（JobManager）<ul>
<li>控制一个应用程序执行的主进程，也就是说，每个应用程序都会被一个不同的JobManager 所控制执行。JobManager会先接收到要执行的应用程序，这个应用程序包括：作业图（JobGraph）,逻辑数据流图（logical dataflow graph）和打包了所有的类，库和其他资源的JAR包。JobManager会把作业图转换成一个物理层面的数据流图，这个图被叫做”执行图“（ExecutionGraph），包含了所有可以并发执行的任务。作业管理器会向资源管理器请求执行任务必要的资源，也就是任务管理器（TaskManager）上的插槽（slot）。一旦作业管理器获取到了足够的资源，就会将执行图分发到真正运行他们的任务管理器（TaskManager）上。而在运行过程中，JobManager会负责所有需要中央协调的操作，比如检查点（checkpoint）的协调。</li>
</ul>
</li>
<li>资源管理器(ResourceManager)<ul>
<li>主要负责管理任务管理器（TaskManager）的插槽（slot），TaskManager插槽是Flink中定义的处理资源单位。Flink为不同的环境和资源管理工具提供了不同的资源管理器，比如Yarn，K8s,standalone。当JobManager申请插槽资源时，ResourceManager会将有空闲插槽的TaskManager分配给JobManager 。如果ResourceManager没有足够的插槽来满足JobManager的请求，它还可以向资源提供平台发起会话，以提供启动TaskManager进程的容器，另外，ResourceManager还负责终止空闲的TaskManager,释放计算资源。</li>
</ul>
</li>
<li>任务管理器（TaskManager）<ul>
<li>通常一个Flink中会有多个TaskManager运行，每一个TaskManager都包含了一定数量的插槽（slots）。插槽的数量限制了TaskManager能执行的任务数量。任务管理器启动之后回向资源管理器注册它的插槽；收到资源管理器的指令后，TaskManager就会将一个或者多个插槽提供给任务管理器（JobManager）调用。任务管理器就可以向插槽分配任务（tasks）来执行。在执行过程中，一个任务管理器可以跟其它运行同一应用程序的TaskManager交换数据。</li>
</ul>
</li>
<li>分发器（Dispatcher）<ul>
<li>可以跨作业运行，它为应用提交提供了REST接口。当一个应用被提交执行时，分发器就会启动并将应用移交给一个JobManager。由于是REST接口，所以Dispatcher可以作为集群的一个HTTP接入点，这样就能够不受防火墙阻挡。Dispatcher也会启动一个Web UI，用来方便的展示和监控作业执行的信息。Dispatcher 在架构中可能并不是必须的，这取决于应用提交运行的方式。</li>
<li>REST接口：REST 用来规范应用如何在 HTTP 层与 API 提供方进行数据交互 。REST 描述了 HTTP 层里客户端和服务器端的数据交互规则；客户端通过向服务器端发送 HTTP（s）请求，接收服务器的响应，完成一次 HTTP 交互。这个交互过程中，REST 架构约定两个重要方面就是 HTTP 请求所采用的方法，以及请求的链接。</li>
</ul>
</li>
</ul>
<h3 id="任务提交流程"><a href="#任务提交流程" class="headerlink" title="任务提交流程"></a>任务提交流程</h3><ul>
<li>Yarn环境下任务的提交流程<ul>
<li><a href="https://imgtu.com/i/IEOkxf"><img src="https://z3.ax1x.com/2021/11/03/IEOkxf.png" alt="IEOkxf.png"></a></li>
<li>Client向HDFS上传Flink的Jar包和配置</li>
<li>Client向ResourceManager提交任务</li>
<li>ResourceManager分配Container资源并通知对应的NodeManager启动ApplicationMaster</li>
<li>ApplicationMaster启动后下载Client提交的资源和配置构建环境，启动JobManager</li>
<li>ApplicationMaster向ResourceManager申请Container资源启动TaskManager。（NodeManager加载flink的jar包和配置构建环境并启动TaskManager）</li>
<li>TaskManager启动后向JobManager发送心跳包，并等待JobManager向其分配任务</li>
</ul>
</li>
</ul>
<h3 id="任务调度原理"><a href="#任务调度原理" class="headerlink" title="任务调度原理"></a>任务调度原理</h3><ul>
<li><p>客户端（Client）不是运行时和程序执行的一部分，但它用于准备并发送dataflow(JobGraph)给Master（JobManager），然后，客户端断开连接或者维持连接以等待接收计算结果。</p>
</li>
<li><p>Client,JobManager,TaskManager三者均为独立的JVM进程。</p>
</li>
<li><p>TaskManager与Slots</p>
<ul>
<li>TaskManager是一个<strong>JVM进程</strong>，它可能会在<strong>独立的线程</strong>上执行一个或多个subtask。为了控制一个TaskManager能接收多少个task，Task Manager通过task slot来进行控制。（一个Task Manager至少有一个task slot）</li>
<li>每一个task slot表示TaskManager拥有资源的<strong>一个固定大小的子集</strong>。假如一个TaskManager有三个slot，那么他会将其管理的内存分成三份给各个slot。</li>
<li>一个TaskManager多个slot意味着更多的subtask可以共享一个JVM。</li>
<li><strong>Task Slot是静态的概念，是指TaskManager具有的并发执行的能力</strong>，可以通过参数配置，而<strong>并行度parallelism是动态概念</strong>，即TaskManager运行程序时实际使用的并发能力。可以通过参数配置</li>
</ul>
</li>
<li><p>程序与数据流</p>
<ul>
<li><p>所有flink都是由三部分组成的</p>
</li>
<li><p>Source</p>
<ul>
<li>负责读取数据源</li>
</ul>
</li>
<li><p>Transformation</p>
<ul>
<li>利用各种算子进行处理加工</li>
</ul>
</li>
<li><p>Sink</p>
<ul>
<li>负责进行输出</li>
</ul>
</li>
<li><p>在运行时，Flink 上运行的程序会被映射成”逻辑数据流“（dataflows），它包含了这三部分，<strong>每一个dataflow以一个或多个source开始以一个或多个sinks结束</strong>dataflow类似于任意的有向无环图（DAG）</p>
</li>
</ul>
</li>
<li><p>执行图</p>
<ul>
<li>由Flink程序直接映射成的数据流图是StreamGraph，也被称为逻辑流图，因为它们表示的是计算逻辑的高级视图。为了执行一个流处理程序，Flink需要将逻辑流图转换为物理数据流图（也叫执行图），详细说明程序的执行方式。</li>
<li><strong>StreamGraph</strong>：是根据用户通过 Stream API 编写的代码生成的最初的图。用来表示程序的拓扑结构。</li>
<li><strong>JobGraph</strong>：StreamGraph经过优化后生成了 JobGraph，提交给 JobManager 的数据结构。主要的优化为，将多个符合条件的节点 chain 在一起作为一个节点，这样可以减少数据在节点之间流动所需要的序列化/反序列化/传输消耗。</li>
<li><strong>ExecutionGraph</strong>：JobManager 根据 JobGraph 生成ExecutionGraph。ExecutionGraph是JobGraph的并行化版本，是调度层最核心的数据结构。</li>
<li><strong>物理执行图</strong>：JobManager 根据 ExecutionGraph 对 Job 进行调度后，在各个TaskManager 上部署 Task 后形成的“图”，并不是一个具体的数据结构。</li>
</ul>
</li>
<li><p>并行度</p>
<ul>
<li><p>在flink程序执行过程中，一个流（stream）包含一个或多个分区（stream partition），而每个算子（operator）可以包含一个或多个子任务（operator subtask）</p>
</li>
<li><p>一个特定算子的子任务（subtask）的个数称作它的并行度</p>
</li>
<li><p>stream算子之间传输数据的形式可以是one-to-one(forwarding)的模式也可以是redistributing的模式</p>
</li>
<li><p><strong>One-to-one</strong>：stream(比如在source和map operator之间)维护着分区以及元素的顺序。那意味着map 算子的子任务看到的元素的个数以及顺序跟source 算子的子任务生产的元素的个数、顺序相同，map、fliter、flatMap等算子都是one-to-one的对应关系。类似于spark中的窄依赖</p>
</li>
<li><p><strong>Redistributing</strong>：stream(map()跟keyBy/window之间或者keyBy/window跟sink之间)的分区会发生改变。每一个算子的子任务依据所选择的transformation发送数据到不同的目标任务。例如，keyBy() 基于hashCode重分区、broadcast和rebalance会随机重新分区，这些算子都会引起redistribute过程，而redistribute过程就类似于Spark中的shuffle过程。类似于spark中的宽依赖。</p>
</li>
</ul>
</li>
<li><p>任务链</p>
<ul>
<li>相同并行度的one to one操作，Flink这样相连的算子链接在一起形成一个task，原来的算子成为里面的一部分。将算子链接成task是非常有效的优化，它能减少线程之间的切换和基于缓存区的数据交换，在减少时延的同时提升吞吐量。</li>
</ul>
</li>
</ul>
<h2 id="Flink-流处理API"><a href="#Flink-流处理API" class="headerlink" title="Flink 流处理API"></a>Flink 流处理API</h2><h3 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h3><ul>
<li>ExcutionEnvironment.getExcutionEnvironment</li>
<li>val env = StreamExecutionEnvironment.createLocalEnvironment(1)</li>
<li>val env = ExecutionEnvironment.createRemoteEnvironment(“jobmanage-hostname”, 6123,”YOURPATH//wordcount.jar”)</li>
</ul>
<h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><ul>
<li>从集合读取数据</li>
<li>从文件读取数据</li>
<li>以Kafka消息队列的数据作为来源</li>
<li>自定义Source</li>
</ul>
<h3 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h3><ul>
<li>map</li>
<li>flatMap</li>
<li>Filter</li>
<li>KeyBy</li>
<li>滚动聚合算子</li>
<li>Reduce</li>
<li>Split和Select</li>
<li>Connect和CoMap</li>
<li>Union</li>
</ul>
<h3 id="支持的数据类型"><a href="#支持的数据类型" class="headerlink" title="支持的数据类型"></a>支持的数据类型</h3><ul>
<li>基础数据类型</li>
<li>Java和Scala元组</li>
<li>Scala样例类</li>
<li>Java简单对象</li>
<li>Flink对Java和Scala中的一些特殊目的的类型也都是支持的，比如Java的ArrayList，HashMap，Enum等等。</li>
</ul>
<h3 id="实现UDF函数"><a href="#实现UDF函数" class="headerlink" title="实现UDF函数"></a>实现UDF函数</h3><ul>
<li>函数类（Function Classes）</li>
<li>匿名函数（Lambda Functions）</li>
<li>富函数（Rich Functions）<ul>
<li>富函数是DataStream API提供的一个函数类接口，所有Flink函数类都有其Rich版本</li>
<li>富函数与常规函数的不同在于，可以获取运行环境的上下文，并拥有一些生命周期方法，所以可以实现更复杂的功能。</li>
</ul>
</li>
</ul>
<h3 id="Sink"><a href="#Sink" class="headerlink" title="Sink"></a>Sink</h3><ul>
<li>Kafka</li>
<li>Redis</li>
<li>Elasticsearch</li>
<li>JDBC自定义sink</li>
</ul>
<h2 id="Flink中的Window（重点）"><a href="#Flink中的Window（重点）" class="headerlink" title="Flink中的Window（重点）"></a>Flink中的Window（重点）</h2><ul>
<li><p>flink中处理一般是分流–》开窗–》聚合 </p>
</li>
<li><p>窗口就是将无限流切割成为有限流的一种方式，它会将流数据分发到有限大小的桶中进行分析</p>
</li>
<li><p>窗口类型：时间窗口，计数窗口</p>
</li>
<li><p>时间窗口</p>
<ul>
<li>滚动时间窗口</li>
<li>滑动时间窗口</li>
<li>会话窗口（flink支持）</li>
</ul>
</li>
<li><p>计数窗口</p>
<ul>
<li>滚动计数窗口</li>
<li>滑动计数窗口</li>
</ul>
</li>
<li><p>增量聚合函数 AggregateFunction</p>
<ul>
<li>来一条数据进行一次运算，只保存一个简单的状态（累加器）</li>
<li>当窗口闭合的时候，增量聚合完成</li>
<li>处理时间：当机器时间超过窗口结束时间的时候，窗口闭合</li>
<li>来一条数据计算一次</li>
</ul>
</li>
<li><p>全窗口聚合函数 ProcessWindowFunction</p>
<ul>
<li>先把窗口所有的数据收集起来，等到计算的时候会遍历所有数据</li>
<li>可以访问到窗口信息</li>
</ul>
<p>可以将增量窗口聚合函数和全窗口聚合函数结合使用，ProcessWindowFunction提供更多对数据流的访问权限（比如窗口开始时间，窗口结束时间），但是耗性能，先用AggregateFunction处理，最后传一个结果值给ProcessWindowFunction。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> org.apache.flink.api.common.functions.<span class="hljs-type">AggregateFunction</span><br><span class="hljs-keyword">import</span> org.apache.flink.streaming.api.scala._<br><span class="hljs-keyword">import</span> org.apache.flink.streaming.api.scala.function.<span class="hljs-type">ProcessWindowFunction</span><br><span class="hljs-keyword">import</span> org.apache.flink.streaming.api.windowing.time.<span class="hljs-type">Time</span><br><span class="hljs-keyword">import</span> org.apache.flink.streaming.api.windowing.windows.<span class="hljs-type">TimeWindow</span><br><span class="hljs-keyword">import</span> org.apache.flink.util.<span class="hljs-type">Collector</span><br><span class="hljs-comment">//最低最高温度</span><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">MinMaxTemp</span> </span>&#123;<br><br>  <span class="hljs-comment">//样例类</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinMaxTemp</span>(<span class="hljs-params">id: <span class="hljs-type">String</span>, min: <span class="hljs-type">Double</span>, max: <span class="hljs-type">Double</span>, endTs: <span class="hljs-type">Long</span></span>)</span><br><span class="hljs-class"></span><br><span class="hljs-class">  <span class="hljs-title">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]</span>)</span>: <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-keyword">val</span> env: <span class="hljs-type">StreamExecutionEnvironment</span> = <span class="hljs-type">StreamExecutionEnvironment</span>.getExecutionEnvironment<br>    env.setParallelism(<span class="hljs-number">1</span>)<br><br>    <span class="hljs-keyword">val</span> stream: <span class="hljs-type">DataStream</span>[<span class="hljs-type">SensorReading</span>] = env.addSource(<span class="hljs-keyword">new</span> <span class="hljs-type">SensorSource</span>)<br>    stream.keyBy(_.id).timeWindow(<span class="hljs-type">Time</span>.seconds(<span class="hljs-number">5</span>))<br>      .aggregate(<span class="hljs-keyword">new</span> <span class="hljs-type">HighAndLowAgg</span>, <span class="hljs-keyword">new</span> <span class="hljs-type">WindowResult</span>)<br>      .print()<br>    env.execute()<br>  &#125;<br><span class="hljs-comment">//增量聚合函数</span><br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HighAndLowAgg</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AggregateFunction</span>[<span class="hljs-type">SensorReading</span>, (<span class="hljs-type">String</span>, <span class="hljs-type">Double</span>, <span class="hljs-type">Double</span>), (<span class="hljs-type">String</span>, <span class="hljs-type">Double</span>, <span class="hljs-type">Double</span>)] </span>&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">createAccumulator</span></span>(): (<span class="hljs-type">String</span>, <span class="hljs-type">Double</span>, <span class="hljs-type">Double</span>) = (<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-type">Double</span>.<span class="hljs-type">MaxValue</span>, <span class="hljs-type">Double</span>.<span class="hljs-type">MinValue</span>)<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span></span>(value: <span class="hljs-type">SensorReading</span>, accumulator: (<span class="hljs-type">String</span>, <span class="hljs-type">Double</span>, <span class="hljs-type">Double</span>)): (<span class="hljs-type">String</span>, <span class="hljs-type">Double</span>, <span class="hljs-type">Double</span>) =<br>      (value.id, value.temperature.min(accumulator._2), value.temperature.max(accumulator._3))<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getResult</span></span>(accumulator: (<span class="hljs-type">String</span>, <span class="hljs-type">Double</span>, <span class="hljs-type">Double</span>)): (<span class="hljs-type">String</span>, <span class="hljs-type">Double</span>, <span class="hljs-type">Double</span>) = accumulator<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge</span></span>(a: (<span class="hljs-type">String</span>, <span class="hljs-type">Double</span>, <span class="hljs-type">Double</span>), b: (<span class="hljs-type">String</span>, <span class="hljs-type">Double</span>, <span class="hljs-type">Double</span>)): (<span class="hljs-type">String</span>, <span class="hljs-type">Double</span>, <span class="hljs-type">Double</span>) =<br>      (a._1, a._2.min(b._2), a._3.max(b._3))<br>  &#125;<br><span class="hljs-comment">//全窗口聚合函数</span><br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowResult</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ProcessWindowFunction</span>[(<span class="hljs-type">String</span>, <span class="hljs-type">Double</span>, <span class="hljs-type">Double</span>), <span class="hljs-type">MinMaxTemp</span>, <span class="hljs-type">String</span>, <span class="hljs-type">TimeWindow</span>] </span>&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process</span></span>(key: <span class="hljs-type">String</span>, context: <span class="hljs-type">Context</span>, elements: <span class="hljs-type">Iterable</span>[(<span class="hljs-type">String</span>, <span class="hljs-type">Double</span>, <span class="hljs-type">Double</span>)], out: <span class="hljs-type">Collector</span>[<span class="hljs-type">MinMaxTemp</span>]): <span class="hljs-type">Unit</span> = &#123;<br>      <span class="hljs-keyword">val</span> minMax: (<span class="hljs-type">String</span>, <span class="hljs-type">Double</span>, <span class="hljs-type">Double</span>) = elements.head<br>      out.collect(<span class="hljs-type">MinMaxTemp</span>(key, minMax._2, minMax._3, context.window.getEnd))<br><br>    &#125;<br>  &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="Flink中的时间语义和Watermark（重点）"><a href="#Flink中的时间语义和Watermark（重点）" class="headerlink" title="Flink中的时间语义和Watermark（重点）"></a>Flink中的时间语义和Watermark（重点）</h2><h3 id="时间语义"><a href="#时间语义" class="headerlink" title="时间语义"></a>时间语义</h3><ul>
<li>事件时间（event time）<ul>
<li>真正正确的时间，时间语义完全正确。事件创建的事件（必须包含在数据源中的元素里面）</li>
<li>是事件创建的时间。它通常由事件中的时间戳描述，例如采集的日志数据中，每一条日志都会记录自己的生成时间，Flink通过时间戳分配器访问事件时间戳。</li>
<li>flink事件事件单位是ms，代码中需要注意</li>
</ul>
</li>
<li>机器时间<ul>
<li>Ingestion Time（摄入时间） :数据进入Flink的时间,与机器相关</li>
<li>Processing Time（处理时间）: 是每一个执行基于时间操作的算子的本地系统时间，与机器相关，默认的时间属性就是Processing Time</li>
</ul>
</li>
</ul>
<h3 id="Watermark"><a href="#Watermark" class="headerlink" title="Watermark"></a>Watermark</h3><ul>
<li>当Flink以Event Time模式处理数据流时，它会根据数据里的时间戳来处理基于时间的算子</li>
<li>由于网络，分布式等原因，会导致乱序数据的产生</li>
<li>乱序数据会让窗口计算不准确</li>
<li>窗口的区间是左闭右开区间</li>
<li>Watermark的特点<ul>
<li>水位线：系统认为时间戳小于水位线的事件都已经达到了</li>
<li>水位线是一种特殊的事件，在source算子后面插入到流中</li>
<li>事件时间窗口的闭合触发规则：水位线大于等于窗口结束时间的时候</li>
<li>水位线由程序员编程插入到流中，水位线是一个特殊的事件</li>
</ul>
</li>
<li>水位线几个重要的概念<ul>
<li>Flink默认每隔200ms（机器时间）向数据流中插入一次Watermark</li>
<li><font color=red>水位线产生的公式：水位线=系统观察到的最大事件时间 - 最大延迟时间</font></li>
<li><font color=red>最大延迟时间由程序员自己设定</font></li>
<li>分配时间戳和水位线一定要在keyBy之前进行</li>
</ul>
</li>
<li>为了保证事件时间的正确性：Flink有三重保障<ul>
<li>watermark</li>
<li>允许迟到时间  allowedLateness()</li>
<li>侧输出流  sideOutputLateData()</li>
</ul>
</li>
</ul>
<h2 id="ProcessFunction-API-底层-API"><a href="#ProcessFunction-API-底层-API" class="headerlink" title="ProcessFunction API(底层 API)"></a>ProcessFunction API(底层 API)</h2><ul>
<li><p>之前学习的转换算子是无法访问事件的时间戳信息和水位线信息的。基于此 DataStream API提供了一系列的Low-Level转换算子。可以访问时间戳，watermark以及注册定时事件。还可以输出特定的一些事件，例如超时事件等。ProcessFunction用来构建事件驱动的应用以及实现自定义的业务逻辑（使用之前的window 函数和转换算子无法实现）。例如，Flink SQL就是使用Process Function实现的。</p>
</li>
<li><p>常用的几个</p>
<ul>
<li><strong>KeyedProcessFunction</strong>：KeyBy以后的流，没有开窗口</li>
<li>ProcessFunction：既没有分流也没有开窗</li>
<li><strong>ProcessWindowFunction</strong>：分流和开窗口以后的流</li>
<li>ProcessAllWindowFunction：没有分流，但是开了窗口的流</li>
<li><strong>CoProcessFunction</strong>：两条联合的流（connect）</li>
<li><strong>AggregateFunction</strong>：窗口的增量聚合函数</li>
<li>Trigger: 窗口聚合函数的底层实现，可以自由的控制窗口计算的时机</li>
</ul>
</li>
<li><p>常用函数的案例：</p>
<ul>
<li><p>KeyedProcessFunction</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> org.apache.flink.api.common.state.<span class="hljs-type">ValueStateDescriptor</span><br><span class="hljs-keyword">import</span> org.apache.flink.api.scala.typeutils.<span class="hljs-type">Types</span><br><span class="hljs-keyword">import</span> org.apache.flink.streaming.api.functions.<span class="hljs-type">KeyedProcessFunction</span><br><span class="hljs-keyword">import</span> org.apache.flink.streaming.api.scala._<br><span class="hljs-keyword">import</span> org.apache.flink.util.<span class="hljs-type">Collector</span><br><br><span class="hljs-comment">//检查连续1s内温度上升</span><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">TempIncreaseAlert</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-keyword">val</span> env = <span class="hljs-type">StreamExecutionEnvironment</span>.getExecutionEnvironment<br>    env.setParallelism(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">val</span> stream = env.addSource(<span class="hljs-keyword">new</span> <span class="hljs-type">SensorSource</span>)<br>      .keyBy(_.id)<br>      .process(<span class="hljs-keyword">new</span> <span class="hljs-type">TempIncreaseAlertFunction</span>)<br><br>    stream.print()<br><br>    env.execute()<br>  &#125;<br><br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TempIncreaseAlertFunction</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">KeyedProcessFunction</span>[<span class="hljs-type">String</span>, <span class="hljs-type">SensorReading</span>, <span class="hljs-type">String</span>] </span>&#123;<br>    <span class="hljs-comment">//初始化一个状态变量</span><br>    <span class="hljs-comment">//懒加载，惰性赋值</span><br>    <span class="hljs-comment">//当执行到process算子时，才会初始化，所以是懒加载</span><br>    <span class="hljs-comment">//通过配置，状态变量可以通过检查点操作，保存在hdfs里面</span><br>    <span class="hljs-comment">//当程序故障时，可以从最近一次检查点恢复</span><br>    <span class="hljs-comment">//所以要有一个名字last-temp和变量的类型（需要明确告诉flink状态变量的类型）</span><br>    <span class="hljs-comment">//状态变量只会被初始化一次，允许程序时，如果没有这个状态变量，就初始化一个，如果有这个状态变量，直接读取，是单例模式</span><br>    <span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> lastTemp = getRuntimeContext.getState(<br>      <span class="hljs-keyword">new</span> <span class="hljs-type">ValueStateDescriptor</span>[<span class="hljs-type">Double</span>](<span class="hljs-string">&quot;last-temp&quot;</span>, <span class="hljs-type">Types</span>.of[<span class="hljs-type">Double</span>])<br>    )<br>    <span class="hljs-comment">//用来保存报警定时器的时间戳，默认是0L</span><br>    <span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> timerTs = getRuntimeContext.getState(<br>      <span class="hljs-keyword">new</span> <span class="hljs-type">ValueStateDescriptor</span>[<span class="hljs-type">Long</span>](<span class="hljs-string">&quot;ts&quot;</span>, <span class="hljs-type">Types</span>.of[<span class="hljs-type">Long</span>])<br>    )<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">processElement</span></span>(value: <span class="hljs-type">SensorReading</span>, ctx: <span class="hljs-type">KeyedProcessFunction</span>[<span class="hljs-type">String</span>, <span class="hljs-type">SensorReading</span>, <span class="hljs-type">String</span>]#<span class="hljs-type">Context</span>, out: <span class="hljs-type">Collector</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>      <span class="hljs-comment">//获取最近一次温度，调用&#x27;.valeu()&#x27;方法</span><br>      <span class="hljs-comment">//如果来的是第一条温度，那么prevTemp是0.0</span><br>      <span class="hljs-keyword">val</span> prevTemp = lastTemp.value()<br>      <span class="hljs-comment">//将来的温度值更新到lastTemp状态变量，使用update方法</span><br>      lastTemp.update(value.temperature)<br><br>      <span class="hljs-keyword">val</span> curTimerTs = timerTs.value()<br><br>      <span class="hljs-keyword">if</span> (prevTemp == <span class="hljs-number">0.0</span> || value.temperature &lt; prevTemp) &#123;<br>        <span class="hljs-comment">//如果来的温度是第一条温度，或者来的温度小于最近一次温度</span><br>        <span class="hljs-comment">//删除报警定时器</span><br>        ctx.timerService().deleteProcessingTimeTimer(curTimerTs)<br>        <span class="hljs-comment">//情况保存定时器时间戳的状态变量，使用clear方法</span><br>        timerTs.clear()<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value.temperature &gt; prevTemp &amp;&amp; curTimerTs == <span class="hljs-number">0</span>L) &#123;<br>        <span class="hljs-comment">//来的温度大于最近一次温度，并且我们没有注册报警定时器，因为curTimerTs等于0L</span><br>        <span class="hljs-keyword">val</span> ts = ctx.timerService().currentProcessingTime() + <span class="hljs-number">1000</span>L<br>        ctx.timerService().registerProcessingTimeTimer(ts)<br>        timerTs.update(ts)<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">onTimer</span></span>(timestamp: <span class="hljs-type">Long</span>, ctx: <span class="hljs-type">KeyedProcessFunction</span>[<span class="hljs-type">String</span>, <span class="hljs-type">SensorReading</span>, <span class="hljs-type">String</span>]#<span class="hljs-type">OnTimerContext</span>, out: <span class="hljs-type">Collector</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>      out.collect(<span class="hljs-string">&quot;传感器ID为&quot;</span> + ctx.getCurrentKey + <span class="hljs-string">&quot;的传感器温度连续1s上升&quot;</span>)<br>      timerTs.clear() <span class="hljs-comment">//清空定时器</span><br>    &#125;<br>  &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure></li>
<li><p>ProcessFunction</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> org.apache.flink.streaming.api.functions.<span class="hljs-type">ProcessFunction</span><br><span class="hljs-keyword">import</span> org.apache.flink.streaming.api.scala._<br><span class="hljs-keyword">import</span> org.apache.flink.util.<span class="hljs-type">Collector</span><br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">FreezingAlarm</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-keyword">val</span> env: <span class="hljs-type">StreamExecutionEnvironment</span> = <span class="hljs-type">StreamExecutionEnvironment</span>.getExecutionEnvironment<br>    env.setParallelism(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">val</span> stream = env.addSource(<span class="hljs-keyword">new</span> <span class="hljs-type">SensorSource</span>)<br>      <span class="hljs-comment">//没有KeyBy,没有开窗口函数</span><br>      .process(<span class="hljs-keyword">new</span> <span class="hljs-type">FreezingAlarmFunction</span>)<br>    <span class="hljs-comment">//stream.print()//打印常规输出</span><br>    <span class="hljs-comment">//打印侧输出流</span><br>    <span class="hljs-comment">//侧输出标签的名字必须是一样的</span><br>    stream.getSideOutput(<span class="hljs-keyword">new</span> <span class="hljs-type">OutputTag</span>[<span class="hljs-type">String</span>](<span class="hljs-string">&quot;freezing-alarm&quot;</span>)).print()<br>    env.execute()<br>  &#125;<br><br>  <span class="hljs-comment">//ProcessFunction处理的是没有KeyBy的流</span><br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FreezingAlarmFunction</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ProcessFunction</span>[<span class="hljs-type">SensorReading</span>, <span class="hljs-type">SensorReading</span>] </span>&#123;<br>    <span class="hljs-comment">//定义一个侧输出标签，实际上就是侧输出流的名字</span><br>    <span class="hljs-comment">//侧输出流中的元素泛型是String</span><br>    <span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> freezingAlarmOut = <span class="hljs-keyword">new</span> <span class="hljs-type">OutputTag</span>[<span class="hljs-type">String</span>](<span class="hljs-string">&quot;freezing-alarm&quot;</span>)<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">processElement</span></span>(value: <span class="hljs-type">SensorReading</span>, ctx: <span class="hljs-type">ProcessFunction</span>[<span class="hljs-type">SensorReading</span>, <span class="hljs-type">SensorReading</span>]#<span class="hljs-type">Context</span>, out: <span class="hljs-type">Collector</span>[<span class="hljs-type">SensorReading</span>]): <span class="hljs-type">Unit</span> = &#123;<br>      <span class="hljs-keyword">if</span> (value.temperature &lt; <span class="hljs-number">32.0</span>) &#123;<br>        <span class="hljs-comment">//第一个参数是侧输出标签，第二个参数是发送的数据</span><br>        ctx.output(freezingAlarmOut, value.id + <span class="hljs-string">&quot;的传感器低温报警&quot;</span>)<br>      &#125;<br>      <span class="hljs-comment">//将所以读数发送到常规输出</span><br>      out.collect(value)<br>    &#125;<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>CoProcessFunction</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> org.apache.flink.api.common.state.<span class="hljs-type">ValueStateDescriptor</span><br><span class="hljs-keyword">import</span> org.apache.flink.api.scala.typeutils.<span class="hljs-type">Types</span><br><span class="hljs-keyword">import</span> org.apache.flink.streaming.api.functions.co.<span class="hljs-type">CoProcessFunction</span><br><span class="hljs-keyword">import</span> org.apache.flink.streaming.api.scala._<br><span class="hljs-keyword">import</span> org.apache.flink.util.<span class="hljs-type">Collector</span><br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">CoProcessFunctionExample</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-keyword">val</span> env = <span class="hljs-type">StreamExecutionEnvironment</span>.getExecutionEnvironment<br>    env.setParallelism(<span class="hljs-number">1</span>)<br>    <span class="hljs-comment">//第一条流,无限流</span><br>    <span class="hljs-keyword">val</span> stream1 = env.addSource(<span class="hljs-keyword">new</span> <span class="hljs-type">SensorSource</span>)<br>    <span class="hljs-comment">//第二条流，有限流，只有一个元素，用来做开关，对Sensor_7的数据放行10s</span><br>    <span class="hljs-keyword">val</span> stream2 = env.fromElements(<br>      (<span class="hljs-string">&quot;Sensor_7&quot;</span>, <span class="hljs-number">5</span> * <span class="hljs-number">1000</span>L)<br>    )<br>    <span class="hljs-keyword">val</span> result = stream1<br>      .connect(stream2)<br>      .keyBy(_.id, _._1) <span class="hljs-comment">//on stream1.id=stream2._1</span><br>      .process(<span class="hljs-keyword">new</span> <span class="hljs-type">ReadingFilter</span>)<br><br>    result.print()<br><br>    env.execute()<br><br>  &#125;<br><br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadingFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CoProcessFunction</span>[<span class="hljs-type">SensorReading</span>, (<span class="hljs-type">String</span>, <span class="hljs-type">Long</span>), <span class="hljs-type">SensorReading</span>] </span>&#123;<br>    <span class="hljs-comment">//初始值为false</span><br>    <span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> forwardEnabled = getRuntimeContext.getState(<br>      <span class="hljs-keyword">new</span> <span class="hljs-type">ValueStateDescriptor</span>[<span class="hljs-type">Boolean</span>](<span class="hljs-string">&quot;switch&quot;</span>, <span class="hljs-type">Types</span>.of[<span class="hljs-type">Boolean</span>])<br>    )<br><br>    <span class="hljs-comment">//处理来自传感器的流数据</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">processElement1</span></span>(value: <span class="hljs-type">SensorReading</span>, ctx: <span class="hljs-type">CoProcessFunction</span>[<span class="hljs-type">SensorReading</span>, (<span class="hljs-type">String</span>, <span class="hljs-type">Long</span>), <span class="hljs-type">SensorReading</span>]#<span class="hljs-type">Context</span>, out: <span class="hljs-type">Collector</span>[<span class="hljs-type">SensorReading</span>]): <span class="hljs-type">Unit</span> = &#123;<br>      <span class="hljs-comment">//如果开关为true，就允许数据流向下发送</span><br>      <span class="hljs-keyword">if</span> (forwardEnabled.value()) &#123;<br>        out.collect(value)<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//处理来自开关流的数据</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">processElement2</span></span>(value: (<span class="hljs-type">String</span>, <span class="hljs-type">Long</span>), ctx: <span class="hljs-type">CoProcessFunction</span>[<span class="hljs-type">SensorReading</span>, (<span class="hljs-type">String</span>, <span class="hljs-type">Long</span>), <span class="hljs-type">SensorReading</span>]#<span class="hljs-type">Context</span>, out: <span class="hljs-type">Collector</span>[<span class="hljs-type">SensorReading</span>]): <span class="hljs-type">Unit</span> = &#123;<br>      <span class="hljs-comment">//打开开关</span><br>      forwardEnabled.update(<span class="hljs-literal">true</span>)<br>      <span class="hljs-comment">//开关元组的第二个值是放行时间</span><br>      <span class="hljs-keyword">val</span> ts = ctx.timerService().currentProcessingTime() + value._2<br>      <span class="hljs-comment">//注册一个定时器</span><br>      ctx.timerService().registerProcessingTimeTimer(ts)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">onTimer</span></span>(timestamp: <span class="hljs-type">Long</span>, ctx: <span class="hljs-type">CoProcessFunction</span>[<span class="hljs-type">SensorReading</span>, (<span class="hljs-type">String</span>, <span class="hljs-type">Long</span>), <span class="hljs-type">SensorReading</span>]#<span class="hljs-type">OnTimerContext</span>, out: <span class="hljs-type">Collector</span>[<span class="hljs-type">SensorReading</span>]): <span class="hljs-type">Unit</span> = &#123;<br>      <span class="hljs-comment">//关闭开关</span><br>      forwardEnabled.clear()<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>水位线+迟到事件处理+侧输出流处理</p>
<ul>
<li>每200ms系统默认插入一个水位线</li>
<li>窗口是一个左闭右开的区间</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><br><span class="hljs-keyword">import</span> org.apache.flink.api.common.state.<span class="hljs-type">ValueStateDescriptor</span><br><span class="hljs-keyword">import</span> org.apache.flink.api.scala.typeutils.<span class="hljs-type">Types</span><br><span class="hljs-keyword">import</span> org.apache.flink.streaming.api.<span class="hljs-type">TimeCharacteristic</span><br><span class="hljs-keyword">import</span> org.apache.flink.streaming.api.functions.timestamps.<span class="hljs-type">BoundedOutOfOrdernessTimestampExtractor</span><br><span class="hljs-keyword">import</span> org.apache.flink.streaming.api.scala._<br><span class="hljs-keyword">import</span> org.apache.flink.streaming.api.scala.function.<span class="hljs-type">ProcessWindowFunction</span><br><span class="hljs-keyword">import</span> org.apache.flink.streaming.api.windowing.time.<span class="hljs-type">Time</span><br><span class="hljs-keyword">import</span> org.apache.flink.streaming.api.windowing.windows.<span class="hljs-type">TimeWindow</span><br><span class="hljs-keyword">import</span> org.apache.flink.util.<span class="hljs-type">Collector</span><br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">UpdateWindowResultWithLateElement</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-keyword">val</span> env = <span class="hljs-type">StreamExecutionEnvironment</span>.getExecutionEnvironment<br>    env.setParallelism(<span class="hljs-number">1</span>)<br>    <span class="hljs-comment">//设置事件时间</span><br>    env.setStreamTimeCharacteristic(<span class="hljs-type">TimeCharacteristic</span>.<span class="hljs-type">EventTime</span>)<br>    <span class="hljs-keyword">val</span> stream = env<br>      .socketTextStream(<span class="hljs-string">&quot;hadoop100&quot;</span>, <span class="hljs-number">9999</span>, &#x27;\n&#x27;)<br>      .map(line =&gt; &#123;<br>        <span class="hljs-keyword">val</span> arr = line.split(<span class="hljs-string">&quot; &quot;</span>)<br>        (arr(<span class="hljs-number">0</span>), arr(<span class="hljs-number">1</span>).toLong * <span class="hljs-number">1000</span>L)<br>      &#125;)<br>      .assignTimestampsAndWatermarks(<br>        <span class="hljs-comment">//最大延迟时间5s</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-type">BoundedOutOfOrdernessTimestampExtractor</span>[(<span class="hljs-type">String</span>, <span class="hljs-type">Long</span>)](<span class="hljs-type">Time</span>.seconds(<span class="hljs-number">5</span>)) &#123;<br>          <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">extractTimestamp</span></span>(element: (<span class="hljs-type">String</span>, <span class="hljs-type">Long</span>)): <span class="hljs-type">Long</span> = element._2<br>        &#125;<br>      )<br>      .keyBy(_._1)<br>      .timeWindow(<span class="hljs-type">Time</span>.seconds(<span class="hljs-number">5</span>))<br>      <span class="hljs-comment">//允许迟到时间</span><br>      .allowedLateness(<span class="hljs-type">Time</span>.seconds(<span class="hljs-number">5</span>))<br>      <span class="hljs-comment">//将迟到事件发送到侧输出流中去</span><br>      .process(<span class="hljs-keyword">new</span> <span class="hljs-type">UpdateWindowResult</span>)<br>    stream.print()<br>    env.execute()<br>  &#125;<br><br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UpdateWindowResult</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ProcessWindowFunction</span>[(<span class="hljs-type">String</span>, <span class="hljs-type">Long</span>), <span class="hljs-type">String</span>, <span class="hljs-type">String</span>, <span class="hljs-type">TimeWindow</span>] </span>&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process</span></span>(key: <span class="hljs-type">String</span>, context: <span class="hljs-type">Context</span>, elements: <span class="hljs-type">Iterable</span>[(<span class="hljs-type">String</span>, <span class="hljs-type">Long</span>)], out: <span class="hljs-type">Collector</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>      <span class="hljs-comment">//当第一次对窗口进行求值时，也就是水位线超过窗口结束时间的时候</span><br>      <span class="hljs-comment">//会第一次调用process函数</span><br>      <span class="hljs-comment">//这是isUpdate为默认值false</span><br>      <span class="hljs-comment">//窗口内初始化一个状态变量使用windowState,只对当前窗口可见</span><br>      <span class="hljs-keyword">val</span> isUpdate = context.windowState.getState(<br>        <span class="hljs-keyword">new</span> <span class="hljs-type">ValueStateDescriptor</span>[<span class="hljs-type">Boolean</span>](<span class="hljs-string">&quot;update&quot;</span>, <span class="hljs-type">Types</span>.of[<span class="hljs-type">Boolean</span>])<br>      )<br>      <span class="hljs-keyword">if</span> (!isUpdate.value()) &#123;<br>        <span class="hljs-comment">//当水位线超过窗口结束时间，第一次调用</span><br>        out.collect(<span class="hljs-string">&quot;窗口第一次求值了！元素共有&quot;</span> + elements.size + <span class="hljs-string">&quot; 个&quot;</span>)<br>        <span class="hljs-comment">//第一次调用完process后，将isUpdate赋值为true</span><br>        isUpdate.update(<span class="hljs-literal">true</span>)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        out.collect(<span class="hljs-string">&quot;迟到元素来了，更新的元素数量为&quot;</span> + elements.size + <span class="hljs-string">&quot; 个&quot;</span>)<br>      &#125;<br>    &#125;<br>  &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure></li>
<li><p>触发器Trigger</p>
</li>
<li><p>每次调用Trigger都会产生一个TriggerResult来决定窗口接下来发生什么。TriggerResult可以取以下结果:</p>
<ul>
<li>CONTINUE：什么都不做</li>
<li>FIRE：如果window operator有ProcessWindowFunction这个参数，将会调用ProcessWindowFunction，如果窗口仅有增量聚合函数（ReduceFunction或者AggregateFunction）作为参数，那么当前的聚合结果将会被发送，窗口的state不变</li>
<li>PURGE：窗口所以内容包括窗口的元数据都将被丢弃</li>
<li>FIRE_AND_PURGE:先对窗口求值，再将窗口中的内容丢弃</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> org.apache.flink.api.common.state.<span class="hljs-type">ValueStateDescriptor</span><br><span class="hljs-keyword">import</span> org.apache.flink.api.scala.typeutils.<span class="hljs-type">Types</span><br><span class="hljs-keyword">import</span> org.apache.flink.streaming.api.<span class="hljs-type">TimeCharacteristic</span><br><span class="hljs-keyword">import</span> org.apache.flink.streaming.api.scala._<br><span class="hljs-keyword">import</span> org.apache.flink.streaming.api.scala.function.<span class="hljs-type">ProcessWindowFunction</span><br><span class="hljs-keyword">import</span> org.apache.flink.streaming.api.windowing.time.<span class="hljs-type">Time</span><br><span class="hljs-keyword">import</span> org.apache.flink.streaming.api.windowing.triggers.<span class="hljs-type">Trigger</span>.<span class="hljs-type">TriggerContext</span><br><span class="hljs-keyword">import</span> org.apache.flink.streaming.api.windowing.triggers.&#123;<span class="hljs-type">Trigger</span>, <span class="hljs-type">TriggerResult</span>&#125;<br><span class="hljs-keyword">import</span> org.apache.flink.streaming.api.windowing.windows.<span class="hljs-type">TimeWindow</span><br><span class="hljs-keyword">import</span> org.apache.flink.util.<span class="hljs-type">Collector</span><br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">TriggerExample</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-keyword">val</span> env = <span class="hljs-type">StreamExecutionEnvironment</span>.getExecutionEnvironment<br>    env.setParallelism(<span class="hljs-number">1</span>)<br>    env.setStreamTimeCharacteristic(<span class="hljs-type">TimeCharacteristic</span>.<span class="hljs-type">EventTime</span>)<br>    <span class="hljs-keyword">val</span> stream = env<br>      .socketTextStream(<span class="hljs-string">&quot;hadoop100&quot;</span>, <span class="hljs-number">9999</span>, &#x27;\n&#x27;)<br>      .map(line =&gt; &#123;<br>        <span class="hljs-keyword">val</span> arr = line.split(<span class="hljs-string">&quot; &quot;</span>)<br>        (arr(<span class="hljs-number">0</span>), arr(<span class="hljs-number">1</span>).toLong)<br>      &#125;)<br>      .assignAscendingTimestamps(_._2)<br>      .keyBy(_._1)<br>      .timeWindow(<span class="hljs-type">Time</span>.seconds(<span class="hljs-number">10</span>))<br>      .trigger(<span class="hljs-keyword">new</span> <span class="hljs-type">OneSecondIntervalTrigger</span>)<br>      .process(<span class="hljs-keyword">new</span> <span class="hljs-type">WindowCount</span>)<br><br>    stream.print()<br>    env.execute()<br>  &#125;<br><br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OneSecondIntervalTrigger</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Trigger</span>[(<span class="hljs-type">String</span>, <span class="hljs-type">Long</span>), <span class="hljs-type">TimeWindow</span>] </span>&#123;<br>    <span class="hljs-comment">//每来一条元素都要调用一次</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">onElement</span></span>(element: (<span class="hljs-type">String</span>, <span class="hljs-type">Long</span>), timestamp: <span class="hljs-type">Long</span>, window: <span class="hljs-type">TimeWindow</span>, ctx: <span class="hljs-type">TriggerContext</span>): <span class="hljs-type">TriggerResult</span> = &#123;<br>      <span class="hljs-comment">//默认值为false</span><br>      <span class="hljs-comment">//当第一条事件来的时候将firstSeen置为false</span><br>      <span class="hljs-keyword">val</span> firstSeen = ctx.getPartitionedState(<br>        <span class="hljs-keyword">new</span> <span class="hljs-type">ValueStateDescriptor</span>[<span class="hljs-type">Boolean</span>](<span class="hljs-string">&quot;first-seen&quot;</span>, <span class="hljs-type">Types</span>.of[<span class="hljs-type">Boolean</span>])<br>      )<br>      <span class="hljs-comment">//当第一条数据来的时候，！firstSeen.value()为true</span><br>      <span class="hljs-comment">//仅对第一条数据注册定时器</span><br>      <span class="hljs-comment">//这里的定时器指的是：onEventTime函数</span><br>      <span class="hljs-keyword">if</span> (!firstSeen.value()) &#123;<br>        <span class="hljs-comment">//如果当前水位线为1234，那么t=1234+(1000-1234%1000)=2000</span><br>        println(<span class="hljs-string">&quot;第一条数据进入时的水位线是：&quot;</span>+ctx.getCurrentWatermark)<br>        <span class="hljs-keyword">val</span> t = ctx.getCurrentWatermark + (<span class="hljs-number">1000</span> - (ctx.getCurrentWatermark % <span class="hljs-number">1000</span>))<br>        println(<span class="hljs-string">&quot;第一次注册的定时器时间是：&quot;</span>+ t)<br>        ctx.registerEventTimeTimer(t) <span class="hljs-comment">//第一条数据的时间戳之后的整数秒注册一个定时器</span><br>        println(<span class="hljs-string">&quot;第一次注册的窗口结束时间定时器时间是：&quot;</span>+window.getEnd)<br>        ctx.registerEventTimeTimer(window.getEnd) <span class="hljs-comment">//在窗口结束时间注册一个定时器</span><br>        firstSeen.update(<span class="hljs-literal">true</span>)<br>      &#125;<br>      <span class="hljs-type">TriggerResult</span>.<span class="hljs-type">CONTINUE</span> <span class="hljs-comment">//什么都不敢(fire=false,purge=false)</span><br>    &#125;<br><br>    <span class="hljs-comment">//我们使用的是事件事件，所以onProcessingTime什么都不用做</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">onProcessingTime</span></span>(time: <span class="hljs-type">Long</span>, window: <span class="hljs-type">TimeWindow</span>, ctx: <span class="hljs-type">TriggerContext</span>): <span class="hljs-type">TriggerResult</span> = &#123;<br>      <span class="hljs-type">TriggerResult</span>.<span class="hljs-type">CONTINUE</span><br>    &#125;<br>    <span class="hljs-comment">//定时器函数，在水位线到达time时触发</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">onEventTime</span></span>(time: <span class="hljs-type">Long</span>, window: <span class="hljs-type">TimeWindow</span>, ctx: <span class="hljs-type">TriggerContext</span>): <span class="hljs-type">TriggerResult</span> = &#123;<br>      println(<span class="hljs-string">&quot;当前水位线是&quot;</span>+ctx.getCurrentWatermark)<br>      <span class="hljs-comment">//在onElement函数中，我们注册过窗口结束时间的定时器</span><br>      <span class="hljs-keyword">if</span> (time == window.getEnd) &#123;<br>        <span class="hljs-comment">//在窗口闭合时，触发计算并清空窗口</span><br>        <span class="hljs-type">TriggerResult</span>.<span class="hljs-type">FIRE_AND_PURGE</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">val</span> t = ctx.getCurrentWatermark + (<span class="hljs-number">1000</span> - (ctx.getCurrentWatermark % <span class="hljs-number">1000</span>))<br>        <span class="hljs-keyword">if</span> (t &lt; window.getEnd) &#123;<br>          ctx.registerEventTimeTimer(t)<br>          println(<span class="hljs-string">&quot;注册的定时器时间是：&quot;</span>+t)<br>        &#125;<br>        <span class="hljs-type">TriggerResult</span>.<span class="hljs-type">FIRE</span><br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">clear</span></span>(window: <span class="hljs-type">TimeWindow</span>, ctx: <span class="hljs-type">TriggerContext</span>): <span class="hljs-type">Unit</span> = &#123;<br>      <span class="hljs-comment">//状态变量是一个单例</span><br>      <span class="hljs-keyword">val</span> firstSeen = ctx.getPartitionedState(<br>        <span class="hljs-keyword">new</span> <span class="hljs-type">ValueStateDescriptor</span>[<span class="hljs-type">Boolean</span>](<span class="hljs-string">&quot;first-seen&quot;</span>, <span class="hljs-type">Types</span>.of[<span class="hljs-type">Boolean</span>])<br>      )<br><br>      firstSeen.clear()<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowCount</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ProcessWindowFunction</span>[(<span class="hljs-type">String</span>, <span class="hljs-type">Long</span>), <span class="hljs-type">String</span>, <span class="hljs-type">String</span>, <span class="hljs-type">TimeWindow</span>] </span>&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process</span></span>(key: <span class="hljs-type">String</span>, context: <span class="hljs-type">Context</span>, elements: <span class="hljs-type">Iterable</span>[(<span class="hljs-type">String</span>, <span class="hljs-type">Long</span>)], out: <span class="hljs-type">Collector</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>      out.collect(<span class="hljs-string">&quot;窗口中有&quot;</span> + elements.size + <span class="hljs-string">&quot;条数据！ &quot;</span> + <span class="hljs-string">&quot;窗口结束时间是&quot;</span> + context.window.getEnd)<br>    &#125;<br>  &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="Flink状态编程和容错机制"><a href="#Flink状态编程和容错机制" class="headerlink" title="Flink状态编程和容错机制"></a>Flink状态编程和容错机制</h2><h3 id="状态编程"><a href="#状态编程" class="headerlink" title="状态编程"></a>状态编程</h3><ul>
<li><p>流式计算分为无状态编程和有状态编程两种情况。无状态计算观察每个独立事件，并根据最后一个事件输出结果。</p>
</li>
<li><p>无状态计算例子：</p>
<ul>
<li>流处理应用程序从传感器接收温度读数，并在温度超过90度时发出警告。</li>
</ul>
</li>
<li><p>有状态计算例子：</p>
<ul>
<li>所有窗口类型，例如，计算过去一小时的平均温度，就是有状态的计算</li>
<li>所有用于复杂事件处理的状态机。例如，若在一分钟内收到两个相差20度以上的温度读数，则发出警告，这就是有状态的计算。</li>
<li>流与流之间的所有关联操作，以及流与静态表或动态表之间的关联操作，都是有状态的计算。</li>
</ul>
</li>
<li><p>可以认为状态就是一个本地变量，可以被任务的业务逻辑访问</p>
</li>
<li><p>无状态流处理每次只转换一条输入记录，并且仅根据最新的输入记录输出结果，有状态流处理维护所有已经处理记录的状态值，并根据每条新输入的记录更新状态，因此输出记录反映的是综合考虑多个事件之后的结果。</p>
</li>
<li><p>在Flink中，状态始终与特定算子相关联。总的来说，有两种类型的状态：</p>
<ul>
<li>算子状态（operator state）<ul>
<li>算子状态的作用范围限定为算子任务。这意味着同一并行任务所处理的所有数据都可以访问到相同的状态，状态对于同一任务而言是共享的，算子状态不能由相同或不同算子的另一个任务访问。</li>
</ul>
</li>
<li>键控状态  (keyed state)<ul>
<li>键控状态是根据输入数据流中定义的键（key）来维护和访问的。Fink为每个键值维护一个状态实例，并将具有相同键的所有数据，都分区到同一个算子任务中，这个任务会维护和处理这个key对应的状态。当任务处理一条数据时，它会自动将状态的访问范围限定为当前数据的key。因此，具有相同key的所有数据都会访问相同的状态。Keyed State很类似于一个分布式的key-value map数据结构，只能用于KeyedStream (KeyBy算子处理之后)</li>
<li><a href="https://imgtu.com/i/IwrVfS"><img src="https://z3.ax1x.com/2021/11/11/IwrVfS.png" alt="IwrVfS.png"></a></li>
<li>Flink的Keyed State 支持以下数据类型：<ul>
<li>ValueState[T]保存单个的值，值的类型为T。<ul>
<li>get操作: ValueState.value()</li>
<li>set操作: ValueState.update(value: T)</li>
</ul>
</li>
<li> ListState[T]保存一个列表，列表里的元素的数据类型为T。基本操作如下：</li>
<li>o ListState.add(value: T)</li>
<li> ListState.addAll(values: java.util.List[T])</li>
<li>ListState.get()返回Iterable[T]</li>
<li>ListState.update(values: java.util.List[T])</li>
<li>MapState[K,V]保存Key-Value对<ul>
<li>MapState.get(key:K)</li>
<li>MapState.put(key:K,value:V)</li>
<li>MapState.contains(key:K)</li>
<li>MapState.remove(key:K)</li>
</ul>
</li>
<li>ReducingState[T]</li>
<li>AggregatingState[I,O]</li>
<li>State.clear()是清空操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> org.apache.flink.api.common.state.&#123;<span class="hljs-type">ListStateDescriptor</span>, <span class="hljs-type">ValueStateDescriptor</span>&#125;<br><span class="hljs-keyword">import</span> org.apache.flink.api.scala.typeutils.<span class="hljs-type">Types</span><br><span class="hljs-keyword">import</span> org.apache.flink.streaming.api.functions.<span class="hljs-type">KeyedProcessFunction</span><br><span class="hljs-keyword">import</span> org.apache.flink.streaming.api.scala._<br><span class="hljs-keyword">import</span> org.apache.flink.util.<span class="hljs-type">Collector</span><br><br><span class="hljs-keyword">import</span> scala.collection.mutable.<span class="hljs-type">ListBuffer</span><br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">ListStateExample</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-keyword">val</span> env = <span class="hljs-type">StreamExecutionEnvironment</span>.getExecutionEnvironment<br>    env.setParallelism(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">val</span> stream = env<br>      .addSource(<span class="hljs-keyword">new</span> <span class="hljs-type">SensorSource</span>)<br>      .filter(_.id.equals(<span class="hljs-string">&quot;Sensor_1&quot;</span>))<br>      .keyBy(_.id)<br>      .process(<span class="hljs-keyword">new</span> <span class="hljs-type">Keyed</span>)<br><br>    stream.print()<br><br>    env.execute()<br>  &#125;<br><br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Keyed</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">KeyedProcessFunction</span>[<span class="hljs-type">String</span>, <span class="hljs-type">SensorReading</span>, <span class="hljs-type">String</span>] </span>&#123;<br>    <span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> listState = getRuntimeContext.getListState(<br>      <span class="hljs-keyword">new</span> <span class="hljs-type">ListStateDescriptor</span>[<span class="hljs-type">SensorReading</span>](<span class="hljs-string">&quot;list-state&quot;</span>, <span class="hljs-type">Types</span>.of[<span class="hljs-type">SensorReading</span>])<br>    )<br>    <span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> timer = getRuntimeContext.getState(<br>      <span class="hljs-keyword">new</span> <span class="hljs-type">ValueStateDescriptor</span>[<span class="hljs-type">Long</span>](<span class="hljs-string">&quot;timer&quot;</span>, <span class="hljs-type">Types</span>.of[<span class="hljs-type">Long</span>])<br>    )<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">processElement</span></span>(value: <span class="hljs-type">SensorReading</span>, ctx: <span class="hljs-type">KeyedProcessFunction</span>[<span class="hljs-type">String</span>, <span class="hljs-type">SensorReading</span>, <span class="hljs-type">String</span>]#<span class="hljs-type">Context</span>, out: <span class="hljs-type">Collector</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>      listState.add(value) <span class="hljs-comment">//添加value到列表状态变量中</span><br>      <span class="hljs-keyword">if</span> (timer.value() == <span class="hljs-number">0</span>L) &#123;<br>        <span class="hljs-keyword">val</span> ts = ctx.timerService().currentProcessingTime() + <span class="hljs-number">10</span> * <span class="hljs-number">1000</span>L<br>        ctx.timerService().registerProcessingTimeTimer(ts)<br>        timer.update(ts)<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">onTimer</span></span>(timestamp: <span class="hljs-type">Long</span>, ctx: <span class="hljs-type">KeyedProcessFunction</span>[<span class="hljs-type">String</span>, <span class="hljs-type">SensorReading</span>, <span class="hljs-type">String</span>]#<span class="hljs-type">OnTimerContext</span>, out: <span class="hljs-type">Collector</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>      <span class="hljs-comment">//不能直接对列表状态变量进行计数</span><br>      <span class="hljs-keyword">val</span> readings: <span class="hljs-type">ListBuffer</span>[<span class="hljs-type">SensorReading</span>] = <span class="hljs-keyword">new</span> <span class="hljs-type">ListBuffer</span>()<br>      <span class="hljs-comment">//隐式类型转换必须导入</span><br>      <span class="hljs-keyword">import</span> scala.collection.<span class="hljs-type">JavaConversions</span>._<br>      <span class="hljs-keyword">for</span> (r &lt;- listState.get()) &#123;<br>        readings += r;<br>      &#125;<br>      out.collect(<span class="hljs-string">&quot;当前时刻列表状态变量里面共有&quot;</span> + readings.size + <span class="hljs-string">&quot;条数据&quot;</span>)<br>      timer.clear() <span class="hljs-comment">//清空定时器</span><br>    &#125;<br>  &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure></li>
<li><p>状态后端(State Backends)</p>
<ul>
<li>每传入一条数据，有状态的算子任务都会读取和更新状态</li>
<li>由于有效的状态访问对于处理数据的低延迟至关重要，因此每个并行任务都会在本地维护其状态，以确保快速的状态访问。</li>
<li>状态的存储，访问以及维护，由一个可插入的组件决定这个组件就叫做状态后端。</li>
<li>状态后端主要负责两件事情，本地状态管理，以及将检查点（checkpoint）状态写入远程存储（HDFS）。</li>
</ul>
</li>
<li><p>状态后端的选择</p>
<ul>
<li>MemoryStateBackend<ul>
<li>内存级的状态后端，会将键控状态作为内存中的对象进行管理，将他们存储在TaskManager的JVM堆上，而将checkpoint存储在JobManager的内存中</li>
<li>特定：快速，但不稳定，一般用于测试</li>
</ul>
</li>
<li>FsStateBackend<ul>
<li>将checkpoint存到远程的持久化文件系统（FileSystem）上，而对于本地状态，跟MemoryStateBackend一样，也会存储在TaskManager的JVM堆上</li>
<li>特点：同时拥有内存级的本地访问速度，和更好的容错保证</li>
</ul>
</li>
<li>RocksDBStateBackend<ul>
<li>将所有状态序列化后，存入本地的RocksDB中存储。</li>
</ul>
</li>
</ul>
</li>
<li><p>Flink的一个重大价值在于，它既保证了exactly-once，也具有低延迟和高吞吐的处理能力</p>
</li>
</ul>
<h3 id="容错机制"><a href="#容错机制" class="headerlink" title="容错机制"></a>容错机制</h3><ul>
<li>Flink故障恢复机制的核心就是<strong>应用状态的一致性检查点</strong></li>
<li>有状态应用的一致检查点，其实就是所有任务的状态，在某个时间点的一份拷贝（一份快照）；这个时间点，应该是所有任务都恰好处理完一个相同的输入数据的时候。</li>
<li>从检查点恢复状态过程：<ul>
<li>遇到故障之后，第一步就是重启应用</li>
<li>第二步是从checkpoint中读取状态，将状态重置，从检查点重新启动应用程序后，其内部状态与检查点完成时的状态完全相同。</li>
<li>第三步：开始消费并处理检查点到发生故障之间的所有数据</li>
</ul>
</li>
<li>这种检查点的保存和恢复机制可以为应用程序提供“精确一次”（exactly-once）的一致性，因为所有算子都会保存检查点并恢复其所有状态，这样一来所有的输入流都会被重置到检查点完成时的位置。</li>
<li>保存点：flink提供了可以自定义的镜像保存功能，就是保存点（savepoints）<ul>
<li>原则上，创建保存点使用的算法与检查点完全相同，因此保存点可以认为就是具有一些额外元数据的检查点</li>
<li>flink不会自动创建保存点，需要用户手动执行的（在程序中编写相应的代码）</li>
</ul>
</li>
</ul>
<h4 id="状态一致性"><a href="#状态一致性" class="headerlink" title="状态一致性"></a>状态一致性</h4><ul>
<li><p>状态一致性级别</p>
</li>
<li><p>flink 端到端（end-to-end）状态一致性</p>
<ul>
<li><p>内部保证 checkpoint</p>
</li>
<li><p>source端  可重设数据的读取位置   (Kafka,FileSystem)</p>
</li>
<li><p>sink 端      从故障恢复时，数据不会重复写入外部系统</p>
<ul>
<li><p>幂等写入：   幂等操作就是指：一个操作，可以重复执行很多次，但只导致一次结果更改，也就是说，后面再重复执行就不起作用了</p>
</li>
<li><p>事物写入：  具有原子性，一个事务中的一系列操作要么全部成功，要么一个都不做</p>
<ul>
<li>实现思想：构建的事务对应着checkpoint，等到checkpoint 真正完成的时候，才把所有对应的结果写入sink系统中</li>
<li>实现方式：<ul>
<li>预写日志   (宕机会导致不能实现exactly-once)</li>
<li>两阶段提交（真正实现exactly-once）外部sink系统必须要提供事务</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>不同sink的一致性保证</p>
<ul>
<li><a href="https://imgse.com/i/ppOOckT"><img src="https://s1.ax1x.com/2023/04/12/ppOOckT.png" alt="ppOOckT.png"></a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Flink-CEP"><a href="#Flink-CEP" class="headerlink" title="Flink CEP"></a>Flink CEP</h2><ul>
<li><p>一个或多个由简单事件构成的事件流通过一定的规则匹配，然后输出用户想得到的数据，满足规则的复杂事件。</p>
<ul>
<li>目标：从有序的简单事件流中发现一些高阶特征</li>
<li>输入：一个或多个由简单事件构成的事件流</li>
<li>处理：识别简单事件之间的内在联系，多个符合一定规则的简单事件构成复杂事件</li>
<li>输出：满足规则的复杂事件</li>
</ul>
</li>
<li><p>CEP用于分析低延迟、频繁产生的不同来源的事件流。CEP可以帮助在复杂的、不相关的事件流中找出有意义的模式和复杂的关系，以接近实时或准实时的获得通知并阻止一些行为。</p>
<p>CEP支持在流上进行模式匹配，根据模式的条件不同，分为连续的条件或不连续的条件；模式的条件允许有时间的限制，当在条件范围内没有达到满足的条件时，会导致模式匹配超时。</p>
</li>
<li><p>功能</p>
<ul>
<li>输入的流数据，尽快产生结果</li>
<li>在2个event流上，基于时间进行聚合类的计算</li>
<li>提供实时/准实时的警告和通知</li>
<li>在多样的数据源中产生关联并分析模式</li>
<li>高吞吐、低延迟的处理</li>
</ul>
</li>
</ul>
<h2 id="Flink-SQL"><a href="#Flink-SQL" class="headerlink" title="Flink SQL"></a>Flink SQL</h2><ul>
<li>SQL的几个优点<ul>
<li>声明式（Declarative）</li>
<li>自动调优（Optimized）</li>
<li>易于理解（Understandable）</li>
<li>稳定（Stable）</li>
<li>流与批的统一（Unify）</li>
</ul>
</li>
<li>Flink SQL的流与批统一总结起来就一句话：One Query，One Result</li>
</ul>
<h3 id="Flink-SQL核心概念"><a href="#Flink-SQL核心概念" class="headerlink" title="Flink SQL核心概念"></a>Flink SQL核心概念</h3><ul>
<li>动态表&amp;流表二像性<ul>
<li>传统的SQL是定义在表上的，为了能在流上定义SQL，我们也需要一个表的概念。这里就需要引入一个非常重要的概念：动态表（Dynamic Table）。所谓动态表，就是数据会随着时间变化的表，可以想象成就是数据库中一张被不断更新的表。我们发现流与表有非常紧密的关系，流表可以看作动态表，动态表可以看做流。我们称之为流表二象性。<ul>
<li><a href="https://imgtu.com/i/TrLqK0"><img src="https://s4.ax1x.com/2021/12/28/TrLqK0.png" alt="TrLqK0.png"></a></li>
</ul>
</li>
</ul>
</li>
<li>连续查询<ul>
<li>动态表是流的另一种表现形式，有了动态表后，我们就可以在流上定义SQL了，流式SQL可以想象成连续查询（Continous Query）。传统的查询是只运行一次的SQL，产生一个结果表就结束了。连续查询会一直运行在那里，当每个数据到来，都会持续增量地更新计算结果，从而产生另一个动态表。而这个结果动态表（也就是流）会作为另一个SQL（连续查询）的输入接着计算，从而串起整个数据流图。</li>
<li><a href="https://imgtu.com/i/TrOOSA"><img src="https://s4.ax1x.com/2021/12/28/TrOOSA.png" alt="TrOOSA.png"></a></li>
</ul>
</li>
</ul>
<h3 id="Flink-SQL核心功能"><a href="#Flink-SQL核心功能" class="headerlink" title="Flink SQL核心功能"></a>Flink SQL核心功能</h3><ul>
<li><a href="https://imgtu.com/i/TrXKkF"><img src="https://s4.ax1x.com/2021/12/28/TrXKkF.png" alt="TrXKkF.png"></a></li>
<li>高级功能<ul>
<li>双流join<ul>
<li>双流join功能是将两条流进行关联，用来补齐流上的字段。双流join又分为无限流的双流JOIN和带窗口的双流JOIN</li>
</ul>
</li>
<li>维表join<ul>
<li>维表JOIN功能是流与表的关联，也是用来为数据流补齐字段，只是补齐的维表字段是在外部存储的维表中的。</li>
</ul>
</li>
<li>TopN<ul>
<li>全局TopN，分组TopN</li>
</ul>
</li>
<li>Window<ul>
<li>支持滚动窗口，滑动窗口，会话窗口，以及传统数据库中的OVER窗口</li>
</ul>
</li>
<li>多路输入，多路输出</li>
<li>MiniBatch 优化<ul>
<li>对于有状态的算子，每个进入算子的元素都需要对状态做序列化/反序列化的操作，频繁的状态序列化/反序列化操作占了性能开销的大半。MiniBatch的核心思想是，对进入算子的元素进行攒批，一批数据只需要对状态序列化/反序列化一次即可，极大地提升了性能。</li>
</ul>
</li>
<li>Retraction 撤回机制<ul>
<li>撤回机制是Flink SQL中一个非常重要地基石，它解决了early-fire导致的结果正确性问题（所有的GroupBy都是early-fire的）。而利用好撤回机制有时候能够很巧妙地帮助业务解决一些特殊需求。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Flink-SQL-维表JOIN与异步优化"><a href="#Flink-SQL-维表JOIN与异步优化" class="headerlink" title="Flink SQL 维表JOIN与异步优化"></a>Flink SQL 维表JOIN与异步优化</h3><ul>
<li><p>维表JOIN语法</p>
<ul>
<li>假设我们有一个Orders订单数据流，希望根据产品ID补全流上地产品维度信息，所以需要跟Products维度表进行关联。Orders 和 Products的DDL声明语句如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Orders (<br>  orderId <span class="hljs-built_in">VARCHAR</span>,          <span class="hljs-comment">-- 订单 id</span><br>  productId <span class="hljs-built_in">VARCHAR</span>,        <span class="hljs-comment">-- 产品 id</span><br>  units <span class="hljs-built_in">INT</span>,                <span class="hljs-comment">-- 购买数量</span><br>  orderTime <span class="hljs-built_in">TIMESTAMP</span>       <span class="hljs-comment">-- 下单时间</span><br>) <span class="hljs-keyword">with</span> (<br>  <span class="hljs-keyword">type</span> = <span class="hljs-string">&#x27;tt&#x27;</span>,              <span class="hljs-comment">-- tt 日志流</span><br>  ...<br>)<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Products (<br>  productId <span class="hljs-built_in">VARCHAR</span>,        <span class="hljs-comment">-- 产品 id</span><br>  <span class="hljs-keyword">name</span> <span class="hljs-built_in">VARCHAR</span>,             <span class="hljs-comment">-- 产品名称</span><br>  unitPrice <span class="hljs-keyword">DOUBLE</span>          <span class="hljs-comment">-- 单价</span><br>  <span class="hljs-keyword">PERIOD</span> <span class="hljs-keyword">FOR</span> SYSTEM_TIME,   <span class="hljs-comment">-- 这是一张随系统时间而变化的表，用来声明维表</span><br>  PRIMARY <span class="hljs-keyword">KEY</span> (productId)   <span class="hljs-comment">-- 维表必须声明主键</span><br>) <span class="hljs-keyword">with</span> (<br>  <span class="hljs-keyword">type</span> = <span class="hljs-string">&#x27;alihbase&#x27;</span>,        <span class="hljs-comment">-- HBase 数据源</span><br>  ...<br>)<br><br><span class="hljs-comment">-- JOIN当前维表</span><br><span class="hljs-keyword">SELECT</span> *<br><span class="hljs-keyword">FROM</span> Orders <span class="hljs-keyword">AS</span> o<br>[<span class="hljs-keyword">LEFT</span>] <span class="hljs-keyword">JOIN</span> Products <span class="hljs-keyword">FOR</span> SYSTEM_TIME <span class="hljs-keyword">AS</span> <span class="hljs-keyword">OF</span> PROCTIME() <span class="hljs-keyword">AS</span> p<br><span class="hljs-keyword">ON</span> o.productId = p.productId<br><br><br><span class="hljs-comment">-- Flink SQL支持LEFT JOIN和INNER JOIN的维表关联。只是Products维表后面需要跟上FOR SYSTEM_TIME AS OF PROCTIME()的关键字，其含义是每条到达的数据所关联上的是到达时刻的维表快照，也就是说，当数据到达时，我们会根据数据上的Key去查询远程数据库，拿到匹配的结果后关联输出。这里的PROCTIME()即processing time。使用JOIN当前维表功能需要注意的是，如果维表插入了一条数据能匹配上之前左表的数据时，JOIN的结果流，不会发出更新的数据以弥补之前的未匹配。JOIN行为只发生在处理时间（processing time）,即使维表中的数据都被删了，之前JOIN流已经发出的关联上的数据也不会被撤回或改变。</span><br></code></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>JOIN当前维表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> *<br><span class="hljs-keyword">FROM</span> Orders <span class="hljs-keyword">AS</span> o<br>[<span class="hljs-keyword">LEFT</span>] <span class="hljs-keyword">JOIN</span> Products <span class="hljs-keyword">FOR</span> SYSTEM_TIME <span class="hljs-keyword">AS</span> <span class="hljs-keyword">OF</span> PROCTIME() <span class="hljs-keyword">AS</span> p<br><span class="hljs-keyword">ON</span> o.productId = p.productId<br></code></pre></td></tr></table></figure>

<ul>
<li>Flink SQL支持LEFT JOIN和INNER JOIN的维表关联。只是Products维表后面需要跟上<strong>FOR SYSTEM_TIME AS OF PROCTIME()<strong>的关键字，其含义是每条到达的数据所关联上的是到达时刻的维表快照，也就是说，当数据到达时，我们会根据数据上的Key去查询远程数据库，拿到匹配的结果后关联输出。这里的</strong>PROCTIME()<strong>即</strong>processing time</strong>。使用JOIN当前维表功能需要注意的是，如果维表插入了一条数据能匹配上之前左表的数据时，JOIN的结果流，不会发出更新的数据以弥补之前的未匹配。JOIN行为只发生在处理时间（processing time）,即使维表中的数据都被删了，之前JOIN流已经发出的关联上的数据也不会被撤回或改变。</li>
</ul>
</li>
<li><p>JOIN历史维表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> *<br><span class="hljs-keyword">FROM</span> Orders <span class="hljs-keyword">AS</span> o<br>[<span class="hljs-keyword">LEFT</span>] <span class="hljs-keyword">JOIN</span> Products <span class="hljs-keyword">FOR</span> SYSTEM_TIME <span class="hljs-keyword">AS</span> <span class="hljs-keyword">OF</span> o.orderTime <span class="hljs-keyword">AS</span> p<br><span class="hljs-keyword">ON</span> o.productId = p.productId<br></code></pre></td></tr></table></figure>

<ul>
<li>有时候想关联上的维度数据，并不是当前时刻的值，而是某个时刻的值。比如，产品的价格一直在发生变化，订单流希望补全的是下单时的价格，而不是当前的价格，那就是JOIN历史维表。语法上只需要将上文的PROCTIME()改成o.orderTime即可。</li>
</ul>
</li>
<li><p>Flink 在获取维度数据时，会根据左流的时间去查对应时刻的快照数据。因此JOIN历史维表需要外部存储支持多版本存储，如HBase，或者存储的数据中带有多版本信息。</p>
</li>
<li><p>维表优化</p>
<ul>
<li>提高吞吐。维表的IO请求严重阻塞了数据流的计算处理。解决办法：异步IO，原始的维表JOIN是同步访问的方式，来一条数据，去数据库查询一次，等待返回后输出关联结果。可以发现网络等待时间极大地阻碍了吞吐和延迟。为了解决同步访问地问题，异步模式可以并发地处理多个请求和回复，从而连续地请求之间不需要阻塞等待。</li>
<li>降低维表数据库读压力。如HBase也只能承受单机每秒20万的读请求。解决办法：进行缓存，LRU和ALL（维表较小，可以将整个维表缓存到本地）</li>
<li>通过 <code>cache=&#39;LRU&#39;</code>参数可以开启 LRU 缓存优化</li>
<li>ALL cache 可以通过 <code>cache=&#39;ALL&#39;</code>参数开启</li>
<li>通过<code>cacheTTLMs</code>控制缓存的刷新间隔。</li>
</ul>
</li>
</ul>
<h3 id="Flink-sql-支持的语法"><a href="#Flink-sql-支持的语法" class="headerlink" title="Flink sql 支持的语法"></a>Flink sql 支持的语法</h3><ul>
<li><p>````sql<br>insert:<br>  INSERT INTO tableReference<br>  query</p>
<p>query:<br>  values<br>  | {</p>
<pre><code>  select
  | selectWithoutFrom
  | query UNION [ ALL ] query
  | query EXCEPT query
  | query INTERSECT query
&#125;
[ ORDER BY orderItem [, orderItem ]* ]
[ LIMIT &#123; count | ALL &#125; ]
[ OFFSET start &#123; ROW | ROWS &#125; ]
[ FETCH &#123; FIRST | NEXT &#125; [ count ] &#123; ROW | ROWS &#125; ONLY]
</code></pre>
<p>orderItem:<br>  expression [ ASC | DESC ]</p>
<p>select:<br>  SELECT [ ALL | DISTINCT ]<br>  { * | projectItem [, projectItem ]* }<br>  FROM tableExpression<br>  [ WHERE booleanExpression ]<br>  [ GROUP BY { groupItem [, groupItem ]* } ]<br>  [ HAVING booleanExpression ]<br>  [ WINDOW windowName AS windowSpec [, windowName AS windowSpec ]* ]</p>
<p>selectWithoutFrom:<br>  SELECT [ ALL | DISTINCT ]<br>  { * | projectItem [, projectItem ]* }</p>
<p>projectItem:<br>  expression [ [ AS ] columnAlias ]<br>  | tableAlias . *</p>
<p>tableExpression:<br>  tableReference [, tableReference ]*<br>  | tableExpression [ NATURAL ] [ LEFT | RIGHT | FULL ] JOIN tableExpression [ joinCondition ]</p>
<p>joinCondition:<br>  ON booleanExpression<br>  | USING ‘(‘ column [, column ]* ‘)’</p>
<p>tableReference:<br>  tablePrimary<br>  [ [ AS ] alias [ ‘(‘ columnAlias [, columnAlias ]* ‘)’ ] ]</p>
<p>tablePrimary:<br>  [ TABLE ] [ [ catalogName . ] schemaName . ] tableName<br>  | LATERAL TABLE ‘(‘ functionName ‘(‘ expression [, expression ]* ‘)’ ‘)’<br>  | UNNEST ‘(‘ expression ‘)’</p>
<p>values:<br>  VALUES expression [, expression ]*</p>
<p>groupItem:<br>  expression<br>  | ‘(‘ ‘)’<br>  | ‘(‘ expression [, expression ]* ‘)’<br>  | CUBE ‘(‘ expression [, expression ]* ‘)’<br>  | ROLLUP ‘(‘ expression [, expression ]* ‘)’<br>  | GROUPING SETS ‘(‘ groupItem [, groupItem ]* ‘)’</p>
<p>windowRef:</p>
<pre><code>windowName
</code></pre>
<p>  | windowSpec</p>
<p>windowSpec:</p>
<pre><code>[ windowName ]
&#39;(&#39;
[ ORDER BY orderItem [, orderItem ]* ]
[ PARTITION BY expression [, expression ]* ]
[
    RANGE numericOrIntervalExpression &#123;PRECEDING&#125;
  | ROWS numericExpression &#123;PRECEDING&#125;
]
&#39;)&#39;
</code></pre>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs"><br>  <br><br>#### Group Window<br><br>* 根据窗口数据划分的不同，目前Flink有如下三种Bounded Window<br><br>  - Tumble,滚动窗口，窗口数据有固定的大小，窗口数据无叠加<br><br>    ````sqlite<br>    SELECT <br>        [gk],<br>        [TUMBLE_START(timeCol, size)], <br>        [TUMBLE_END(timeCol, size)], <br>        agg1(col1), <br>        ... <br>        aggn(colN)<br>    FROM Tab1<br>    GROUP BY [gk], TUMBLE(timeCol, size)<br>    <br>    /*<br>    [gk] 决定了是否需要按照字段进行聚合；<br>    TUMBLE_START 代表窗口开始时间；<br>    TUMBLE_END 代表窗口结束时间；<br>    timeCol 是流表中表示时间字段；<br>    size 表示窗口的大小，如 秒、分钟、小时、天。<br>    */<br>    -- 举个例子，假如我们要计算每个人每天的订单量，按照 user 进行聚合分组：<br>    <br>    SELECT user, <br>    TUMBLE_START(rowtime, INTERVAL ‘1’ DAY) as wStart, <br>    SUM(amount) <br>    FROM Orders <br>    GROUP BY TUMBLE(rowtime, INTERVAL ‘1’ DAY), user;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>Hop,滑动窗口，窗口数据有固定大小，有固定的窗口重建频率，窗口数据有叠加</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <br>    [gk], <br>    [HOP_START(timeCol, slide, <span class="hljs-keyword">size</span>)] ,  <br>    [HOP_END(timeCol, slide, <span class="hljs-keyword">size</span>)],<br>    agg1(col1), <br>    ... <br>    aggN(colN) <br><span class="hljs-keyword">FROM</span> Tab1<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> [gk], HOP(timeCol, slide, <span class="hljs-keyword">size</span>)<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">[gk] 决定了是否需要按照字段进行聚合；</span><br><span class="hljs-comment">HOP_START 表示窗口开始时间；</span><br><span class="hljs-comment">HOP_END 表示窗口结束时间；</span><br><span class="hljs-comment">timeCol 表示流表中表示时间字段；</span><br><span class="hljs-comment">slide 表示每次窗口滑动的大小；</span><br><span class="hljs-comment">size 表示整个窗口的大小，如 秒、分钟、小时、天。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">-- 我们要每过一小时计算一次过去 24 小时内每个商品的销量：</span><br><span class="hljs-keyword">SELECT</span> product, <br><span class="hljs-keyword">SUM</span>(amount) <br><span class="hljs-keyword">FROM</span> Orders <br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> HOP(rowtime, <span class="hljs-built_in">INTERVAL</span> <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">HOUR</span>, <span class="hljs-built_in">INTERVAL</span> <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">DAY</span>), product<br></code></pre></td></tr></table></figure></li>
<li><p>Session, 会话窗口，窗口数据没有固定的大小，根据窗口数据活跃程度划分窗口，窗口数据无叠加</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <br>    [gk], <br>    SESSION_START(timeCol, gap) <span class="hljs-keyword">AS</span> winStart,  <br>    SESSION_END(timeCol, gap) <span class="hljs-keyword">AS</span> winEnd,<br>    agg1(col1),<br>     ... <br>    aggn(colN)<br><span class="hljs-keyword">FROM</span> Tab1<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> [gk], <span class="hljs-keyword">SESSION</span>(timeCol, gap)<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">[gk] 决定了是否需要按照字段进行聚合；</span><br><span class="hljs-comment">SESSION_START 表示窗口开始时间；</span><br><span class="hljs-comment">SESSION_END 表示窗口结束时间；</span><br><span class="hljs-comment">timeCol 表示流表中表示时间字段；</span><br><span class="hljs-comment">gap 表示窗口数据非活跃周期的时长。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">-- 例如，我们需要计算每个用户访问时间 12 小时内的订单量：</span><br><span class="hljs-keyword">SELECT</span> <br><span class="hljs-keyword">user</span>, <br>SESSION_START(rowtime, <span class="hljs-built_in">INTERVAL</span> ‘<span class="hljs-number">12</span>’ <span class="hljs-keyword">HOUR</span>) <span class="hljs-keyword">AS</span> sStart, <br>SESSION_ROWTIME(rowtime, <span class="hljs-built_in">INTERVAL</span> ‘<span class="hljs-number">12</span>’ <span class="hljs-keyword">HOUR</span>) <span class="hljs-keyword">AS</span> sEnd, <br><span class="hljs-keyword">SUM</span>(amount) <br><span class="hljs-keyword">FROM</span> Orders <br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">SESSION</span>(rowtime, <span class="hljs-built_in">INTERVAL</span> ‘<span class="hljs-number">12</span>’ <span class="hljs-keyword">HOUR</span>), <span class="hljs-keyword">user</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Flink</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>Flink</tag>
      </tags>
  </entry>
</search>
