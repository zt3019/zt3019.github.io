<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java网络编程基础</title>
    <url>/2021/04/23/Java-network/</url>
    <content><![CDATA[<h1 id="Java网络编程基础"><a href="#Java网络编程基础" class="headerlink" title="Java网络编程基础"></a>Java网络编程基础</h1><h2 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> network;<br><br><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.BufferedWriter;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.io.InputStreamReader;<br><span class="hljs-keyword">import</span> java.io.OutputStream;<br><span class="hljs-keyword">import</span> java.io.OutputStreamWriter;<br><span class="hljs-keyword">import</span> java.net.ServerSocket;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><span class="hljs-keyword">import</span> java.time.LocalDateTime;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetTest</span> </span>&#123;<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">server3</span><span class="hljs-params">()</span> </span>&#123;<br>		ServerSocket server = <span class="hljs-keyword">null</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8888</span>); <span class="hljs-comment">// 绑定端口</span><br>			<span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>				System.out.println(<span class="hljs-string">&quot;服务器在8888端口监听中.....&quot;</span>);<br>				<span class="hljs-keyword">final</span> Socket socket1 = server.accept();<br>				;<br>				Runnable runner = <span class="hljs-keyword">new</span> Runnable() &#123;<br>					<span class="hljs-meta">@Override</span><br>					<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>						BufferedWriter bufferedWriter = <span class="hljs-keyword">null</span>;<br>						<span class="hljs-keyword">try</span> &#123;<br>							bufferedWriter = <span class="hljs-keyword">new</span> BufferedWriter(<span class="hljs-keyword">new</span> OutputStreamWriter(socket1.getOutputStream()));<br>							bufferedWriter.write(<span class="hljs-string">&quot;我是服务器, 现在时间 : &quot;</span> + LocalDateTime.now());<br>							bufferedWriter.newLine();<br>							bufferedWriter.flush(); <span class="hljs-comment">// 把数据真的刷入网线中</span><br>						&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>							e.printStackTrace();<br>						&#125; <span class="hljs-keyword">finally</span> &#123;<br>							<span class="hljs-keyword">if</span> (bufferedWriter != <span class="hljs-keyword">null</span>) &#123;<br>								<span class="hljs-keyword">try</span> &#123;<br>									bufferedWriter.close();<br>								&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>								&#125;<br>							&#125;<br>							<span class="hljs-keyword">if</span> (socket1 != <span class="hljs-keyword">null</span>) &#123;<br>								<span class="hljs-keyword">try</span> &#123;<br>									socket1.close();<br>								&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>								&#125;<br>							&#125;<br>						&#125;<br>						<span class="hljs-keyword">try</span> &#123;<br>							Thread.sleep(<span class="hljs-number">5000</span>);<br>						&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>							e.printStackTrace();<br>						&#125;<br>					&#125;<br>				&#125;;<br>				<span class="hljs-keyword">new</span> Thread(runner).start();<br>			&#125;<br>		&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br><br>			<span class="hljs-keyword">if</span> (server != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					System.out.println(<span class="hljs-string">&quot;服务器关闭....&quot;</span>);<br>					server.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">client3</span><span class="hljs-params">()</span> </span>&#123;<br>		Socket socket2 = <span class="hljs-keyword">null</span>;<br>		BufferedReader bufferedReader = <span class="hljs-keyword">null</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			socket2 = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8888</span>);<br>			bufferedReader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(socket2.getInputStream()));<br>			String readLine = bufferedReader.readLine();<br>			System.out.println(readLine);<br>		&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			<span class="hljs-keyword">if</span> (bufferedReader != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					bufferedReader.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">if</span> (socket2 != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					socket2.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">// 从客户端发送文件给服务端，服务端保存到本地。并返回“发送成功”给客户端。并关闭相应的连接。</span><br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">server2</span><span class="hljs-params">()</span> </span>&#123;<br>		ServerSocket server = <span class="hljs-keyword">null</span>;<br>		Socket socket1 = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 网络套接字</span><br><br>		InputStream nis = <span class="hljs-keyword">null</span>;<br>		FileOutputStream fos = <span class="hljs-keyword">null</span>;<br>		BufferedWriter netWriter = <span class="hljs-keyword">null</span>;<br><br>		<span class="hljs-keyword">try</span> &#123;<br>			server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">7777</span>);<span class="hljs-comment">// 指定服务器接口</span><br>			socket1 = server.accept();<br>			nis = socket1.getInputStream();<br>			fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;朴树 - 猎户星座2.mp3&quot;</span>);<br>			netWriter = <span class="hljs-keyword">new</span> BufferedWriter(<span class="hljs-keyword">new</span> OutputStreamWriter(socket1.getOutputStream()));<br><br>			<span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">8192</span>];<br>			<span class="hljs-keyword">int</span> realCount = nis.read(buf);<br>			<span class="hljs-keyword">while</span> (realCount != -<span class="hljs-number">1</span>) &#123;<br>				fos.write(buf, <span class="hljs-number">0</span>, realCount);<br>				realCount = nis.read(buf);<br>			&#125;<br>			netWriter.write(<span class="hljs-string">&quot;发送成功&quot;</span>);<br>			netWriter.newLine();<br>			netWriter.flush();<br><br>		&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			<span class="hljs-keyword">if</span> (netWriter != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					netWriter.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">if</span> (fos != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					fos.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">if</span> (nis != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					nis.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">if</span> (socket1 != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					socket1.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">if</span> (server != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					server.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">client2</span><span class="hljs-params">()</span> </span>&#123;<br>		Socket socket2 = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 网络套接字</span><br><br>		FileInputStream fis = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 文件输入流</span><br>		OutputStream nos = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 网络输出流</span><br>		BufferedReader netReader = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 网络输入流</span><br>		<span class="hljs-keyword">try</span> &#123;<br>			socket2 = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">7777</span>);<br>			fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;src/朴树 - 猎户星座.mp3&quot;</span>);<span class="hljs-comment">// 要传到服务器端的文件，先读入到客户端</span><br>			nos = socket2.getOutputStream();<span class="hljs-comment">// 传输到服务器端的文件输出流</span><br>			netReader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(socket2.getInputStream()));<span class="hljs-comment">// 读取服务器端返回的数据</span><br><br>			<span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">8192</span>];<br>			<span class="hljs-comment">// 读取数据</span><br>			<span class="hljs-keyword">int</span> realCount = fis.read(buf);<br>			<span class="hljs-keyword">while</span> (realCount != -<span class="hljs-number">1</span>) &#123;<br>				<span class="hljs-comment">// 1) 处理已经读的数据</span><br>				nos.write(buf, <span class="hljs-number">0</span>, realCount);<br>				<span class="hljs-comment">// 2) 继续读</span><br>				realCount = fis.read(buf);<br>			&#125;<br>			nos.flush();<span class="hljs-comment">// 将在缓存中的数据全部输出去</span><br>			socket2.shutdownOutput();<span class="hljs-comment">// 关闭输出流</span><br><br>			String readLine = netReader.readLine();<span class="hljs-comment">// 接受服务器端的数据</span><br>			System.out.println(readLine);<br><br>		&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<span class="hljs-comment">// 关闭相应的资源</span><br>			<span class="hljs-keyword">if</span> (netReader != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					netReader.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">if</span> (nos != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					nos.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">if</span> (fis != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					fis.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">if</span> (socket2 != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					socket2.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">server</span><span class="hljs-params">()</span> </span>&#123;<br>		ServerSocket server = <span class="hljs-keyword">null</span>;<br>		Socket socket1 = <span class="hljs-keyword">null</span>;<br>		BufferedReader bufferedReader = <span class="hljs-keyword">null</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">9999</span>); <span class="hljs-comment">// 绑定9999端口.</span><br>			socket1 = server.accept(); <span class="hljs-comment">// 接受客户端的连接请求, 此方法会引起阻塞.</span><br>			System.out.println(socket1);<br>			<span class="hljs-comment">// 服务器端的socket1和客户端的socket2就建立了双向的网络通道</span><br>			InputStream inputStream = socket1.getInputStream();<br>			InputStreamReader isr = <span class="hljs-keyword">new</span> InputStreamReader(inputStream);<br><br>			bufferedReader = <span class="hljs-keyword">new</span> BufferedReader(isr);<br>			String readLine = bufferedReader.readLine();<br>			System.out.println(readLine);<br>		&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			<span class="hljs-keyword">if</span> (bufferedReader != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					bufferedReader.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br><br>			<span class="hljs-keyword">if</span> (socket1 != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					socket1.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br><br>			<span class="hljs-keyword">if</span> (server != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					server.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br><br>			&#125;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">client</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">// 连接服务器, 必须知道ip和端口.</span><br>		Socket socket2 = <span class="hljs-keyword">null</span>;<br>		BufferedWriter bufferedWriter = <span class="hljs-keyword">null</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			socket2 = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">9999</span>);<br>			System.out.println(socket2);<br>			<span class="hljs-comment">// 客户端的socket2和服务器端的socket1就建立了双向的网络通道</span><br>			OutputStream outputStream = socket2.getOutputStream();<br>			OutputStreamWriter osw = <span class="hljs-keyword">new</span> OutputStreamWriter(outputStream);<br>			bufferedWriter = <span class="hljs-keyword">new</span> BufferedWriter(osw);<br>			bufferedWriter.write(<span class="hljs-string">&quot;你好, 服务器, 俺是客户端.....&quot;</span>);<br>			bufferedWriter.newLine();<span class="hljs-comment">// 必须要有换行</span><br>			bufferedWriter.flush();<br>		&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			<span class="hljs-keyword">if</span> (bufferedWriter != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					bufferedWriter.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br><br>			<span class="hljs-keyword">if</span> (socket2 != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					socket2.close();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h2 id="杀死本机被占用的端口号"><a href="#杀死本机被占用的端口号" class="headerlink" title="杀死本机被占用的端口号"></a>杀死本机被占用的端口号</h2><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">netstat</span> -ano   查看操作系统所有占用端口的进程<br><span class="hljs-attribute">netstat</span> -ano | findstr <span class="hljs-string">&quot;9999&quot;</span> 获取占用了<span class="hljs-number">9999</span>端口的进程<br><span class="hljs-attribute">taskkill</span> /F /pid <span class="hljs-number">1234</span> 关闭进程号为<span class="hljs-number">1234</span>的进程<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop的介绍</title>
    <url>/2020/11/11/hadoop%20installation/</url>
    <content><![CDATA[<h1 id="Hadoop的介绍"><a href="#Hadoop的介绍" class="headerlink" title="Hadoop的介绍"></a>Hadoop的介绍</h1><p>1.hadoop两大核心组件    </p>
<blockquote>
<ul>
<li>HDFS(Hadoop Distributed File System )     <blockquote>
<ul>
<li>NameNode(管理各种元数据并提供服务) ,DataNode  </li>
<li> 冷备份SecondaryNameNode(HDFS1.0)</li>
</ul>
</blockquote>
</li>
<li>MapReduce    <blockquote>
<ul>
<li>JobTracker TaskTracker    </li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<p>2.Hadoop集群基准测试</p>
<blockquote>
<ul>
<li>Hadoop自带的一些基准测试程序，被打包在测试程序JAR文件中</li>
<li>用TestDFSIO基准测试，来测试HDFS的IO性能</li>
<li>用排序测试MapReduce</li>
</ul>
</blockquote>
<p>3.HDFS系统介绍<br>基本介绍：HDFS开源实现了GFS的基本思想<br>优良特性：</p>
<blockquote>
<ul>
<li>兼容廉价的硬件设备</li>
<li>流数据读写</li>
<li>大数据集</li>
<li>简单的文件模型</li>
<li>强大的跨平台兼容性   </li>
</ul>
</blockquote>
<p>局限性：</p>
<blockquote>
<ul>
<li>不适合低延迟数据访问</li>
<li>无法高效存储大量小文件</li>
<li>不支持多用户写入及任意修改文件 </li>
</ul>
</blockquote>
<p>相关概念：</p>
<blockquote>
<ul>
<li>块（64MB）</li>
<li>名称节点（NameNode）整个HDFS集群的管家<blockquote>
<ul>
<li>FsImage</li>
<li>EditLog</li>
</ul>
</blockquote>
</li>
<li>第二名称节点</li>
<li>数据节点    </li>
</ul>
</blockquote>
<p>HDFS存储原理：</p>
<blockquote>
<ul>
<li>冗余数据保存的问题</li>
<li>数据保存策略问题</li>
<li>数据恢复的问题<br>HDFS数据读写：</li>
<li>读写过程：<br><img src="https://img-blog.csdn.net/20160520174354336?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="数据读写过程" title="过程"></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop简介</title>
    <url>/2020/10/21/hadoop-introduction/</url>
    <content><![CDATA[<h1 id="hadoop简介"><a href="#hadoop简介" class="headerlink" title="hadoop简介"></a>hadoop简介</h1><p>1.定义：<br>hadoop是一个开源分布式计算平台，为用户提供了底层细节透明的分布式基础框架。<br>2.特性：    </p>
<ul>
<li>高可靠性    </li>
<li>高效性</li>
<li>高可扩展性</li>
<li>高容错性</li>
<li>成本低</li>
<li>运行在linux中</li>
<li>支持多种编程语言</li>
</ul>
<p>3.版本</p>
<ul>
<li>1.0</li>
<li>2.0</li>
</ul>
<p>4.hadoop结构</p>
<ul>
<li><img src="https://img-blog.csdnimg.cn/20191024090622860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZtMzQ1Njg5,size_16,color_FFFFFF,t_70" alt="图片展示" title="Hadoop项目结构图"></li>
<li>参考别人博客的<a href="https://blog.csdn.net/fm345689/article/details/102715230">文字记录</a></li>
</ul>
<p>5.Hadoop项目核心模块</p>
<ul>
<li>Hadoop Common：为Hadoop其他模块提供支持实用程序。</li>
<li>HDFS：提供对应用程序数据的高吞吐量访问</li>
<li>Hadoop YARN：作业调度和集群资源管理的框架</li>
<li>MapReduce：YARN系统的大型数据集并行处理技术</li>
</ul>
<p>6.Hadoop RPC工作原理</p>
<p>7.MapReduce工作原理</p>
<blockquote>
<ul>
<li>策略：分而治之</li>
<li>计算向数据靠拢而不是数据向计算靠拢</li>
</ul>
</blockquote>
<p>8.HDFS工作原理</p>
<p>9.YARN工作原理</p>
]]></content>
      <categories>
        <category>hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/09/22/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Java多线程基础</title>
    <url>/2021/04/20/multithreading/</url>
    <content><![CDATA[<h1 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h1><h2 id="1-程序，进程，线程"><a href="#1-程序，进程，线程" class="headerlink" title="1.程序，进程，线程"></a>1.程序，进程，线程</h2><blockquote>
<ul>
<li>程序：（可以执行的静态代码，是保存在硬盘上的一个文件）是为完成特定任务，用某种语言编写的一组指令的集合。即<em><strong>一段静态的代码</strong></em>，静态对象.</li>
<li>进程：（正在执行中的一个程序，在内存中处于激活状态，有生命周期）是程序的一次执行过程，或是<em><strong>正在运行的一个程序</strong></em>。动态过程：有它自身的产生、存在和消亡的过程</li>
<li>线程：（进程中的子任务）进程可以进一步细化为线程，是一个程序内部的一条执行路径</li>
</ul>
</blockquote>
<h2 id="2-Java中多线程的创建和使用"><a href="#2-Java中多线程的创建和使用" class="headerlink" title="2.Java中多线程的创建和使用"></a>2.Java中多线程的创建和使用</h2><blockquote>
<ul>
<li>实现Runnable接口与继承Thread类</li>
<li><h3 id="Thread类的主要方法"><a href="#Thread类的主要方法" class="headerlink" title="Thread类的主要方法"></a>Thread类的主要方法</h3><blockquote>
<ul>
<li>每个线程都是通过某个特定Thread对象的run()方法来完成操作的，经常把run()方法的主题称为线程体</li>
<li>通过该Thread对象的start()方法来调用这个线程</li>
<li>static Thread currentThread(),返回当前方法正在执行此方法所压入的栈的线程对象</li>
<li>void join()它的作用是调用此方法的另一个线程阻塞，当前线程执行完再执行另一个线程</li>
<li>static void sleep(long millis)作用是让当前线程（正在执行此方法的栈的线程）进入睡眠状态<blockquote>
<ul>
<li>两种方式结束sleep状态：1.时间到了。2.被其他进程打断 interrupt() 方法</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><h3 id="创建并启动线程的方式"><a href="#创建并启动线程的方式" class="headerlink" title="创建并启动线程的方式"></a>创建并启动线程的方式</h3></li>
<li><h4 id="实现Runnable的方式"><a href="#实现Runnable的方式" class="headerlink" title="实现Runnable的方式"></a>实现Runnable的方式</h4><blockquote>
<ol>
<li>写一个具体类，实现Runnable接口，并实现接口中的抽象方法run(),这个run方法就是线程体</li>
<li>创建这个具体类对象，并把这个对象作为实参，创建Thread线程对象</li>
<li>调用Thread线程对象的start方法</li>
</ol>
<ul>
<li>代码示例</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> multi_thread;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">200</span>;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>		System.out.println(cnt);<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>			<span class="hljs-keyword">synchronized</span> (<span class="hljs-string">&quot;&quot;</span>) &#123;<span class="hljs-comment">// ()中是一个锁对象，任意对象都可以做锁，称为互斥锁，作用是只允许一个线程进入执行，其他线程等待</span><br><br>				cnt -= <span class="hljs-number">2</span>;<br>				<span class="hljs-keyword">try</span> &#123;<br>					Thread.sleep(<span class="hljs-number">10</span>);<br>				&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>					<span class="hljs-comment">// TODO Auto-generated catch block</span><br>					e.printStackTrace();<br>				&#125;<br>				System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;: &quot;</span> + cnt);<br>			&#125;<br>		&#125;<br>	&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> multi_thread;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CounterTest</span> </span>&#123;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		Runnable counter = <span class="hljs-keyword">new</span> Counter();<br>		Thread thread1 = <span class="hljs-keyword">new</span> Thread(counter);<br>		Thread thread2 = <span class="hljs-keyword">new</span> Thread(counter);<br>		thread1.start();<br>		thread2.start();<br>	&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><h4 id="继承Thread的方式"><a href="#继承Thread的方式" class="headerlink" title="继承Thread的方式"></a>继承Thread的方式</h4><blockquote>
<ol>
<li>写一个类，继承Thread,并重写run方法，此方法就是线程体</li>
<li>创建这个类的对象，相当于创建了线程对象</li>
<li>调用这个线程对象的start方法</li>
</ol>
<ul>
<li>代码示例</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> multi_thread;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++) &#123;<br>			System.out.println(currentThread().getName()+<span class="hljs-string">&quot; &quot;</span>+i);<br>		&#125;<br>	&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTest2</span> </span>&#123;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		Thread myThread1 = <span class="hljs-keyword">new</span> MyThread();<br>		myThread1.start();<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++) &#123;<br>			System.out.println(<span class="hljs-string">&quot;-----main &quot;</span>+i);<br>		&#125;<br>	&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>
<h2 id="3-线程的同步"><a href="#3-线程的同步" class="headerlink" title="3.线程的同步"></a>3.线程的同步</h2><blockquote>
<ul>
<li>synchronized (lock){}</li>
<li>()中是一个锁对象，任意对象都可以做锁，称为互斥锁，作用是只允许一个线程进入执行，其他线程等待</li>
<li>具有原子性，不可分割</li>
<li>synchronized()可重入锁（同一个线程可以无限次获取同一个锁）</li>
<li>避免死锁：不要嵌套synchronized，即使有嵌套，锁对象尽量少</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>shell介绍</title>
    <url>/2021/03/25/shell_introduction/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反射</title>
    <url>/2021/04/22/Java-reflect/</url>
    <content><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="单元测试类"><a href="#单元测试类" class="headerlink" title="单元测试类"></a>单元测试类</h2><blockquote>
<ul>
<li>单元测试方法的要求：类必须是公共的，必需不能有任何构造器</li>
<li>方法必修是公共非静态无返回值参数</li>
<li>执行：在方法名中右击，点击run as -junit</li>
<li>包装类：把基本数据类型包装成对象</li>
</ul>
</blockquote>
<h2 id="反射基础实例代码"><a href="#反射基础实例代码" class="headerlink" title="反射基础实例代码"></a>反射基础实例代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> reflect;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.junit.Assert.*;<br><br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.io.Serializable;<br><span class="hljs-keyword">import</span> java.lang.annotation.Annotation;<br><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map.Entry;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 反射 : java的动态处理技术</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(&#123;ElementType.TYPE, ElementType.FIELD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@interface</span> HelloAnnotation &#123;<br>	<span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;缺省名字&quot;</span>;<br>	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">id</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 10</span>;<br>&#125;<br><br><span class="hljs-meta">@HelloAnnotation(name=&quot;abc&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ArrayList</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span>, <span class="hljs-title">Comparable</span>, <span class="hljs-title">Runnable</span> </span>&#123;<br>	<br>	<span class="hljs-meta">@HelloAnnotation</span><br>	<span class="hljs-keyword">private</span> String name;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>	<span class="hljs-keyword">private</span> String gender;<br>	<br>	<span class="hljs-comment">//@HelloAnnotation</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Teacher</span><span class="hljs-params">()</span> </span>&#123;<br>	&#125;<br>	<span class="hljs-comment">//构造方法，Ctrl+Alt+S+O</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Teacher</span><span class="hljs-params">(String name)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.name = name;<br>	&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Teacher</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.age = age;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Teacher</span><span class="hljs-params">(String name,String gender)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.name = name;<br>		<span class="hljs-keyword">this</span>.gender = gender;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Teacher</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, String gender)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.name = name;<br>		<span class="hljs-keyword">this</span>.age = age;<br>		<span class="hljs-keyword">this</span>.gender = gender;<br>	&#125;<br>    <span class="hljs-comment">//set,get方法 快捷键Ctrl+Alt+S+R</span><br>	<span class="hljs-comment">//@HelloAnnotation</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> name;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.name = name;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> age;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.age = age;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getGender</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> gender;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setGender</span><span class="hljs-params">(String gender)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.gender = gender;<br>	&#125;<br>    <span class="hljs-comment">//Ctrl+Alt+S+S</span><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Teacher [name=&quot;</span> + name + <span class="hljs-string">&quot;, age=&quot;</span> + age + <span class="hljs-string">&quot;, gender=&quot;</span> + gender + <span class="hljs-string">&quot;]&quot;</span>;<br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lesson</span><span class="hljs-params">(String content, <span class="hljs-keyword">int</span> time)</span> </span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;老师在上[&quot;</span> + content + <span class="hljs-string">&quot;]课, 共上了[&quot;</span> + time +<span class="hljs-string">&quot;]小时&quot;</span>);<br>		<span class="hljs-comment">//return true;</span><br>		<span class="hljs-comment">//throw new RuntimeException(&quot;一个异常&quot;);</span><br>	&#125;<br>	<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReflectTest</span> </span>&#123;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testName</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>		Class clazz = Class.forName(<span class="hljs-string">&quot;reflect.Teacher&quot;</span>);<br>		Annotation[] annotations = clazz.getAnnotations();<br>		System.out.println(annotations.length);<br>		System.out.println(annotations[<span class="hljs-number">0</span>]);<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test14</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>		Class clazz = Class.forName(<span class="hljs-string">&quot;reflect.Teacher&quot;</span>);<br>		System.out.println(<span class="hljs-string">&quot;父类 : &quot;</span> + clazz.getSuperclass());<br>		Constructor[] constructors = clazz.getConstructors();<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; constructors.length; i++) &#123;<br>			System.out.println(<span class="hljs-string">&quot;构造器 : &quot;</span> + constructors[i]);<br>		&#125;<br>		System.out.println(<span class="hljs-string">&quot;************************************************&quot;</span>);<br>		Field[] fields = clazz.getFields(); <span class="hljs-comment">// 所有公共属性</span><br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; fields.length; i++) &#123;<br>			System.out.println(<span class="hljs-string">&quot;公共属性：&quot;</span>+fields[i]);<br>		&#125;<br>		<span class="hljs-comment">//反射尽量不要破坏封装性，容易发生严重后果，慎用getDeclared.....()方法</span><br>		Field[] declaredFields = clazz.getDeclaredFields(); <span class="hljs-comment">// 所有本类属性</span><br>		<span class="hljs-keyword">for</span> (Field field : declaredFields) &#123;<br>			System.out.println(<span class="hljs-string">&quot;本类属性：&quot;</span>+field);<br>		&#125;<br>		System.out.println(<span class="hljs-string">&quot;************************************************&quot;</span>);<br>		Method[] methods = clazz.getMethods();<span class="hljs-comment">//所有公共方法</span><br>		<span class="hljs-keyword">for</span> (Method method : methods) &#123;<br>			System.out.println(<span class="hljs-string">&quot;公共方法&quot;</span>+method);<br>		&#125;<br>		System.out.println(<span class="hljs-string">&quot;************************************************&quot;</span>);<br>		Method[] declaredMethods = clazz.getDeclaredMethods();<span class="hljs-comment">//所有本类方法</span><br>		<span class="hljs-keyword">for</span> (Method method : declaredMethods) &#123;<br>			System.out.println(<span class="hljs-string">&quot;本类方法：&quot;</span>+method);<br>		&#125;<br>	&#125;<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test13</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">try</span> &#123;<br>			Class clazz = Class.forName(<span class="hljs-string">&quot;reflect.Teacher&quot;</span>);<br>			Method lessonMethod = clazz.getDeclaredMethod(<span class="hljs-string">&quot;lesson&quot;</span>, String.class, <span class="hljs-keyword">int</span>.class);<br>			lessonMethod.setAccessible(<span class="hljs-keyword">true</span>);<br>			<br>			Short n = <span class="hljs-number">3</span>;<br>			Object retValue = lessonMethod.invoke(<span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;JavaWEB&quot;</span>, n); <span class="hljs-comment">// 静态方法传null, 不需要传入对象</span><br>			System.out.println(retValue);<br>		&#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (SecurityException e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (IllegalArgumentException e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123;<br>			e.printStackTrace();<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test12</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">try</span> &#123;<br>			Class clazz = Class.forName(<span class="hljs-string">&quot;reflect.Teacher&quot;</span>);<br>			Constructor constructor = clazz.getConstructor(String.class, <span class="hljs-keyword">int</span>.class, String.class);<br>			Object object = constructor.newInstance(<span class="hljs-string">&quot;佟刚&quot;</span>, <span class="hljs-number">40</span>, <span class="hljs-string">&quot;男&quot;</span>);<br>			<br>			<span class="hljs-comment">// getMethod只能获取公共的方法, 包括从父类继承的. </span><br>			<span class="hljs-comment">//Method lessonMethod = clazz.getMethod(&quot;lesson&quot;, String.class, int.class); </span><br>			<br>			<span class="hljs-comment">// getDeclaredMethod可以获取本类中所有声明的方法</span><br>			Method lessonMethod = clazz.getDeclaredMethod(<span class="hljs-string">&quot;lesson&quot;</span>, String.class, <span class="hljs-keyword">int</span>.class);<br>			lessonMethod.setAccessible(<span class="hljs-keyword">true</span>);<br>			<br>			Short n = <span class="hljs-number">3</span>;<br>			Object retValue = lessonMethod.invoke(object, <span class="hljs-string">&quot;JavaWEB&quot;</span>, n); <br>			System.out.println(retValue);<br>			<span class="hljs-comment">/*</span><br><span class="hljs-comment">		    private String outOfBoundsMsg(int index) &#123;</span><br><span class="hljs-comment">		        return &quot;Index: &quot;+index+&quot;, Size: &quot;+size;</span><br><span class="hljs-comment">		    &#125;</span><br><span class="hljs-comment">		    */</span><br>			<span class="hljs-comment">/*</span><br><span class="hljs-comment">			//拿父类的方法，会有警告，最好不要暴力访问私有方法，属性</span><br><span class="hljs-comment">			Method declaredMethod = clazz.getSuperclass().getDeclaredMethod(&quot;outOfBoundsMsg&quot;, int.class);</span><br><span class="hljs-comment">			System.out.println(declaredMethod);</span><br><span class="hljs-comment">			//危险操作</span><br><span class="hljs-comment">			declaredMethod.setAccessible(true);</span><br><span class="hljs-comment">			</span><br><span class="hljs-comment">			Object invoke = declaredMethod.invoke(object, 20);</span><br><span class="hljs-comment">			System.out.println(invoke);</span><br><span class="hljs-comment">			*/</span><br>		&#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123; <span class="hljs-comment">// 类未找到</span><br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123; <span class="hljs-comment">// 方法没有找到, 方法名错误或参数列表错误</span><br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (SecurityException e) &#123; <span class="hljs-comment">// 安全异常</span><br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (InstantiationException e) &#123; <span class="hljs-comment">// 创建对象时出现异常</span><br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123; <span class="hljs-comment">// 非法访问异常</span><br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (IllegalArgumentException e) &#123; <span class="hljs-comment">// 非法实参异常, 实参和形参不匹配, 类型和顺序和数量</span><br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123; <span class="hljs-comment">// 调用的目标方法内部出现异常了.</span><br>			e.printStackTrace();<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test11</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">try</span> &#123;<br>			Class clazz = Class.forName(<span class="hljs-string">&quot;reflect.Teacher&quot;</span>);<br>			Constructor constructor = clazz.getConstructor(String.class, <span class="hljs-keyword">int</span>.class, String.class);<br>			Object object = constructor.newInstance(<span class="hljs-string">&quot;佟刚&quot;</span>, <span class="hljs-number">40</span>, <span class="hljs-string">&quot;男&quot;</span>);<br>			<br>			<span class="hljs-comment">//object.lesson(&quot;JavaWEB&quot;, 3);</span><br>			<span class="hljs-comment">//先获取方法</span><br>			<br>			Method lessonMethod = clazz.getMethod(<span class="hljs-string">&quot;lesson&quot;</span>, String.class, <span class="hljs-keyword">int</span>.class); <span class="hljs-comment">// 后面是方法参数类型列表</span><br>			<span class="hljs-keyword">short</span> n = <span class="hljs-number">3</span>;<br>			Object retValue = lessonMethod.invoke(object, <span class="hljs-string">&quot;JavaWEB&quot;</span>, n); <span class="hljs-comment">// 后面是实参列表, 如果方法没有返回值, 它的返回值是null</span><br>			System.out.println(retValue);<br>		&#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123; <span class="hljs-comment">// 类未找到</span><br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123; <span class="hljs-comment">// 方法没有找到, 方法名错误或参数列表错误</span><br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (SecurityException e) &#123; <span class="hljs-comment">// 安全异常</span><br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (InstantiationException e) &#123; <span class="hljs-comment">// 创建对象时出现异常</span><br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123; <span class="hljs-comment">// 非法访问异常</span><br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (IllegalArgumentException e) &#123; <span class="hljs-comment">// 非法实参异常, 实参和形参不匹配, 类型和顺序和数量</span><br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123; <span class="hljs-comment">// 调用的目标方法内部出现异常了.</span><br>			e.printStackTrace();<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test10</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">try</span> &#123;<br>			Class clazz = Class.forName(<span class="hljs-string">&quot;reflect.Teacher&quot;</span>);<br>			<span class="hljs-comment">//Object object = clazz.newInstance(); 没有无参构造器时出问题</span><br>			<br>			<span class="hljs-comment">//public Teacher(String name, int age, String gender) 要想定位这个构造器, 必须让参数列表一致.</span><br>			<br>			<span class="hljs-comment">// 提供形式参数类型列表, 是类模板对象的列表</span><br>			Constructor constructor = clazz.getConstructor(String.class, <span class="hljs-keyword">int</span>.class, String.class); <span class="hljs-comment">// 定位合适的构造器</span><br>			<span class="hljs-comment">// 调用时必须给定实参列表</span><br>			Object object = constructor.newInstance(<span class="hljs-string">&quot;程程&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&quot;女&quot;</span>); <span class="hljs-comment">// new Teacher(&quot;程程&quot;, 20, &quot;女&quot;);</span><br>			System.out.println(object);<br>			<br>		&#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (InstantiationException e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123; <span class="hljs-comment">// 参数列表出错, 或者方法名出错</span><br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (SecurityException e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (IllegalArgumentException e) &#123; <span class="hljs-comment">// 方法调用时实参和形参不匹配</span><br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123;<br>			e.printStackTrace();<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test9</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException  </span>&#123;<br>		<span class="hljs-comment">//FileInputStream fis = new FileInputStream(&quot;只能读当前目录下的文件&quot;);</span><br>		ClassLoader classLoader = <span class="hljs-keyword">this</span>.getClass().getClassLoader();<br>		<span class="hljs-comment">// 只能加载build-path和src下的文件</span><br>		<span class="hljs-comment">//InputStream inputStream = classLoader.getResourceAsStream(&quot;com/sun/corba/se/impl/logging/LogStrings.properties&quot;); // 读取资源文件, 只要是Build-Path(classpath)中的文件都可以</span><br>		InputStream inputStream = classLoader.getResourceAsStream(<span class="hljs-string">&quot;s2&quot;</span>);<br>		Properties properties = <span class="hljs-keyword">new</span> Properties();<br>		properties.load(inputStream);<br>		<br>		Set&lt;Entry&lt;Object, Object&gt;&gt; entrySet = properties.entrySet();<br>		<span class="hljs-keyword">for</span> (Entry&lt;Object, Object&gt; entry : entrySet) &#123;<br>			System.out.println(entry);<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test8</span><span class="hljs-params">()</span>  </span>&#123;<br>		ClassLoader classLoader1 = ClassLoader.getSystemClassLoader(); <span class="hljs-comment">// 获取系统类加载器</span><br>		System.out.println(classLoader1);<br>		ClassLoader classLoader2 = <span class="hljs-keyword">this</span>.getClass().getClassLoader(); <span class="hljs-comment">// 使用最多的, 获取当前类的类加载器</span><br>		System.out.println(classLoader2);<br>		<br>		ClassLoader classLoader3 = classLoader1.getParent(); <span class="hljs-comment">// 获取父 &quot;类加载器&quot;,  是 扩展 &quot;类加载器&quot;</span><br>		System.out.println(classLoader3);<br>		<br>		ClassLoader classLoader4 = classLoader3.getParent(); <span class="hljs-comment">// 获取到的是引导类加载器(Bootstrap )</span><br>		System.out.println(classLoader4); <span class="hljs-comment">// 这个类加载器无法获取, 无法使用</span><br>		<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		双亲委派机制</span><br><span class="hljs-comment">		用户类加载器加载类时, 必须把此加载请求转发给父类加载器, 父类加载器再继续向父类加载器委派, 直到Bootstrap类加载器</span><br><span class="hljs-comment">		从Bootstrap类加载器开始真正加载, 各司其职. </span><br><span class="hljs-comment">		*/</span><br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test7</span><span class="hljs-params">()</span>  </span>&#123;<br>		Class strClazz = String.class;<br>		System.out.println(strClazz);<br>		<br>		<span class="hljs-comment">// 基本数据类型的类模板只能用第一种方式获取.</span><br>		Class clazz1 = <span class="hljs-keyword">int</span>.class; <span class="hljs-comment">// 基本数据类型也有相应的类模板对象, 但是不能获取属性和方法, 只能作为一个标记来使用.</span><br>		Class clazz2 = Integer.class; <span class="hljs-comment">// 这是一个普通类模板.</span><br>		System.out.println(clazz1 == clazz2);<br>		<br>		<span class="hljs-comment">// 判断类模板类型</span><br>		System.out.println(<span class="hljs-string">&quot;是否是基本型 : &quot;</span> + clazz1.isPrimitive());<br>		System.out.println(<span class="hljs-string">&quot;是否是基本型 : &quot;</span> + clazz2.isPrimitive());<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test6</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>		<span class="hljs-comment">// 获取类模板对象的方法 ，有４种</span><br>		<span class="hljs-comment">// 1) 直接通过类.class, 效率最高, 最安全.</span><br>		Class clazz1 = Teacher.class;<br>		<br>		<span class="hljs-comment">// 2) 根据对象, 调用它的getClass()方法获取, 此方法也很常用.</span><br>		Teacher teacher = <span class="hljs-keyword">new</span> Teacher(<span class="hljs-string">&quot;佟刚&quot;</span>, <span class="hljs-number">40</span>, <span class="hljs-string">&quot;男&quot;</span>);<br>		Class clazz2 = teacher.getClass();<br>		<br>		System.out.println(clazz1 == clazz2);<br>		<br>		<span class="hljs-comment">// 3) 反射中最常用的 Class.forName(&quot;全限定类名&quot;);</span><br>		Class clazz3 = Class.forName(<span class="hljs-string">&quot;reflect.Teacher&quot;</span>);<br>		System.out.println(clazz2 == clazz3);<br>		<br>		<span class="hljs-comment">// 4) 通过类加载器对象动态加载类</span><br>		ClassLoader classLoader = <span class="hljs-keyword">this</span>.getClass().getClassLoader();<br>		Class clazz4 = classLoader.loadClass(<span class="hljs-string">&quot;reflect.Teacher&quot;</span>);<br>		System.out.println(clazz3 == clazz4);<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>		Class clazz = Class.forName(<span class="hljs-string">&quot;reflect.Teacher&quot;</span>);<br>		String name = clazz.getName();<br>		System.out.println(<span class="hljs-string">&quot;类名 : &quot;</span> + name);<br>		System.out.println(<span class="hljs-string">&quot;简单类名 :  &quot;</span> + clazz.getSimpleName());<br>		Class superclass = clazz.getSuperclass();<br>		System.out.println(<span class="hljs-string">&quot;父类 : &quot;</span> + superclass);<br>		Class[] interfaces = clazz.getInterfaces();<br>		System.out.println(<span class="hljs-string">&quot;接口列表 &quot;</span>);<br>		<span class="hljs-keyword">for</span> (Class class1 : interfaces) &#123;<br>			System.out.println(class1);<br>		&#125;<br>		<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">try</span> &#123;<br>			Class clazz = Class.forName(<span class="hljs-string">&quot;reflect.Teacher&quot;</span>);<br>			Object object = clazz.newInstance();<br>			System.out.println(object);<br>			<br>			<span class="hljs-comment">//Field ageField = clazz.getField(&quot;age&quot;); // getField方法只能获取公共的属性, 也包括从父类继承的属性, 不可以获取私有属性</span><br>			Field ageField = clazz.getDeclaredField(<span class="hljs-string">&quot;age&quot;</span>); <span class="hljs-comment">// 获取本类中声明的任意属性 </span><br>			<span class="hljs-comment">// 暴力反射!!! 不推荐使用!!</span><br>			ageField.setAccessible(<span class="hljs-keyword">true</span>); <span class="hljs-comment">// 设置此属性为可访问的.</span><br>			ageField.set(object, <span class="hljs-number">40</span>); <br>			System.out.println(ageField.get(object)); <br>			<br>			Field nameField = clazz.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>			nameField.setAccessible(<span class="hljs-keyword">true</span>);<br>			nameField.set(object, <span class="hljs-string">&quot;佟刚&quot;</span>);<br>			<br>			System.out.println(object);<br>		&#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (InstantiationException e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123; <span class="hljs-comment">// 查找属性时, 有可能属性名不对, 可能是属性不存在</span><br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (SecurityException e) &#123; <span class="hljs-comment">// 如果有安全检查.</span><br>			e.printStackTrace();<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">try</span> &#123;<br>			Class clazz = Class.forName(<span class="hljs-string">&quot;reflect.Teacher&quot;</span>);<br>			Object object = clazz.newInstance();<br>			System.out.println(object);<br>			<br>			<span class="hljs-comment">// 要想使用属性, 1)先获取属性定义对象 2) 配合目标this对象完成对象属性的间接访问.</span><br>			Field ageField = clazz.getField(<span class="hljs-string">&quot;age&quot;</span>); <span class="hljs-comment">// 根据属性名获取属性的定义对象</span><br>			ageField.set(object, <span class="hljs-number">40</span>); <span class="hljs-comment">// 设置属性值, 相当于 object.age = 40; </span><br>			System.out.println(ageField.get(object)); <span class="hljs-comment">// 获取属性值,  相当于 System.out.println(object.age)</span><br>			<br>			Field nameField = clazz.getField(<span class="hljs-string">&quot;name&quot;</span>);<br>			nameField.set(object, <span class="hljs-string">&quot;佟刚&quot;</span>); <span class="hljs-comment">// object.name = &quot;佟刚&quot;</span><br>			<br>			Field genderField = clazz.getField(<span class="hljs-string">&quot;gender&quot;</span>);<br>			genderField.set(object, <span class="hljs-string">&quot;男&quot;</span>);<br>			<br>			System.out.println(object);<br>		&#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (InstantiationException e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123; <span class="hljs-comment">// 查找属性时, 有可能属性名不对, 可能是属性不存在</span><br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (SecurityException e) &#123; <span class="hljs-comment">// 如果有安全检查.</span><br>			e.printStackTrace();<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 软编码, 灵活, 把问题延迟到运行时.</span><br>		<span class="hljs-keyword">try</span> &#123;<br>			<span class="hljs-comment">// 干预类的加载, 直接获取类模板对象.</span><br>			Class clazz = Class.forName(<span class="hljs-string">&quot;reflect.Teacher&quot;</span>); <span class="hljs-comment">// 类名必须全限定!!!</span><br>			<span class="hljs-comment">// 通过类模板对象.newInstance创建实体对象</span><br>			Object object = clazz.newInstance(); <span class="hljs-comment">// 调用无参构造器创建对象</span><br>			System.out.println(object);<br>		&#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123; <span class="hljs-comment">// 在运行时动态加载类时, 发现没有找到类</span><br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (InstantiationException e) &#123; <span class="hljs-comment">// 在创建对象时出现异常, 可能是构造器不存在</span><br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123; <span class="hljs-comment">// 非法访问, 访问权限不够时出现</span><br>			e.printStackTrace();<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 编译时必须依赖类, 硬编码</span><br>		<br>		<span class="hljs-comment">//Teacher t1 = new Teacher(); // 强烈依赖类</span><br>		<span class="hljs-comment">//t1.name = &quot;佟刚&quot;;</span><br>		<span class="hljs-comment">//t1.age = 40;</span><br>		<span class="hljs-comment">//t1.gender = &quot;男&quot;;</span><br>		<br>		<span class="hljs-comment">//System.out.println(t1.name);</span><br>		<span class="hljs-comment">//System.out.println(t1.age);</span><br>		<span class="hljs-comment">//System.out.println(t1.gender);</span><br>		<br>		<span class="hljs-comment">//System.out.println(t1);</span><br>		<br>		Teacher t2 = <span class="hljs-keyword">new</span> Teacher(<span class="hljs-string">&quot;程程&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&quot;女&quot;</span>);<br>		System.out.println(t2);<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test0</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">// 测试方法所在的线程永远是守护线程</span><br>	&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-comment">// 守护线程, setDaemon(true); 此方法必须在start()以前调用.</span><br>		<span class="hljs-comment">// 主线程永远是用户线程</span><br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>Java杂记</title>
    <url>/2021/04/14/Java%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Java杂记"><a href="#Java杂记" class="headerlink" title="Java杂记"></a>Java杂记</h1><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul>
<li><h3 id="异常定义"><a href="#异常定义" class="headerlink" title="异常定义"></a>异常定义</h3></li>
<li>程序在运行时有可能出现的非正常状况，会导致程序崩溃 </li>
<li><h3 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h3></li>
<li><h4 id="按程度分："><a href="#按程度分：" class="headerlink" title="按程度分："></a>按程度分：</h4></li>
<li>Error：虚拟机都无法处理的错误状况</li>
<li>Exception：一般性的问题     </li>
<li><h4 id="按照处理方式为分："><a href="#按照处理方式为分：" class="headerlink" title="按照处理方式为分："></a>按照处理方式为分：</h4></li>
<li>受检异常，在程序中必须对其进行处理的异常，如果不处理，编译出错</li>
<li>Exception及其子类，RuntimeException及其子类除外：问题程序不容忽视         </li>
<li>非受检异常 在程序中不是必须对其进行处理的异常</li>
<li>Error及其子类：太严重了 </li>
<li>RuntimeException及其子类：太轻微了</li>
<li><h3 id="异常处理："><a href="#异常处理：" class="headerlink" title="异常处理："></a>异常处理：</h3></li>
<li><h3 id="1）捕获-try-catch-try-可能抛出异常的语句-catch-可能的异常类型-引用-通过异常处理异常对象"><a href="#1）捕获-try-catch-try-可能抛出异常的语句-catch-可能的异常类型-引用-通过异常处理异常对象" class="headerlink" title="1）捕获 try catch try{ 可能抛出异常的语句 }catch(可能的异常类型 引用){ 通过异常处理异常对象 }"></a>1）捕获 try catch try{ 可能抛出异常的语句 }catch(可能的异常类型 引用){ 通过异常处理异常对象 }</h3></li>
<li><h3 id="2）异常抛出-在方法中使用throw异常对象，方法一旦执行了throw和执行return效果是一样的，都会导致方法结束"><a href="#2）异常抛出-在方法中使用throw异常对象，方法一旦执行了throw和执行return效果是一样的，都会导致方法结束" class="headerlink" title="2）异常抛出 在方法中使用throw异常对象，方法一旦执行了throw和执行return效果是一样的，都会导致方法结束"></a>2）异常抛出 在方法中使用throw异常对象，方法一旦执行了throw和执行return效果是一样的，都会导致方法结束</h3></li>
<li>return时正常结束返回，throw时异常结束返回 </li>
<li>在签名中使用throws，可能的异常类型列表，警告调用者，调用此方法有风险，请考虑清楚</li>
<li>方法中的throw作用是真的产生破环</li>
<li><h3 id="3）先捕获再抛出"><a href="#3）先捕获再抛出" class="headerlink" title="3）先捕获再抛出"></a>3）先捕获再抛出</h3></li>
<li>在方法中先尝试执行某代码，如果真的出现了异常，再把这个异常关联到自定义异常对象中，再抛出自定义异常对象       </li>
<li>异常处理的选择：</li>
<li>入口方法尽量捕获（这个方法出问题会不会影响栈）</li>
<li>普通方法尽量抛出</li>
<li>如果代码中有潜在风险，尽量先捕再抛</li>
<li>如果代码中没有风险，但是有时不满足方法继续的条件时，直接抛出<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2></li>
<li>volatile :提醒子线程，此主存中的属性不要制作副本…</li>
</ul>
<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="冒泡排序："><a href="#冒泡排序：" class="headerlink" title="* 冒泡排序："></a>* 冒泡排序：</h3> <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">int</span>[] arr=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.length;i++) &#123;<br>	arr[i]=(<span class="hljs-keyword">int</span>)(Math.random()*<span class="hljs-number">20</span>);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> tmp:arr) &#123;<br>System.out.print(tmp+<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br>System.out.println();<br><span class="hljs-comment">//冒泡排序</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.length-<span class="hljs-number">1</span>;i++) &#123;<span class="hljs-comment">//控制趟数</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;arr.length-<span class="hljs-number">1</span>-i;j++) &#123;<span class="hljs-comment">//控制每一趟的交换次数，应该随着外循环的增加而减少</span><br>		<span class="hljs-keyword">if</span>(arr[j]&gt;arr[j+<span class="hljs-number">1</span>]) &#123;<span class="hljs-comment">//比较相邻元素，满足条件，则交换.</span><br>			<span class="hljs-keyword">int</span> tmp=arr[j];<br>			arr[j]=arr[j+<span class="hljs-number">1</span>];<br>			arr[j+<span class="hljs-number">1</span>]=tmp;<br>		&#125;<br>	&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> tmp:arr) &#123;<br>System.out.print(tmp+<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br>System.out.println();<br></code></pre></td></tr></table></figure>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="* 选择排序"></a>* 选择排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">int</span>[] arr1=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;arr1.length;i++) &#123;<br>	arr1[i]=(<span class="hljs-keyword">int</span>)(Math.random()*<span class="hljs-number">20</span>);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> tmp:arr1) &#123;<br>System.out.print(tmp+<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br>System.out.println();<br><span class="hljs-comment">//选择排序</span><br><span class="hljs-keyword">int</span> minindex;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;arr1.length-<span class="hljs-number">1</span>;i++) &#123;<span class="hljs-comment">//从0开始到倒数第二个位置</span><br>	minindex=i;<span class="hljs-comment">//最小下标先默认等于i</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;arr1.length;j++) &#123;<span class="hljs-comment">//遍历从i+1开始到数组长度的所有数</span><br>		<span class="hljs-keyword">if</span>(arr1[j]&lt;arr1[minindex]) &#123;<span class="hljs-comment">//找最小值</span><br>			minindex=j;<span class="hljs-comment">//更新最小下标</span><br>		&#125;<br>	&#125;<br>	<span class="hljs-comment">//交换元素，实现最小值赋值到基准位置i</span><br>	<span class="hljs-keyword">int</span> tmp=arr1[i];<br>	arr1[i]=arr1[minindex];<br>	arr1[minindex]=tmp;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> tmp:arr1) &#123;<br>System.out.print(tmp+<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br>System.out.println();<br></code></pre></td></tr></table></figure>

<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="* 快速排序"></a>* 快速排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuickSort</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quick</span><span class="hljs-params">(<span class="hljs-keyword">int</span> []arr,<span class="hljs-keyword">int</span> begin,<span class="hljs-keyword">int</span> end)</span> </span>&#123;<span class="hljs-comment">//结束索引不包含</span><br>		<span class="hljs-keyword">if</span>(end-begin&lt;=<span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//递归结束条件</span><br>			<span class="hljs-keyword">return</span>;<br>		&#125;<br>		<span class="hljs-comment">//分区，分三个部分，中间是键，左边比键小，右边比键大</span><br>		<span class="hljs-comment">//定位索引最关键</span><br>		<span class="hljs-keyword">int</span> key=arr[begin];<span class="hljs-comment">//总是取第一个元素为键值</span><br>		<span class="hljs-keyword">int</span> keyIndex=begin;<span class="hljs-comment">// 键索引值，用于动态保存比键值小的值的索引</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=begin+<span class="hljs-number">1</span>;i&lt;end;i++) &#123;<br>			<span class="hljs-keyword">if</span>(arr[i]&lt;key) &#123;<br>				keyIndex++;<span class="hljs-comment">//只要找到比key小的数据，keyIndex就往右移</span><br>				<span class="hljs-comment">//交换下标为keyIndex和i位置的数据</span><br>				<span class="hljs-keyword">int</span> tmp=arr[keyIndex];<br>				arr[keyIndex]=arr[i];<span class="hljs-comment">//保证比键小的值在键的右面依次保存</span><br>				arr[i]=tmp;<br>			&#125;<br>		&#125;<br>		<span class="hljs-comment">//让键值归为到keyIndex位置处</span><br>		arr[begin]=arr[keyIndex];<br>		arr[keyIndex]=key;<br>		<span class="hljs-comment">//左子列递归</span><br>		quick(arr,begin,keyIndex-<span class="hljs-number">1</span>);<br>		<span class="hljs-comment">//右子列递归</span><br>		 quick(arr,keyIndex+<span class="hljs-number">1</span>,end);<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-keyword">int</span>[] arr=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.length;i++) &#123;<br>			arr[i]=(<span class="hljs-keyword">int</span>)(Math.random()*<span class="hljs-number">20</span>);<br>		&#125;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> tmp:arr) &#123;<br>		System.out.print(tmp+<span class="hljs-string">&quot; &quot;</span>);<br>		&#125;<br>		System.out.println();<br>		quick(arr,<span class="hljs-number">0</span>,arr.length);<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> tmp:arr) &#123;<br>		System.out.print(tmp+<span class="hljs-string">&quot; &quot;</span>);<br>		&#125;<br>		System.out.println();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-keyword">import</span> javax.lang.model.element.Element;<br><br><span class="hljs-keyword">import</span> jdk.jfr.Registered;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 注解的处理只能通过反射，要想反射，必须使用元注解<span class="hljs-doctag">@Retention</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Hasee</span><br><span class="hljs-comment"> *注解：是一种特殊的注释，不参与程序的执行，特殊之处在于编译器和JVM都可以识别它.</span><br><span class="hljs-comment"> *<span class="hljs-doctag">@Override</span> 作用是告诉编译器，它修饰的方法要完成方法覆盖，请帮助做条件检查，只能修饰方法</span><br><span class="hljs-comment"> *<span class="hljs-doctag">@Deprecated</span> 作用是警告使用者，它修饰的目标过期了，可以修饰类，属性，方法，构造器，形参，局部变量</span><br><span class="hljs-comment"> *<span class="hljs-doctag">@SuppressWarnings</span> 作用是抑制编译器警告，并且可以传递参数，参数可以是一个值也可以是一个数组</span><br><span class="hljs-comment"> *注解：</span><br><span class="hljs-comment"> *1）没有属性的，称为标记型注解</span><br><span class="hljs-comment"> *2）有属性的，可以进一步传递数据</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-comment">//自定义注解,默认可以修饰类，属性，构造器，方法，形参，局部变量</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-comment">//只有注解的停留期定义在运行时才可以被反射</span><br><span class="hljs-meta">@interface</span> MyAnnotation&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">int</span> <span class="hljs-title">id</span><span class="hljs-params">()</span><span class="hljs-keyword">default</span> 10</span>;<br>	<span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;我是缺省值&quot;</span>;<span class="hljs-comment">//可以有缺省值</span><br>	<span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;qaq&quot;</span>;<span class="hljs-comment">//当属性名为value()时可以省略属性名</span><br>&#125;<br><span class="hljs-meta">@MyAnnotation(id = 0, name = &quot;sda&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>	<span class="hljs-keyword">private</span> String name;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>	<span class="hljs-keyword">private</span> String gender;<br>	<span class="hljs-meta">@SuppressWarnings(&quot;unused&quot;)</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span> </span>&#123;<br><br>	&#125;<br>	<span class="hljs-meta">@MyAnnotation</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, String gender)</span> </span>&#123;<br>		<span class="hljs-keyword">super</span>();<br>		<span class="hljs-keyword">this</span>.name = name;<br>		<span class="hljs-keyword">this</span>.age = age;<br>		<span class="hljs-keyword">this</span>.gender = gender;<br>	&#125;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person [name=&quot;</span> + name + <span class="hljs-string">&quot;, age=&quot;</span> + age + <span class="hljs-string">&quot;, gender=&quot;</span> + gender + <span class="hljs-string">&quot;]&quot;</span>;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> name;<br>	&#125;<br>	<span class="hljs-meta">@MyAnnotation(&quot;aqa&quot;)</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.name = name;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> age;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.age = age;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getGender</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> gender;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setGender</span><span class="hljs-params">(String gender)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.gender = gender;<br>	&#125;<br>	<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnnotationTest</span> </span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="路径问题："><a href="#路径问题：" class="headerlink" title="路径问题："></a>路径问题：</h2><blockquote>
<ul>
<li>绝对路径：以根目录为开始的路径</li>
<li>相对路径：以当前目录未开始的路径（./）</li>
</ul>
</blockquote>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 泛型要解决类型安全问题</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&lt;<span class="hljs-title">X</span>&gt; </span>&#123; <span class="hljs-comment">// X表示某种类型, X在这里称为泛型的类型参数(是一个形参)</span><br>	<span class="hljs-comment">// X类型的真实类型会在创建对象时确定下来, 隶属于对象的存在而存在.</span><br>	<br>	<span class="hljs-keyword">private</span> String name;<br>	<span class="hljs-keyword">private</span> X info;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span> </span>&#123;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, X info)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.name = name;<br>		<span class="hljs-keyword">this</span>.info = info;<br>	&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> X <span class="hljs-title">getInfo</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> info;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setInfo</span><span class="hljs-params">(X info)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.info = info;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> name;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.name = name;<br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person [name=&quot;</span> + name + <span class="hljs-string">&quot;, info=&quot;</span> + info + <span class="hljs-string">&quot;]&quot;</span>;<br>	&#125;<br>	<br>	<span class="hljs-comment">//在静态方法中不可以使用泛型类中的泛型</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(X x)</span> </span>&#123;<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">// 泛型和继承之间的关系</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&lt;<span class="hljs-title">Y</span>&gt; </span>&#123;<br>	<span class="hljs-keyword">private</span> Y y;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> Y <span class="hljs-title">getY</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> y;<br>	&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;&#125; <span class="hljs-comment">// 子类中没有处理父类的泛型. 泛型类型就是类型最模糊的Object, 这种不好</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;&#125; <span class="hljs-comment">// 子类在继承时把父类的泛型写死了 ,  这是最简单</span><br><span class="hljs-comment">//class B3 extends A&lt;Teacher&gt; &#123;&#125; // 在创建子类对象后, 其泛型是固定的.</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B4</span>&lt;<span class="hljs-title">Y</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span>&lt;<span class="hljs-title">Y</span>&gt; </span>&#123;&#125; <span class="hljs-comment">// 子类在继承时仍然继续泛型, 这是最灵活</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericMethod</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(T t)</span> </span>&#123;<br>	&#125;<br>	<br>	<span class="hljs-comment">//public Object get(Object obj) &#123;</span><br>	<span class="hljs-comment">// 泛型方法中必须传入泛型类型的参数, 如果不传泛型永远无法确定.</span><br>	<span class="hljs-comment">// 这个泛型类型由实参的类型来决定, 所以它是和方法的某次调用相关</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-function">E <span class="hljs-title">get</span><span class="hljs-params">(E e)</span> </span>&#123; <span class="hljs-comment">// E表示只可以在此方法中使用的某种类型</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>	&#125;<br>	<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericTest</span> </span>&#123;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">//Object object = GenericMethod.get();</span><br>		String string = GenericMethod.get(<span class="hljs-string">&quot;abc&quot;</span>); <span class="hljs-comment">// 泛型方法必须通过实参来告诉方法, 泛型的具体类型是什么</span><br>		Integer integer = GenericMethod.get(<span class="hljs-number">200</span>);<br>		Boolean boolean1 = GenericMethod.get(<span class="hljs-keyword">false</span>);<br>		Object object = GenericMethod.get(<span class="hljs-keyword">null</span>); <span class="hljs-comment">// 如果实参是null, 将会导致泛型类型无法感知!!! </span><br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>&#123;<br>		B1 b1 = <span class="hljs-keyword">new</span> B1();<br>		Object y = b1.getY();<br>		<br>		Integer y2 = <span class="hljs-keyword">new</span> B2().getY();<br>		Integer y3 = <span class="hljs-keyword">new</span> B2().getY();<br>		<br>		<span class="hljs-comment">//Teacher y4 = new B3().getY();</span><br>		<br>		B4 b4 = <span class="hljs-keyword">new</span> B4();<br>		Object y5 = b4.getY();<br>		Double y6 = <span class="hljs-keyword">new</span> B4&lt;Double&gt;().getY();<br>		String y7 = <span class="hljs-keyword">new</span> B4&lt;String&gt;().getY();<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;<br>		Person&lt;Integer&gt; person1 = <span class="hljs-keyword">new</span> Person&lt;Integer&gt;(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">20</span>); <span class="hljs-comment">// 使用了泛型后, 类型就安全了.</span><br>		Integer info1 = person1.getInfo(); <span class="hljs-comment">// 获取到的属性也安全了, 清晰了.</span><br>		<br>		Person&lt;Boolean&gt; person2 = <span class="hljs-keyword">new</span> Person&lt;Boolean&gt;(<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-keyword">true</span>);<br>		Boolean info2 = person2.getInfo();<br>		<br>		Person person3 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;王五&quot;</span>, <span class="hljs-number">3.22</span>);<br>		Object info3 = person3.getInfo();<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br>		Person person1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">30</span>);<br>		Object info1 = person1.getInfo();<br>		<br>		Person person2 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;女&quot;</span>);<br>		Object info2 = person2.getInfo();<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br>		List list1 = <span class="hljs-keyword">new</span> ArrayList();<br>		list1.add(<span class="hljs-number">1</span>);<br>		list1.add(<span class="hljs-string">&quot;abc&quot;</span>);<br>		<br>		Object object = list1.get(<span class="hljs-number">0</span>);<br>		<br>		List&lt;Integer&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>		list2.add(<span class="hljs-number">3</span>);<br>		<span class="hljs-comment">//list2.add(&quot;abc&quot;);</span><br>		<br>		List&lt;Object&gt; list3 = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;();<br>	&#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> collection;<br><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 	Collection 集合 : 保存一个一个的对象, 特点 : 无序可重复</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 		Set 特点 : 无序不可重复</span><br><span class="hljs-comment"> * 			HashSet : 基于数组使用哈希算法实现的Set集合, 判定重复的标准是两个对象的equals为true, 并且两个对象的hashCode一样</span><br><span class="hljs-comment"> * 				优点 : 全是优点</span><br><span class="hljs-comment"> * 				缺点 : 对内存要求高</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 			TreeSet : 基于二叉搜索树(红黑树)实现的Set集合, 判定重复的标准是两个对象的比较结果为0</span><br><span class="hljs-comment"> * 				优点 : 对内存要求低, 搜索速度快</span><br><span class="hljs-comment"> * 				缺点 : 插入和删除的速度慢，大量元素的比较和树的旋转</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 		List : 特点 : 有序可重复</span><br><span class="hljs-comment"> * 			ArrayList : 基于数组实现的List集合, 线程不安全.</span><br><span class="hljs-comment"> * 				缺点 : 对内存要求高, 因为内存必须连续, 非末端数据的插入和删除都是最慢的, 因为有大量元素的移动.</span><br><span class="hljs-comment"> * 				优点 : 末端插入删除速度快</span><br><span class="hljs-comment"> * 				适用场景 : 存档数据, 主要用于查询检索</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 			Vector : 和ArrayList一样, 是一个古老的实现. 但是线程安全</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 			LinkedList : 基于链表实现的List集合</span><br><span class="hljs-comment"> * 				优点 : 对内存要求低. 插入,删除速度非常快</span><br><span class="hljs-comment"> * 				缺点 : 检索速度慢,</span><br><span class="hljs-comment"> * 				适用场景 : 频繁修改数据, 很少检索</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> *	泛型 : 类型安全问题, 在集合中使用泛型的好处是约束中的元素的数据类型, 类型可以是确定的, 不再是类型最模糊的Object</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *	遍历 : 增强for</span><br><span class="hljs-comment"> *			for (元素数据类型 临时变量 : 集合) &#123;</span><br><span class="hljs-comment"> *			&#125;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *		  迭代器 Iterator</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> 	必须从集合对象获取迭代器</span><br><span class="hljs-comment"> 	while (迭代器.hasNext()) &#123;</span><br><span class="hljs-comment"> 		元素 = 迭代器.next();</span><br><span class="hljs-comment"> 		处理元素;</span><br><span class="hljs-comment"> 	&#125;</span><br><span class="hljs-comment"> 	</span><br><span class="hljs-comment"> 	Map集合 : 保存的是一对一对的对象. 是具有映射关系的键值对象, 键值对象都可以是任意对象. 键到值是单向一对一映射.</span><br><span class="hljs-comment"> 	Map可以简单地看作是一个词典, 键是词条, 值是解释.</span><br><span class="hljs-comment"> 		Object put(Object key, Object value); //写入条目</span><br><span class="hljs-comment"> 		Object remove(Object key); // 根据键删除 一个条目</span><br><span class="hljs-comment"> 		Object get(Object key); // 根据键查找值, 查词典</span><br><span class="hljs-comment"> 		Set keySet(); // 获取一个保存所有键对象的Set子集合</span><br><span class="hljs-comment"> 		Set entrySet(); // 获取保存所有条件对象的Set集合</span><br><span class="hljs-comment"> 		int size() ; 条目个数</span><br><span class="hljs-comment"> 		</span><br><span class="hljs-comment"> 		</span><br><span class="hljs-comment"> 		HashMap 是典型实现, 使用哈希算法实现的Map集合</span><br><span class="hljs-comment"> 		TreeMap 是基于二叉树实现的Map集合</span><br><span class="hljs-comment"> 		Hashtable 是古老的实现, 和HashMap一样, 它是线程安全, 效率低.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span></span>&#123;<br>	<span class="hljs-keyword">private</span> String name;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> weight;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dog</span><span class="hljs-params">()</span> </span>&#123;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> name;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.name = name;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> age;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.age = age;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getWeight</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> weight;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setWeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> weight)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.weight = weight;<br>	&#125;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Dog [name=&quot;</span> + name + <span class="hljs-string">&quot;, age=&quot;</span> + age + <span class="hljs-string">&quot;, weight=&quot;</span> + weight + <span class="hljs-string">&quot;]&quot;</span>;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dog</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, <span class="hljs-keyword">int</span> weight)</span> </span>&#123;<br>		<span class="hljs-keyword">super</span>();<br>		<span class="hljs-keyword">this</span>.name = name;<br>		<span class="hljs-keyword">this</span>.age = age;<br>		<span class="hljs-keyword">this</span>.weight = weight;<br>	&#125;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>		<span class="hljs-keyword">if</span>(o <span class="hljs-keyword">instanceof</span> Dog) &#123;<br>		<span class="hljs-keyword">return</span> ((Dog)o).age-<span class="hljs-keyword">this</span>.age;<br>		&#125;<br>		<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;对象不可比&quot;</span>);<br>	&#125;<br>	 <br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollectionTest</span> </span>&#123;<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br>		<br>	&#125;<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br>		Set set=<span class="hljs-keyword">new</span> TreeSet();<br>		Dog dog1=<span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&quot;小白&quot;</span>, <span class="hljs-number">5</span>, <span class="hljs-number">25</span>);<br>		Dog dog2=<span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&quot;小黄&quot;</span>, <span class="hljs-number">6</span>, <span class="hljs-number">50</span>);<br>		Dog dog3=<span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&quot;小黑&quot;</span>, <span class="hljs-number">4</span>, <span class="hljs-number">30</span>);<br>		Dog dog4=<span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&quot;狗蛋&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">10</span>);<br>		set.add(dog1);<br>		set.add(dog2);<br>		set.add(dog3);<br>		set.add(dog4);<br>		<br>		<span class="hljs-keyword">for</span> (Object object : set) &#123;<br>			System.out.println(object);<br>		&#125;<br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> date;<br><br><span class="hljs-keyword">import</span> java.text.ParseException;<br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><span class="hljs-keyword">import</span> java.time.LocalDate;<br><span class="hljs-keyword">import</span> java.time.LocalDateTime;<br><span class="hljs-keyword">import</span> java.time.LocalTime;<br><span class="hljs-keyword">import</span> java.time.format.DateTimeFormatter;<br><span class="hljs-keyword">import</span> java.util.Calendar;<br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * LocalDate,LocalTime,LocalDateTime Java8中新提供的处理时间的类</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DateTest</span> </span>&#123;<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test6</span><span class="hljs-params">()</span> </span>&#123;<br>		LocalDateTime of = LocalDateTime.of(<span class="hljs-number">2000</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>,<span class="hljs-number">1</span>);<br>		System.out.println(of);<br>		DateTimeFormatter dtf = DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy年MM月dd天&quot;</span>);<br>		System.out.println(dtf.format(of));<br>	&#125;<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span> </span>&#123;<br>		LocalTime time=LocalTime.now();<br>		System.out.println(time);<br>		LocalDateTime now = LocalDateTime.now();<br>		System.out.println(now);<br>		DateTimeFormatter dtf = DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>		System.out.println(dtf.format(now));<br>	&#125;<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>&#123;<br>		String str1 = <span class="hljs-string">&quot;abcwerthelloyuiodef &quot;</span>;<br>		String str2 = <span class="hljs-string">&quot;cvhellobnm&quot;</span>;<br>		<span class="hljs-keyword">int</span> length = str2.length();<br>		l1: <span class="hljs-keyword">while</span> (length &gt; <span class="hljs-number">0</span>) &#123;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> begin = <span class="hljs-number">0</span>; begin + length &lt;= str2.length(); begin++) &#123;<br>				<span class="hljs-keyword">if</span> (str1.contains(str2.substring(begin, begin + length))) &#123;<br>					System.out.println(str2.substring(begin, begin + length));<br>					<span class="hljs-keyword">break</span> l1;<br>				&#125;<br>			&#125;<br>			length--;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;<br>		LocalDate date = LocalDate.now();<br>		System.out.println(date);<br>		LocalDate withYear = date.withYear(<span class="hljs-number">2000</span>).withMonth(<span class="hljs-number">8</span>).withDayOfMonth(<span class="hljs-number">10</span>);<br>		System.out.println(withYear);<br>		LocalDate plusYears = withYear.plusDays(<span class="hljs-number">100</span>);<br>		System.out.println(plusYears);<br>	&#125;<br><br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br>		Calendar instance = Calendar.getInstance();<br>		<span class="hljs-comment">//</span><br>		instance.set(Calendar.YEAR, <span class="hljs-number">2000</span>);<br>		instance.set(Calendar.MONTH, <span class="hljs-number">7</span>);<br>		instance.set(Calendar.YEAR, <span class="hljs-number">10</span>);<br>		System.out.println(instance.getTime());<br>		instance.add(Calendar.DAY_OF_MONTH, <span class="hljs-number">100</span>);<br>		System.out.println(instance.getTime());<br>	&#125;<br><br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br>		System.out.println(System.currentTimeMillis());<span class="hljs-comment">// 距离1970-01-01 00:00:00:000的毫秒数</span><br>		Date date = <span class="hljs-keyword">new</span> Date();<br>		System.out.println(date);<br>		SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>		String format = sdf.format(date);<br>		System.out.println(format);<br>		String string = <span class="hljs-string">&quot;2001-12-06 20:45:19&quot;</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			System.out.println(sdf.parse(string));<br>		&#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;<br>			<span class="hljs-comment">// TODO Auto-generated catch block</span><br>			e.printStackTrace();<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="大数"><a href="#大数" class="headerlink" title="大数"></a>大数</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> math;<br><br><span class="hljs-keyword">import</span> java.math.BigInteger;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * java中所有字符都是两个字节</span><br><span class="hljs-comment"> * C语言中汉字占两个字节，其他字符1个字节</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MathClassTest</span> </span>&#123;<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br>		System.out.println(Math.random());<br>		System.out.println(Math.round(-<span class="hljs-number">4.5</span>));<br>		BigInteger bi1=<span class="hljs-keyword">new</span> BigInteger(<span class="hljs-string">&quot;41654894789415618977465187416518948651327849816354184894561564897488465415415&quot;</span>);<br>		BigInteger bi2=<span class="hljs-keyword">new</span> BigInteger(<span class="hljs-string">&quot;41654894789415641568977465187416518948651327849816354184894561564897488465415415&quot;</span>);<br>		System.out.println(bi2.add(bi1));<br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> string;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * StringBuffer :内容可以改变的Unicode字符序列，任何修改都不会产生新对象，是内部的数据的变化，效率高</span><br><span class="hljs-comment"> * 是一个容器，是一个可以保存字符的容器，底层仍让使用数组</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * StringBuilder append(...) 在字符串末尾追加任意数据. StringBuilder insert(int index, ...)</span><br><span class="hljs-comment"> * 在指定位置处插入任意新数据 StringBuilder delete(int begin, int end) 删除指定区间的所有字符</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * StringBuffer是线程安全的, 效率低 .</span><br><span class="hljs-comment"> * StringBuilder是线程不安全的, 效率高.(优先使用)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringBuilderTest</span> </span>&#123;<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br>		String str=<span class="hljs-keyword">null</span>;<br>		StringBuffer sb=<span class="hljs-keyword">new</span> StringBuffer();<br>		sb.append(str);<span class="hljs-comment">//如果append null会把null分解成单个字符，加入到StringBuffer中，count+=4</span><br>		System.out.println(sb.length());<br>		System.out.println(sb);<br>		StringBuffer sb1=<span class="hljs-keyword">new</span> StringBuffer(str);<span class="hljs-comment">//空指针错误,无法运行</span><br>		System.out.println(sb1);<br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> string;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 字符串：内容不可改变的Unicode字符的序列，任何对自负床的修改都一定会产生新的字符串对象</span><br><span class="hljs-comment"> * 底层使用byte[]来保存字符，字符串的处理与下标密切相关</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//System.arrycopy(value,0,result,0,value.length)实现从源数组到目标数组的复制</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 字符串 : 内容不可改变的Unicode字符的序列, 任何的对字符串的修改都一定会产生新的字符串对象.</span><br><span class="hljs-comment"> * 底层使用了char[]来保存字符, 字符串的处理和下标密切相关.</span><br><span class="hljs-comment"> * 					0 2         12       17        23        29      37 39</span><br><span class="hljs-comment"> * String string = &quot;  abcABXXyy 我喜欢你,你喜欢我吗?我不喜欢你 qqyyZZ123  &quot;;</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 	*****public int length() 获取字符串长度(字符数) string.length() =&gt; 40</span><br><span class="hljs-comment">	*****public char charAt(int index) 获取参数指定的下标位置处的字符 string.charAt(10) =&gt; y. string.charAt(13) =&gt; 喜</span><br><span class="hljs-comment">	public char[] toCharArray() 获取字符串相应的字符数组, 是内部数组的一个副本</span><br><span class="hljs-comment">			System.arraycopy(value, 0, result, 0, value.length);</span><br><span class="hljs-comment">			// 第一个参数是源数组, </span><br><span class="hljs-comment">			 * 第2个参数是源数组开始下标</span><br><span class="hljs-comment">			// 第3个参数是目标数组, </span><br><span class="hljs-comment">			 * 第4个参数是目标数组的开始复制的下标, </span><br><span class="hljs-comment">			 * 第5个参数是总共要复制的元素个数.</span><br><span class="hljs-comment">			 * </span><br><span class="hljs-comment">			效果相当于 : </span><br><span class="hljs-comment">			for (int i = 0; i &lt; value.length; i++) &#123;</span><br><span class="hljs-comment">				result[i] = value[i];</span><br><span class="hljs-comment">			&#125;</span><br><span class="hljs-comment">			</span><br><span class="hljs-comment">	****public boolean equals(Object anObject)</span><br><span class="hljs-comment">	public int compareTo(String anotherString)</span><br><span class="hljs-comment">	</span><br><span class="hljs-comment"> * 					0 2         12       17        23        29      37 39</span><br><span class="hljs-comment"> * String string = &quot;  abcABXXyy 我喜欢你,你喜欢我吗?我不喜欢你 qqyyZZ123  &quot;;</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment">	***public int indexOf(String s), 获取参数中的子串在当前字符串中首次出现的下标值 string.indexOf(&quot;喜欢&quot;) =&gt; 13, 如果搜索失败返回-1</span><br><span class="hljs-comment">	public int indexOf(String s ,int startpoint) 获取第2个喜欢 : string.indexOf(&quot;喜欢&quot;, 14) =&gt; 18, </span><br><span class="hljs-comment">												  获取第3个喜欢 : string.indexOf(&quot;喜欢&quot;, 19) =&gt; 25,</span><br><span class="hljs-comment">												  </span><br><span class="hljs-comment">	public int lastIndexOf(String s) 从右向左搜索子串出现的下标, string.lastIndexOf(&quot;喜欢&quot;) =&gt; 25</span><br><span class="hljs-comment">	public int lastIndexOf(String s ,int startpoint) 获取第2个喜欢 : string.lastIndexOf(&quot;喜欢&quot;, 24) =&gt; 18</span><br><span class="hljs-comment">	</span><br><span class="hljs-comment">	// 通常获取文件列表名, 对文件名进行判断</span><br><span class="hljs-comment">	*public boolean startsWith(String prefix) 判断字符串是否以参数中的子串为开始 string.startsWith(&quot;  abc&quot;) =&gt; true</span><br><span class="hljs-comment">	*public boolean endsWith(String suffix) 判断字符串是否以参数中的子串为结束 string.endsWith(&quot;123&quot;) =&gt; false</span><br><span class="hljs-comment">	</span><br><span class="hljs-comment">	*****public String substring(int start,int end) 从当前字符串中截取子串, start表示开始下标(包含), end表示结束下标(不包含)</span><br><span class="hljs-comment">						string.substring(12, 16) =&gt; &quot;我喜欢你&quot;,  结束下标-开始下标 == 子串长度</span><br><span class="hljs-comment">	public String substring(int startpoint) 从当前字符串中取子串,从start开始到结束</span><br><span class="hljs-comment">	</span><br><span class="hljs-comment">	public String replace(char oldChar,char newChar) 替换字符串中的所有旧字符为新字符</span><br><span class="hljs-comment">	public String replaceAll(String old,String new) 全部替换老串为新串, 特殊字符 \ [ * +</span><br><span class="hljs-comment">	</span><br><span class="hljs-comment">	public String trim() 修剪字符串的首尾的空白字符(Unicode码值小于等于32的字符，都是空白字符)</span><br><span class="hljs-comment">	</span><br><span class="hljs-comment">	public String concat(String str)</span><br><span class="hljs-comment">	public String toUpperCase() 改变大小写</span><br><span class="hljs-comment">	public String toLowerCase()</span><br><span class="hljs-comment">	public String[] split(String regex) 以参数中的子串为切割器, 把字符串切割成多个部分.</span><br><span class="hljs-comment">	*****public boolean equalsIgnoreCase(String s2) 比较字符串的内容, 忽略大小写</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringClassTest</span> </span>&#123;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>&#123;<br>		String s=<span class="hljs-string">&quot;  		\r\t\n  	\r\tw 		\t\r\t\n\r&quot;</span>;<br>		<span class="hljs-keyword">int</span> begin=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++) &#123;<br>			<span class="hljs-keyword">if</span>(s.charAt(i)&gt;<span class="hljs-number">32</span>) &#123;<br>				begin=i;<br>				<span class="hljs-keyword">break</span>;<br>			&#125;<br>		&#125;<br>		System.out.println(begin);<br>		<span class="hljs-keyword">int</span> end=begin;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=s.length()-<span class="hljs-number">1</span>;i&gt;begin;i--) &#123;<br>			<span class="hljs-keyword">if</span>(s.charAt(i)&gt;<span class="hljs-number">32</span>) &#123;<br>				end=i;<br>				<span class="hljs-keyword">break</span>;<br>			&#125;<br>		&#125;<br>		System.out.println(end);<br>		System.out.println(s.substring(begin, end+<span class="hljs-number">1</span>));<br>		<br>		<br>		<br>		String string=<span class="hljs-string">&quot;PATH=C:\\Python38\\Scripts\\;C:\\Python38\\;C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\;C:\\Windows\\System32\\OpenSSH\\;C:\\Program Files (x86)\\NVIDIA Corporation\\PhysX\\Common;C:\\Program Files\\NVIDIA Corporation\\NVIDIA NGX;C:\\Program Files (x86)\\Intel\\Intel(R) Management Engine Components\\DAL;C:\\Program Files\\Intel\\Intel(R) Management Engine Components\\DAL;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\;C:\\WINDOWS\\System32\\OpenSSH\\;D:\\Program Files\\Java\\jdk-13.0.2\\bin;C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Anaconda3 (64-bit);D:\\python;D:\\python\\Scripts;D:\\python\\Library\\bin;D:\\Git\\cmd;C:\\ProgramData\\chocolatey\\bin;D:\\blog\\;C:\\Users\\Hasee\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Users\\Hasee\\AppData\\Local\\Programs\\Microsoft VS Code\\bin;D:\\python\\PyCharm Community Edition 2019.3.3\\bin;D:\\Fiddler;C:\\Users\\Hasee\\AppData\\Roaming\\npm;D:\\PyCharm Community Edition 2020.2.3\\bin;C:\\adb;C:\\Program Files\\NVIDIA Corporation\\NVIDIA NvDLISR;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\;C:\\WINDOWS\\System32\\OpenSSH\\;D:\\tomcat\\apache-tomcat-10.0.2\\bin;D:\\Program Files\\Java\\jdk-13.0.2\\bin;C:\\Users\\Hasee\\AppData\\Local\\Microsoft\\WindowsApps;;C:\\Users\\Hasee\\AppData\\Local\\Programs\\Microsoft VS Code\\bin;D:\\python\\PyCharm Community Edition 2019.3.3\\bin;D:\\Fiddler;C:\\Users\\Hasee\\AppData\\Roaming\\npm;D:\\PyCharm Community Edition 2020.2.3\\bin;;C:\\Users\\Hasee\\AppData\\Local\\Microsoft\\WindowsApps&quot;</span>;<br>		String[] splitString=string.split(<span class="hljs-string">&quot;;&quot;</span>);<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;splitString.length;i++) &#123;<br>			System.out.println(splitString[i]);<br>		&#125;<br>	&#125;<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;<br>		String s=<span class="hljs-string">&quot;abcdefghijklmn&quot;</span>;<br>		<span class="hljs-keyword">int</span> begin=<span class="hljs-number">2</span>;<br>		<span class="hljs-keyword">int</span> end=<span class="hljs-number">6</span>;<br>		String s1=s.substring(<span class="hljs-number">0</span>,begin);<br>		String s2=s.substring(begin, end);<br>		String s3=s.substring(end,s.length());<br>		System.out.println(s1);<br>		System.out.println(s2);<br>		System.out.println(s3);<br>		String news=<span class="hljs-string">&quot;&quot;</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s2.length();i++) &#123;<br>			news=s2.charAt(i)+news;<br>		&#125;<br>		System.out.println(news);<br>		news=s1+news+s3;<br>		System.out.println(news);<br>	&#125;<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">char</span>[] arr= &#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;7&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>&#125;;<br>		String s1=<span class="hljs-keyword">new</span> String(arr);<br>		System.out.println(s1);<br>		String s2=<span class="hljs-keyword">new</span> String(arr,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<span class="hljs-comment">//new String(char[],startindex,count)</span><br>		System.out.println(s2);<br>		System.out.println(s2.length());<br>		String s3=<span class="hljs-string">&quot;&quot;</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=s1.length()-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--) &#123;<br>			s3+=s1.charAt(i);<br>		&#125;<br>		System.out.println(s3);<br>	&#125;<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br>		String s=<span class="hljs-string">&quot;abkkcadkabkebfkabkskab&quot;</span>;<br>		String s1=<span class="hljs-string">&quot;ab&quot;</span>;<br>		<span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();) &#123;<br>			<span class="hljs-keyword">if</span>(s.indexOf(s1,i)!=-<span class="hljs-number">1</span>) &#123;<br>				cnt++;<br>				i=s.indexOf(s1,i)+<span class="hljs-number">1</span>;<br>			&#125;<br>			<span class="hljs-keyword">else</span> &#123;<br>				i++;<br>			&#125;<br>		&#125;<br>		System.out.println(cnt);<br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h2 id="装箱"><a href="#装箱" class="headerlink" title="装箱"></a>装箱</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> wrapper;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WrapperTest</span> </span>&#123;<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">int</span> n=<span class="hljs-number">20</span>;<br>		Integer obj1=<span class="hljs-keyword">new</span> Integer(n);<br>		Integer obj2=n;<span class="hljs-comment">//自动装箱</span><br>		System.out.println(obj1==obj2);<br>		System.out.println(obj1.equals(obj2));<br>	&#125;<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br>		Integer i=<span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);<br>		Integer j=<span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);<br>		System.out.println(i==j);<span class="hljs-comment">//false</span><br>		<span class="hljs-comment">//自动装箱，调用Integer.valueOf(n)</span><br>		<span class="hljs-comment">//在-128到127之间，自动装箱不会创建新的对象，会取缓冲对象数组中的一个，超过该范围，自动装箱会创建新对象</span><br>		Integer m=<span class="hljs-number">1</span>;<span class="hljs-comment">//自动装箱</span><br>		Integer n=<span class="hljs-number">1</span>;<br>		System.out.println(m==n);<span class="hljs-comment">// true</span><br>		<br>		<br>		Integer x=<span class="hljs-number">128</span>;<span class="hljs-comment">//自动装箱</span><br>		Integer y=<span class="hljs-number">128</span>;<br>		System.out.println(x==y);<span class="hljs-comment">//false</span><br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h2 id="JavaIo"><a href="#JavaIo" class="headerlink" title="JavaIo"></a>JavaIo</h2><figure class="highlight plain"><figcaption><span>javaio;</span></figcaption><table><tr><td class="code"><pre><code class="hljs Javpackage">import java.io.BufferedInputStream;<br>import java.io.BufferedOutputStream;<br>import java.io.BufferedReader;<br>import java.io.BufferedWriter;<br>import java.io.FileInputStream;<br>import java.io.FileOutputStream;<br>import java.io.FileReader;<br>import java.io.FileWriter;<br>import java.io.InputStream;<br>import java.io.InputStreamReader;<br>import java.io.ObjectInputStream;<br>import java.io.ObjectOutputStream;<br>import java.io.OutputStreamWriter;<br>import java.io.Serializable;<br>import java.io.UnsupportedEncodingException;<br>import java.util.ArrayList;<br>import java.util.Iterator;<br>import java.util.List;<br><br>import org.junit.Test;<br>&#x2F;*<br> * 绝对路径：以根目录为开始的路径<br> * 相对路径：以当前目录未开始的路径（.&#x2F;）<br> *&#x2F;<br>class Student implements Serializable &#123;<br>	<br>	public static String school; &#x2F;&#x2F; 序列化不可以序列化静态属性<br>	<br>	&#x2F;&#x2F; 只序列化对象在GC区中的数据<br>	private int id;<br>	private String name;<br>	private int grade;<br>	private transient double score;<br>	<br>	public Student() &#123;<br>	&#125;<br><br>	public Student(int id, String name, int grade, double score) &#123;<br>		super();<br>		this.id &#x3D; id;<br>		this.name &#x3D; name;<br>		this.grade &#x3D; grade;<br>		this.score &#x3D; score;<br>	&#125;<br><br>	public int getId() &#123;<br>		return id;<br>	&#125;<br><br>	public void setId(int id) &#123;<br>		this.id &#x3D; id;<br>	&#125;<br><br>	public String getName() &#123;<br>		return name;<br>	&#125;<br><br>	public void setName(String name) &#123;<br>		this.name &#x3D; name;<br>	&#125;<br><br>	public int getGrade() &#123;<br>		return grade;<br>	&#125;<br><br>	public void setGrade(int grade) &#123;<br>		this.grade &#x3D; grade;<br>	&#125;<br><br>	public double getScore() &#123;<br>		return score;<br>	&#125;<br><br>	public void setScore(double score) &#123;<br>		this.score &#x3D; score;<br>	&#125;<br><br>	@Override<br>	public String toString() &#123;<br>		return &quot;Student [id&#x3D;&quot; + id + &quot;, name&#x3D;&quot; + name + &quot;, grade&#x3D;&quot; + grade + &quot;, score&#x3D;&quot; + score + &quot;]&quot;;<br>	&#125;<br>	<br>&#125;<br><br>public class JavaIoTest &#123;<br>	&#x2F;&#x2F; 从键盘输入一些内容, 把文件保存成UTF8格式的文本文件content.txt<br>	&#x2F;&#x2F; 直到键盘输入over命令, 或ctrl+z <br>	@Test<br>	public void test13() &#123;<br>		InputStream is &#x3D; System.in; &#x2F;&#x2F; 以键盘为数据源<br>		InputStreamReader isr &#x3D; null;<br>		BufferedReader bufferedReader &#x3D; null;<br>		try &#123;<br>			isr &#x3D; new InputStreamReader(is);<br>			bufferedReader &#x3D; new BufferedReader(isr);<br>			String line &#x3D; bufferedReader.readLine();<br>			while (line !&#x3D; null) &#123;<br>				&#x2F;&#x2F; 1) 处理数据 <br>				if (line.equals(&quot;exit&quot;)) &#123;<br>					break;<br>				&#125;<br>				System.out.println(line);<br>				&#x2F;&#x2F; 2) 继续读<br>				line &#x3D; bufferedReader.readLine(); &#x2F;&#x2F; ctrl+z 提醒流数据已经结束<br>			&#125;<br>		&#125; catch (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125; finally &#123;<br>			if (bufferedReader !&#x3D; null) &#123;<br>				try &#123;<br>					bufferedReader.close();<br>				&#125; catch (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<br>	@Test<br>	public void test12() &#123;<br>		System.out.println(&quot;hello&quot;);<br>		System.err.println(&quot;Error&quot;);<br>	&#125;<br>	<br>	@Test<br>	public void test11() &#123;<br>		&#x2F;&#x2F;FileWriter fileWriter &#x3D; null;<br>		FileOutputStream fos &#x3D; null;<br>		OutputStreamWriter osw &#x3D; null;<br>		BufferedWriter bufferedWriter &#x3D; null;<br>		try &#123;<br>			&#x2F;&#x2F;fileWriter &#x3D; new FileWriter(&quot;一个文本文件&quot;);<br>			fos &#x3D; new FileOutputStream(&quot;一个文本文件_UTF8&quot;, true); &#x2F;&#x2F; 在创建节点流时, 传入第2个参数true,表示追加<br>			osw &#x3D; new OutputStreamWriter(fos, &quot;utf8&quot;); &#x2F;&#x2F; 在写文件时, 把字符串全部按照UTF8编码方式进行编码<br>			bufferedWriter &#x3D; new BufferedWriter(osw);<br>			bufferedWriter.write(&quot;abc我和你&quot;);<br>			<br>			&#x2F;&#x2F;bufferedWriter.flush(); &#x2F;&#x2F; 把数据真的从缓冲区刷入硬盘<br>			<br>		&#125; catch (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125; finally &#123;<br>			if (bufferedWriter !&#x3D; null) &#123;<br>				try &#123;<br>					bufferedWriter.close(); &#x2F;&#x2F; 在关闭前会自动flush<br>				&#125; catch (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<br>	@Test<br>	public void test10() &#123;<br>		&#x2F;&#x2F;FileReader fileReader &#x3D; null; &#x2F;&#x2F; 它太弱了, 不好用<br>		FileInputStream fis &#x3D; null;<br>		InputStreamReader isr &#x3D; null;<br>		BufferedReader bufferedReader &#x3D; null;<br>		try &#123;<br>			&#x2F;&#x2F;fileReader &#x3D; new FileReader(&quot;HashMap.java&quot;); &#x2F;&#x2F; 只能处理和项目一致的编码的文本文件<br>			fis &#x3D; new FileInputStream(&quot;HashMap.java&quot;);<br>			&#x2F;&#x2F;isr &#x3D; new InputStreamReader(fis); &#x2F;&#x2F; 在这里仍然使用的是默认编码方式<br>			isr &#x3D; new InputStreamReader(fis, &quot;utf8&quot;); &#x2F;&#x2F; 指明转换流在处理字节数据时按照UTF8编码方式处理字符串<br>			bufferedReader &#x3D; new BufferedReader(isr);<br>			<br>			String line &#x3D; bufferedReader.readLine(); <br>			while (line !&#x3D; null) &#123;<br>				System.out.println(line);<br>				line &#x3D; bufferedReader.readLine();<br>			&#125;<br>		&#125; catch (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125; finally &#123;<br>			if (bufferedReader !&#x3D; null) &#123;<br>				try &#123;<br>					bufferedReader.close();<br>				&#125; catch (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<br>	@Test<br>	public void unserialize() &#123;<br>		FileInputStream fis &#x3D; null;<br>		BufferedInputStream bis &#x3D; null;<br>		ObjectInputStream ois &#x3D; null;<br>		try &#123;<br>			fis &#x3D; new FileInputStream(&quot;对象序列化&quot;);<br>			bis &#x3D; new BufferedInputStream(fis);<br>			ois &#x3D; new ObjectInputStream(bis);<br>			<br>			&#x2F;*<br>			Object obj1 &#x3D; ois.readObject();<br>			Object obj2 &#x3D; ois.readObject();<br>			Object obj3 &#x3D; ois.readObject();<br>			<br>			System.out.println(obj1);<br>			System.out.println(obj2);<br>			System.out.println(obj3);<br>			<br>			System.out.println(Student.school);<br>			*&#x2F;<br>			<br>			&#x2F;*<br>			Student[] arr &#x3D; (Student[])ois.readObject();<br>			for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;<br>				System.out.println(arr[i]);<br>			&#125;<br>			*&#x2F;<br>			<br>			List&lt;Student&gt; list &#x3D; (List&lt;Student&gt;)ois.readObject();<br>			Iterator&lt;Student&gt; iterator &#x3D; list.iterator();<br>			while (iterator.hasNext()) &#123;<br>				System.out.println(iterator.next());<br>			&#125;<br>			<br>		&#125; catch (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125; finally &#123;<br>			if (ois !&#x3D; null) &#123;<br>				try &#123;<br>					ois.close();<br>				&#125; catch (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<br>	@Test<br>	public void serialize() &#123;<br>		FileOutputStream fos &#x3D; null;<br>		BufferedOutputStream bos &#x3D; null;<br>		ObjectOutputStream oos &#x3D; null;<br>		try &#123;<br>			fos &#x3D; new FileOutputStream(&quot;对象序列化&quot;);<br>			bos &#x3D; new BufferedOutputStream(fos);<br>			oos &#x3D; new ObjectOutputStream(bos);<br>			<br>			Student s1 &#x3D; new Student(1, &quot;小明&quot;, 3, 90);<br>			Student s2 &#x3D; new Student(2, &quot;小花&quot;, 1, 80);<br>			Student s3 &#x3D; new Student(3, &quot;小丽&quot;, 4, 20);<br>			<br>			s1.school &#x3D; &quot;atguigu&quot;;<br>			<br>			&#x2F;&#x2F;oos.writeObject(s1);<br>			&#x2F;&#x2F;oos.writeObject(s2);<br>			&#x2F;&#x2F;oos.writeObject(s3);<br>			<br>			&#x2F;&#x2F;Student[] arr &#x3D; &#123;s1, s2, s3&#125;;<br>			&#x2F;&#x2F;oos.writeObject(arr);<br>			<br>			List&lt;Student&gt; list &#x3D; new ArrayList&lt;Student&gt;();<br>			list.add(s1);<br>			list.add(s2);<br>			list.add(s3);<br>			oos.writeObject(list);<br>			<br>		&#125; catch (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125; finally &#123;<br>			if (oos !&#x3D; null) &#123;<br>				try &#123;<br>					oos.close();<br>				&#125; catch (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<br>	@Test<br>	public void test8() throws UnsupportedEncodingException &#123;<br>		&#x2F;*<br>		 * Unicoode编码每个字符占两个字节<br>		   GBK编码汉字占两个字节，其他字符一个字节<br>		   UTF-8编码汉字占三个字节，其他字符占一个字节<br>		 *&#x2F;<br>		&#x2F;&#x2F; e6 88 91 可变长度编码<br>		int n1 &#x3D; 0x6211; &#x2F;&#x2F; Unicode码是国际标准委员会制定<br>		System.out.println(n1);<br>		System.out.println((char)n1);<br>		<br>		int n2 &#x3D; 0xCED2; &#x2F;&#x2F; GBK码值, 是中国人自己制定<br>		System.out.println(n2);<br>		<br>		&#x2F;&#x2F; 编码 : 字符串 &#x3D;&gt; 字节数组, string.getBytes(), 目标是把字符串保存到文件中或通过网络传输.<br>		String string &#x3D; &quot;abc我和你&quot;;<br>		byte[] bytes1 &#x3D; string.getBytes(&quot;gbk&quot;); &#x2F;&#x2F; 按照项目默认的编码方式: GBK编码方式进行编码<br>		for (int i &#x3D; 0; i &lt; bytes1.length; i++) &#123;<br>			System.out.print(Integer.toHexString(bytes1[i]) + &quot; &quot;);<br>		&#125;<br>		System.out.println();<br>		<br>		byte[] bytes2 &#x3D; string.getBytes(&quot;utf8&quot;);<br>		for (int i &#x3D; 0; i &lt; bytes2.length; i++) &#123;<br>			System.out.print(Integer.toHexString(bytes2[i]) + &quot; &quot;);<br>		&#125;<br>		System.out.println();<br>		<br>		&#x2F;&#x2F; 解码 : 字节数组 &#x3D;&gt; 字符串, new String(byte[]), 把文件中或从网络接收的数据还原成字符串<br>		String string2 &#x3D; new String(bytes1, &quot;gbk&quot;); &#x2F;&#x2F; 把字节数组按照gbk编码方式进行解码 <br>		&#x2F;&#x2F; 每2个字节凑一个整数, 是GBK码, 再查表找到对应的Unicode码<br>		System.out.println(string2);<br>		<br>		String string3 &#x3D; new String(bytes2, &quot;utf8&quot;);<br>		&#x2F;&#x2F; 每3个字节凑一个字符, 从3个字节中拆出数据, 拆出的数据直接就是Unicode<br>		System.out.println(string3);<br>	&#125;<br>	<br>	@Test<br>	public void test9() &#123;<br>		FileInputStream fis &#x3D; null;<br>		BufferedInputStream bis &#x3D; null;<br>		ObjectInputStream ois &#x3D; null;<br>		try &#123;<br>			fis &#x3D; new FileInputStream(&quot;对象输出流文件2&quot;);<br>			bis &#x3D; new BufferedInputStream(fis);<br>			ois &#x3D; new ObjectInputStream(bis);<br>			<br>			int readInt &#x3D; ois.readInt();<br>			System.out.println(readInt);<br>			boolean readBoolean1 &#x3D; ois.readBoolean();<br>			boolean readBoolean2 &#x3D; ois.readBoolean();<br>			System.out.println(readBoolean1);<br>			System.out.println(readBoolean2);<br>			long readLong &#x3D; ois.readLong();<br>			System.out.println(readLong);<br>			double readDouble &#x3D; ois.readDouble();<br>			System.out.println(readDouble);<br>			String readUTF &#x3D; ois.readUTF(); &#x2F;&#x2F; 读文件要解码<br>			System.out.println(readUTF);<br>			<br>		&#125; catch (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125; finally &#123;<br>			if (ois !&#x3D; null) &#123;<br>				try &#123;<br>					ois.close();<br>				&#125; catch (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<br>	@Test<br>	public void test7() &#123;<br>		FileOutputStream fos &#x3D; null;<br>		BufferedOutputStream bos &#x3D; null;<br>		ObjectOutputStream oos &#x3D; null;<br>		try &#123;<br>			fos &#x3D; new FileOutputStream(&quot;对象输出流文件2&quot;);<br>			bos &#x3D; new BufferedOutputStream(fos);<br>			oos &#x3D; new ObjectOutputStream(bos);<br>			<br>			oos.writeInt(10); <br>			oos.writeBoolean(false);<br>			oos.writeBoolean(true);<br>			oos.writeLong(20);<br>			oos.writeDouble(3.14);<br>			oos.writeUTF(&quot;abc我和你xxx&quot;); &#x2F;&#x2F; 写文件要编码<br>			&#x2F;&#x2F;oos.writeChars(&quot;abc我和你xxx&quot;); &#x2F;&#x2F; 把字符串直接写文件<br>			<br>		&#125; catch (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125; finally &#123;<br>			if (oos !&#x3D; null) &#123;<br>				try &#123;<br>					oos.close();<br>				&#125; catch (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<br>	@Test<br>	public void test6() &#123;<br>		FileInputStream fis &#x3D; null;<br>		BufferedInputStream bis &#x3D; null;<br>		ObjectInputStream ois &#x3D; null;<br>		try &#123;<br>			fis &#x3D; new FileInputStream(&quot;对象输出流文件&quot;);<br>			bis &#x3D; new BufferedInputStream(fis);<br>			ois &#x3D; new ObjectInputStream(bis);<br>			<br>			int readInt &#x3D; ois.readInt();<br>			System.out.println(readInt);<br>			boolean readBoolean1 &#x3D; ois.readBoolean();<br>			boolean readBoolean2 &#x3D; ois.readBoolean();<br>			System.out.println(readBoolean1);<br>			System.out.println(readBoolean2);<br>			long readLong &#x3D; ois.readLong();<br>			System.out.println(readLong);<br>			double readDouble &#x3D; ois.readDouble();<br>			System.out.println(readDouble);<br>			<br>		&#125; catch (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125; finally &#123;<br>			if (ois !&#x3D; null) &#123;<br>				try &#123;<br>					ois.close();<br>				&#125; catch (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<br>	&#x2F;&#x2F; 使用对象流写文件, 写入50个100以内的随机整数<br>	@Test<br>	public void exer1() &#123;<br>		FileOutputStream fos &#x3D; null;<br>		BufferedOutputStream bos &#x3D; null;<br>		ObjectOutputStream oos &#x3D; null;<br>		try &#123;<br>			fos &#x3D; new FileOutputStream(&quot;50个随机数&quot;);<br>			bos &#x3D; new BufferedOutputStream(fos);<br>			oos &#x3D; new ObjectOutputStream(bos);<br>			<br>			for (int i &#x3D; 0; i &lt; 50; i++) &#123;<br>				oos.writeInt((int)(Math.random() * 100));<br>			&#125;<br>		&#125; catch (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125; finally &#123;<br>			if (oos !&#x3D; null) &#123;<br>				try &#123;<br>					oos.close();<br>				&#125; catch (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	&#x2F;&#x2F; 使用对象输入流读取这50个随机整数<br>	@Test<br>	public void exer2() &#123;<br>		FileInputStream fis &#x3D; null;<br>		BufferedInputStream bis &#x3D; null;<br>		ObjectInputStream ois &#x3D; null;<br>		try &#123;<br>			fis &#x3D; new FileInputStream(&quot;50个随机数&quot;);<br>			bis &#x3D; new BufferedInputStream(fis);<br>			ois &#x3D; new ObjectInputStream(bis);<br>			<br>			for (int i &#x3D; 0; i &lt; 50; i++) &#123;<br>				System.out.println(ois.readInt());<br>			&#125;<br>			<br>		&#125; catch (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125; finally &#123;<br>			if (ois !&#x3D; null) &#123;<br>				try &#123;<br>					ois.close();<br>				&#125; catch (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<br>	@Test<br>	public void test5() &#123;<br>		&#x2F;&#x2F; ObjectInputStream和ObjectOutputStream<br>		FileOutputStream fos &#x3D; null;<br>		BufferedOutputStream bos &#x3D; null;<br>		ObjectOutputStream oos &#x3D; null;<br>		try &#123;<br>			fos &#x3D; new FileOutputStream(&quot;对象输出流文件&quot;);<br>			bos &#x3D; new BufferedOutputStream(fos);<br>			oos &#x3D; new ObjectOutputStream(bos);<br>			<br>			oos.writeInt(10); &#x2F;&#x2F; 数据在内存中如何 保存 它就如何写入文件<br>			oos.writeBoolean(false);<br>			oos.writeBoolean(true);<br>			oos.writeLong(20);<br>			oos.writeDouble(3.14);<br>			<br>		&#125; catch (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125; finally &#123;<br>			if (oos !&#x3D; null) &#123;<br>				try &#123;<br>					oos.close();<br>				&#125; catch (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<br>	@Test<br>	public void test4() &#123;<br>		FileWriter fileWriter &#x3D; null;<br>		BufferedWriter bufferedWriter &#x3D; null;<br>		try &#123;<br>			fileWriter &#x3D; new FileWriter(&quot;使用缓冲流写文本&quot;);<br>			bufferedWriter &#x3D; new BufferedWriter(fileWriter);<br>			String[] content &#x3D; &#123;&quot;来上一些字符串内容1&quot;,<br>								&quot;来上一些字符串内容2&quot;,<br>								&quot;来上一些字符串内容3&quot;,<br>								&quot;来上一些字符串内容4&quot;,<br>								&quot;来上一些字符串内容5&quot;,<br>								&quot;来上一些字符串内容6&quot;,<br>								&quot;来上一些字符串内容7&quot;,<br>								&quot;来上一些字符串内容8&quot;,<br>								&quot;1234567890123456&quot;,<br>								&quot;asdfkjasldfjalksdjflaksjdflkasjdflkasjdff&quot;,<br>								&quot;xcvadsfasdfasdfasdfasdf&quot;&#125;;<br>			for (String string : content) &#123;<br>				bufferedWriter.write(string);<br>				bufferedWriter.newLine(); &#x2F;&#x2F; 最有价值方法<br>			&#125;<br>		&#125; catch (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125; finally &#123;<br>			if (bufferedWriter !&#x3D; null) &#123;<br>				try &#123;<br>					bufferedWriter.close();<br>				&#125; catch (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<br>	@Test<br>	public void test3() &#123;<br>		&#x2F;&#x2F; 使用缓冲流(处理流)<br>		FileReader fileReader &#x3D; null;<br>		BufferedReader bufferedReader &#x3D; null;<br>		try &#123;<br>			&#x2F;&#x2F; 包装流, 使用对象关联, 包装流把节点流对象关联为属性.<br>			fileReader &#x3D; new FileReader(&quot;HashMap.java&quot;);<br>			bufferedReader &#x3D; new BufferedReader(fileReader);<br>			&#x2F;&#x2F; 最有价值方法<br>			String line &#x3D; bufferedReader.readLine(); &#x2F;&#x2F; 读到的字符串没有换行<br>			int num &#x3D; 1;<br>			while (line !&#x3D; null) &#123;<br>				&#x2F;&#x2F; 处理读到的行<br>				System.out.println(num++ + &quot; &quot; + line);<br>				&#x2F;&#x2F; 继续读后面的行, 直到null<br>				line &#x3D; bufferedReader.readLine();<br>			&#125;<br>		&#125; catch (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125; finally &#123;<br>			&#x2F;&#x2F; 只需要关闭高级流, 因为低级流被关联, 并且会在关闭高级流时自动关闭<br>			if (bufferedReader !&#x3D; null) &#123;<br>				try &#123;<br>					bufferedReader.close();<br>				&#125; catch (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<br>	@Test<br>	public void test2() &#123;<br>		FileWriter fileWriter &#x3D; null;<br>		try &#123;<br>			fileWriter &#x3D; new FileWriter(&quot;写一个文件&quot;);<br>			&#x2F;&#x2F; 写数组<br>			String[] content &#x3D; &#123;&quot;来上一些字符串内容1&quot;,<br>								&quot;来上一些字符串内容2&quot;,<br>								&quot;来上一些字符串内容3&quot;,<br>								&quot;来上一些字符串内容4&quot;,<br>								&quot;来上一些字符串内容5&quot;,<br>								&quot;来上一些字符串内容6&quot;,<br>								&quot;来上一些字符串内容7&quot;,<br>								&quot;来上一些字符串内容8&quot;,<br>								&quot;1234567890123456&quot;,<br>								&quot;asdfkjasldfjalksdjflaksjdflkasjdflkasjdff&quot;,<br>								&quot;xcvadsfasdfasdfasdfasdf&quot;&#125;;<br>			for (int i &#x3D; 0; i &lt; content.length; i++) &#123;<br>				char[] charArray &#x3D; content[i].toCharArray();<br>				&#x2F;&#x2F;fileWriter.write(charArray);&#x2F;&#x2F; 直接把一个数组的全部内容写入到输出流中<br>				&#x2F;&#x2F;这是超重点方法, 把数组的一部分写入文件<br>				fileWriter.write(charArray, 1, charArray.length - 1); &#x2F;&#x2F; 第2个参数是offset偏移, 第3个参数是length长度<br>				<br>				fileWriter.write(13); &#x2F;&#x2F; 写回车<br>				fileWriter.write(10); &#x2F;&#x2F; 写换行<br>			&#125;<br>		&#125; catch (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125; finally &#123;<br>			if (fileWriter !&#x3D; null) &#123;<br>				try &#123;<br>					fileWriter.close();<br>				&#125; catch (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<br>	&#x2F;&#x2F;使用缓冲区读文件, 要求在每一行前面加上行号<br>	@Test<br>	public void test1() &#123;<br>		int line &#x3D; 1;<br>		System.out.print(line++ + &quot; &quot;);<br>		FileReader fileReader &#x3D; null;<br>		try &#123;<br>			fileReader &#x3D; new FileReader(&quot;HashMap.java&quot;);<br>			char[] buf &#x3D; new char[8192];<br>			int realCount &#x3D; fileReader.read(buf);<br>			while (realCount !&#x3D; -1) &#123;<br>				&#x2F;&#x2F; 1) 处理已经实际读到的数据<br>				for (int i &#x3D; 0; i &lt; realCount; i++) &#123;<br>					System.out.print(buf[i]);<br>					if (buf[i] &#x3D;&#x3D; 10) &#123;<br>						System.out.print(line++ + &quot; &quot;);<br>					&#125;<br>				&#125;<br>				&#x2F;&#x2F; 2) 继续读后面的数据, 直到-1为止<br>				realCount &#x3D; fileReader.read(buf);<br>			&#125;<br>		&#125; catch (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125; finally &#123;<br>			if (fileReader !&#x3D; null) &#123;<br>				try &#123;<br>					fileReader.close();<br>				&#125; catch (Exception e2) &#123;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>文件复制</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> javaio;<br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileCopy</span> </span>&#123;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		FileInputStream fis=<span class="hljs-keyword">null</span>;<br>		FileOutputStream fos=<span class="hljs-keyword">null</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			fis=<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;s&quot;</span>);<br>			fos=<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;s2&quot;</span>);<br>			<span class="hljs-keyword">byte</span>[] buf=<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">8192</span>];<br>			<span class="hljs-keyword">int</span> realCount=fis.read(buf);<br>			<span class="hljs-keyword">while</span>(realCount!=-<span class="hljs-number">1</span>) &#123;<br>				<span class="hljs-comment">//处理数据</span><br>				fos.write(buf, <span class="hljs-number">0</span>, realCount);<br>				<span class="hljs-comment">//继续读</span><br>				realCount=fis.read(buf);<br>			&#125;<br>		&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>			e.printStackTrace();<br>		&#125;<span class="hljs-keyword">finally</span> &#123;<br>			<span class="hljs-keyword">if</span>(fis!=<span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					fis.close();<br>				&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>					e.printStackTrace();<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">if</span>(fos!=<span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					fos.close();<br>				&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>					e.printStackTrace();<br>				&#125;<br>			&#125;<br>		&#125;<br>		<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>异常</tag>
        <tag>Java关键字</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>java8新特性</title>
    <url>/2021/04/23/java8-new-features/</url>
    <content><![CDATA[<h1 id="Java8新特性"><a href="#Java8新特性" class="headerlink" title="Java8新特性"></a>Java8新特性</h1><h2 id="Lambda表达式与函数式接口"><a href="#Lambda表达式与函数式接口" class="headerlink" title="Lambda表达式与函数式接口"></a>Lambda表达式与函数式接口</h2><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><blockquote>
<ol>
<li>Consumer<T> 消费器, 作用是消费一个T类型的对象, 并没有返回.</li>
</ol>
<ul>
<li>void accept(T t) : 有输入无输出</li>
</ul>
</blockquote>
<hr>
<blockquote>
<ol start="2">
<li>Supplier<T> 供给器, 作用是供给一个T类型的对象, 不需要参数.</li>
</ol>
<ul>
<li>T get() : 无输入有输出</li>
</ul>
</blockquote>
<hr>
<blockquote>
<ol start="3">
<li>Function&lt;T, R&gt; 转换器, 作用是输入一个T类型对象, 经过处理, 返回的是R类型对象.</li>
</ol>
<ul>
<li>R apply(T t) : 有输入有输出</li>
</ul>
</blockquote>
<hr>
<blockquote>
<ol start="4">
<li>Predicate<T> 判定器, 作用是输入一个T类型对象, 经过某种判断, 返回true或false</li>
</ol>
<ul>
<li>boolean test(T t) : 有输入有固定输出布尔</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> java8;<br><br><span class="hljs-keyword">import</span> java.util.function.Consumer;<br><span class="hljs-keyword">import</span> java.util.function.Function;<br><span class="hljs-keyword">import</span> java.util.function.Predicate;<br><span class="hljs-keyword">import</span> java.util.function.Supplier;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> javabean.Student;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 函数式接口</span><br><span class="hljs-comment"> * 		只有一个抽象方法的接口, 可以用<span class="hljs-doctag">@FunctionalInterface</span>修饰</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * Consumer&lt;T&gt; 消费器, 作用是消费一个T类型的对象, 并没有返回.</span><br><span class="hljs-comment"> * 		void accept(T t) : 有输入无输出</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * Supplier&lt;T&gt; 供给器, 作用是供给一个T类型的对象, 不需要参数.</span><br><span class="hljs-comment"> * 		T get() : 无输入有输出</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * Function&lt;T, R&gt; 转换器, 作用是输入一个T类型对象, 经过处理, 返回的是R类型对象.</span><br><span class="hljs-comment"> * 		R apply(T t) : 有输入有输出</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * Predicate&lt;T&gt; 判定器, 作用是输入一个T类型对象, 经过某种判断, 返回true或false</span><br><span class="hljs-comment"> * 		boolean test(T t) : 有输入有固定输出布尔</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 方法引用 : 接口中的抽象方法的模式(输入和输出) 和 Lambda体中的方法调用是一致时, 就可以简化写法.</span><br><span class="hljs-comment"> * 类或对象 :: 方法名</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FunctionTest</span> </span>&#123;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exer22</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">//Supplier&lt;Student&gt; supplier2 = () -&gt; new Student();</span><br>		Supplier&lt;Student&gt; supplier2 = Student::<span class="hljs-keyword">new</span>;<br>		System.out.println(supplier2.get());<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test42</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">//Function&lt;Integer, String&gt; function2 = t -&gt; String.valueOf(t);</span><br>		Function&lt;Integer, String&gt; function2 = String::valueOf;<br>		System.out.println(function2.apply(<span class="hljs-number">1112</span>));<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test32</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">//Supplier&lt;Double&gt; supplier2 = () -&gt; Math.random();</span><br>		Supplier&lt;Double&gt; supplier2 = Math::random;<br>		System.out.println(supplier2.get());<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test12</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">//Consumer&lt;String&gt; consumer2 = t -&gt; System.out.println(t);</span><br>		Consumer&lt;String&gt; consumer2 = System.out::println;<br>		consumer2.accept(<span class="hljs-string">&quot;lkjxlkcjccc&quot;</span>);<br>	&#125;<br>	<br>	<span class="hljs-comment">// 写一个判定器, 判断一个学生是否及格</span><br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exer4</span><span class="hljs-params">()</span> </span>&#123;<br>		Predicate&lt;Integer&gt; predicate1 = <span class="hljs-keyword">new</span> Predicate&lt;Integer&gt;() &#123;<br>			<span class="hljs-meta">@Override</span><br>			<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(Integer t)</span> </span>&#123;<br>				<span class="hljs-keyword">return</span> t&gt;= <span class="hljs-number">60</span>;<br>			&#125;<br>		&#125;;<br>		<span class="hljs-keyword">boolean</span> test = predicate1.test(<span class="hljs-number">100</span>);<br>		System.out.println(test);<br>		<br>		Predicate&lt;Integer&gt; predicate2 = t -&gt; t &gt;= <span class="hljs-number">60</span>;<br>		System.out.println(predicate2.test(<span class="hljs-number">100</span>));<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span> </span>&#123;<br>		Predicate&lt;Integer&gt; predicate1 = <span class="hljs-keyword">new</span> Predicate&lt;Integer&gt;() &#123;<br>			<span class="hljs-meta">@Override</span><br>			<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(Integer t)</span> </span>&#123;<br>				<span class="hljs-keyword">return</span> t % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<br>			&#125;<br>		&#125;;<br>		<span class="hljs-keyword">boolean</span> test = predicate1.test(<span class="hljs-number">83</span>);<br>		System.out.println(test);<br>		<br>		Predicate&lt;Integer&gt; predicate2 = t -&gt; t % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<br>		System.out.println(predicate2.test(<span class="hljs-number">20</span>));<br>	&#125;<br>	<br>	<span class="hljs-comment">// 写一个转换器, 把学生对象转换成字符串, 内容是姓名+分数</span><br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exer3</span><span class="hljs-params">()</span> </span>&#123;<br>		Function&lt;Student, String&gt; function1 = <span class="hljs-keyword">new</span> Function&lt;Student, String&gt;() &#123;<br>			<span class="hljs-meta">@Override</span><br>			<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">apply</span><span class="hljs-params">(Student t)</span> </span>&#123;<br>				<span class="hljs-keyword">return</span> t.getName() + <span class="hljs-string">&quot;:&quot;</span> + t.getScore();<br>			&#125;<br>		&#125;;<br>		String apply = function1.apply(<span class="hljs-keyword">new</span> Student(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;小刚&quot;</span>, <span class="hljs-number">5</span>, <span class="hljs-number">80</span>));<br>		System.out.println(apply);<br>		<br>		Function&lt;Student, String&gt; function2 = t -&gt; t.getName() + <span class="hljs-string">&quot;:&quot;</span> + t.getScore();<br>		System.out.println(function2.apply(<span class="hljs-keyword">new</span> Student(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;小花&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">100</span>)));<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>&#123;<br>		Function&lt;Integer, String&gt; function1 = <span class="hljs-keyword">new</span> Function&lt;Integer, String&gt;() &#123;<br>			<span class="hljs-meta">@Override</span><br>			<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">apply</span><span class="hljs-params">(Integer t)</span> </span>&#123;<br>				<span class="hljs-keyword">return</span> String.valueOf(t);<br>			&#125;<br>		&#125;;<br>		<br>		String apply = function1.apply(<span class="hljs-number">9238</span>);<br>		System.out.println(apply);<br>		<br>		Function&lt;Integer, String&gt; function2 = t -&gt; String.valueOf(t);<br>		System.out.println(function2.apply(<span class="hljs-number">1112</span>));<br>	&#125;<br>	<br>	<span class="hljs-comment">// 写一个供给器, 每调用一次供给一个学生对象</span><br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exer2</span><span class="hljs-params">()</span> </span>&#123;<br>		Supplier&lt;Student&gt; supplier1 = <span class="hljs-keyword">new</span> Supplier&lt;Student&gt;() &#123;<br>			<span class="hljs-meta">@Override</span><br>			<span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>				<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Student();<br>			&#125;<br>		&#125;;<br>		Student student = supplier1.get();<br>		System.out.println(student);<br>		<br>		Supplier&lt;Student&gt; supplier2 = () -&gt; <span class="hljs-keyword">new</span> Student();<br>		System.out.println(supplier2.get());<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;<br>		Supplier&lt;Double&gt; supplier = <span class="hljs-keyword">new</span> Supplier&lt;Double&gt;() &#123;<br>			<span class="hljs-meta">@Override</span><br>			<span class="hljs-function"><span class="hljs-keyword">public</span> Double <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>				<span class="hljs-keyword">return</span> Math.random();<br>			&#125;<br>		&#125;;<br>		System.out.println(supplier.get());<br>		<br>		Supplier&lt;Double&gt; supplier2 = () -&gt; Math.random();<br>		System.out.println(supplier2.get());<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br>		Supplier&lt;Integer&gt; supplier1 = <span class="hljs-keyword">new</span> Supplier&lt;Integer&gt;() &#123;<br>			<span class="hljs-meta">@Override</span><br>			<span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>				<span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>			&#125;<br>		&#125;;<br>		Integer integer = supplier1.get();<br>		System.out.println(integer);<br>		<br>		Supplier&lt;Integer&gt; supplier2 = () -&gt; <span class="hljs-number">100</span>;<br>		Integer integer2 = supplier2.get();<br>		System.out.println(integer2);<br>	&#125;<br>	<br>	<span class="hljs-comment">// 写一个消费器, 消费一个Student对象.</span><br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exer1</span><span class="hljs-params">()</span> </span>&#123;<br>		Consumer&lt;Student&gt; consumer1 = <span class="hljs-keyword">new</span> Consumer&lt;Student&gt;() &#123;<br>			<span class="hljs-meta">@Override</span><br>			<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Student t)</span> </span>&#123;<br>				System.out.println(t);<br>			&#125;<br>		&#125;;<br>		consumer1.accept(<span class="hljs-keyword">new</span> Student());<br>		<br>		Consumer&lt;Student&gt; consumer2 = t -&gt; System.out.println(t);<br>		consumer2.accept(<span class="hljs-keyword">new</span> Student(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;小花&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">50</span>));<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br>		Consumer&lt;String&gt; consumer1 = <span class="hljs-keyword">new</span> Consumer&lt;String&gt;() &#123;<br>			<span class="hljs-meta">@Override</span><br>			<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(String t)</span> </span>&#123;<br>				System.out.println(t);<br>			&#125;<br>		&#125;;<br>		consumer1.accept(<span class="hljs-string">&quot;alsdkjfalksdjf&quot;</span>);<br>		<br>		Consumer&lt;String&gt; consumer2 = t -&gt; System.out.println(t);<br>		consumer2.accept(<span class="hljs-string">&quot;lkjxlkcjccc&quot;</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> java8;<br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.stream.Collectors;<br><span class="hljs-keyword">import</span> java.util.stream.Stream;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> javabean.Student;<br><span class="hljs-keyword">import</span> javabean.StudentTest;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Stream : </span><br><span class="hljs-comment"> * 	1) 不保存数据, 只负责处理数据</span><br><span class="hljs-comment"> * 	2) 处理数据不会造成原始数据的变化 , 每次处理都会产生新的流</span><br><span class="hljs-comment"> * 	3) 所有操作都是延迟执行的, 只有终止操作执行时才执行中间操作</span><br><span class="hljs-comment"> * 	4) 每个流只能&quot;消费&quot;一次, 消费过后就作废.</span><br><span class="hljs-comment"> * 	5) 单向, 一次性使用, 可以支持高并发...</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 典型的操作 :</span><br><span class="hljs-comment"> * 	1) 创建流(获取流) </span><br><span class="hljs-comment"> * 		1) 从集合获取流, 集合.stream();</span><br><span class="hljs-comment"> * 		2) 从数组获取流, Arrays.stream(Xxx[] arr);</span><br><span class="hljs-comment"> * 		3) 基于散数据, Stream.of(T... objs)</span><br><span class="hljs-comment"> * 		4) 使用供给器, 无限流</span><br><span class="hljs-comment"> * 	2) 中间操作, 多个中间操作就形成流水线, 是延迟执行的, 中间操作可以省略</span><br><span class="hljs-comment"> * 		***filter(Predicate p) : 让流中的每个对象都经过判定器, 如果结果为true留下, 如果是false丢弃. 产生新流</span><br><span class="hljs-comment"> * 		distinct(); 把流中的数据去重并产生新流, 依据对象的hashCode和equals</span><br><span class="hljs-comment"> * 		limit(long maxSize) 限制流中的最大数据量</span><br><span class="hljs-comment"> * 		skip(long n) 跳过前n个元素</span><br><span class="hljs-comment"> * 		***map(Function f) 让流中的每个对象都转换为新对象, 所以它的结果的流全变了.</span><br><span class="hljs-comment"> * 		sorted() 把流中的对象排序 , 自然排序</span><br><span class="hljs-comment"> * 		*sorted(Comparator c) 定制排序</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 	3) 终止操作, 一旦中止, 所有的中间操作就开始执行, 终止操作是必须的.</span><br><span class="hljs-comment"> * 		***forEach(Consumer c) : 让流中的每个对象都经过消费器消费一下.</span><br><span class="hljs-comment"> * 		findFirst() 返回流中的第一个对象</span><br><span class="hljs-comment"> * 		**count() 计数</span><br><span class="hljs-comment"> * 		**collect(采集器) 可以把结果集采集到一个新的容器中.</span><br><span class="hljs-comment"> * 		***reduce(BinaryOperator op) 把流中的对象两两处理最后产生一个结果</span><br><span class="hljs-comment"> *	</span><br><span class="hljs-comment"> *	Optional是一容器, 里面放一个引用, 如果引用为空, 获取时直接抛异常.</span><br><span class="hljs-comment"> *	防止空指针.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamTest</span> </span>&#123;<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exer6</span><span class="hljs-params">()</span> </span>&#123;<br>		List&lt;Student&gt; collect = StudentTest.getList()<br>					.stream()<br>					.distinct()<br>					.filter(t -&gt; t.getGrade() == <span class="hljs-number">3</span>)<br>					.filter(t -&gt; t.getScore() &lt; <span class="hljs-number">60</span>).sorted((o1, o2) -&gt; -(<span class="hljs-keyword">int</span>)(o1.getScore() - o2.getScore()))<br>					.collect(Collectors.toList());<br>		<span class="hljs-keyword">for</span> (Student student : collect) &#123;<br>			System.out.println(student);<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-comment">// 找出全校最高分</span><br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exer5</span><span class="hljs-params">()</span> </span>&#123;<br>		Optional&lt;Double&gt; reduce = StudentTest.getList().stream().distinct().map(t -&gt; t.getScore()).reduce((d1, d2) -&gt; d1 &gt; d2 ? d1 : d2);<br>		Double orElse = reduce.orElse((<span class="hljs-keyword">double</span>) <span class="hljs-number">999</span>);<br>		System.out.println(orElse);<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exer4</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">long</span> count = StudentTest.getList().stream().distinct().count();<br>		System.out.println(count);<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exer3</span><span class="hljs-params">()</span> </span>&#123;<br>		Optional&lt;Student&gt; findFirst = StudentTest.getList()<br>												.stream()<br>												.distinct()<br>												.filter(t -&gt; t.getGrade() == <span class="hljs-number">4</span>)<br>												.filter(t -&gt; t.getScore() &lt; <span class="hljs-number">60</span>).sorted((o1, o2) -&gt; -(<span class="hljs-keyword">int</span>)(o1.getScore() - o2.getScore()))<br>												.limit(<span class="hljs-number">2</span>).findFirst();<br>		<span class="hljs-comment">//Student student = findFirst.get();</span><br>		Student student = findFirst.orElse(<span class="hljs-keyword">new</span> Student()); <span class="hljs-comment">// 最大化减少空指针</span><br>		System.out.println(student);<br>	&#125;<br>		<br>	<span class="hljs-comment">// 3年级没有及格的同学倒序, 取出前2个.</span><br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exer2</span><span class="hljs-params">()</span> </span>&#123;<br>		StudentTest.getList()<br>					.stream()<br>					.distinct()<br>					.filter(t -&gt; t.getGrade() == <span class="hljs-number">3</span>)<br>					.filter(t -&gt; t.getScore() &lt; <span class="hljs-number">60</span>).sorted((o1, o2) -&gt; -(<span class="hljs-keyword">int</span>)(o1.getScore() - o2.getScore()))<br>					.limit(<span class="hljs-number">2</span>).forEach(System.out::println);<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test9</span><span class="hljs-params">()</span> </span>&#123;<br>		StudentTest.getList().stream().distinct().sorted((t1, t2) -&gt; (<span class="hljs-keyword">int</span>)(t1.getScore() - t2.getScore())).forEach(System.out::println);<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test8</span><span class="hljs-params">()</span> </span>&#123;<br>		StudentTest.getList().stream().distinct().map(t -&gt; t.getScore()).forEach(System.out::println);<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test7</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">// 第6个到第10个</span><br>		StudentTest.getList().stream().distinct().skip(<span class="hljs-number">10</span>).limit(<span class="hljs-number">5</span>).forEach(System.out::println);<br>	&#125;<br>	<br>	<span class="hljs-comment">// 找出5年级姓张的同学</span><br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exer1</span><span class="hljs-params">()</span> </span>&#123;<br>		List&lt;Student&gt; list = StudentTest.getList();<br>		list.stream().filter(t -&gt; t.getGrade() == <span class="hljs-number">5</span>).filter(t -&gt; t.getName().startsWith(<span class="hljs-string">&quot;张&quot;</span>)).forEach(System.out::println);<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test62</span><span class="hljs-params">()</span> </span>&#123;<br>		List&lt;Student&gt; list = StudentTest.getList();<br>		list.stream().filter(t -&gt; t.getGrade() == <span class="hljs-number">3</span>).filter(t -&gt; t.getScore() &gt;= <span class="hljs-number">60</span>).forEach(System.out::println);<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test6</span><span class="hljs-params">()</span> </span>&#123;<br>		List&lt;Student&gt; list = StudentTest.getList();<br>		Stream&lt;Student&gt; stream = list.stream();<br>		Stream&lt;Student&gt; stream2 = stream.filter(t -&gt; t.getGrade() == <span class="hljs-number">3</span>);<br>		Stream&lt;Student&gt; stream3 = stream2.filter(t -&gt; t.getScore() &gt;= <span class="hljs-number">60</span>);<br>		stream3.forEach(System.out::println);<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span> </span>&#123;<br>		Stream.generate(Math::random).limit(<span class="hljs-number">10</span>).forEach(System.out::println);<span class="hljs-comment">// 无限流</span><br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>&#123;<br>		Stream&lt;Integer&gt; generate = Stream.generate(() -&gt; <span class="hljs-number">200</span>); <span class="hljs-comment">// 无限流</span><br>		generate.forEach(System.out::println);<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;<br>		Stream&lt;Number&gt; of = Stream.of(<span class="hljs-number">3.22</span>, <span class="hljs-number">9.33</span>, <span class="hljs-number">4.88</span>, <span class="hljs-number">4.2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>		of.forEach(System.out::println);<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br>		String[] arr = &#123;<span class="hljs-string">&quot;kjsf&quot;</span>, <span class="hljs-string">&quot;qqa&quot;</span>, <span class="hljs-string">&quot;cv&quot;</span>, <span class="hljs-string">&quot;XXX&quot;</span>&#125;;<br>		Stream&lt;String&gt; stream = Arrays.stream(arr);<br>		stream.forEach(System.out::println);<br>	&#125;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br>		List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>			list.add((<span class="hljs-keyword">int</span>)(Math.random() * <span class="hljs-number">20</span>));<br>		&#125;<br>		System.out.println(list);<br>		<br>		Stream&lt;Integer&gt; stream = list.stream();<br>		stream.forEach(System.out::println);<br>		<br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Mapreduce介绍</title>
    <url>/2020/11/23/MapReduce/</url>
    <content><![CDATA[<p>#MapReduce介绍</p>
<blockquote>
<p><em><strong>1.mapreduce编程思想</strong></em></p>
<blockquote>
<ul>
<li>适用于数据密集型的应用</li>
<li>mapreduce 采用分而治之的策略<blockquote>
<ul>
<li>把非常庞大的数据集，切分成非常多独立的小分片</li>
<li>然后为每一个分片单独地启动一个map任务</li>
<li>最终通过多个map任务，并行地在多个机器上去处理</li>
</ul>
</blockquote>
</li>
<li>mapreduce计算向数据靠拢的理念<blockquote>
<ul>
<li>计算向数据靠拢而不是数据向计算靠拢</li>
</ul>
</blockquote>
</li>
<li>Master/Slave架构 <blockquote>
<ul>
<li>一个Master服务器–》作业跟踪器JobTracker–》负责整个作业的调度和处理以及失败和恢复</li>
<li>若干个Slave服务器–》负责具体任务执行的组件TaskTracker–》负责接收JobTracker给它发的作业处理指令，完成具体的任务处理</li>
</ul>
</blockquote>
</li>
<li>map 函数的作用：将输入的一个键值对进行处理生成一批的键值对</li>
<li>reduce函数的作用： 输入：&lt;key,list(value)&gt;,就是一个键以及一堆值的列表。输出：&lt;key,value&gt;</li>
</ul>
</blockquote>
</blockquote>
<blockquote>
<p><em><strong>2.mapreduce体系结构</strong></em></p>
<blockquote>
<ul>
<li>Client客户端<blockquote>
<ul>
<li>通过Client可以提交用户编写的应用程序用户通过它将应用程序交到JobTracker端</li>
<li>通过这些Client用户也可以通过它提供的一些接口去查看当前提交作业的运行状态</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>JobTracker（作业跟踪器）<blockquote>
<ul>
<li>负责资源的监控和作业的调度</li>
<li>监控底层的其他TaskTracker以及当前运行的Job的健康状况</li>
<li>一旦探测到失败的情况就把这个任务转移到其它节点继续执行跟踪任务执行进度和资源使用量</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<ul>
<li>TaskTracker（任务调度器）<blockquote>
<ul>
<li>执行具体的相关任务一般接收JobTracker发送过来的命令</li>
<li>把一些自己的资源使用情况，以及任务的运行进度通过心跳的方式，也就是heartbeat发送给JobTracker（通过slot查看目前的资源使用情况。slot是一种资源调度单位，包括内存,CPU的资源）</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<ul>
<li>Task<blockquote>
<ul>
<li>map任务</li>
<li>reduce任务 </li>
</ul>
</blockquote>
</li>
<li><strong>3.mapreduce工程流程</strong>*</li>
<li>输入(分片操作)</li>
<li>Map任务（每个分片启动一个map任务）</li>
<li>Reduce任务</li>
<li>输出<br>shuffle 将map任务产生的中间结果（一系列的&lt;key,value&gt;）转换为 &lt;key,value-list&gt;<br>最优的Reduce任务个数取决于集群中可用的reduce任务槽（slot）的数目(一般比该数目稍小，这样可以预留一些系统资源处理可能发生的错误)</li>
</ul>
</blockquote>
</blockquote>
<blockquote>
<p><em><strong>4.shuffle过程解析</strong></em></p>
<blockquote>
<ul>
<li>Map端的Shuffle过程<blockquote>
<p>步骤：</p>
<ol>
<li>输入数据和执行Map任务</li>
<li>写入缓存</li>
<li>溢写（分区，排序，合并（要自己定义才执行））</li>
<li>文件归并</li>
</ol>
</blockquote>
</li>
<li>Reduce端的Shuffle过程 <blockquote>
<p>步骤：</p>
<ol>
<li>取数据</li>
<li>归并数据</li>
<li>把数据输入给Reduce任务</li>
</ol>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>MapReduce应用程序的执行过程：</strong><br>程序部署-》分配Map任务，分配Reduce任务-》读数据-》本地写数据-》远程读数据-》写数据<br><em><strong>5. mapreduce具体应用</strong></em> </p>
<blockquote>
<ul>
<li>关系代数运算 </li>
<li>分组聚合运算</li>
<li>矩阵乘法</li>
<li>矩阵运算</li>
<li>关系的自然连接</li>
</ul>
</blockquote>
</blockquote>
<blockquote>
<p><em><strong>6.mapreduce编程实践</strong></em></p>
</blockquote>
]]></content>
      <categories>
        <category>hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法介绍</title>
    <url>/2020/10/27/markdown-introduction/</url>
    <content><![CDATA[<h1 id="markdow语法的简单介绍"><a href="#markdow语法的简单介绍" class="headerlink" title="markdow语法的简单介绍"></a>markdow语法的简单介绍</h1><blockquote>
<ul>
<li>第一项：markdown标题  <blockquote>
<ul>
<li>用“#”号的个数来表示标题的级数</li>
</ul>
<ul>
<li>使用 = 和 - 标记一级和二级标题</li>
</ul>
</blockquote>
</li>
</ul>
<ul>
<li>第二项：段落格式<blockquote>
<ul>
<li>Markdown 段落没有特殊的格式<br>直接编写文字，<strong>段落的换行是使用两个以上空格加回车,也可以在段落后面使用一个空行来表示重新开始一个段落</strong>  </li>
</ul>
<ul>
<li><em><strong>字体：</strong></em><br>markdown可以使用斜体文本（一个<em>或_在文字的两边），粗体文本（两个</em>或_在文字的两边），粗斜体文本（三个）    </li>
</ul>
</blockquote>
</li>
<li>斜体文本*<br><em>斜体文本</em>    </li>
<li><em>粗体文本</em>*<br><strong>粗体文本</strong>    </li>
<li><strong>粗斜体文本</strong>*<br><em><strong>粗斜体文本</strong></em>    <blockquote>
<ul>
<li><em><strong>分隔线：</strong></em><br>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。    </li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<hr>
<hr>
<hr>
<blockquote>
<blockquote>
<ul>
<li><em><strong>删除线：</strong></em><br>删除线： 如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可<br><del>删除线</del></li>
<li><strong>下划线：</strong><br>下划线可以通过 HTML 的 <u> 标签来实现</u><br><u>下划线</u></li>
<li><strong>脚注：</strong><br>脚注是对文本的补充说明。<br>创建脚注格式类似这样 [^RUNOOB]。<br>[^RUNOOB]: 菜鸟教程 – 学的不仅是技术，更是梦想！！！</li>
</ul>
</blockquote>
<ul>
<li>第三项：列表<br>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容     <blockquote>
<ul>
<li><strong>嵌套列表：</strong><br>列表嵌套只需在子列表中的选项前面添加四个空格即可    </li>
</ul>
</blockquote>
</li>
<li>第四项：<strong>区块</strong><br>Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号<br>另外区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推<br>区块中可以使用列表，列表中也可以使用区块</li>
<li>第五项：<strong>markdown代码</strong><br><code>printf()</code>函数<br>如果是段落上的一个函数或片段的代码可以用反引号把它包起来(`)    <blockquote>
<ul>
<li>代码区块：<br>四个空格或者制表符（代码区块使用 4 个空格或者一个制表符（Tab 键）。）<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/6DC89E5C-B41A-4938-97D8-D7D06B879F91.jpg" alt="展示" title="结果展示"><br>你也可以用 ``` 包裹一段代码，并指定一种语言（也可以不指定）    </li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">include &lt;bits/stdc++.h&gt;    <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;hello world&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <br>&#125;    <br></code></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><strong>第六项：Markdown 链接:</strong><br>参考<a href="https://www.runoob.com/markdown/md-tutorial.html">菜鸟教程</a></li>
<li><strong>第七项：markdown 表格</strong><br>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。  </li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>表头</th>
<th>表头</th>
</tr>
</thead>
<tbody><tr>
<td>单元格</td>
<td>单元格</td>
</tr>
<tr>
<td>单元格</td>
<td>单元格</td>
</tr>
<tr>
<td>我们可以设置表格的对齐方式：</td>
<td></td>
</tr>
</tbody></table>
<pre><code>-: 设置内容和标题栏居右对齐。
:- 设置内容和标题栏居左对齐。
:-: 设置内容和标题栏居中对齐。
</code></pre>
<table>
<thead>
<tr>
<th align="left">左对齐</th>
<th align="right">右对齐</th>
<th align="center">居中对齐</th>
</tr>
</thead>
<tbody><tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
<tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
</tbody></table>
<blockquote>
<ul>
<li><strong>第八项：markdown高级技巧</strong><br>参考连接<a href="https://www.runoob.com/markdown/md-advance.html">菜鸟教程</a></li>
</ul>
</blockquote>
<hr>
<hr>
<p>本文参考菜鸟教程的markdown教学，超链接上文已给出。（<a href="https://www.runoob.com/markdown/md-tutorial.html%EF%BC%89">https://www.runoob.com/markdown/md-tutorial.html）</a></p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/2021/04/25/mysql/</url>
    <content><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><blockquote>
<ul>
<li>C/S 架构</li>
<li>服务器程序是 mysqld.exe</li>
<li>客户端程序是 mysql.exe</li>
<li>cmd的打开方式：</li>
</ul>
</blockquote>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">mysql -uroot -p123456 -h127.0.0.1 -P3306<br>长选项：<br>mysql <span class="hljs-attribute">--host</span>=主机地址 <span class="hljs-attribute">--port</span>=端口 <span class="hljs-attribute">--user</span>=用户名 <span class="hljs-attribute">--password</span>=密码 默认数据库<br></code></pre></td></tr></table></figure>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><blockquote>
<ul>
<li>查看服务器中的所有数据库</li>
</ul>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">databases</span>;<br></code></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>创建新的数据库</li>
<li>数据库以目录的形式保存在服务器<br>安装目录/data目录下</li>
</ul>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">databases</span>;<br></code></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>切换当前工作数据库<br>mysql&gt; use company;</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>查看当前数据库中的所有表<br>show tables;</li>
<li>跨库查看表<br>show tables from 其他库</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>把.sql文件中数据导入数据库<br>source e:sql/company.sql;</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>查看表中的所有数据<br>select * from employees;</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>创建world数据库, 并导入 world.sql , 查看表中的数据</li>
<li>create database world;</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>use world;</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>source d:/mywork/mysql/world.sql;</li>
<li>查看当前数据库<br>select database();</li>
<li>创建表</li>
</ul>
</blockquote>
<figure class="highlight crystal"><table><tr><td class="code"><pre><code class="hljs crystal">create table customer(<br>	id int,<br>	name varchar(<span class="hljs-number">20</span>),<br>	age int,<br>	email varchar(<span class="hljs-number">50</span>),<br>	gender <span class="hljs-class"><span class="hljs-keyword">enum</span>(&#x27;男&#x27;, &#x27;女&#x27;)</span><br>);<br></code></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>丢弃表<br>drop table customer;</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>查看表结构<br>describe customer;</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>desc 表名</li>
<li>查看表的建表语句<br>show create table 表名;</li>
<li>插入数据</li>
<li>存储引擎 : InnoDB(支持事务, 外键等高级特性), MyISAM(不支持事务, 不支持外键)</li>
<li>show engines;显示支持的引擎</li>
<li>``号专门用于包围数据库对象的名称(数据库, 表, 列, 主键, 外键, 索引, 函数, 存储过程, 触发器)<br>查询表中的所有数据</li>
<li>select * from 表名; from关键字可以省略</li>
</ul>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">插入数据<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> customer(<br>	<span class="hljs-keyword">id</span>,<br>	<span class="hljs-keyword">name</span>,<br>	age,<br>	email,<br>	gender <br>) <span class="hljs-keyword">values</span> (<br>	<span class="hljs-number">1</span>,<br>	<span class="hljs-string">&#x27;张三&#x27;</span>,<br>	<span class="hljs-number">30</span>,<br>	<span class="hljs-string">&#x27;zhang3@qq.com&#x27;</span>,<br>	<span class="hljs-string">&#x27;男&#x27;</span><br>);<br></code></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>修改数据, 如果没有where 语句会导致修改所有记录</li>
</ul>
</blockquote>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">update<span class="hljs-built_in"> customer </span><span class="hljs-builtin-name">set</span> <br>	age = 3,<br>	email = <span class="hljs-string">&#x27;QQQ&#x27;</span><br>where <br>	id = 1;<br></code></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>删除数据, 如果没有where语句会导致删除所有记录</li>
</ul>
</blockquote>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">delete <span class="hljs-keyword">from</span> customer<br>where id = 3;<br></code></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>针对数据的操作.</li>
</ul>
</blockquote>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">C insert into  <span class="hljs-regexp">//</span>Create <br>R select 		<span class="hljs-regexp">//</span>Retrieve<br>U update 		<span class="hljs-regexp">//</span>Update<br>D <span class="hljs-keyword">delete</span> 		<span class="hljs-regexp">//</span>Delete<br></code></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>查看表结构 :<br>desc 表名;</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>SQL注意 :<blockquote>
<ul>
<li>SQL 语言大小写不敏感。 </li>
<li>SQL 可以写在一行或者多行</li>
<li>关键字不能被缩写也不能分行</li>
<li>各子句一般要分行写。</li>
<li>使用缩进提高语句的可读性。</li>
</ul>
</blockquote>
</li>
<li>给列起别名, 可以省略as关键字, 别名中如果有特殊符号, 可以使用””包围.</li>
</ul>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <br>	population <span class="hljs-keyword">as</span> pop,<br>	<span class="hljs-keyword">name</span> <span class="hljs-string">&quot;国家 名称&quot;</span>,<br>	code<br><span class="hljs-keyword">from</span> <br>	country;<br></code></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>where 条件布尔(一个表达式，返回结果永远是一个布尔值)</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>执行顺序SQL：先from, 再where 最后select </li>
</ul>
</blockquote>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">SELECT</span> <span class="hljs-string"></span><br>	<span class="hljs-attr">employee_id</span> <span class="hljs-string">empId, </span><br>	<span class="hljs-attr">last_name</span> <span class="hljs-string">name, </span><br>	<span class="hljs-attr">job_id</span> <span class="hljs-string">job, </span><br>	<span class="hljs-attr">department_id</span> <span class="hljs-string">deptId</span><br><span class="hljs-attr">FROM</span>   <span class="hljs-string"></span><br>	<span class="hljs-attr">employees</span><br><span class="hljs-attr">WHERE</span>  <span class="hljs-string"></span><br>	<span class="hljs-attr">department_id</span> = <span class="hljs-string">90 ;</span><br>	<br><span class="hljs-meta">--</span> <span class="hljs-string">错误!! where中不可以使用列的别名, 因为此时虚表的列还没有生成好.</span><br></code></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>Between a and b 都包含</li>
<li>like <blockquote>
<ul>
<li>% 表示任意个任意字符</li>
<li>_ 表示一个任意字符</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">查询姓名中第2个字母是o其他无所谓<br><span class="hljs-keyword">SELECT</span> last_name<br><span class="hljs-keyword">FROM</span>   employees<br><span class="hljs-keyword">WHERE</span>  last_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;_o%&#x27;</span>;<br></code></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>只要有null参与比较运算, 结果一定是false</li>
</ul>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">查询哪些国家没有首都<br>只要有null参与比较运算, 结果一定是false<br><span class="hljs-comment">--错误!!</span><br><span class="hljs-keyword">select</span> <br>	<span class="hljs-keyword">name</span>,<br>	continent,<br>	capital<br><span class="hljs-keyword">from</span> <br>	country <br><span class="hljs-keyword">where</span> <br>	capital = <span class="hljs-literal">null</span>;<br>	<br>查询哪些国家没有首都<br><span class="hljs-keyword">select</span> <br>	<span class="hljs-keyword">name</span>,<br>	continent,<br>	capital<br><span class="hljs-keyword">from</span> <br>	country <br><span class="hljs-keyword">where</span> <br>	capital <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span>;<br><br>查询哪些国家有首都<br><span class="hljs-keyword">select</span> <br>	<span class="hljs-keyword">name</span>,<br>	continent,<br>	capital<br><span class="hljs-keyword">from</span> <br>	country <br><span class="hljs-keyword">where</span> <br>	capital <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>where 也支持算术运算, 结果为0表示假非0表示真</li>
<li>distinct 去重, 要求列真的有重复的</li>
</ul>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span><br>	<span class="hljs-keyword">distinct</span><br>		continent,<br>		<span class="hljs-keyword">name</span><br><span class="hljs-keyword">from</span><br>	country;<br></code></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>order by  可以排序, 只是给结果集虚表排序</li>
<li>默认是升充(asc)    </li>
<li>降序必须指定(desc)</li>
<li>order by 可以使用列的别名.</li>
<li>order by  列1, 列2 先以列1排序, 再在相同的列1数据中, 再依据列2再微排.</li>
</ul>
</blockquote>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> <br>	last_name, <br>	department_id, <br>	salary<br><span class="hljs-keyword">FROM</span>   <br>	employees<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <br>	department_id, <br>	salary <span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>写SQL的步骤 : <blockquote>
<ul>
<li>(1) from 基表</li>
<li>(2) where 过滤哪些行</li>
<li>(3) select 选择哪些列</li>
<li>(4) order by 以哪些列为排序依据. </li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h3 id="表联接"><a href="#表联接" class="headerlink" title="表联接"></a>表联接</h3><figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql">表联接<br><span class="hljs-keyword">select</span> <br>	* <br><span class="hljs-keyword">from</span> <br>	city2,<br>	country2;<br>笛卡尔集中的数据绝大多数都是垃圾, 必须使用行过滤.<br></code></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>笛卡尔集中的数据绝大多数都是垃圾, 必须使用行过滤.</li>
<li>解决列名冲突可以使用表名限定</li>
</ul>
</blockquote>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">解决列名冲突可以使用表名限定<br><span class="hljs-keyword">select</span> <br>	city2.name cityName,<br>	city2.population cityPop,<br>	country2.name countryName,<br>	country2.population countryPop,<br>	country2.continent<br><span class="hljs-keyword">from</span> <br>	city2,<br>	country2<br><span class="hljs-keyword">where</span> <br>	countrycode = code;<br>	<br><span class="hljs-comment">--表名也可以起别名, 而且是如果多表联接, 最好起别名.</span><br><span class="hljs-keyword">select</span> <br>	ci.name cityName,<br>	ci.population cityPop,<br>	co.name countryName,<br>	co.population countryPop,<br>	co.continent<br><span class="hljs-keyword">from</span> <br>	city2 ci,<br>	country2 co <br><span class="hljs-keyword">where</span> <br>	ci.countrycode = co.code;<br>	<br><span class="hljs-comment">--一旦给表起了别名, 原名不可以使用, 必须使用别名. 原因是from最先执行, 它把原始表名变了.</span><br><span class="hljs-keyword">select</span> <br>	city2.name cityName,<br>	city2.population cityPop,<br>	country2.name countryName,<br>	country2.population countryPop,<br>	country2.continent<br><span class="hljs-keyword">from</span> <br>	city2 ci,<br>	country2 co <br><span class="hljs-keyword">where</span> <br>	city2.countrycode = country2.code;//错误，要用已经声明的别名<br></code></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">考试_day03 :<br><br>1 哪些国家没有列出任何使用语言？(2种做法)<br><span class="hljs-keyword">select</span> <br>	co.name,<br>	cl.language<br><span class="hljs-keyword">from</span> <br>	country co <br><span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> <br>	countrylanguage cl <br><span class="hljs-keyword">on</span> <br>	co.code = cl.countrycode<br><span class="hljs-keyword">where</span> <br>	cl.language <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">select</span> <br>	co.name,<br>	<span class="hljs-keyword">count</span>(cl.language) ct <br><span class="hljs-keyword">from</span> <br>	country co <br><span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> <br>	countrylanguage cl <br><span class="hljs-keyword">on</span> <br>	co.code = cl.countrycode<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <br>	co.name<br><span class="hljs-keyword">having</span> <br>	ct = <span class="hljs-number">0</span>;<br><br>2 列出在城市表中80%人口居住在城市的国家<br><span class="hljs-keyword">select</span> <br>	co.name,<br>	<span class="hljs-keyword">sum</span>(ci.population),<br>	co.population<br><span class="hljs-keyword">from</span> <br>	city ci <br><span class="hljs-keyword">join</span> <br>	country co <br><span class="hljs-keyword">on</span> <br>	ci.countrycode = co.code <br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <br>	co.name<br><span class="hljs-keyword">having</span> <br>	<span class="hljs-keyword">sum</span>(ci.population) / co.population &gt; <span class="hljs-number">0.8</span>;<br><br><br>3 查询人均寿命最长和最短的国家的名称及人均寿命<br><span class="hljs-keyword">select</span><br>	<span class="hljs-keyword">name</span>,<br>	LifeExpectancy<br><span class="hljs-keyword">from</span> <br>	country <br><span class="hljs-keyword">where</span> <br>	LifeExpectancy <span class="hljs-keyword">in</span> ((<span class="hljs-keyword">select</span> <span class="hljs-keyword">max</span>(LifeExpectancy) <span class="hljs-keyword">from</span> country), (<span class="hljs-keyword">select</span> <span class="hljs-keyword">min</span>(LifeExpectancy) <span class="hljs-keyword">from</span> country));<br><br>4 查询哪些国家没有官方语言<br><span class="hljs-keyword">select</span><br>	co.name,<br>	cl.language<br><span class="hljs-keyword">from</span> <br>	countrylanguage cl <br><span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> <br>	country co <br><span class="hljs-keyword">on</span> <br>		cl.countrycode = co.code <br>	<span class="hljs-keyword">and</span><br>		cl.isofficial = <span class="hljs-string">&#x27;T&#x27;</span> <br><span class="hljs-keyword">where</span> 	 <br>	cl.isofficial <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span>;<br><br><br>5 查询所有国家的首都和使用率最高的官方语言(选做)<br><span class="hljs-keyword">select</span> <br>	co.name,<br>	ci.name,<br>	cl3.language,<br>	cl3.percentage<br><span class="hljs-keyword">from</span> <br>	country co <br><span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> <br>	city ci <br><span class="hljs-keyword">on</span> <br>	co.capital = ci.id <br><span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> <br>	(<span class="hljs-keyword">select</span> <br>		cl.countrycode,<br>		cl.language,<br>		cl.percentage,<br>		cl.isofficial<br>	<span class="hljs-keyword">from</span> <br>		countrylanguage cl <br>	<span class="hljs-keyword">join</span>  <br>		(<span class="hljs-keyword">select</span> countrycode, <span class="hljs-keyword">max</span>(Percentage) maxPer <span class="hljs-keyword">from</span> countrylanguage <span class="hljs-keyword">where</span> isofficial = <span class="hljs-string">&#x27;T&#x27;</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> countrycode) cl2<br>	<span class="hljs-keyword">on</span> <br>			cl.countrycode = cl2.countrycode <br>		<span class="hljs-keyword">and</span> <br>			cl.percentage = cl2.maxPer<br>	<span class="hljs-keyword">where</span> <br>		cl.isofficial = <span class="hljs-string">&#x27;T&#x27;</span><br>	) cl3<br><span class="hljs-keyword">on</span> <br>	co.code = cl3.countrycode <br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <br>	cl3.percentage;<br>		<br><br><br>创建数据库 <br><span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> 数据库名 <span class="hljs-keyword">charset</span> utf8;<br><br>修改数据库 只能修改字符集<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">database</span> 数据库名 <span class="hljs-keyword">charset</span> 新字符集;<br><br>丢弃数据库<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">database</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">exists</span> 数据加名;<br><br>查看库或表<br><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span>(<span class="hljs-keyword">table</span>) 数据库名或表名<br><br><span class="hljs-keyword">SQL</span>语言分类<br>	<span class="hljs-number">1</span>) DML 数据操纵语言, 主要处理数据<br>		<span class="hljs-keyword">insert</span> <span class="hljs-keyword">select</span> <span class="hljs-keyword">update</span> <span class="hljs-keyword">delete</span> <br>		<br>	<span class="hljs-number">2</span>) <span class="hljs-keyword">DDL</span> 数据定义语言, 主要处理数据库对象<br>		<span class="hljs-keyword">create</span> <span class="hljs-keyword">show</span> <span class="hljs-keyword">alter</span> <span class="hljs-keyword">drop</span> <br>		<br>	<span class="hljs-number">3</span>) DCL 数据控制语句, 主要用于控制事务<br>		<span class="hljs-keyword">commit</span> <span class="hljs-keyword">rollback</span><br><br>创建表<br><span class="hljs-number">1</span>) 全新方式建表<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> 表名(<br>	列<span class="hljs-number">1</span> 数据类型<span class="hljs-number">1</span>(长度) 其他选项,<br>	列<span class="hljs-number">2</span> 数据类型<span class="hljs-number">2</span>(长度) 其他选项,<br>	......,<br>	primary <span class="hljs-keyword">key</span>(列) <span class="hljs-comment">-- 表级主键</span><br>) <span class="hljs-keyword">engine</span> 数据库引擎 <span class="hljs-keyword">charset</span> 字符集;<br><br>数据库引擎 : <br>	InnoDB : 缺省引擎, 支持事务, 外键等高级特性, 速度慢<br>	MyIsam : 速度快, 早期的缺省引擎, 不支持事务,外键等高级特性<br><br>其他选项 : auto_increment, default 缺省值, not null, unique.<br><br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> teacher(<br>	<span class="hljs-keyword">id</span> <span class="hljs-built_in">int</span> auto_increment,<br>	<span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>),<br>	age <span class="hljs-built_in">int</span>,<br>	phone <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>),<br>	address <span class="hljs-built_in">varchar</span>(<span class="hljs-number">100</span>),<br>	gender enum(<span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>) <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;男&#x27;</span>,<br>	primary <span class="hljs-keyword">key</span>(<span class="hljs-keyword">id</span>)<br>) <span class="hljs-keyword">engine</span> <span class="hljs-keyword">innodb</span> <span class="hljs-keyword">charset</span> gbk;<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> classes(<br>	<span class="hljs-keyword">id</span> <span class="hljs-built_in">int</span> auto_increment,<br>	<span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">30</span>),<br>	student_count <span class="hljs-built_in">int</span>,<br>	room <span class="hljs-built_in">char</span>(<span class="hljs-number">3</span>),<br>	<span class="hljs-keyword">master</span> <span class="hljs-built_in">int</span>, <span class="hljs-comment">-- 班主任</span><br>	begindate <span class="hljs-built_in">date</span>,<br>	primary <span class="hljs-keyword">key</span>(<span class="hljs-keyword">id</span>)<br>);<br><br>// 创建学生表student, id, name, age, classes, phone.<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> student (<br>	<span class="hljs-keyword">id</span> <span class="hljs-built_in">int</span> auto_increment,<br>	<span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>,<br>	age <span class="hljs-built_in">int</span>,<br>	classes <span class="hljs-built_in">int</span>,<br>	phone <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">unique</span>,<br>	primary <span class="hljs-keyword">key</span>(<span class="hljs-keyword">id</span>)<br>);<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> teacher (<br>	<span class="hljs-keyword">name</span>,<br>	age,<br>	phone,<br>	address<br>) <span class="hljs-keyword">values</span> (<br>	<span class="hljs-string">&#x27;佟刚&#x27;</span>,<br>	<span class="hljs-number">40</span>,<br>	<span class="hljs-string">&#x27;234234&#x27;</span>, <br>	<span class="hljs-string">&#x27;北京昌平&#x27;</span><br>);<br><br>2) 基于子查询, 可以复制数据，不能复制各种约束（key）...<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> 表名 <br>子查询 <br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> country3 <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> world.country <span class="hljs-keyword">where</span> continent = <span class="hljs-string">&#x27;asia&#x27;</span>;<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> country4 <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> world.country;<br><br>3) 完全复制表结构，不能复制数据<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> 表名 <span class="hljs-keyword">like</span> 已有表名;<br><br>表结构的修改<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <br><span class="hljs-comment">--子句</span><br><br>添加新列<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <br><span class="hljs-keyword">add</span> 新列名 数据类型 其他选项;<br><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> teacher <br><span class="hljs-keyword">add</span> gender enum(<span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>) <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;男&#x27;</span>;<br><br>修改列<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <br><span class="hljs-keyword">modify</span> 列名 新数据类型 新其他选项;<br>+<span class="hljs-comment">---------+-----------------+------+-----+---------+----------------+</span><br>| Field   | Type            | Null | Key | Default | Extra          |<br>+<span class="hljs-comment">---------+-----------------+------+-----+---------+----------------+</span><br>| id      | int(11)         | NO   | PRI | NULL    | auto_increment |<br>| name    | varchar(20)     | YES  |     | NULL    |                |<br>| age     | int(11)         | YES  |     | NULL    |                |<br>| phone   | varchar(20)     | YES  |     | NULL    |                |<br>| address | varchar(100)    | YES  |     | NULL    |                |<br>| gender  | enum(&#x27;男&#x27;,&#x27;女&#x27;) | YES  |     | 男      |                |<br>+<span class="hljs-comment">---------+-----------------+------+-----+---------+----------------+</span><br><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> teacher <br><span class="hljs-keyword">modify</span> phone <span class="hljs-built_in">char</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>;<br><br><br>+<span class="hljs-comment">---------+-------------+------+-----+---------+----------------+</span><br>| Field   | Type        | Null | Key | Default | Extra          |<br>+<span class="hljs-comment">---------+-------------+------+-----+---------+----------------+</span><br>| id      | int(11)     | NO   | PRI | NULL    | auto_increment |<br>| name    | varchar(20) | NO   |     | NULL    |                |<br>| age     | int(11)     | YES  |     | NULL    |                |<br>| classes | int(11)     | YES  |     | NULL    |                |<br>| phone   | varchar(20) | YES  | UNI | NULL    |                |<br>+<span class="hljs-comment">---------+-------------+------+-----+---------+----------------+</span><br><br>// 给学生表添加新列address, 非空<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> student<br><span class="hljs-keyword">add</span> address <span class="hljs-built_in">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>;<br><br>// 把phone也改为char(11)<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> student <br><span class="hljs-keyword">modify</span> phone <span class="hljs-built_in">char</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">unique</span>;<br><br>// 再添加新列gender.<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> student <br><span class="hljs-keyword">add</span> gender enum(<span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>) <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;男&#x27;</span>;<br><br>修改列名<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <br><span class="hljs-keyword">change</span> 老列名 新列名 新数据类型 新其他选项;<br><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> teacher<br><span class="hljs-keyword">change</span> phone mobile <span class="hljs-built_in">char</span>(<span class="hljs-number">11</span>);<br><br>+<span class="hljs-comment">---------+-----------------+------+-----+---------+----------------+</span><br>| Field   | Type            | Null | Key | Default | Extra          |<br>+<span class="hljs-comment">---------+-----------------+------+-----+---------+----------------+</span><br>| id      | int(11)         | NO   | PRI | NULL    | auto_increment |<br>| name    | varchar(20)     | NO   |     | NULL    |                |<br>| age     | int(11)         | YES  |     | NULL    |                |<br>| classes | int(11)         | YES  |     | NULL    |                |<br>| phone   | char(11)        | YES  | UNI | NULL    |                |<br>| address | varchar(50)     | NO   |     | NULL    |                |<br>| gender  | enum(&#x27;男&#x27;,&#x27;女&#x27;) | YES  |     | 男      |                |<br>+<span class="hljs-comment">---------+-----------------+------+-----+---------+----------------+</span><br><br>把classes换成 class_id , phone也换成mobile, 要求之前的选项还保留.<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> student <br><span class="hljs-keyword">change</span> classes class_id <span class="hljs-built_in">int</span>;<br><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> student <br><span class="hljs-keyword">change</span> phone mobile <span class="hljs-built_in">char</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">unique</span>;<br><br><br>+<span class="hljs-comment">---------+-----------------+------+-----+---------+----------------+</span><br>| Field   | Type            | Null | Key | Default | Extra          |<br>+<span class="hljs-comment">---------+-----------------+------+-----+---------+----------------+</span><br>| id      | int(11)         | NO   | PRI | NULL    | auto_increment |<br>| name    | varchar(20)     | YES  |     | NULL    |                |<br>| age     | int(11)         | YES  |     | NULL    |                |<br>| mobile  | char(11)        | YES  |     | NULL    |                |<br>| address | varchar(100)    | YES  |     | NULL    |                |<br>| gender  | enum(&#x27;男&#x27;,&#x27;女&#x27;) | YES  |     | 男      |                |<br>+<span class="hljs-comment">---------+-----------------+------+-----+---------+----------------+</span><br><br>丢弃一个列, 此列对应的所有数据都会删除<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">column</span> 列名 <br><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> teacher<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">column</span> address;<br><br><br>丢弃表 <br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">exists</span> 表名<span class="hljs-number">1</span>, 表名<span class="hljs-number">2</span>, ....;<br><br>清空表数据<br><span class="hljs-keyword">truncate</span> <span class="hljs-keyword">table</span> 表名; <span class="hljs-comment">-- 它是一个DDL语句, 一旦清除,就不能回滚, 效率高.</span><br><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> 表名; <span class="hljs-comment">-- 它是一个DML语句, 意味着是可以回滚的. 效率低.</span><br><br>修改表名<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名<br><span class="hljs-keyword">rename</span> <span class="hljs-keyword">to</span> 新表名<br><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> teacher <br><span class="hljs-keyword">rename</span> <span class="hljs-keyword">to</span> teachers;<br><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> student <br><span class="hljs-keyword">rename</span> <span class="hljs-keyword">to</span> students;<br><br>teachers表<br>+<span class="hljs-comment">--------+-----------------+------+-----+---------+----------------+</span><br>| Field  | Type            | Null | Key | Default | Extra          |<br>+<span class="hljs-comment">--------+-----------------+------+-----+---------+----------------+</span><br>| id     | int(11)         | NO   | PRI | NULL    | auto_increment |<br>| name   | varchar(20)     | YES  |     | NULL    |                |<br>| age    | int(11)         | YES  |     | NULL    |                |<br>| mobile | char(11)        | YES  |     | NULL    |                |<br>| gender | enum(&#x27;男&#x27;,&#x27;女&#x27;) | YES  |     | 男      |                |<br>+<span class="hljs-comment">--------+-----------------+------+-----+---------+----------------+</span><br><br>插入数据 <br>1) 全新方式插入<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> 表名 (<br>	列<span class="hljs-number">1</span>,<br>	列<span class="hljs-number">2</span>,<br>	列<span class="hljs-number">3</span>,<br>	.....<br>) <span class="hljs-keyword">values</span> (<br>	值<span class="hljs-number">1</span>,<br>	值<span class="hljs-number">2</span>,<br>	值<span class="hljs-number">3</span>,<br>	....<br>)<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> teachers(<br>	<span class="hljs-keyword">name</span>,<br>	age,<br>	mobile <br>) <span class="hljs-keyword">values</span> (<br>	<span class="hljs-string">&#x27;阳哥&#x27;</span>,<br>	<span class="hljs-number">35</span>,<br>	<span class="hljs-string">&#x27;2342394&#x27;</span><br>);<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> teachers(<br>	<span class="hljs-keyword">name</span>,<br>	age,<br>	gender,<br>	mobile<br>) <span class="hljs-keyword">value</span> (<br>	<span class="hljs-string">&#x27;程程&#x27;</span>,<br>	<span class="hljs-number">20</span>,<br>	<span class="hljs-string">&#x27;女&#x27;</span>,<br>	<span class="hljs-string">&#x27;123342342&#x27;</span><br>);<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> teachers(<br>	<span class="hljs-keyword">name</span>,<br>	age,<br>	gender,<br>	mobile<br>) <span class="hljs-keyword">values</span> (<br>	<span class="hljs-string">&#x27;杨老师&#x27;</span>,<br>	<span class="hljs-number">40</span>,<br>	<span class="hljs-string">&#x27;男&#x27;</span>,<br>	<span class="hljs-string">&#x27;122342342&#x27;</span><br>), (<br>	<span class="hljs-string">&#x27;李老师&#x27;</span>,<br>	<span class="hljs-number">28</span>,<br>	<span class="hljs-string">&#x27;女&#x27;</span>,<br>	<span class="hljs-string">&#x27;234234234&#x27;</span><br>), (<br>	<span class="hljs-string">&#x27;王老师&#x27;</span>,<br>	<span class="hljs-number">37</span>,<br>	<span class="hljs-literal">null</span>,<br>	<span class="hljs-literal">null</span><br>);<br><br>2) 使用子查询插入.<br>+<span class="hljs-comment">----+--------+------+-----------+--------+</span><br>| id | name   | age  | mobile    | gender |<br>+<span class="hljs-comment">----+--------+------+-----------+--------+</span><br>|  1 | 佟刚   |   40 | 234234    | 男     |<br>|  2 | 阳哥   |   35 | 2342394   | 男     |<br>|  3 | 程程   |   20 | 123342342 | 女     |<br>|  4 | 杨老师 |   40 | 122342342 | 男     |<br>|  5 | 李老师 |   28 | 234234234 | 女     |<br>|  6 | 王老师 |   37 | NULL      | NULL   |<br>+<span class="hljs-comment">----+--------+------+-----------+--------+</span><br>6 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br><br>mysql&gt; <span class="hljs-keyword">desc</span> students;<br>+<span class="hljs-comment">----------+-----------------+------+-----+---------+----------------+</span><br>| Field    | Type            | Null | Key | Default | Extra          |<br>+<span class="hljs-comment">----------+-----------------+------+-----+---------+----------------+</span><br>| id       | int(11)         | NO   | PRI | NULL    | auto_increment |<br>| name     | varchar(20)     | NO   |     | NULL    |                |<br>| age      | int(11)         | YES  |     | NULL    |                |<br>| class_id | int(11)         | YES  |     | NULL    |                |<br>| mobile   | char(11)        | YES  | UNI | NULL    |                |<br>| address  | varchar(50)     | NO   |     | NULL    |                |<br>| gender   | enum(&#x27;男&#x27;,&#x27;女&#x27;) | YES  |     | 男      |                |<br>+<span class="hljs-comment">----------+-----------------+------+-----+---------+----------------+</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> students(<br>	<span class="hljs-keyword">name</span>,<br>	age,<br>	mobile,<br>	gender,<br>	address<br>) <span class="hljs-keyword">select</span> <br>	<span class="hljs-keyword">name</span>,<br>	age, <br>	mobile,<br>	gender,<br>	<span class="hljs-string">&#x27;北京&#x27;</span><br><span class="hljs-keyword">from</span> <br>	teachers <br><span class="hljs-keyword">where</span> <br>	<span class="hljs-keyword">id</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><br><span class="hljs-comment">-- 克隆表</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 新表 <span class="hljs-keyword">like</span> 旧表;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> 新表 <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> 旧表 <br><br>克隆城市表到当前库下新成中国城市表 (chinaCity)<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> chinaCity <span class="hljs-keyword">like</span> world.city; <br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> chinacity <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> world.city <span class="hljs-keyword">where</span> countrycode = <span class="hljs-string">&#x27;chn&#x27;</span>;<br><br>3) 插入一条数据 <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> 表名 <span class="hljs-keyword">set</span> 数据<br>+<span class="hljs-comment">--------+-----------------+------+-----+---------+----------------+</span><br>| <span class="hljs-keyword">Field</span>  | <span class="hljs-keyword">Type</span>            | <span class="hljs-literal">Null</span> | <span class="hljs-keyword">Key</span> | <span class="hljs-keyword">Default</span> | Extra          |<br>+<span class="hljs-comment">--------+-----------------+------+-----+---------+----------------+</span><br>| <span class="hljs-keyword">id</span>     | <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>)         | <span class="hljs-keyword">NO</span>   | PRI | <span class="hljs-literal">NULL</span>    | auto_increment |<br>| <span class="hljs-keyword">name</span>   | <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>)     | YES  |     | <span class="hljs-literal">NULL</span>    |                |<br>| age    | <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>)         | YES  |     | <span class="hljs-literal">NULL</span>    |                |<br>| mobile | <span class="hljs-built_in">char</span>(<span class="hljs-number">11</span>)        | YES  |     | <span class="hljs-literal">NULL</span>    |                |<br>| gender | enum(<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-string">&#x27;女&#x27;</span>) | YES  |     | 男      |                |<br>+<span class="hljs-comment">--------+-----------------+------+-----+---------+----------------+</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <br>	teachers <br><span class="hljs-keyword">set</span> <br>	<span class="hljs-keyword">name</span> = <span class="hljs-string">&#x27;丁老师&#x27;</span>,<br>	age = <span class="hljs-number">25</span>,<br>	mobile = <span class="hljs-string">&#x27;123234234&#x27;</span>;<br>	<br>修改数据 <br><span class="hljs-keyword">update</span> 表名 <span class="hljs-keyword">set</span> <br>	列<span class="hljs-number">1</span> = 值<span class="hljs-number">1</span>,<br>	列<span class="hljs-number">2</span> = 值<span class="hljs-number">2</span>,<br>	列<span class="hljs-number">3</span> = 值<span class="hljs-number">3</span>,<br>	....<br><span class="hljs-keyword">where</span> <br>	行过滤<br>	<br><span class="hljs-keyword">update</span> teachers <span class="hljs-keyword">set</span> <br>	age = <span class="hljs-number">40</span>,<br>	mobile = <span class="hljs-string">&#x27;135342342&#x27;</span><br><span class="hljs-keyword">where</span> <br>	<span class="hljs-keyword">id</span> = <span class="hljs-number">1</span>;<br>	<br>删除数据 <br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> 表名 <br><span class="hljs-keyword">where</span> 行过滤<br><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> teachers <br><span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> &gt; <span class="hljs-number">3</span><br><br>数据库事务<br>让数据从一种状态到另一种状态<br><br>让一组逻辑操作单元当成一个单个的命令来执行.<br>A 原子性 : 不可分割 <br>C 一致性 : 数据前后是一致<br>I 独立性 : 事务间, (独立性有等级)<br>D 持久性 : 事务一旦提交, 数据持久化.<br><br>设置提交状态：<span class="hljs-keyword">SET</span> AUTOCOMMIT = <span class="hljs-literal">FALSE</span>;<br>或者显式的执行 <span class="hljs-keyword">start</span> <span class="hljs-keyword">transaction</span><br>            或 <span class="hljs-keyword">begin</span><br>			<br>以第一个 DML 语句的执行作为开始<br><br>以下面的其中之一作为结束:<br><span class="hljs-keyword">COMMIT</span> 或 <span class="hljs-keyword">ROLLBACK</span> 语句<br><span class="hljs-keyword">DDL</span> 语句（自动提交）<br>用户会话正常结束, 提交<br>系统异常终止      回滚<br><br><span class="hljs-keyword">SET</span> AUTOCOMMIT = <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">set</span> autocommit = <span class="hljs-literal">false</span>;<br><br>用一个客户端在事务中删除表数据, 另一个客户端查询??<br><br>预编译 : 提前把SQL编译成可执行的, 在执行时只需要调用它即可.<br><span class="hljs-keyword">prepare</span> 预编译名 <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;SQL&#x27;</span>; <br><br><span class="hljs-keyword">prepare</span> p1 <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;select * from teachers&#x27;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>继续更新中</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Hbase简介</title>
    <url>/2020/11/17/HBase%20introduction/</url>
    <content><![CDATA[<p>#分布式数据库HBase简介</p>
<ol>
<li><p>概述    </p>
<ul>
<li>HBase是针对谷歌BigTable的开源实现，是一个高可靠，高性能，面向列，可伸缩的分布式数据库           </li>
<li>可以用来存储非结构化和半结构化的松散数据</li>
</ul>
</li>
<li><p>数据模型</p>
<ul>
<li>索引通过四个元素来定位：行键，列族，列限定符，时间戳</li>
<li> 面向列的存储</li>
</ul>
</li>
<li><p>实现原理 </p>
<ul>
<li>HBase的功能组件<blockquote>
<p>库函数<br>Master服务器<br>Region服务器    </p>
</blockquote>
</li>
<li>两个核心概念表和Region<blockquote>
<p>一个HBase表被划分成多个Region<br>一个Region会分裂成多个新的Region</p>
</blockquote>
</li>
<li>怎么实现Region定位<blockquote>
<p>三层结构索引实现Region的定位<br>Zookeeper文件<br>-ROOT-表<br>.MEAT.表      </p>
</blockquote>
</li>
</ul>
</li>
<li><p>运行机制</p>
<ul>
<li>HBase的系统架构<blockquote>
<p><img src="https://img-blog.csdnimg.cn/2020070104123335.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTE1NDU1OQ==,size_16,color_FFFFFF,t_70#pic_center" title="系统架构图"><br>Zookeeper服务器（被大量用于分布式系统，提供配置维护，域名服务，分布式同步服务）实现协同管理服务，提供管家功能（维护和管理整个HBase集群）<br>Master服务器作用：1.对表增删改查。2.负责不同Region服务器的负载均衡。3.负责调整分裂合并后Region的分布。4.负责重新分配故障，失效的Region服务器</p>
</blockquote>
</li>
<li>Region服务器（负责用户数据的存储和管理）的工作原理</li>
<li>Store的工作原理</li>
<li>HLog的工作原理</li>
</ul>
</li>
<li><p>编程实践<br>HBase安装及实践，参考厦门大学数据库实验室博客<br><a href="http://dblab.xmu.edu.cn/blog/2442-2/">参考链接</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
</search>
