<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Spark</title>
    <link href="/2021/08/27/Spark/"/>
    <url>/2021/08/27/Spark/</url>
    
    <content type="html"><![CDATA[<h1 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h1><h2 id="Spark入门"><a href="#Spark入门" class="headerlink" title="Spark入门"></a>Spark入门</h2><ul><li><p>spark是一种基于内存的快速，通用，可扩展的大数据分析计算引擎。</p></li><li><p>spark内置模块</p><p><a href="https://imgtu.com/i/h16ZB4"><img src="https://z3.ax1x.com/2021/08/28/h16ZB4.png" alt="h16ZB4.png"></a></p><ul><li>spark core：实现了Spark的基本功能，包含任务调度、内存管理、错误恢复、与存储系统交互等模块。Spark Core中还包含了对弹性分布式数据集(Resilient Distributed DataSet，简称RDD)的API定义。 </li><li>Spark SQL：是Spark用来操作结构化数据的程序包。通过Spark SQL，我们可以使用 SQL或者Apache Hive版本的HQL来查询数据。Spark SQL支持多种数据源，比如Hive表、Parquet以及JSON等。</li><li>Spark Streaming：是Spark提供的对实时数据进行流式计算的组件。提供了用来操作数据流的API，并且与Spark Core中的 RDD API高度对应。 </li><li>Spark MLlib：提供常见的机器学习功能的程序库。包括分类、回归、聚类、协同过滤等，还提供了模型评估、数据 导入等额外的支持功能。 </li><li>Spark GraphX：主要用于图形并行计算和图挖掘系统的组件。</li><li>集群管理器：Spark设计为可以高效地在一个计算节点到数千个计算节点之间伸缩计算。为了实现这样的要求，同时获得最大灵活性，Spark支持在各种集群管理器(Cluster Manager)上运行，包括Hadoop YARN、Apache Mesos，以及Spark自带的一个简易调度器，叫作独立调度器。</li></ul></li></ul><h3 id="Spark运行模式"><a href="#Spark运行模式" class="headerlink" title="Spark运行模式"></a>Spark运行模式</h3><ul><li><p>运行模式:单机模式，集群模式</p><ul><li>Local模式：本地部署单个spark模式</li><li>Standalone：spark自带的任务调度模式</li><li>YARN模式：spark使用Hadoop的YARN组件进行资源与任务调度。（重点）</li><li>Mesos模式：saprk使用Mesos平台进行资源与任务的调度。</li></ul></li><li><p>运行流程</p><ul><li>Spark有yarn-client和yarn-cluster两种模式，主要区别在于：Driver程序的运行节点。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大数据</tag>
      
      <tag>spark</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scala</title>
    <link href="/2021/08/10/Scala/"/>
    <url>/2021/08/10/Scala/</url>
    
    <content type="html"><![CDATA[<h1 id="Scala"><a href="#Scala" class="headerlink" title="Scala"></a>Scala</h1><h2 id="Scala简介"><a href="#Scala简介" class="headerlink" title="Scala简介"></a>Scala简介</h2><ul><li>Scala是一门多范式的编程语言，Scala支持面向对象和函数式编程。（多范式，就是多种编程方法的意思。有面向过程，面向对象，泛型，函数式四种程序设计方式。）</li></ul><h3 id="class和object说明"><a href="#class和object说明" class="headerlink" title="class和object说明"></a>class和object说明</h3><ul><li>object：从语法的角度上讲，上面的语法表示声明了一个伴生对象，但是还会生成一个伴生类。Scala是纯面向对象的，去除了java中的static关键字，通过伴生对象模拟static效果</li><li>伴生对象：伴随类产生的一个对象</li><li>对scala源文件进行编译后，默认会生成两个字节码文件，一个是伴生类另一个是伴生对象所属类（类名+一个$符号）</li><li>真正的伴生对象是伴生对象所属类中创建的单例对象</li><li>如果不想生成伴生类，可以手动生成，要求伴生类名称和伴生对象名称一致。</li><li>运行原理：<ul><li>java运行原理：先编译，再解释。.java源文件—&gt;编译器(javac)—&gt;.class字节码文件—&gt;JVM(java 不同平台)—&gt;机器指令</li><li>scala运行原理：先编译，再解释。.scala源文件—&gt;编译器(scalac)—&gt;.class字节码文件—&gt;JVM(scala 不同平台)—&gt;机器指令</li></ul></li></ul><h2 id="变量和数据类型"><a href="#变量和数据类型" class="headerlink" title="变量和数据类型"></a>变量和数据类型</h2><ul><li><p>注释和java规则一样。</p></li><li><p>变量 var 变量名[:变量类型]=初始值</p></li><li><p>常量 val 变量名[:变量类型]=初始值</p></li><li><p>声明变量时必须要有初始指</p></li><li><p>标识符业余java基本一致。特殊情况：（1）以字母或者下划线开头，后接字母、数字、下划线</p><p>（2）以操作符开头，且只包含操作符（+ - * / # !等）</p><p>（3）用反引号<code>....</code>包括的任意字符串，即使是Scala关键字（39个）也可以</p></li><li><p>键盘输入输出：</p></li><li><p>输出：（1）字符串，通过+号连接</p><p>（2）printf用法：字符串，通过%传值。</p><p>（3）字符串模板（插值字符串）：通过”$”获取变量值。</p><p>${}</p></li><li><p>输入：StdIn.readLine()、StdIn.readShort()、StdIn.readDouble()</p></li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li>Any：所有类的父类</li><li>AnyVal:(值类型)<ul><li>Byte,Short,Int,Long,Float,Double,Boolean,Char</li><li>Unit:表示返回值类型为空，相当于Java中的 void  关键字</li><li>StringOps:对自负床功能的 增强</li></ul></li><li>AnyRef（引用类型 ）<ul><li>所有java语言中的类</li><li>Scala  语言中的类</li><li>集合</li><li>Null：表示变量声明后，没有指向任何对象，相当于java中的null关键字</li></ul></li><li>Nothing :所有类的子类</li></ul><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul><li>char在java中是没有符号位的。char占两个字节。</li></ul><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><ul><li><p>面向对象编程：</p><ul><li>Scala是一个完全面向对象的编程语言，万物皆对象。</li><li>对象的本质：对数据和行为的一个封装。</li></ul></li><li><p>函数式编程：</p><ul><li>将问题分解成一个一个的步骤，将每一个步骤进行封装，通调用这些封装好的步骤。</li><li>Scala是一个完全函数式编程语言，万物皆函数。</li></ul></li><li><p>函数的本质：函数可以当做一个值进行传递。</p></li></ul><h4 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h4><ul><li><p>函数与方法的区别</p><ul><li>为完成某一功能的程序语句的集合，称为函数。</li><li>类中的函数称为方法</li><li>函数没有重载和重写的概念；方法可以进行重载和重写</li><li>Scala中函数可以嵌套定义</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">TestFunction</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>        <span class="hljs-comment">// （1）函数定义</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span></span>(arg: <span class="hljs-type">String</span>): <span class="hljs-type">Unit</span> = &#123;<br>            println(arg)<br>        &#125;<br>        <span class="hljs-comment">// （2）函数调用</span><br>        <span class="hljs-comment">// 函数名（参数）</span><br>        f(<span class="hljs-string">&quot;hello world&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>函数至简原则</p><ul><li><p>（1）return可以省略，Scala会使用函数体的最后一行代码作为返回值</p><p>（2）如果函数体只有一行代码，可以省略花括号</p><p>（3）返回值类型如果能够推断出来，那么可以省略（:和返回值类型一起省略）</p><p>（4）如果有return，则不能省略返回值类型，必须指定</p><p>（5）如果函数明确声明unit，那么即使函数体中使用return关键字也不起作用</p><p>（6）Scala如果期望是无返回值类型，可以省略等号</p><p>（7）如果函数无参，但是声明了参数列表，那么调用时，小括号，可加可不加</p><p>（8）如果函数没有参数列表，那么小括号可以省略，调用时小括号必须省略</p><p>（9）如果不关心名称，只关心逻辑处理，那么函数名（def）可以省略</p></li></ul></li></ul><h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><ul><li>函数可以作为值进行传递<ul><li>var f = 函数名 _</li><li>如果明确了变量的数据类型，那么下划线可以省略</li></ul></li><li>函数可以作为参数进行传递<ul><li>通过匿名函数</li><li>扩展函数的功能</li><li>提高函数的灵活度</li></ul></li><li>函数可以作为返回值进行传递<ul><li>函数的嵌套</li><li>函数链式调用，通过参数传递数据，在执行过程中，函数始终占据栈内存，容易导致内存溢出</li><li>闭包：内层函数访问外层函数的局部变量，会自动延长外层函数局部变量的生命周期，与内层函数形成一个闭合的效果，我们称之为闭包</li><li>柯里化：将一个参数列表中的多个参数，拆分为多个参数列表</li></ul></li><li>匿名函数：<ul><li>参数的类型可以省略，会根据形参进行自动的推导</li><li>类型省略之后，发现只有一个参数，则圆括号可以省略；其他情况：没有参数和参数超过1的永远不能省略圆括号。</li><li>匿名函数如果只有一行，则大括号也可以省略</li><li>如果参数只出现一次，则参数省略且后面参数可以用_代替</li></ul></li></ul><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h3><ul><li><p>在自然界中，只要是客观存在的都是对象（万物皆对象）</p></li><li><p>对大量对象共性的抽象，抽取为类</p><ul><li>有什么         属性</li><li>能做什么     方法</li></ul></li><li><p>在面向对象语言中，类是创建对象的模板</p></li><li><p>类是客观事务在人脑中的主观反映</p></li><li><p>Scala的属性：</p><ul><li>在Scala语言中，类，方法，属性，默认修饰符都是public，但是没有public关键字</li><li>对于Scala中的属性，底层会用private修饰，同时提供公开的设置以及获取属性的方法—-面向封装</li><li>如果要生成满足JavaBean规范的get和set方法的话，需要在属性上加@BeanProperty注解</li></ul></li><li><p>访问权限</p><ul><li><p>Java</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">private私有的，只能在本类中被访问<br>default默认的，可以在本类以及同包的其它类中被访问<br>protected受保护的，可以在本类、同包的其它类以及非同包的子类中被访问<br>public 公开的，所有类<br></code></pre></td></tr></table></figure></li><li><p>Scala</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">private</span>      私有的，只能在本类中被访问<br><span class="hljs-keyword">public</span>(默认)     公开的，所有类<br><span class="hljs-keyword">protected</span>  比Java设置的更严格，只能在本类以及子类中被访问，同包其他类访问不了<br><span class="hljs-keyword">private</span>[包名]  可以让指定的包进行访问<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h3><ul><li><p>构造器</p><ul><li><p>主构造方法</p><ul><li>在声明类的同时，主构造方法也被声明</li><li>主构造方法只能有一个</li><li>如果主构造方法没有参数，那么声明以及调用的时候，小括号可以省略。</li></ul></li><li><p>辅助构造方法</p><ul><li>方法名必修叫this</li><li>辅助构造方法可以重载</li><li>辅助构造方法中的第一行代码必须直接或者间接调用主构造方法</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">//（1）如果主构造器无参数，小括号可省略</span><br><span class="hljs-comment">//class Person ()&#123;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> = _<br><br>    <span class="hljs-keyword">var</span> age: <span class="hljs-type">Int</span> = _<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">this</span></span>(age: <span class="hljs-type">Int</span>) &#123;<br>        <span class="hljs-keyword">this</span>()<br>        <span class="hljs-keyword">this</span>.age = age<br>        println(<span class="hljs-string">&quot;辅助构造器&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">this</span></span>(age: <span class="hljs-type">Int</span>, name: <span class="hljs-type">String</span>) &#123;<br>        <span class="hljs-keyword">this</span>(age)<br>        <span class="hljs-keyword">this</span>.name = name<br>    &#125;<br><br>    println(<span class="hljs-string">&quot;主构造器&quot;</span>)<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br><br>        <span class="hljs-keyword">val</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>(<span class="hljs-number">18</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>继承</p><ul><li>class 子类名 extends 父类名  { 类体 }</li><li>Scala是单继承</li></ul></li><li><p>创建对象的方式</p><ul><li><p>new   底层调用的是构造方法</p></li><li><p>类名()  底层调用的是伴生对象中apply方法</p></li><li><p>实现单例设计模式</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Test</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br><br>        <span class="hljs-comment">//（1）通过伴生对象的apply方法，实现不使用new关键字创建对象。</span><br>        <span class="hljs-keyword">val</span> p1 = <span class="hljs-type">Person</span>()<br>        println(<span class="hljs-string">&quot;p1.name=&quot;</span> + p1.name)<br><br>        <span class="hljs-keyword">val</span> p2 = <span class="hljs-type">Person</span>(<span class="hljs-string">&quot;bobo&quot;</span>)<br>        println(<span class="hljs-string">&quot;p2.name=&quot;</span> + p2.name)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//（2）如果想让主构造器变成私有的，可以在()之前加上private</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-title">private</span>(<span class="hljs-params">cName: <span class="hljs-type">String</span></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> = cName<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(): <span class="hljs-type">Person</span> = &#123;<br>        println(<span class="hljs-string">&quot;apply空参被调用&quot;</span>)<br>        <span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>(<span class="hljs-string">&quot;xx&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(name: <span class="hljs-type">String</span>): <span class="hljs-type">Person</span> = &#123;<br>        println(<span class="hljs-string">&quot;apply有参被调用&quot;</span>)<br>        <span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>(name)<br>&#125;<br><span class="hljs-comment">//注意：也可以创建其它类型对象，并不一定是伴生类对象</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="特质和抽象类"><a href="#特质和抽象类" class="headerlink" title="特质和抽象类"></a>特质和抽象类</h3><ul><li><p>使用abstract关键字定义抽象类</p><ul><li>定义抽象类：abstract class Person{} //通过abstract关键字标记抽象类</li></ul></li><li><p>抽象类一般和抽象属性以及抽象方法配合使用</p></li><li><p>抽象属性</p><ul><li>属性只有声明，但是没有赋值</li><li>定义抽象属性：val|var name:String //一个属性没有初始化，就是抽象属性</li></ul></li><li><p>抽象方法</p><ul><li>方法只有声明，没有实现</li><li>定义抽象方法：def hello():String //只声明而没有实现的方法，就是抽象方法</li></ul></li><li><p>抽象类总结</p><ul><li>在一个类中，如果存在抽象属性或者抽象方法，那么这个类一定是抽象类</li><li>如果一个类是抽象类，那么它不一定包含抽象属性和抽象方法</li><li>如果一个类中存在抽象属性或者抽象方法，那么具体的实现应该交给子类完成</li><li>如果子类也实现不了抽象内容，那么子类也应该声明为抽象类</li><li>如果重写(实现)抽象属性或者方法，那么override关键字可以省略</li><li>如果重写(覆盖)非抽象属性或者方法，那么override关键字不能省略，必须得加</li><li>如果对非抽象属性进行覆盖，要求属性必须得用val修饰</li><li>可以通过super关键字调用父类的方法，但是不能super调用父类的属性</li></ul></li><li><p>在Scala中，属性和方法都是动态绑定</p><ul><li>静态绑定（编译器绑定）<ul><li>在编译阶段，确定属性或者方法所属类型，多态的时候根据这个来看。（编译看左，运行看右）</li></ul></li><li>动态绑定<ul><li>在运行阶段，根据实际创建的对象类型来决定属性或者方法所属类型</li></ul></li></ul></li></ul><h4 id="特质（Trait）"><a href="#特质（Trait）" class="headerlink" title="特质（Trait）"></a>特质（Trait）</h4><ul><li><p>Scala中采用特质trait来代替接口的概念。</p></li><li><p>Scala中的trait中即<strong>可以有抽象属性和方法，也可以有具体的属性和方法</strong>，<strong>一个类可以混入（mixin）多个特质</strong>。这种感觉类似于Java中的抽象类。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">PersonTrait</span> </span>&#123;<br><br>    <span class="hljs-comment">// 声明属性</span><br>    <span class="hljs-keyword">var</span> name:<span class="hljs-type">String</span> = _<br><br>    <span class="hljs-comment">// 声明方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">eat</span></span>():<span class="hljs-type">Unit</span>=&#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">// 抽象属性</span><br>    <span class="hljs-keyword">var</span> age:<span class="hljs-type">Int</span><br>    <br>    <span class="hljs-comment">// 抽象方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">say</span></span>():<span class="hljs-type">Unit</span><br>&#125;<br><span class="hljs-comment">//通过查看字节码，可以看到特质=抽象类+接口</span><br></code></pre></td></tr></table></figure></li><li><p>基本语法</p><ul><li><strong>没有父类</strong>：class  类名 <em><strong>extends</strong></em> 特质1  <em><strong>with</strong></em>  特质2  <em><strong>with</strong></em>  特质3 …</li><li><strong>有父类</strong>：class  类名  <em><strong>extends</strong></em> 父类  <em><strong>with</strong></em> 特质1  <em><strong>with</strong></em>  特质2  <em><strong>with</strong></em> 特质3…</li></ul></li><li><p>特质（trait）叠加：</p><ul><li><p>由于一个类可以混入（mixin）多个trait，且trait中可以有具体的属性和方法，若混入的特质中具有相同的方法（方法名，参数列表，返回值均相同），必然会出现继承冲突问题。冲突分为以下两种：</p><ul><li>第一种，一个类（Sub）混入的两个trait（TraitA，TraitB）中具有相同的具体方法，且两个trait之间没有任何关系，解决这类冲突问题，直接在类（Sub）中重写冲突方法。</li><li>第二种，一个类（Sub）混入的两个trait（TraitA，TraitB）中具有相同的具体方法，且两个trait继承自相同的trait（TraitC），及所谓的“钻石问题”，解决这类冲突问题，Scala采用了<em><strong>特质叠加</strong></em>的策略。</li></ul></li><li><p>特质叠加顺序</p><ul><li>第一步：列出第一个混入特质的继承关系，作为临时叠加的顺序</li><li>第二步：列出第二个混入特质的继承关系,并且该顺序放到临时叠加顺序的前面，已经出现的特质不在出现   </li><li>第三步：将子类放到临时叠加顺序的第一个</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Ball</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">describe</span></span>(): <span class="hljs-type">String</span> = &#123;<br>      <span class="hljs-string">&quot;ball&quot;</span><br>   &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Color</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Ball</span> </span>&#123;<br>   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">describe</span></span>(): <span class="hljs-type">String</span> = &#123;<br>      <span class="hljs-string">&quot;blue-&quot;</span> + <span class="hljs-keyword">super</span>.describe()<br>   &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Category</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Ball</span> </span>&#123;<br>   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">describe</span></span>(): <span class="hljs-type">String</span> = &#123;<br>      <span class="hljs-string">&quot;foot-&quot;</span> + <span class="hljs-keyword">super</span>.describe()<br>   &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBall</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Category</span> <span class="hljs-keyword">with</span> <span class="hljs-title">Color</span> </span>&#123;<br>   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">describe</span></span>(): <span class="hljs-type">String</span> = &#123;<br>      <span class="hljs-string">&quot;my ball is a &quot;</span> + <span class="hljs-keyword">super</span>.describe()<br>   &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">TestTrait</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>      println(<span class="hljs-keyword">new</span> <span class="hljs-type">MyBall</span>().describe())<br>   &#125;<br>&#125;<br><span class="hljs-comment">//注意：这个时候super不是调用父类中的方法了，而是调用特质叠加顺序上下一个节点的方法</span><br><span class="hljs-comment">//运行结果：my ball is a blue-foot-ball</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>特质和抽象类的区别</p><ul><li>优先使用特质。一个类扩展多个特质是很方便的，但却只能扩展一个抽象类。</li><li>如果你需要构造函数参数，使用抽象类。因为抽象类可以定义带参数的构造函数，而特质不行（有无参构造）。</li></ul></li><li><p>类型检查和转换</p><ul><li>obj.isInstanceOf[T]：判断obj是不是T类型。</li><li>obj.asInstanceOf[T]：将obj强转成T类型。</li><li>classOf获取对象的类名。</li></ul></li></ul><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="集合基本概述"><a href="#集合基本概述" class="headerlink" title="集合基本概述"></a>集合基本概述</h3><ul><li><p>存放单值类型</p><ul><li>Seq   有序，可重复</li><li>Set    无序，不能重复</li></ul></li><li><p>存放键值对</p><ul><li>Map   以k-v键值对的形式存放数据，其中key无序不能重复</li></ul></li><li><p>对于几乎所有的集合类，Scala都同时提供了可变和不可变的版本，分别位于以下两个包</p><ul><li>不可变集合：scala.collection.immutable<ul><li>对集合进行添加或者删除操作的时候，会创建新的集合对象</li></ul></li><li>可变集合：scala.collection.mutable<ul><li>对集合进行添加或者删除操作的时候，直接在原来的集合上操作，不会创建新的集合对象</li></ul></li></ul></li><li><p>数组</p><ul><li><p>Array</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">TestArray</span></span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br><br>        <span class="hljs-comment">//（1）数组定义</span><br>        <span class="hljs-keyword">val</span> arr01 = <span class="hljs-keyword">new</span> <span class="hljs-type">Array</span>[<span class="hljs-type">Int</span>](<span class="hljs-number">4</span>)<br>        println(arr01.length) <span class="hljs-comment">// 4</span><br>        <br>        <span class="hljs-keyword">var</span> arr02 = <span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;bobo&quot;</span>)<br>        println(arr02.length)<br>        <span class="hljs-keyword">for</span> (i &lt;- arr02) &#123;<br>            println(i)<br>        &#125;<br>        <span class="hljs-comment">//（2）数组赋值</span><br><br><br>        <span class="hljs-comment">//（2.1）修改某个元素的值</span><br>        arr01(<span class="hljs-number">3</span>) = <span class="hljs-number">10</span><br>        <span class="hljs-comment">//（2.2）采用方法的形式给数组赋值</span><br>        arr01.update(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<br><br>        <span class="hljs-comment">//（3）遍历数组</span><br>        <span class="hljs-comment">//（3.1）查看数组</span><br>        println(arr01.mkString(<span class="hljs-string">&quot;,&quot;</span>))<br><br>        <span class="hljs-comment">//（3.2）普通遍历</span><br>        <span class="hljs-keyword">for</span> (i &lt;- arr01) &#123;<br>            println(i)<br>        &#125;<br><br>        <span class="hljs-comment">//（3.3）简化遍历</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printx</span></span>(elem:<span class="hljs-type">Int</span>): <span class="hljs-type">Unit</span> = &#123;<br>            println(elem)<br>        &#125;<br>         arr01.foreach(printx)<br>        <span class="hljs-comment">// arr01.foreach((x)=&gt;&#123;println(x)&#125;)</span><br>        <span class="hljs-comment">// arr01.foreach(println(_))</span><br>        arr01.foreach(println)<br><br>        <span class="hljs-comment">//（4）增加元素（由于创建的是不可变数组，增加元素，其实是产生新的数组）</span><br>        println(arr01)<br>        <span class="hljs-keyword">val</span> ints: <span class="hljs-type">Array</span>[<span class="hljs-type">Int</span>] = arr01 :+ <span class="hljs-number">5</span><br>        println(ints)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>ArrayBuffer</p></li><li><p>多维数组</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">DimArray</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>        <br>        <span class="hljs-comment">//（1）创建了一个二维数组, 有三个元素，每个元素是，含有4个元素一维数组()</span><br>        <span class="hljs-keyword">val</span> arr = <span class="hljs-type">Array</span>.ofDim[<span class="hljs-type">Int</span>](<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br>        arr(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>) = <span class="hljs-number">88</span><br><br>        <span class="hljs-comment">//（2）遍历二维数组</span><br>        <span class="hljs-keyword">for</span> (i &lt;- arr) &#123; <span class="hljs-comment">//i 就是一维数组</span><br><br>            <span class="hljs-keyword">for</span> (j &lt;- i) &#123;<br>                print(j + <span class="hljs-string">&quot; &quot;</span>)<br>            &#125;<br><br>            println()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>Seq</p><ul><li><p>List</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">TestList</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br><br>        <span class="hljs-comment">//（1）List默认为不可变集合</span><br>        <span class="hljs-comment">//（2）创建一个List（数据有顺序，可重复）</span><br>        <span class="hljs-keyword">val</span> list: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>)<br>        <br>        <span class="hljs-comment">//（7）空集合Nil</span><br>        <span class="hljs-keyword">val</span> list5 = <span class="hljs-number">1</span>::<span class="hljs-number">2</span>::<span class="hljs-number">3</span>::<span class="hljs-number">4</span>::<span class="hljs-type">Nil</span><br><br>        <span class="hljs-comment">//（4）List增加数据</span><br>        <span class="hljs-comment">//（4.1）::的运算规则从右向左</span><br>        <span class="hljs-comment">//val list1 = 5::list</span><br>        <span class="hljs-keyword">val</span> list1 = <span class="hljs-number">7</span>::<span class="hljs-number">6</span>::<span class="hljs-number">5</span>::list<br>        <span class="hljs-comment">//（4.2）添加到第一个元素位置</span><br>        <span class="hljs-keyword">val</span> list2 = list.+:(<span class="hljs-number">5</span>)<br><br>        <span class="hljs-comment">//（5）集合间合并：将一个整体拆成一个一个的个体，称为扁平化</span><br>        <span class="hljs-keyword">val</span> list3 = <span class="hljs-type">List</span>(<span class="hljs-number">8</span>,<span class="hljs-number">9</span>)<br>        <span class="hljs-comment">//val list4 = list3::list1</span><br>        <span class="hljs-keyword">val</span> list4 = list3:::list1<br><br>        <span class="hljs-comment">//（6）取指定数据</span><br>        println(list(<span class="hljs-number">0</span>))<br><br>        <span class="hljs-comment">//（3）遍历List</span><br>        <span class="hljs-comment">//list.foreach(println)</span><br>        <span class="hljs-comment">//list1.foreach(println)</span><br>        <span class="hljs-comment">//list3.foreach(println)</span><br>        <span class="hljs-comment">//list4.foreach(println)</span><br>        list5.foreach(println)<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>ListBuffer</p></li></ul></li><li><p>Set</p></li><li><p>Map</p><ul><li><p>当调用map.get方法的时候，返回的Option类型数据,Option有两个子类型，一个Some，另一个None,可以帮我们避免对空值进行处理的情况，使用getOrElse函数，给空值赋默认值</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">TestMap</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>        <span class="hljs-comment">// Map</span><br>        <span class="hljs-comment">//（1）创建不可变集合Map</span><br>        <span class="hljs-keyword">val</span> map = <span class="hljs-type">Map</span>( <span class="hljs-string">&quot;a&quot;</span>-&gt;<span class="hljs-number">1</span>, <span class="hljs-string">&quot;b&quot;</span>-&gt;<span class="hljs-number">2</span>, <span class="hljs-string">&quot;c&quot;</span>-&gt;<span class="hljs-number">3</span> )<br><br>        <span class="hljs-comment">//（3）访问数据</span><br>        <span class="hljs-keyword">for</span> (elem &lt;- map.keys) &#123;<br>            <span class="hljs-comment">// 使用get访问map集合的数据，会返回特殊类型Option(选项):有值（Some），无值(None)</span><br>            println(elem + <span class="hljs-string">&quot;=&quot;</span> + map.get(elem).get)<br>        &#125;<br><br>        <span class="hljs-comment">//（4）如果key不存在，返回0</span><br>        println(map.get(<span class="hljs-string">&quot;d&quot;</span>).getOrElse(<span class="hljs-number">0</span>))<br>        println(map.getOrElse(<span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-number">0</span>))<br><br>        <span class="hljs-comment">//（2）循环打印</span><br>        map.foreach((kv)=&gt;&#123;println(kv)&#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="集合函数"><a href="#集合函数" class="headerlink" title="集合函数"></a>集合函数</h3><ul><li><p>基本属性和常用操作</p><p>（1）获取集合长度          length</p><p>（2）获取集合大小          size</p><p>（3）循环遍历                  foreach</p><p>（4）迭代器                      iterator</p><p>（5）生成字符串              mkString</p><p>（6）是否包含                  contains</p></li><li><p>衍生集合</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">（<span class="hljs-number">1</span>）获取集合的头<br>head<br>（<span class="hljs-number">2</span>）获取集合的尾（不是头的就是尾）<br>tail<br>（<span class="hljs-number">3</span>）集合最后一个数据<br>last<br>（<span class="hljs-number">4</span>）集合初始数据（不包含最后一个）<br>init<br>（<span class="hljs-number">5</span>）反转<br>reverse<br>（<span class="hljs-number">6</span>）取前（后）n个元素<br>take|takeRight<br>（<span class="hljs-number">7</span>）去掉前（后）n个元素<br>drop|dropRight<br>（<span class="hljs-number">8</span>）并集<br>union<br>（<span class="hljs-number">9</span>）交集<br><span class="hljs-built_in">int</span>ersect<br>（<span class="hljs-number">10</span>）差集<br>diff<br>（<span class="hljs-number">11</span>）拉链<br>zip<br>（<span class="hljs-number">12</span>）滑窗<br>sliding<br></code></pre></td></tr></table></figure></li><li><p>集合计算初级，高级函数</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">（<span class="hljs-number">1</span>）求和<br>sum<br>（<span class="hljs-number">2</span>）求乘积<br>product<br>（<span class="hljs-number">3</span>）最大值<br>max<br>（<span class="hljs-number">4</span>）最小值<br>min<br>（<span class="hljs-number">5</span>）排序<br>sorded|sortBy|sortWith<br><br>集合计算高级函数：<br>（<span class="hljs-number">1</span>）过滤 filter(函数：指定过滤条件) <br> 遍历一个集合并从中获取满足指定条件的元素组成一个新的集合<br><br>（<span class="hljs-number">2</span>）转换/映射  map<br> <br>（<span class="hljs-number">3</span>）扁平化 flatten   :::<br>将集合中元素由整体转换为个体的过程<br><br>（<span class="hljs-number">4</span>）扁平映射  flatMap  <br>先映射再进行扁平化处理<br><br>（<span class="hljs-number">5</span>）分组gruopBy<br>按照一定的分组规则，将集合中的元素放到不同的组中<br><br>（<span class="hljs-number">6</span>）简化|规约<br>&gt;对集合内部元素之间进行聚合 <br>&gt;reduce   聚合的数据类型一致<br>&gt;reduceLeft|reduceRight 聚合的数据类型可以不一致<br><br>（<span class="hljs-number">7</span>）折叠<br>&gt;对外部元素和集合内部元素之间进行聚合<br>&gt;fold 聚合的数据类型一致<br>&gt;foldLeft|foldRight聚合的数据类型可以不一致<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Scala</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Scala</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>warehouse-project</title>
    <link href="/2021/07/29/warehouse-project/"/>
    <url>/2021/07/29/warehouse-project/</url>
    
    <content type="html"><![CDATA[<h1 id="离线数仓项目"><a href="#离线数仓项目" class="headerlink" title="离线数仓项目"></a>离线数仓项目</h1><h2 id="数仓分层"><a href="#数仓分层" class="headerlink" title="数仓分层"></a>数仓分层</h2><ul><li><p>为什么要分层</p><p><a href="https://imgtu.com/i/WHSDoQ"><img src="https://z3.ax1x.com/2021/07/29/WHSDoQ.png" alt="WHSDoQ.png"></a></p><ul><li>ODS层（Operation Data Store）原始数据层，将前端日志数据，后端业务数据直接导入，不做处理</li><li>DWD层 (Data Warehouse Detail) 明细数据层，对ODS层数据进行数据清洗，维度退化，脱敏等。</li><li>DWS层 （Data Warehouse Service）服务数据层，以DWD层为基础，按天进行轻度汇总。</li><li>DWT层 （Data Warehouse Topic）主题数据层，以DWS层为基础，按主题进行汇总。</li><li>ADS层 （Application Data Store）应用数据层，为各种统计报表提供数据。</li></ul></li></ul><h2 id="数仓理论"><a href="#数仓理论" class="headerlink" title="数仓理论"></a>数仓理论</h2><h3 id="范式概念"><a href="#范式概念" class="headerlink" title="范式概念"></a>范式概念</h3><ul><li>范式可以理解为设计一张数据表的表结构应符合的标准级别。</li><li>按照范式理论建表目的在于<font color=red>降低数据的冗余性</font></li><li>范式的缺点是查询数据时需要进行大量的join操作。</li></ul><h4 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h4><ul><li>完全函数依赖：简单来说：就是AB能推出C，但是AB单独时不能推出C，那么说C完全依赖于AB。</li><li>部分函数依赖：AB能推出C,AB单独也能推出C，即C部分依赖于AB。</li><li>传递函数依赖：通过A推出B，通过B推出C，但是C推不出A，那么C传递函数依赖于A。</li></ul><h4 id="范式区别"><a href="#范式区别" class="headerlink" title="范式区别"></a>范式区别</h4><ul><li>第一范式：属性不可切割</li><li>第二范式：不能存在部分函数依赖</li><li>第三范式：不能存在传递函数依赖</li></ul><h3 id="关系建模和维度建模"><a href="#关系建模和维度建模" class="headerlink" title="关系建模和维度建模"></a>关系建模和维度建模</h3><ul><li><p>当今的数据处理大致可以分成两大类：联机事务处理OLTP（on-line transaction processing）、联机分析处理OLAP（On-Line Analytical Processing）。OLTP是传统的关系型数据库的主要应用，主要是基本的、日常的事务处理，例如银行交易。OLAP是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。</p></li><li><table><thead><tr><th><em><strong>对比属性</strong></em></th><th><em><strong>OLTP</strong></em></th><th><em><strong>OLAP</strong></em></th></tr></thead><tbody><tr><td><em><strong>读特性</strong></em></td><td>每次查询只返回少量记录</td><td>对大量记录进行汇总</td></tr><tr><td><em><strong>写特性</strong></em></td><td>随机、低延时写入用户的输入</td><td>批量导入</td></tr><tr><td><em><strong>使用场景</strong></em></td><td>用户，Java EE项目</td><td>内部分析师，为决策提供支持</td></tr><tr><td><em><strong>数据表征</strong></em></td><td>最新数据状态</td><td>随时间变化的历史状态</td></tr><tr><td><em><strong>数据规模</strong></em></td><td>GB</td><td>TB到PB</td></tr></tbody></table></li></ul><h4 id="关系建模"><a href="#关系建模" class="headerlink" title="关系建模"></a>关系建模</h4><ul><li>关系建模，严格遵循第三范式。表较为松散，零碎，物理表数量多，而数据冗余程度低。由于数据分布于众多的表中，这些数据可以更为灵活地被应用，功能性较强。</li></ul><h4 id="维度建模"><a href="#维度建模" class="headerlink" title="维度建模"></a>维度建模</h4><ul><li><p>维度模型主要应用在OLAP系统中，通常以某一个事实表为中心进行表的组织，主要面向业务。特征可能是存在数据的冗余，但是能方便得到数据。</p></li><li><p>关系模型虽然冗余少，但是在大规模数据，跨表分析统计查询过程中，会造成多表关联，这会大大降低执行效率。所以通常我们采用维度模型建模，把相关各种表整理成两种：事实表和维度表两种。</p></li><li><p>维度建模分成三种模型：</p><ul><li>星型模型</li><li>雪花模型</li><li><a href="https://imgtu.com/i/WzGEEd"><img src="https://z3.ax1x.com/2021/08/01/WzGEEd.png" alt="WzGEEd.png"></a></li><li>星座模型</li><li><img src="C:\Users\Hasee\AppData\Roaming\Typora\typora-user-images\image-20210801175519654.png" alt="image-20210801175519654"></li></ul></li></ul><h3 id="维度表与事实表（重点）"><a href="#维度表与事实表（重点）" class="headerlink" title="维度表与事实表（重点）"></a>维度表与事实表（重点）</h3><h4 id="维度表"><a href="#维度表" class="headerlink" title="维度表"></a>维度表</h4><ul><li>维度表：一般是对事实的<font color=red>描述信息</font>。每一张维度表对应现实世界中的一个对象或者概念。例如：用户，商品，时间，地区等。就像是对事物描述的一个角度。</li><li>维度表的特征：<ul><li>维度表范围很宽（具有多个属性，列比较多）</li><li>与事实表相比，行数相对较小。</li><li>内容相对固定：编码表，地区表</li></ul></li></ul><h4 id="事实表"><a href="#事实表" class="headerlink" title="事实表"></a>事实表</h4><ul><li><p>事实表中的每行数据代表一个业务事件（下单，支付，退款等），事实这个术语表示的是业务事件的<font color=red>度量值（可以统计次数，个数，金额等）</font></p></li><li><p>事实表的行包括：</p><ul><li>具有可加性的数值型的度量值</li><li>与维度表相连接的外键（通常具有两个和两个以上的外键，外键之间表示维度表之间多对多的关系）</li></ul></li><li><p>事实表的特征：</p><ul><li>非常大</li><li>列数较少</li><li>经常变化，每天会新增很多</li></ul></li><li><p>事实表分类：</p><ul><li>事务型事实表：以每个<font color=red>事务或事件为单位</font>，例如一个销售订单记录，一比支付数据，作为事实表里一行数据。<font color=red>一旦事务被提交，事实表数据被插入，数据就不再进行更改，其更新方式为增量更新</font></li><li>周期型快照事实表：周期型快照事实表中<font color=red>不会保留所有数据，只保留固定时间间隔的数据</font>，例如月销售额等。</li><li>累积型快照事实表：<font color=red>累积快照事实表用于跟踪业务事实的变化</font>。例如，数据仓库中可能需要累积或存储订单从下订单开始，到订单商品被打包、运输、和签收的各个业务阶段的时间点数据来跟踪订单声明周期的进展情况。当这个业务过程进行时，事实表的记录也要不断更新。</li></ul></li></ul><h3 id="数据仓库建模"><a href="#数据仓库建模" class="headerlink" title="数据仓库建模"></a>数据仓库建模</h3><h4 id="ODS层"><a href="#ODS层" class="headerlink" title="ODS层"></a>ODS层</h4><ul><li>保持数据原貌不做任何修改，起到数据备份的作用</li><li>数据进行压缩，减少磁盘存储空间</li><li>创建分区表，避免全表扫描</li></ul><h4 id="DWD层"><a href="#DWD层" class="headerlink" title="DWD层"></a>DWD层</h4><ul><li><p>DWD层采用维度建模，采用星型模型</p></li><li><p>维度建模步骤：<font color=red>选择业务过程–&gt;声明粒度–&gt;确认维度–&gt;确认事实</font></p><ul><li><p>选择业务过程：一条业务线对应一张事实表</p></li><li><p>声明粒度：声明粒度指数据仓库中保存数据的细化程度或综合程度的级别。声明粒度意味着精确定义事实表中的一行数据表示什么，应该尽可能选择最小粒度，以此来应对各种各样的需求。</p></li><li><p>确定维度：维度的主要作用是描述业务是事实。</p></li><li><p>确定事实：此处事实指业务中的度量值。在DWD层中，以业务过程为建模驱动，基于每个具体以业务过程的特点，构建最细粒度的明细层事实表。</p></li></ul></li><li><p><a href="https://imgtu.com/i/fpvuSf"><img src="https://z3.ax1x.com/2021/08/02/fpvuSf.png" alt="fpvuSf.png"></a></p></li></ul><ul><li><table><thead><tr><th></th><th><em><strong>时间</strong></em></th><th><em><strong>用户</strong></em></th><th><em><strong>地区</strong></em></th><th><em><strong>商品</strong></em></th><th><em><strong>优惠券</strong></em></th><th><em><strong>活动</strong></em></th><th><em><strong>编码</strong></em></th><th><em><strong>度量值</strong></em></th></tr></thead><tbody><tr><td><em><strong>订单</strong></em></td><td>√</td><td>√</td><td>√</td><td></td><td></td><td>√</td><td></td><td>件数/金额</td></tr><tr><td><em><strong>订单详情</strong></em></td><td>√</td><td></td><td>√</td><td>√</td><td></td><td></td><td></td><td>件数/金额</td></tr><tr><td><em><strong>支付</strong></em></td><td>√</td><td></td><td>√</td><td></td><td></td><td></td><td></td><td>金额</td></tr><tr><td><em><strong>加购</strong></em></td><td>√</td><td>√</td><td></td><td>√</td><td></td><td></td><td></td><td>件数/金额</td></tr><tr><td><em><strong>收藏</strong></em></td><td>√</td><td>√</td><td></td><td>√</td><td></td><td></td><td></td><td>个数</td></tr><tr><td><em><strong>评价</strong></em></td><td>√</td><td>√</td><td></td><td>√</td><td></td><td></td><td></td><td>个数</td></tr><tr><td><em><strong>退款</strong></em></td><td>√</td><td>√</td><td></td><td>√</td><td></td><td></td><td></td><td>件数/金额</td></tr><tr><td><em><strong>优惠券领用</strong></em></td><td>√</td><td>√</td><td></td><td></td><td>√</td><td></td><td></td><td>个数</td></tr></tbody></table></li><li><p>至此，数仓的维度建模完成。DWS，DWT和ADS层和维度建模已经没有关系了。DWS和DWT都是建宽表，宽表(通常是指业务主题相关的指标、维度、属性关联在一起的一张数据库表。由于把不同的内容都放在同一张表存储，宽表已经不符合三范式的模型设计规范，随之带来的主要坏处就是数据的大量冗余，与之相对应的好处就是查询性能的提高与便捷。)都是按照主题去建。主题相当于观察问题得到角度。对应着维度表。</p></li></ul><h4 id="DWS层，DWT层"><a href="#DWS层，DWT层" class="headerlink" title="DWS层，DWT层"></a>DWS层，DWT层</h4><ul><li>DWS层统计各个主题对象的当天行为，服务于DWT层的主题宽表。<ul><li>每日设备行为</li><li>每日会员行为</li><li>每日商品行为</li><li>每日地区统计</li><li>每日活动统计</li></ul></li><li>DWT层：以分析的主题对象为建模驱动，基于上层的应用和产品的指标需求，构建主题对象的全量宽表。<ul><li>设备主题</li><li>用户主题</li><li>商品主题</li><li>地区主题</li><li>营销活动主题</li></ul></li></ul><h4 id="ADS"><a href="#ADS" class="headerlink" title="ADS"></a>ADS</h4><ul><li>对电商系统各大主题指标分别进行分析。</li></ul>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
      <category>离线数仓搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据仓库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>project_logcollect</title>
    <link href="/2021/07/04/project-logcollect/"/>
    <url>/2021/07/04/project-logcollect/</url>
    
    <content type="html"><![CDATA[<h1 id="电商采集项目搭建流程"><a href="#电商采集项目搭建流程" class="headerlink" title="电商采集项目搭建流程"></a>电商采集项目搭建流程</h1><h2 id="自动生成数据脚本"><a href="#自动生成数据脚本" class="headerlink" title="自动生成数据脚本"></a>自动生成数据脚本</h2><ul><li>生成用于测试的数据</li></ul><h2 id="数据采集模块"><a href="#数据采集模块" class="headerlink" title="数据采集模块"></a>数据采集模块</h2><h3 id="Hadoop安装"><a href="#Hadoop安装" class="headerlink" title="Hadoop安装"></a>Hadoop安装</h3><ul><li><p>在这里只说以下大致步骤以及容易出错的地方</p></li><li><p>配置集群之间分发数据的脚本，以及集群之间ssh免密登录</p></li><li><p>hadoop安装，解压就行，注意解压的目录。</p></li><li><p>核心文件配置：</p><ul><li><font color=red>core-site.xml</font>文件配置</li><li><font color=red>hdfs-site.xml</font>文件配置，因为是测试，在这里设置HDFS副本数量为1，防止存储不够，浪费存储。</li><li><font color=red>yran-site.xml</font>文件配置</li><li><font color=red>mapred-site.xml</font>文件</li><li>workers文件配置，注意不用多打空格等输入错误，里面配置hadoop的datanode节点的主机名。</li></ul></li><li><p>第一次启动注意要先格式化namenode。bin/hdfs namenode -format</p></li><li><p>常见web客户端：</p><ul><li>hadoop100:9870。HDFS的Web界面</li><li>yarn的web界面：hadoop101:8088</li><li>历史服务器hadoop102:19888</li></ul></li><li><p>单点启动关闭命令</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment">#HDFS组件</span><br>hdfs --daemon <span class="hljs-literal">start</span>/<span class="hljs-literal">stop</span> namenode/datanode/secondarynamenode<br><span class="hljs-comment">#Yarn</span><br>yarn --daemon <span class="hljs-literal">start</span>/<span class="hljs-literal">stop</span>  resourcemanager/nodemanager<br><span class="hljs-comment">#历史服务器</span><br>mapred --daemon <span class="hljs-literal">start</span> historyserver<br></code></pre></td></tr></table></figure></li><li><p>配置历史服务器</p></li><li><p>配置日志的聚集</p></li><li><p>集群时间同步</p></li><li><p>配置一下压缩</p></li><li><p>可以测试一下集群基础性能</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br>读写性能测试<br><span class="hljs-comment">#读取HDFS集群的10个128M文件</span><br>hadoop jar <span class="hljs-regexp">/opt/m</span>odule<span class="hljs-regexp">/hadoop-3.1.3/</span>share<span class="hljs-regexp">/hadoop/m</span>apreduce/hadoop-mapreduce-client-jobclient-<span class="hljs-number">3.1</span>.<span class="hljs-number">3</span>-tests.jar TestDFSIO -read -nrFiles <span class="hljs-number">10</span> -fileSize <span class="hljs-number">128</span>MB<br><span class="hljs-comment">#删除测试数据</span><br>hadoop jar <span class="hljs-regexp">/opt/m</span>odule<span class="hljs-regexp">/hadoop-3.1.3/</span>share<span class="hljs-regexp">/hadoop/m</span>apreduce/hadoop-mapreduce-client-jobclient-<span class="hljs-number">3.1</span>.<span class="hljs-number">3</span>-tests.jar TestDFSIO -clean<br><br>运算速度测试<br><span class="hljs-comment">#使用RandomWriter来产生随机数，每个节点运行10个Map任务，每个Map产生大约1G大小的二进制随机数</span><br>hadoop jar <span class="hljs-regexp">/opt/m</span>odule<span class="hljs-regexp">/hadoop-3.1.3/</span>share<span class="hljs-regexp">/hadoop/m</span>apreduce/hadoop-mapreduce-examples-<span class="hljs-number">3.1</span>.<span class="hljs-number">3</span>.jar randomwriter random-data<br><span class="hljs-comment">#执行排序程序</span><br>hadoop jar <span class="hljs-regexp">/opt/m</span>odule<span class="hljs-regexp">/hadoop-3.1.3/</span>share<span class="hljs-regexp">/hadoop/m</span>apreduce/hadoop-mapreduce-examples-<span class="hljs-number">3.1</span>.<span class="hljs-number">3</span>.jar sort random-data sorted-data<br><span class="hljs-comment">#验证数据是否排序成功</span><br>hadoop jar <span class="hljs-regexp">/opt/m</span>odule<span class="hljs-regexp">/hadoop-3.1.3/</span>share<span class="hljs-regexp">/hadoop/m</span>apreduce/hadoop-mapreduce-client-jobclient-<span class="hljs-number">3.1</span>.<span class="hljs-number">3</span>-tests.jar testmapredsort -sortInput random-data -sortOutput sorted-data<br></code></pre></td></tr></table></figure></li></ul><p><a href="https://imgtu.com/i/RWzQ8f"><img src="https://z3.ax1x.com/2021/07/04/RWzQ8f.png" alt="RWzQ8f.png"></a></p><h3 id="ZooKeeper安装"><a href="#ZooKeeper安装" class="headerlink" title="ZooKeeper安装"></a>ZooKeeper安装</h3><ul><li><p>在/zookeeper-3.5.7/这个目录下创建zkData</p></li><li><p>在/zookeeper-3.5.7/zkData目录下创建一个myid的文件，myid唯一。</p></li><li><p>重命名/zookeeper-3.5.7/conf这个目录下的zoo_sample.cfg为zoo.cfg</p></li><li><p>修改数据存储路径：dataDir=/opt/module/zookeeper-3.5.7/zkData</p></li><li><p>cluster下增加集群配置</p></li></ul><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><ul><li><p>Kafka遇到的坑：– Error while fetching metadata with correlation id : {LEADER_NOT_AVAILABLE}</p><ul><li><p>原因：无法识别Kafka hostname</p></li><li><p>解决：修改kafka/config/server.properties配置</p></li><li><p>配置llisteners=PLAINTEXT://hadoop100:9092</p></li><li><p> 配置advertised.listeners=PLAINTEXT://hadoop100:9092</p></li></ul></li><li><p>Kafka压力测试</p></li></ul><h3 id="项目基础架构"><a href="#项目基础架构" class="headerlink" title="项目基础架构"></a>项目基础架构</h3><ul><li><a href="https://imgtu.com/i/W5gHcF"><img src="https://z3.ax1x.com/2021/07/27/W5gHcF.png" alt="W5gHcF.png"></a></li></ul>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
      <category>电商数据采集项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大数据</tag>
      
      <tag>电商采集项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hbase</title>
    <link href="/2021/06/27/hbase/"/>
    <url>/2021/06/27/hbase/</url>
    
    <content type="html"><![CDATA[<h1 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h1><h2 id="HBbse概述"><a href="#HBbse概述" class="headerlink" title="HBbse概述"></a>HBbse概述</h2><ul><li><p>HBase是一种分布式，可扩展，，支持海量数据存储的NoSQL数据库。</p></li><li><p>逻辑结构</p></li><li><p><a href="https://imgtu.com/i/RJBhlV"><img src="https://z3.ax1x.com/2021/06/27/RJBhlV.png" alt="RJBhlV.png"></a></p></li><li><p>row key类似于主键</p></li><li><p>region在行上的一个切分，几行分一个region</p></li><li><p>列族：Column Qualifier。</p></li><li><p>store：按照region和列族可以分为一个个store</p></li><li><p>物理结构</p><p><a href="https://imgtu.com/i/RJBomF"><img src="https://z3.ax1x.com/2021/06/27/RJBomF.png" alt="RJBomF.png"></a></p></li><li><p>数据模型</p><p><strong>1.</strong> <em><strong>Name Space</strong></em></p><p>命名空间，类似于关系型数据库的DatabBase概念，每个命名空间下有多个表。HBase有两个自带的命名空间，分别是hbase和default，hbase中存放的是HBase内置的表，default表是用户默认使用的命名空间。</p><p><strong>2.</strong> <em><strong>Region</strong></em></p><p>类似于关系型数据库的表概念。不同的是，HBase定义表时只需要声明列族即可，不需要声明具体的列。这意味着，往HBase写入数据时，字段可以动态、按需指定。因此，和关系型数据库相比，HBase能够轻松应对字段变更的场景。</p><p><strong>3.</strong> <em><strong>Row</strong></em></p><p>HBase表中的每行数据都由一个<em><strong>RowKey</strong></em>和多个<em><strong>Column</strong></em>（列）组成，数据是按照RowKey的字典顺序存储的，并且查询数据时只能根据RowKey进行检索，所以RowKey的设计十分重要。</p><p><strong>4.</strong> <em><strong>Column</strong></em></p><p>HBase中的每个列都由Column Family(列族)和Column Qualifier（列限定符）进行限定，例如info：name，info：age。建表时，只需指明列族，而列限定符无需预先定义。</p><p><strong>5.</strong> <em><strong>Time</strong></em> <em><strong>Stamp</strong></em></p><p>用于标识数据的不同版本（version），每条数据写入时，如果不指定时间戳，系统会自动为其加上该字段，其值为写入HBase的时间。</p><p><strong>6.</strong> <em><strong>Cell</strong></em></p><p>由{rowkey, column Family：column Qualifier, time Stamp} 唯一确定的单元。cell中的数据是没有类型的，全部是字节数组形式存贮。</p></li><li><p>架构</p><p><a href="https://imgtu.com/i/RJDyjK"><img src="https://z3.ax1x.com/2021/06/27/RJDyjK.png" alt="RJDyjK.png"></a></p></li><li><p>Region Server：region的管理者</p></li><li><p>Master：所有Region Server的管理者</p></li><li><p>Zookeeper：HBase通过Zookeeper来做Master的高可用、RegionServer的监控、元数据的入口以及集群配置的维护等工作。</p></li><li><p>HDFS:HDFS为HBase提供最终的底层数据存储服务，同时为HBase提供高可用的支持。</p></li><li><p>一个RegionServer中有多个Region，每个Region中有多个store，每个Store中有一个Memstore和多个StoreFile</p></li></ul><h2 id="HBase架构"><a href="#HBase架构" class="headerlink" title="HBase架构"></a>HBase架构</h2><p><a href="https://imgtu.com/i/RDKkkR"><img src="https://z3.ax1x.com/2021/06/30/RDKkkR.png" alt="RDKkkR.png"></a></p><p>HBase分多个RegionServer，每个RegionServer内又有多个Region，每个Region中又有多个store，store中数据先写到内存，再写到SotreFile（分布式文件系统）上去。</p><ul><li>WAL:Write-Ahead logfile，防止写入内存后数据丢失，先写到这样一个日志文件中。类似于yarn中的edits文件。</li><li>保存实际数据的物理文件，StoreFile以HFile的形式存储在HDFS上。每个Store会有一个或多个StoreFile（HFile），数据在每个StoreFile中都是有序的。</li></ul><h3 id="写数据流程"><a href="#写数据流程" class="headerlink" title="写数据流程"></a>写数据流程</h3><p><a href="https://imgtu.com/i/RDKXHH"><img src="https://z3.ax1x.com/2021/06/30/RDKXHH.png" alt="RDKXHH.png"></a></p><p>meta表中存放了表的信息，而meta的元数据信息存放在ZK上。</p><ol><li><p>Client先访问zookeeper，获取hbase:meta（）表位于哪个Region Server，client如果在MetaCache中发现有该表的信息，就不会向ZK请求获取meta的位置了。</p></li><li><p>访问对应的Region Server，获取hbase:meta表，根据读请求的namespace:table/rowkey，查询出目标数据位于哪个Region Server中的哪个Region中。并将该table的region信息以及meta表的位置信息缓存在客户端的meta cache，方便下次访问。</p></li><li><p>与目标Region Server进行通讯；</p></li><li><p>将数据顺序写入（追加）到WAL；</p></li><li><p>将数据写入对应的MemStore，数据会在MemStore进行排序；</p></li><li><p>向客户端发送ack；</p></li><li><p>等达到MemStore的刷写时机后，将数据刷写到HFile（分布式存储中）。</p></li></ol><h3 id="MemStore的刷写时机"><a href="#MemStore的刷写时机" class="headerlink" title="MemStore的刷写时机"></a>MemStore的刷写时机</h3><ul><li>当某个memstroe的大小达到了<strong>hbase.hregion.memstore.flush.size</strong>（默认值128M），其所在region的所有memstore都会刷写。但是数据持续写入到memstore也不会达到128就刷，当memstore的大小达到了128*4时，会阻止继续往该memstore写数据。</li><li>Java heap size 堆栈大小, 指Java 虚拟机的内存大小。在Java虚拟机中，分配多少内存用于调用对象,函数和数组。因为底层中，函数和数组的调用在计算机中是用堆栈实现。</li><li>当region server中memstore的总大小达到<br><strong>java_heapsize*hbase.regionserver.global.memstore.size.upper.limit</strong>（默认值0.95），<br>Region server会把它的所有region按照其所有memstore的大小顺序（由大到小）依次进行刷写。直到region server中所有region的memstore的总大小减小到*<strong>hbase.regionserver.global.memstore.size.lower.limit</strong>以下。</li><li>当region server中memstore的总大小达到<br><strong>java_heapsize*hbase.regionserver.global.memstore.size</strong>（默认值0.4）<br>时，会阻止继续往所有的memstore写数据。</li><li>达到自动刷写时间。默认1h。<strong>hbase.regionserver.optionalcacheflushinterval</strong></li></ul><h3 id="读数据流程"><a href="#读数据流程" class="headerlink" title="读数据流程"></a>读数据流程</h3><p><a href="https://imgtu.com/i/RrMr7Q"><img src="https://z3.ax1x.com/2021/07/01/RrMr7Q.png" alt="RrMr7Q.png"></a></p><ul><li>与写数据流程差不多。说一下区别，去目标RegionServer读取数据时，会向Block Cache(读缓存),MemStore,StoreFile中查询数据，并将所有数据进行合并。此处所有数据是指同一条数据的不同版本（time stamp）或者不同的类型（Put/Delete）。</li><li>将从文件中查询到的数据块缓存到Block Cache中。客户端从读缓存中读取相应的数据。返回ACK。</li></ul><h3 id="StoreFile-Compaction"><a href="#StoreFile-Compaction" class="headerlink" title="StoreFile Compaction"></a>StoreFile Compaction</h3><ul><li><p>由于memstore每次刷写都会生成一个新的HFile，且同一个字段的不同版本（timestamp）和不同类型（Put/Delete）有可能会分布在不同的HFile中，因此查询时需要遍历所有的HFile。为了减少HFile的个数，以及清理掉过期和删除的数据，会进行StoreFile Compaction。</p></li><li><p>Compaction（合并）分为两种：分别是Minor Compaction和Major Compaction。</p></li><li><p>Minor Compaction会将临近的若干个较小的HFile合并成一个较大的HFile，但不会清理过期和删除的数据。默认是三个小文件会进行合并，达到一定的数量后也不会直接合并，会根据一个算法判断是否要进行合并。</p></li><li><p>Major Compaction会将一个Store下的所有的HFile合并成一个大HFile，并且会清理掉过期和删除的数据。比较耗费资源，默认是一星期进行一次。</p></li></ul><h3 id="Region-Split"><a href="#Region-Split" class="headerlink" title="Region Split"></a>Region Split</h3><ul><li><p>默认情况下，每个Table起初只有一个Region，随着数据的不断写入，Region会自动进行拆分。刚拆分时，两个子Region都位于当前的Region Server，但处于负载均衡的考虑，HMaster有可能会将某个Region转移给其他的Region Server。</p></li><li><p>分裂时机：如果当前RegionServer上只有一个Region，当这个Region中的所有Store file的总和超过2*hbase.hregion.memstore.flush.size分裂，否则按照超过hbase.hregion.max.filesize 分裂。</p></li><li><p>这样切分会尽量使每个Table的在每个RegionServer中的Region数量尽量一致。</p></li></ul><h2 id="Hive与HBase集成"><a href="#Hive与HBase集成" class="headerlink" title="Hive与HBase集成"></a>Hive与HBase集成</h2><ul><li>hive默认是有jar包可与HBase集成的，可以用Hive对HBase中的数据进行分析，再将分析结果又返回到HBase中，方便其它的工作对分析好的数据的使用。</li></ul><h2 id="Phoenix"><a href="#Phoenix" class="headerlink" title="Phoenix"></a>Phoenix</h2><ul><li>Phoenix是HBase的开源SQL皮肤。可以使用标准JDBC API代替HBase客户端API来创建表，插入数据和查询HBase数据。</li><li>可以用类sql语言操作hbase</li><li>优势：支持索引。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>大数据</tag>
      
      <tag>flume</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka</title>
    <link href="/2021/06/24/kafka/"/>
    <url>/2021/06/24/kafka/</url>
    
    <content type="html"><![CDATA[<h1 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h1><h2 id="Kafka概述"><a href="#Kafka概述" class="headerlink" title="Kafka概述"></a>Kafka概述</h2><ul><li><p>kafaka是一个分布式的基于发布/订阅模式的消息队列，主要应用于大数据实时处理领域。</p></li><li><p>消息队列一般分为两种模式：</p><ol><li>点对点模式（一对一，消费者主动拉取数据，消息收到后消息清除）</li><li>发布/订阅模式（一对多，消费者消费数据之后不会清除消息）</li></ol></li><li><p>基础架构</p><p><a href="https://imgtu.com/i/RgX9C4"><img src="https://z3.ax1x.com/2021/07/03/RgX9C4.png" alt="RgX9C4.png"></a></p><ul><li>prodecer:消息生产者，向Kafka broker发消息的客户端</li><li>consumer：消息消费者，向Kafka broker取消息的客户端</li><li>consumer group：消费者组，由多个consumer组成。消费者组内每个消费者负责消费不同分区的数据，一个分区只能由一个消费者消费；消费者组之间互不影响。所有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。</li><li>broker：一台kafka服务器就是一个broker。一个集群由多个broker组成。一个broker可以容纳多个topic。</li><li>topic：可以理解为一个队列，生产者和消费者面向的都是一个topic</li><li>partition：为了实现扩展性，一个非常大的topic可以分布到多个broker（即服务器）上，一个topic可以分为多个partition，每个partition是一个有序的队列；</li><li>replica：副本，为保证集群中的某个节点发生故障时，该节点上的partition数据不丢失，且kafka仍然能够继续工作，kafka提供了副本机制，一个topic的每个分区都有若干个副本，一个leader和若干个follower</li><li>leader：每个分区多个副本的“主”，生产者发送数据的对象，以及消费者消费数据的对象都是leader。</li><li>follower：每个分区多个副本中的“从”，实时从leader中同步数据，保持和leader数据的同步。leader发生故障时，某个follower会成为新的leader。</li></ul></li></ul><h2 id="架构深入"><a href="#架构深入" class="headerlink" title="架构深入"></a>架构深入</h2><h3 id="文件存储机制"><a href="#文件存储机制" class="headerlink" title="文件存储机制"></a>文件存储机制</h3><ul><li><p>Kafka中的消息使以topic进行分类的，生产者生产消息，消费者消费消息都是面向topic的。</p></li><li><p>topic是逻辑的一个概念，partition是物理上的一个概念，每一个partition对应一个log文件，log文件中存放生产者生产的数据。每条数据也有自己的offset，消费者组中的每一个消费者，都会实时记录自己消费到了哪个offset，以便于出错时恢复，从上次的位置继续消费。</p></li><li><p><a href="https://imgtu.com/i/RgXeUO"><img src="https://z3.ax1x.com/2021/07/03/RgXeUO.png" alt="RgXeUO.png"></a></p></li><li><p>当log文件过大时就会分成多个segment,主要是为了加快索引速度，而且一个log文件分成多个segment都是在磁盘上连续存储的，Kafka这样的设计可以大幅度提高数据读写速度。</p></li><li><p>一个segment对应三个文件，一个log文件，两个index文件，一个.index文件和一个.timeindex文件。</p></li><li><p>“.index”文件存储大量的索引信息，“.log”文件存储大量的数据，索引文件中的元数据指向对应数据文件中message的物理偏移地址。</p></li><li><p>index和log文件以当前segment的第一条消息的offset命名</p><p><a href="https://imgtu.com/i/RgXQxA"><img src="https://z3.ax1x.com/2021/07/03/RgXQxA.png" alt="RgXQxA.png"></a></p></li></ul><h3 id="Kafka生产者"><a href="#Kafka生产者" class="headerlink" title="Kafka生产者"></a>Kafka生产者</h3><ul><li>Kafka的数据也是类似于键值对形式的数据。例如&lt;String,String&gt;</li></ul><h4 id="分区策略"><a href="#分区策略" class="headerlink" title="分区策略"></a>分区策略</h4><ul><li>分区的原因：1.方便在集群中扩展。2.可以提高并发，以partition为单位进行读写。</li><li>分区原则：1.指明partition。2.有key的情况下,将key的hash值与topic的partition数取余得到partiton值。即相同key值得数据会被分到一个分区中。3. round-robin 算法,每个分区轮着来。</li></ul><h4 id="数据可靠性的保证"><a href="#数据可靠性的保证" class="headerlink" title="数据可靠性的保证"></a>数据可靠性的保证</h4><ul><li><p>producer向server发信息时是异步通信，为确保数据的可靠性，需要向producer发送ACK（acknowledgement确认收到）。如果producer收到ack，就会进行下一轮的发送，否则重新发送数据。这时会出现三种返回ack的时机：</p><p>1.收到后还没写立刻发送。最不安全</p><p>2.leader写完数据后发送ack。</p><p>3.ISR中所有副本都写完数据后发送ack。kafka默认的选择。优点：容忍n台节点故障，只需要n+1个副本。</p></li><li><p>根据这三种情况，将ack的值分别分为0，1，all(-1)。</p></li><li><p>在第三种情况中，会出现一种意外情况：leader收到数据，所有follower都开始同步数据，但有一个follower，因为某种故障，迟迟不能与leader进行同步，那leader就要一直等下去，直到它完成同步，才能发送ack。这个问题怎么解决呢？</p></li><li><p>Kafka引入一个Leader维护了一个动态的in-sync replica set (ISR)，解决上述问题。和leader保持同步的follower在ISR中，如果Follower长时间未向leader同步数据，该follower会被踢出ISR，实践阈值由<em><strong>replica.lag.time.max.ms</strong></em>参数设定。leader故障则会重新选举leader。</p><p><a href="https://imgtu.com/i/RgXWRJ"><img src="https://z3.ax1x.com/2021/07/03/RgXWRJ.png" alt="RgXWRJ.png"></a></p><ul><li>当follower故障时会被临时踢出ISR，待待该follower恢复后，follower会读取本地磁盘记录的上次的HW，并将log文件高于HW的部分截取掉，从HW开始向leader进行同步。等该<em><strong>follower的LEO大于等于该Partition的HW</strong></em>，即follower追上leader之后，就可以重新加入ISR了。</li><li>leader发生故障之后，会从ISR中选出一个新的leader，之后，为保证多个副本之间的数据一致性，其余的follower会先将各自的log文件高于HW的部分截掉，然后从新的leader同步数据。</li><li>这只能保证副本之间的数据一致性，并不能保证数据不丢失或者不重复</li></ul></li><li><p>exactly once语义：At Least Once + 幂等性 = Exactly Once。</p></li><li><p>幂等性就是指Producer不论向Server发送多少次重复数据，Server端都只会持久化一条。</p></li><li><p>将服务器的ACK级别设置为-1，可以保证Producer到Server之间不会丢失数据，即At Least Once语义。</p></li><li><p>要启用幂等性，只需要将Producer的参数中enable.idompotence设置为true即可。Kafka的幂等性实现其实就是将原来下游需要做的去重放在了数据上游。开启幂等性的Producer在初始化的时候会被分配一个PID，发往同一Partition的消息会附带Sequence Number。而Broker端会对&lt;PID, Partition, SeqNumber&gt;做缓存，当具有相同主键的消息提交时，Broker只会持久化一条。</p></li><li><p>局限性：但是PID重启就会变化，同时不同的Partition也具有不同主键，所以幂等性无法保证跨分区跨会话的Exactly Once。</p></li></ul><h3 id="Kafka消费者"><a href="#Kafka消费者" class="headerlink" title="Kafka消费者"></a>Kafka消费者</h3><h4 id="消费方式"><a href="#消费方式" class="headerlink" title="消费方式"></a>消费方式</h4><ul><li>消费方式：consumer采用pull模式从broker中读取数据。</li><li>pull模式不足之处是，如果kafka没有数据，消费者可能会陷入循环中，一直返回空数据。针对这一点，Kafka的消费者在消费数据时会传入一个时长参数timeout，如果当前没有数据可供消费，consumer会等待一段时间之后再返回，这段时长即为timeout。</li></ul><h4 id="分区分配策略"><a href="#分区分配策略" class="headerlink" title="分区分配策略"></a>分区分配策略</h4><ul><li><p>理想状况是一个consumergroup中每一个consumer负责拉取一个分区的数据。</p></li><li><p>roundrobin：当分区数大于consumer数量时，轮询分配，类似于斗地主一张一张的发牌。</p></li><li><p>range:类似于斗地主一次性发几张牌</p></li></ul><h4 id="offset维护"><a href="#offset维护" class="headerlink" title="offset维护"></a>offset维护</h4><ul><li>由于consumer在消费过程中可能会出现断电宕机等故障，consumer恢复后，需要从故障前的位置的继续消费，所以consumer需要实时记录自己消费到了哪个offset，以便故障恢复后继续消费。</li><li>将offset放在Kafka内置的一个topic中，__consumer_offsets。由50个分区。</li></ul><h4 id="Zookeeper在Kafka中作用"><a href="#Zookeeper在Kafka中作用" class="headerlink" title="Zookeeper在Kafka中作用"></a>Zookeeper在Kafka中作用</h4><ul><li><p>Kafka集群中有一个broker会被选举为Controller，负责管理集群broker的上下线，所有topic的分区副本分配和leader选举等工作。Controller的选举就是比谁快。</p></li><li><p>Controller的管理工作都是依赖于Zookeeper的。</p><p><a href="https://imgtu.com/i/RgXXzd"><img src="https://z3.ax1x.com/2021/07/03/RgXXzd.png" alt="RgXXzd.png"></a></p></li><li><p>leader挂掉之后，Controller会选举新的leader，更新永久节点state中的信息。state存放某个topic,某个分区的以些必要信息。</p></li></ul><h4 id="Kafka事务"><a href="#Kafka事务" class="headerlink" title="Kafka事务"></a>Kafka事务</h4><ul><li>为了实现跨分区跨会话的事务，需要引入一个全局唯一的Transaction ID，并将Producer获得的PID和Transaction ID绑定。这样当Producer重启后就可以通过正在进行的Transaction ID获得原来的PID。</li></ul><h3 id="KafkaAPI"><a href="#KafkaAPI" class="headerlink" title="KafkaAPI"></a>KafkaAPI</h3><ul><li><p>produceAPI</p></li><li><p>Kafka的Producer发送消息采用的是<em><strong>异步发送</strong></em>的方式。在消息发送的过程中，涉及到了<strong>两个线程——main线程和Sender线程</strong>，以及<em><strong>一个线程共享变量——RecordAccumulator</strong></em>。main线程将消息发送给RecordAccumulator，Sender线程不断从RecordAccumulator中拉取消息发送到Kafka broker。</p><p><a href="https://imgtu.com/i/RGBi1f"><img src="https://z3.ax1x.com/2021/06/26/RGBi1f.png" alt="RGBi1f.png"></a></p><ul><li><p>相关参数：</p><p><em><strong>batch.size</strong>***</em>：***只有数据积累到batch.size之后，sender才会发送数据。</p><p><em><strong>linger.ms</strong>***</em>：***如果数据迟迟未达到batch.size，sender等待linger.time之后就会发送数据。</p></li></ul></li><li><p>ConsumerAPI</p></li><li><p>Consumer消费数据时的可靠性是很容易保证的，因为数据在Kafka中是持久化的，故不用担心数据丢失问题。</p><p>由于consumer在消费过程中可能会出现断电宕机等故障，consumer恢复后，需要从故障前的位置的继续消费，所以consumer需要实时记录自己消费到了哪个offset，以便故障恢复后继续消费。</p><p>所以offset的维护是Consumer消费数据是必须考虑的问题。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Kafka</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大数据</tag>
      
      <tag>kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>flume</title>
    <link href="/2021/06/21/flume/"/>
    <url>/2021/06/21/flume/</url>
    
    <content type="html"><![CDATA[<h1 id="Flume"><a href="#Flume" class="headerlink" title="Flume"></a>Flume</h1><h2 id="Flume概述"><a href="#Flume概述" class="headerlink" title="Flume概述"></a>Flume概述</h2><ul><li><p>配置文档，自定义Source,Interceptor,sink就来看官方文档：<a href="http://flume.apache.org/releases/content/1.9.0/FlumeUserGuide.html#spooling-directory-source">官方文档</a></p></li><li><p>flume是一个高可用的，可靠的，分布式的<em><strong>海量日志采集，聚合，和传输的系统</strong></em>基于流式框架，灵活简单。</p></li><li><p>基础架构：</p><p><a href="https://imgtu.com/i/REvBm8"><img src="https://z3.ax1x.com/2021/06/21/REvBm8.png" alt="REvBm8.png"></a></p><ul><li>Agent:是一个JVM进程，它以事件的形式将数据从源头送至目的</li><li>source负责接收数据到Flume agent 的组件。可以处理各种类型，格式的日志数据。例如：spooling directory，netcat,avro,exec</li><li>sink不断轮询channel中的事件并且批量的移除他们，将这些事件批量写入到存储或索引系统，或者被发送到另一个flume agent。sink组件发送目的地包括：hdfs,logger,avro,file,HBase</li><li>Channel是位于source和sink之间缓冲区。Flume自带两种Channel：Memory Channel和File Channel。</li></ul></li><li><p>event:flume传输数据的基本单元。由Header和Body组成。Header用来存放该event的一些属性，为K-V结构，Body用来存放该条数据，形式为字节数组。</p></li></ul><h2 id="flume入门案例"><a href="#flume入门案例" class="headerlink" title="flume入门案例"></a>flume入门案例</h2><ul><li><p>实时监控Hive日志，并上传到HDFS中</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-number">1</span>.第一种方式<br>flume-ng agent --name agent的名字 --conf 配置文件的目录 --conf-file agent的配置文件（自己手动写）-Dflume.root.<span class="hljs-attr">logger=INFO,console</span><br><br>需要写配置文件<br>基本步骤：<br><span class="hljs-comment">#1.agent的source,channel,sink组件</span><br><span class="hljs-comment">#2.source配置</span><br><span class="hljs-comment">#3.channel配置</span><br><span class="hljs-comment">#4.sink配置</span><br><span class="hljs-comment">#5.source,channel,sink之间的关系</span><br><span class="hljs-comment"># Name the components on this agent</span><br>a2.<span class="hljs-attr">sources</span> = r2<br>a2.<span class="hljs-attr">sinks</span> = k2<br>a2.<span class="hljs-attr">channels</span> = c2<br><br><span class="hljs-comment"># Describe/configure the source</span><br>a2.sources.r2.<span class="hljs-attr">type</span> = exec<br>a2.sources.r2.<span class="hljs-attr">command</span> = tail -F /opt/module/hive/logs/hive.log<br>a2.sources.r2.<span class="hljs-attr">shell</span> = /bin/bash -c<br><br><span class="hljs-comment"># Describe the sink</span><br>a2.sinks.k2.<span class="hljs-attr">type</span> = hdfs<br>a2.sinks.k2.hdfs.<span class="hljs-attr">path</span> = hdfs://hadoop102:<span class="hljs-number">8020</span>/flume/%Y%m%d/%H<br><span class="hljs-comment">#上传文件的前缀</span><br>a2.sinks.k2.hdfs.<span class="hljs-attr">filePrefix</span> = logs-<br><span class="hljs-comment">#是否按照时间滚动文件夹</span><br>a2.sinks.k2.hdfs.<span class="hljs-attr">round</span> = <span class="hljs-literal">true</span><br><span class="hljs-comment">#多少时间单位创建一个新的文件夹</span><br>a2.sinks.k2.hdfs.<span class="hljs-attr">roundValue</span> = <span class="hljs-number">1</span><br><span class="hljs-comment">#重新定义时间单位</span><br>a2.sinks.k2.hdfs.<span class="hljs-attr">roundUnit</span> = hour<br><span class="hljs-comment">#是否使用本地时间戳</span><br>a2.sinks.k2.hdfs.<span class="hljs-attr">useLocalTimeStamp</span> = <span class="hljs-literal">true</span><br><span class="hljs-comment">#积攒多少个Event才flush到HDFS一次</span><br>a2.sinks.k2.hdfs.<span class="hljs-attr">batchSize</span> = <span class="hljs-number">100</span><br><span class="hljs-comment">#设置文件类型，可支持压缩</span><br>a2.sinks.k2.hdfs.<span class="hljs-attr">fileType</span> = DataStream<br><span class="hljs-comment">#多久生成一个新的文件</span><br>a2.sinks.k2.hdfs.<span class="hljs-attr">rollInterval</span> = <span class="hljs-number">60</span><br><span class="hljs-comment">#设置每个文件的滚动大小</span><br>a2.sinks.k2.hdfs.<span class="hljs-attr">rollSize</span> = <span class="hljs-number">134217700</span><br><span class="hljs-comment">#文件的滚动与Event数量无关</span><br>a2.sinks.k2.hdfs.<span class="hljs-attr">rollCount</span> = <span class="hljs-number">0</span><br><br><span class="hljs-comment"># Use a channel which buffers events in memory</span><br>a2.channels.c2.<span class="hljs-attr">type</span> = memory<br>a2.channels.c2.<span class="hljs-attr">capacity</span> = <span class="hljs-number">1000</span><br>a2.channels.c2.<span class="hljs-attr">transactionCapacity</span> = <span class="hljs-number">100</span><br><br><span class="hljs-comment"># Bind the source and sink to the channel</span><br>a2.sources.r2.<span class="hljs-attr">channels</span> = c2<br>a2.sinks.k2.<span class="hljs-attr">channel</span> = c2<br></code></pre></td></tr></table></figure></li><li><p>log4j.properties(日志架构)，类似于程序中的调试代码，输出一些东西，供编码的时候调试。但是项目上线后不能再直接输出，于是将这些调试输出输出到专门的日志文件中。</p></li></ul><h2 id="Flume进阶"><a href="#Flume进阶" class="headerlink" title="Flume进阶"></a>Flume进阶</h2><ul><li><p>flume事务。主要是为了保证数据不会丢失。</p><p><a href="https://imgtu.com/i/RZxhvR"><img src="https://z3.ax1x.com/2021/06/22/RZxhvR.png" alt="RZxhvR.png"></a></p></li><li><p>flume agent内部原理：</p><p><a href="https://imgtu.com/i/RZxsbV"><img src="https://z3.ax1x.com/2021/06/22/RZxsbV.png" alt="RZxsbV.png"></a></p></li></ul><ul><li><ol><li><p>Source接受数据，将数据以event的形式发给ChannnelProcessor</p></li><li><p>ChannelProcessor将事件传递给拦截器，在拦截其中可以对event数据进行更改。</p></li><li><p>拦截器再将事件返回到ChannelProcessor，ChannelProcessor将每个事件给Channel选择器。ChannelSelector的作用就是选出Event将要被发往哪个Channel。其共有两种类型，分别是Replicating（复制）和Multiplexing（多路复用）。</p></li><li><p>再返回到ChannelProcessor，根据选择器的选择，event进入不同的channel</p></li><li><p>SinkProcessor再决定channel中的enevt的走向。</p><p>SinkProcessor共有三种类型，分别是DefaultSinkProcessor、LoadBalancingSinkProcessor和FailoverSinkProcessor。</p><p>DefaultSinkProcessor对应的是单个的Sink，LoadBalancingSinkProcessor和FailoverSinkProcessor对应的是Sink Group，LoadBalancingSinkProcessor可以实现负载均衡的功能，FailoverSinkProcessor可以错误恢复的功能(故障转移）。</p></li></ol></li><li><p>flume拓扑结构</p><ul><li>简单串联。多个agent串起来</li><li>复制和多路复用。Flume支持将事件流向一个或者多个目的地。这种模式可以将相同数据复制到多个channel中，或者将不同数据分发到不同的channel中，sink可以选择传送到不同的目的地。</li><li>负载均衡和故障转移。Flume支持使用将多个sink逻辑上分到一个sink组，sink组配合不同的SinkProcessor可以实现负载均衡和错误恢复的功能。</li><li>聚合。将多台服务器部署一个flume日志采集，再将所有日志聚合到一个集中收集日志的flume，由此上传到HDFS,HBase，进行数据分析。</li></ul></li></ul><h3 id="API编程"><a href="#API编程" class="headerlink" title="API编程"></a>API编程</h3><ul><li>可以查看官网的开发者文档。</li><li>自定义Interceptor。定义类实现Interceptor接口，重写四个方法（初始化，单event修改，多event修改，关闭资源）还需要一个Builder静态内部类。</li></ul><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="flume的source-sink-Channel的作用？"><a href="#flume的source-sink-Channel的作用？" class="headerlink" title="flume的source,sink,Channel的作用？"></a>flume的source,sink,Channel的作用？</h3><ul><li><p>作用：</p><p>（1）Source组件是专门用来收集数据的，可以处理各种类型、各种格式的日志数据，包括avro、thrift、exec、jms、spooling directory、netcat、sequence generator、syslog、http、legacy</p><p>（2）Channel组件对采集到的数据进行缓存，可以存放在Memory或File中。</p><p>（3）Sink组件是用于把数据发送到目的地的组件，目的地包括Hdfs、Logger、avro、thrift、ipc、file、Hbase、solr、自定义。</p></li></ul><h3 id="flume参数调优"><a href="#flume参数调优" class="headerlink" title="flume参数调优"></a>flume参数调优</h3><ul><li><p><em><strong>1. source</strong></em></p><p>增加Source个（使用Tair Dir Source时可增加FileGroups个数）可以增大Source的读取数据的能力。例如：当某一个目录产生的文件过多时需要将这个文件目录拆分成多个文件目录，同时配置好多个Source 以保证Source有足够的能力获取到新产生的数据。</p><p>batchSize参数决定Source一次批量运输到Channel的event条数，适当调大这个参数可以提高Source搬运Event到Channel时的性能。</p><p><em><strong>2. Channel:</strong></em></p><p>type 选择memory时Channel的性能最好，但是如果Flume进程意外挂掉可能会丢失数据。type选择file时Channel的容错性更好，但是性能上会比memory channel差。</p><p>使用file Channel时dataDirs配置多个不同盘下的目录可以提高性能。</p><p>Capacity 参数决定Channel可容纳最大的event条数。transactionCapacity 参数决定每次Source往channel里面写的最大event条数和每次Sink从channel里面读的最大event条数。transactionCapacity需要大于Source和Sink的batchSize参数。</p><p><em><strong>3. Sink</strong></em></p><p>增加Sink的个数可以增加Sink消费event的能力。Sink也不是越多越好够用就行，过多的Sink会占用系统资源，造成系统资源不必要的浪费。</p><p>batchSize参数决定Sink一次批量从Channel读取的event条数，适当调大这个参数可以提高Sink从Channel搬出event的性能。</p></li></ul><h3 id="flume数据是否会丢失？"><a href="#flume数据是否会丢失？" class="headerlink" title="flume数据是否会丢失？"></a>flume数据是否会丢失？</h3><ul><li>flume采用事务机制，Flume使用两个独立的事务分别负责从Soucrce到Channel，以及从Channel到Sink的事件传递。如果因为某种原因使得事件无法记录，那么事务将会回滚。</li><li>正是因为flume完善的事务机制，flume不会丢失数据。</li><li>唯一可能丢失数据的情况是Channel采用memoryChannel，agent宕机导致数据丢失，或者Channel存储数据已满，导致Source不再写入，未写入的数据丢失。</li><li>Flume不会丢失数据，但是有可能造成数据的重复，例如数据已经成功由Sink发出，但是没有接收到响应，Sink会再次发送数据，此时可能会导致数据的重复。</li></ul>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>flume</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大数据</tag>
      
      <tag>flume</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hive</title>
    <link href="/2021/06/04/hive/"/>
    <url>/2021/06/04/hive/</url>
    
    <content type="html"><![CDATA[<h1 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h1><h2 id="Hive基础知识"><a href="#Hive基础知识" class="headerlink" title="Hive基础知识"></a>Hive基础知识</h2><ul><li><p>Hive：由Facebook开源用于解决海量结构化日志的数据统计工具。</p><p>Hive是基于Hadoop的一个<em><strong>数据仓库工具</strong></em>，可以<em><strong>将结构化的数据文件映射为一张表</strong></em>，并<em><strong>提供类SQL查询功能</strong></em>。</p><p>本质是：将HQL转化成MapReduce程序</p></li><li><p>优点：1. 操作采用类SQL语法，提供快速开发的能力。</p></li><li><p>缺点： 1. 效率低</p></li><li><p>架构原理：<a href="https://imgtu.com/i/2YmPaT"><img src="https://z3.ax1x.com/2021/06/04/2YmPaT.png" alt="2YmPaT.png"></a></p></li><li><p>大致流程：Hive通过给用户提供的一系列交互接口，接收到用户的指令(SQL)，使用自己的Driver，结合元数据(MetaStore)，将这些指令翻译成MapReduce，提交到Hadoop中执行，最后，将执行返回的结果输出到用户交互接口。</p></li><li><p>架构解析：</p><ol><li><p>用户接口：Client.CLI（command-line interface）、JDBC/ODBC(jdbc访问hive)、WEBUI（浏览器访问hive）</p></li><li><p>元数据：Meta store .元数据包括：表名、表所属的数据库（默认是default）、表的拥有者、列/分区字段、表的类型（是否是外部表）、表的数据所在目录等；</p><p>默认存储在自带的derby数据库中，推荐使用MySQL存储Metastore</p><p>Metastore的作用是：客户端连接metastore服务，metastore再去连接MySQL数据库来存取元数据。有了metastore服务，就可以有多个客户端同时连接，而且这些客户端不需要知道MySQL数据库的用户名和密码，只需要连接metastore 服务即可。</p><ul><li>内嵌模式使用的是内嵌的Derby数据库来存储元数据，也不需要额外起Metastore服务。这个是默认的，配置简单，但是一次只能一个客户端连接，适用于用来实验，不适用于生产环境。</li><li>本地元存储和远程元存储都采用外部数据库来存储元数据，目前支持的数据库有：MySQL、Postgres、Oracle、MS SQL Server.在这里我们使用MySQL。</li><li>本地元存储和远程元存储的区别是：本地元存储不需要单独起metastore服务，用的是跟hive在同一个进程里的metastore服务。远程元存储需要单独起metastore服务，然后每个客户端都在配置文件里配置连接到该metastore服务。远程元存储的metastore服务和hive运行在不同的进程里。</li></ul></li><li><p>Hadooop.使用HDFS进行存储，使用MapReduce进行计算。</p></li><li><p>驱动器：Driver.</p><ol><li>包括解析器（SQL Parser）:将SQL字符串转换成抽象语法树AST</li><li>编译器（Physical Plan）：将AST编译生成逻辑执行计划。</li><li>优化器（Query Optimizer）：对逻辑执行计划进行优化。</li><li>执行器（Execution）：把逻辑执行计划转换成可以运行的物理计划。对于Hive来说，就是MR/Spark。</li></ol></li></ol></li><li><p>Tez引擎</p><ul><li>可以理解为一个加强版的MapReduce。比MapReduce更快，但是消耗更多的内存</li></ul></li><li><p>hive的数据类型</p><table><thead><tr><th>Hive数据类型</th><th>Java数据类型</th><th>长度</th><th>例子</th></tr></thead><tbody><tr><td>TINYINT</td><td>byte</td><td>1byte有符号整数</td><td>20</td></tr><tr><td>SMALINT</td><td>short</td><td>2byte有符号整数</td><td>20</td></tr><tr><td>INT</td><td>int</td><td>4byte有符号整数</td><td>20</td></tr><tr><td>BIGINT</td><td>long</td><td>8byte有符号整数</td><td>20</td></tr><tr><td>BOOLEAN</td><td>boolean</td><td>布尔类型，true或者false</td><td>TRUE  FALSE</td></tr><tr><td>FLOAT</td><td>float</td><td>单精度浮点数</td><td>3.14159</td></tr><tr><td>DOUBLE</td><td>double</td><td>双精度浮点数</td><td>3.14159</td></tr><tr><td>STRING</td><td>string</td><td>字符系列。可以指定字符集。可以使用单引号或者双引号。</td><td>‘now is the time’ “for all good men”</td></tr><tr><td>TIMESTAMP</td><td></td><td>时间类型</td><td></td></tr><tr><td>BINARY</td><td></td><td>字节数组</td><td></td></tr></tbody></table></li></ul><p>集合数据类型：</p><table><thead><tr><th>数据类型</th><th>描述</th><th>语法示例</th></tr></thead><tbody><tr><td>STRUCT</td><td>和c语言中的struct类似，都可以通过“点”符号访问元素内容。例如，如果某个列的数据类型是STRUCT{first STRING, last STRING},那么第1个元素可以通过字段.first来引用。</td><td>struct()例如struct&lt;street:string, city:string&gt;</td></tr><tr><td>MAP</td><td>MAP是一组键-值对元组集合，使用数组表示法可以访问数据。例如，如果某个列的数据类型是MAP，其中键-&gt;值对是’first’-&gt;’John’和’last’-&gt;’Doe’，那么可以通过字段名[‘last’]获取最后一个元素</td><td>map()例如map&lt;string, int&gt;</td></tr><tr><td>ARRAY</td><td>数组是一组具有相同类型和名称的变量的集合。这些变量称为数组的元素，每个数组元素都有一个编号，编号从零开始。例如，数组值为[‘John’, ‘Doe’]，那么第2个元素可以通过数组名[1]进行引用。</td><td>Array()例如array<string></td></tr></tbody></table><ul><li>数据类型转化<ul><li>隐式转化   与java类似。1.所有整数类型、FLOAT和STRING类型都可以隐式地转换成DOUBLE</li><li>强制转化 CAST(‘1’ AS INT)将把字符串’1’ 转换成整数1；如果强制类型转换失败，如执行CAST(‘X’ AS INT)，表达式返回空值 NULL。</li></ul></li></ul><h2 id="SQL语言的分类"><a href="#SQL语言的分类" class="headerlink" title="SQL语言的分类"></a>SQL语言的分类</h2><p><strong>SQL语言的分类</strong></p><p>SQL语言共分为四大类：数据查询语言DQL，数据操纵语言DML，数据定义语言DDL，数据控制语言DCL。</p><p><strong>1. 数据查询语言DQL</strong><br>数据查询语言DQL基本结构是由SELECT子句，FROM子句，WHERE<br>子句组成的查询块：<br>SELECT &lt;字段名表&gt;<br>FROM &lt;表或视图名&gt;<br>WHERE &lt;查询条件&gt;</p><p><strong>2 .数据操纵语言DML</strong><br>数据操纵语言DML主要有三种形式：</p><ol><li>插入：INSERT</li><li>更新：UPDATE</li><li>删除：DELETE</li></ol><p><strong>3. 数据定义语言DDL</strong><br>数据定义语言DDL用来创建数据库中的各种对象—–表、视图、<br>索引、同义词、聚簇等如：<br>CREATE TABLE/VIEW/INDEX/SYN/CLUSTER<br>| | | | |<br>表 视图 索引 同义词 簇</p><p>DDL操作是隐性提交的！不能rollback </p><p><strong>4. 数据控制语言DCL</strong><br>数据控制语言DCL用来授予或回收访问数据库的某种特权，并控制<br>数据库操纵事务发生的时间及效果，对数据库实行监视等。如：</p><ol><li>GRANT：授权。</li></ol><ol start="2"><li>ROLLBACK [WORK] TO [SAVEPOINT]：回退到某一点。<br>回滚—ROLLBACK<br>回滚命令使数据库状态回到上次最后提交的状态。其格式为：<br>SQL&gt;ROLLBACK;</li></ol><ol start="3"><li>COMMIT [WORK]：提交。</li></ol><p>  在数据库的插入、删除和修改操作时，只有当事务在提交到数据<br>库时才算完成。在事务提交前，只有操作数据库的这个人才能有权看<br>到所做的事情，别人只有在最后提交完成后才可以看到。<br>提交数据有三种类型：显式提交、隐式提交及自动提交。下面分<br>别说明这三种类型。</p><p>(1) 显式提交<br>用COMMIT命令直接完成的提交为显式提交。其格式为：<br>SQL&gt;COMMIT；</p><p>(2) 隐式提交<br>用SQL命令间接完成的提交为隐式提交。这些命令是：<br>ALTER，AUDIT，COMMENT，CONNECT，CREATE，DISCONNECT，DROP，<br>EXIT，GRANT，NOAUDIT，QUIT，REVOKE，RENAME。</p><p>(3) 自动提交<br>若把AUTOCOMMIT设置为ON，则在插入、修改、删除语句执行后，<br>系统将自动进行提交，这就是自动提交。其格式为：<br>SQL&gt;SET AUTOCOMMIT ON；</p><h2 id="DDL语句"><a href="#DDL语句" class="headerlink" title="DDL语句"></a>DDL语句</h2><ul><li><p>库的DDL</p></li><li><p>创建语句，location就相当于数据库，他们之间是有映射关系的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE DATABASE [IF NOT EXISTS] database_name<br>[COMMENT database_comment]<br>[LOCATION hdfs_path]<br>[WITH DBPROPERTIES (property_name&#x3D;property_value, ...)];<br><br>--显示数据库<br>show databases;<br>hive&gt; show databases like &#39;db_hive*&#39;;<br>OK<br>db_hive<br>db_hive_1<br><br>--显示数据库详细信息<br>desc database extended db_hive;<br><br>--删除数据库<br>drop database db_hive2;<br><br>--如果数据库不为空，可以采用cascade命令，强制删除<br>drop database db_hive cascade;<br></code></pre></td></tr></table></figure></li><li><p>表的DDL</p></li><li><p>创建表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE [EXTERNAL] TABLE [IF NOT EXISTS] table_name <br>[(col_name data_type [COMMENT col_comment], ...)] <br>[COMMENT table_comment] <br>[PARTITIONED BY (col_name data_type [COMMENT col_comment], ...)] <br>[CLUSTERED BY (col_name, col_name, ...) <br>[SORTED BY (col_name [ASC|DESC], ...)] INTO num_buckets BUCKETS] <br>[ROW FORMAT row_format] <br>[STORED AS file_format] <br>[LOCATION hdfs_path]<br>[TBLPROPERTIES (property_name&#x3D;property_value, ...)]<br>[AS select_statement]<br><br>--（7）ROW FORMAT <br>DELIMITED [FIELDS TERMINATED BY char] [COLLECTION ITEMS TERMINATED BY char]<br>        [MAP KEYS TERMINATED BY char] [LINES TERMINATED BY char] <br>   | SERDE serde_name [WITH SERDEPROPERTIES (property_name&#x3D;property_value, property_name&#x3D;property_value, ...)]<br>用户在建表的时候可以自定义SerDe或者使用自带的SerDe。如果没有指定ROW FORMAT 或者ROW FORMAT DELIMITED，将会使用自带的SerDe。在建表的时候，用户还需要为表指定列，用户在指定表的列的同时也会指定自定义的SerDe，Hive通过SerDe确定表的具体的列的数据。<br><br></code></pre></td></tr></table></figure></li><li><p>内部表</p><ul><li>默认创建的是内部表，也叫管理表。当我们删除一个管理表时，Hive也会删除这个表中数据。管理表不适合和其他工具共享数据。</li></ul></li><li><p>外部表</p><ul><li>创建时加上 external</li><li>以Hive并非认为其完全拥有这份数据。删除该表并不会删除掉这份数据，不过描述表的元数据信息会被删除掉。</li></ul></li><li><p>内部表外部表转化</p><ul><li><p>修改内部表student2为外部表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">修改内部表student2为外部表<br>alter table student2 set tblproperties(&#39;EXTERNAL&#39;&#x3D;&#39;TRUE&#39;);<br><br>--查询表的类型<br>desc formatted student2;<br>--转换为内部表<br>alter table student2 set tblproperties(&#39;EXTERNAL&#39;&#x3D;&#39;FALSE&#39;);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>分区表</p></li><li><p>Hive中的分区就是分目录，把一个大的数据集根据业务需要分割成小的数据集。</p><ul><li>````mysql<br>create table dept_partition(deptno int, dname string, loc string<br>)<br>partitioned by (month string)<br>row format delimited fields terminated by ‘\t’;<br>–分区字段不能是表中已经存在的数据，可以将分区字段看作表的伪列。<br>– 查询分区表的分区<br>show partitions dept_partition<br>–如果提前准备数据，但是没有元数据<br>–把数据直接上传到分区目录上，让分区表和数据产生关联的三种方式<br>–1.添加分区<br>alter table dept_partition add partition(class=”03”)<br>–2.直接修复<br>msck repair table stu_par;<br>–3.上传带分区–同时创建分区<br>alter table dept_partition add partition(month=’201705’) partition(month=’201704’);<br>–删除多个分区<br> alter table dept_partition drop partition (month=’201705’), partition (month=’201706’);<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">  <br>- 分区表不能转换，只能在建表时就建好<br><br>- 支持二级分区<br><br>  ````mysql<br>  <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> dept_partition2(<br>                 deptno <span class="hljs-built_in">int</span>, dname <span class="hljs-keyword">string</span>, loc <span class="hljs-keyword">string</span><br>                 )<br>                 partitioned <span class="hljs-keyword">by</span> (<span class="hljs-keyword">month</span> <span class="hljs-keyword">string</span>, <span class="hljs-keyword">day</span> <span class="hljs-keyword">string</span>)<br>                 <span class="hljs-keyword">row</span> <span class="hljs-keyword">format</span> <span class="hljs-keyword">delimited</span> <span class="hljs-keyword">fields</span> <span class="hljs-keyword">terminated</span> <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;\t&#x27;</span>;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>修改表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE table_name RENAME TO new_table_name<br>--更新列<br>ALTER TABLE table_name CHANGE [COLUMN] col_old_name col_new_name column_type [COMMENT col_comment] [FIRST|AFTER column_name]<br>--增加和替换列<br>ALTER TABLE table_name ADD|REPLACE COLUMNS (col_name data_type [COMMENT col_comment], ...) <br>--删除表<br>drop table dept_partition;<br></code></pre></td></tr></table></figure></li></ul><h2 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h2><ul><li><p>数据导入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--创建语句<br>create table student(id string, name string) row format delimited fields terminated by &#39;\t&#39;;<br>--1.load导入数据<br>load data [local] inpath &#39;&#x2F;opt&#x2F;module&#x2F;datas&#x2F;student.txt&#39; [overwrite] into table student [partition (partcol1&#x3D;val1,…)];<br>--本地数据导入<br>load data local inpath &#39;&#x2F;opt&#x2F;module&#x2F;datas&#x2F;student.txt&#39; into table default.student;<br>--hdfs数据导入<br>load data inpath &#39;&#x2F;user&#x2F;atguigu&#x2F;hive&#x2F;student.txt&#39; into table default.student;<br>--加载数据覆盖表中已有的数据<br>load data inpath &#39;&#x2F;user&#x2F;atguigu&#x2F;hive&#x2F;student.txt&#39; overwrite into table default.student;<br>--hdfs的导入是移动，本地导入是复制<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--2.通过查询语句向表中插入数据（Insert）<br> create table student_par(id int, name string) partitioned by (month string) row format delimited fields terminated by &#39;\t&#39;;<br> <br> insert overwrite table student partition(month&#x3D;&#39;201708&#39;)<br>             select id, name from student where month&#x3D;&#39;201709&#39;;<br>             <br>--insert into：以追加数据的方式插入到表或分区，原有数据不会删除<br>--insert overwrite：会覆盖表或分区中已存在的数据<br><br>--3.建表时用as select<br>create table if not exists student3<br>as select id, name from student;<br><br>--4.创建表时通过Location指定加载数据路径<br>create external table if not exists student5(<br>              id int, name string<br>              )<br>              row format delimited fields terminated by &#39;\t&#39;<br>              location &#39;&#x2F;student;<br><br><br>--5.Import数据到指定Hive表中<br>import table student2 partition(month&#x3D;&#39;201709&#39;) from<br> &#39;&#x2F;user&#x2F;hive&#x2F;warehouse&#x2F;export&#x2F;student&#39;;<br></code></pre></td></tr></table></figure></li><li><p>数据导出(不重要)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--1. Insert导出<br>--将查询结果导出到本地<br>insert overwrite local directory &#39;&#x2F;opt&#x2F;module&#x2F;datas&#x2F;export&#x2F;student&#39;<br>            select * from student;<br>            <br>--将查询的结果格式化导出到本地<br>insert overwrite local directory &#39;&#x2F;opt&#x2F;module&#x2F;datas&#x2F;export&#x2F;student1&#39;<br>           ROW FORMAT DELIMITED FIELDS TERMINATED BY &#39;\t&#39;             select * from student;<br>           <br>--将查询的结果导出到HDFS上(没有local)<br>insert overwrite directory &#39;&#x2F;user&#x2F;zt&#x2F;student2&#39;<br>ROW FORMAT DELIMITED FIELDS TERMINATED BY &#39;\t&#39; <br>select * from student;<br>--整张表export 到处到HDFS<br>export table default.student to<br> &#39;&#x2F;user&#x2F;hive&#x2F;warehouse&#x2F;export&#x2F;student&#39;;<br></code></pre></td></tr></table></figure></li><li><p>清除数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--Truncate只能删除管理表（内部表），不能删除外部表中数据<br>--只删除数据，不删除本身<br>truncate table student;<br></code></pre></td></tr></table></figure></li></ul><h2 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h2><h3 id="数据查询语言"><a href="#数据查询语言" class="headerlink" title="数据查询语言"></a>数据查询语言</h3><h4 id="1-基本查询（select…-from…-）"><a href="#1-基本查询（select…-from…-）" class="headerlink" title="1. 基本查询（select…..from…..）"></a>1. 基本查询（select…..from…..）</h4><p>（1）SQL 语言大小写不敏感。 </p><p>（2）SQL 可以写在一行或者多行</p><p>（3）关键字不能被缩写也不能分行</p><p>（4）各子句一般要分行写。</p><p>（5）使用缩进提高语句的可读性。</p><ul><li><p>别名</p><ul><li><p>紧跟列名，也可以在列名和别名之间加入关键字‘AS’</p></li><li><p>select ename AS name, deptno dn from emp;</p></li></ul></li><li><p>算数运算符</p><ul><li>select sal +1 from emp;</li></ul><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>A+B</td><td>A和B 相加</td></tr><tr><td>A-B</td><td>A减去B</td></tr><tr><td>A*B</td><td>A和B 相乘</td></tr><tr><td>A/B</td><td>A除以B</td></tr><tr><td>A%B</td><td>A对B取余</td></tr><tr><td>A&amp;B</td><td>A和B按位取与</td></tr><tr><td>A|B</td><td>A和B按位取或</td></tr><tr><td>A^B</td><td>A和B按位取异或</td></tr><tr><td>~A</td><td>A按位取反</td></tr></tbody></table></li><li><p>常用函数</p><ul><li>UDF函数：一个输入一个输出 select substring(ename,1,1) from emp;（从　ｅname的1开始，取一个字符）用户定义（普通）函数，只对单行数值产生作用。实现：继承UDF，实现evaluate()方法</li><li>UDAF函数：多个输入，一个输出 select count(*) cnt from emp;用户定义聚合函数，可对多行数据产生作用；等同与SQL中常用的SUM()，AVG()，也是聚合函数；</li><li>UDTF函数：一个输入，多个输出。用户定义表生成函数。用来解决输入一行输出多行；实现：继承GenericUDTF，实现close(),initialize(),process()方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--1．求总行数（count）<br>select count(*) cnt from emp;<br>--2．求工资的最大值（max）<br>select max(sal) max_sal from emp;<br>--3．求工资的最小值（min）<br>select min(sal) min_sal from emp;<br>--4．求工资的总和（sum）<br>select sum(sal) sum_sal from emp; <br>--5．求工资的平均值（avg）<br>select avg(sal) avg_sal from emp;<br></code></pre></td></tr></table></figure></li><li><p>LIMIT子句用于限制返回的行数</p><ul><li>select * from emp limit 5;</li></ul></li></ul><h4 id="2-条件过滤"><a href="#2-条件过滤" class="headerlink" title="2.条件过滤"></a>2.条件过滤</h4><ol><li><p>使用where子句，将不满足条件的行过滤掉</p><p>select * from emp where sal =5000;</p></li><li><p>比较运算符：下面表中描述了谓词操作符，这些操作符同样可以用于JOIN…ON和HAVING语句中</p><table><thead><tr><th>操作符</th><th>支持的数据类型</th><th>描述</th></tr></thead><tbody><tr><td>A=B</td><td>基本数据类型</td><td>如果A等于B则返回TRUE，反之返回FALSE</td></tr><tr><td>A&lt;=&gt;B</td><td>基本数据类型</td><td>如果A和B都为NULL，则返回TRUE，其他的和等号（=）操作符的结果一致，如果任一为NULL则结果为NULL</td></tr><tr><td>A&lt;&gt;B, A!=B</td><td>基本数据类型</td><td>A或者B为NULL则返回NULL；如果A不等于B，则返回TRUE，反之返回FALSE</td></tr><tr><td>A&lt;B</td><td>基本数据类型</td><td>A或者B为NULL，则返回NULL；如果A小于B，则返回TRUE，反之返回FALSE</td></tr><tr><td>A&lt;=B</td><td>基本数据类型</td><td>A或者B为NULL，则返回NULL；如果A小于等于B，则返回TRUE，反之返回FALSE</td></tr><tr><td>A&gt;B</td><td>基本数据类型</td><td>A或者B为NULL，则返回NULL；如果A大于B，则返回TRUE，反之返回FALSE</td></tr><tr><td>A&gt;=B</td><td>基本数据类型</td><td>A或者B为NULL，则返回NULL；如果A大于等于B，则返回TRUE，反之返回FALSE</td></tr><tr><td>A [NOT] BETWEEN B AND C</td><td>基本数据类型</td><td>如果A，B或者C任一为NULL，则结果为NULL。如果A的值大于等于B而且小于或等于C，则结果为TRUE，反之为FALSE。如果使用NOT关键字则可达到相反的效果。</td></tr><tr><td>A IS NULL</td><td>所有数据类型</td><td>如果A等于NULL，则返回TRUE，反之返回FALSE</td></tr><tr><td>A IS NOT NULL</td><td>所有数据类型</td><td>如果A不等于NULL，则返回TRUE，反之返回FALSE</td></tr><tr><td>IN(数值1, 数值2)</td><td>所有数据类型</td><td>使用 IN运算显示列表中的值</td></tr><tr><td>A [NOT] LIKE B</td><td>STRING 类型</td><td>B是一个SQL下的简单正则表达式，也叫通配符模式，如果A与其匹配的话，则返回TRUE；反之返回FALSE。B的表达式说明如下：‘x%’表示A必须以字母‘x’开头，‘%x’表示A必须以字母’x’结尾，而‘%x%’表示A包含有字母’x’,可以位于开头，结尾或者字符串中间。如果使用NOT关键字则可达到相反的效果。</td></tr><tr><td>A RLIKE B, A REGEXP B</td><td>STRING 类型</td><td>B是基于java的正则表达式，如果A与其匹配，则返回TRUE；反之返回FALSE。匹配使用的是JDK中的正则表达式接口实现的，因为正则也依据其中的规则。例如，正则表达式必须和整个字符串A相匹配，而不是只需与其字符串匹配。</td></tr></tbody></table></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--通配符字符串匹配　% _<br>--%匹配任意串，_匹配任意字符<br>--查询以A开头的员工<br>select * from emp where ename like &quot;A%&quot;;<br><br>--正则匹配<br>--查询以A开头的员工<br>select * from emp where ename rlike &quot;^A&quot;; <br></code></pre></td></tr></table></figure><ul><li><p>rlike匹配正则表达式</p></li><li><p>正则表达式</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs powershell">一般字符匹配自己<br>^ 匹配一行开头 ^R 以<span class="hljs-built_in">R</span>开头<br><span class="hljs-variable">$</span> 匹配一行结束 <span class="hljs-built_in">R</span><span class="hljs-variable">$</span> 以<span class="hljs-built_in">R</span>结尾<br>. 匹配任意字符 ^.<span class="hljs-variable">$</span> 一行只有一个字符<br>* 前一个子式匹配零次或多次<br>.*匹配任意字符<br>[] 匹配一个范围内的任意字符<br>\ 转义<br></code></pre></td></tr></table></figure></li></ul><ol start="3"><li><p>逻辑运算符（AND，OR，NOT）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from emp where sal&gt;1000 and deptno&#x3D;30;<br>select * from emp where sal&gt;1000 or deptno&#x3D;30;<br>select * from emp where deptno not IN(30, 20);<br></code></pre></td></tr></table></figure></li></ol><h4 id="3-分组"><a href="#3-分组" class="headerlink" title="3. 分组"></a>3. 分组</h4><ul><li><p>GROUP BY语句通常会和聚合函数一起使用，按照一个或者多个列队结果进行分组，然后对每个组执行聚合操作。</p></li><li><p>（1）where后面不能写分组函数，而having后面可以使用分组函数。</p><p>（2）having只用于group by分组统计语句。</p></li><li><p>````mysql<br>–计算emp表每个部门的平均工资<br>select t.deptno, avg(t.sal) avg_sal from emp t group by t.deptno<br>–求每个部门的平均薪水大于2000的部门<br>select deptno, avg(sal) avg_sal from emp group by deptno having<br> avg_sal &gt; 2000;</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><br>#### 4.连接<br><br>* Hive支持通常的SQL JOIN语句，但是只支持等值连接，不支持非等值连接。<br><br>  - 内连接<br>  - 左外连接<br>  - 右外连接<br>  - 满外连接<br><br>  ````mysql<br>  <span class="hljs-keyword">select</span><br>      <span class="hljs-built_in">e</span>.empno,<br>      <span class="hljs-built_in">e</span>.ename,<br>      d.deptno, <br>      d.dname <br>  <span class="hljs-keyword">from</span> <br>      emp <span class="hljs-built_in">e</span> <br>  <span class="hljs-keyword">join</span><br>      dept d <br>  <span class="hljs-keyword">on</span><br>      <span class="hljs-built_in">e</span>.deptno = d.deptno;<br>      <br></code></pre></td></tr></table></figure></li><li><p>表的别名：好处：1.简化查询，使用表名前缀可以提高执行效率</p></li><li><p>多表连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT <br>    e.ename,<br>    d.dname, <br>    l.loc_name<br>FROM<br>emp e <br>JOIN<br>dept d<br>ON<br>d.deptno &#x3D; e.deptno <br>JOIN<br>location l<br>ON<br>d.loc &#x3D; l.loc;<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>hive join目前不支持在on子句中使用谓词or(hive1 不支持)</p><p>select e.empno, e.ename, d.deptno from emp e join dept d on e.deptno</p><p>= d.deptno or e.ename=d.deptno;  在hive1错误的,hive3支持</p></li></ul><h4 id="5-排序"><a href="#5-排序" class="headerlink" title="5.排序"></a>5.排序</h4><ul><li>order by:全局排序，只有一个Reducer</li><li>ASC（ascend）: 升序（默认）</li><li>DESC（descend）: 降序</li><li>sort by:局部排序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--一般需求不会要求给所有的数据排序，而要求知道前几<br>--求工资前10的人，Map会先求局部前10<br>select *<br>from emp<br>order by sal desc<br>limit 10;<br><br>--还有一种可能，我们只需要看大概的数据趋势，不需要全排序<br>--Hive的局部排序 sort by<br>select *<br>from emp<br>sort by empno desc;<br><br>--多条件排序，先按部门排序，再按工资排序<br>select *<br>from emp<br>order by<br>deptno asc,<br>sal desc;<br><br>--limit,offset<br>limit X,Y 跳过X条数据，取Y条数据<br>offset X 跳过X条数据<br></code></pre></td></tr></table></figure><ul><li><p>分区排序 （Distribute By）</p></li><li><p><em><strong>distribute by</strong></em>类似MR中partition（自定义分区），进行分区，结合sort by使用。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--指定局部排序的分区字段<br>select * from emp<br>distribute by empno<br>sort by sal desc;<br><br>--如果分区和排序的字段一样，我们可以用cluster by代替<br>select * from emp distribute by empno sort by empno;<br>select * from emp cluster by empno;<br></code></pre></td></tr></table></figure></li><li><p>当distribute by和sorts by字段相同时，可以使用cluster by方式。</p></li></ul><h4 id="6-分桶"><a href="#6-分桶" class="headerlink" title="6.分桶"></a>6.分桶</h4><ul><li><p>分区提供一个隔离数据和优化查询的便利方式。不过，并非所有的数据集都可形成合理的分区。对于一张表或者分区，Hive 可以进一步组织成桶，也就是更为细粒度的数据范围划分。</p></li><li><p>分区针对的是数据的存储路径；分桶针对的是数据文件。</p></li><li><p>分桶：针对某一个区的数据，把它的数据进一步组织成多个文件</p></li><li><p>分区：把多个数据，分成文件夹管理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table stu_buck(id int, name string)<br>clustered by(id) <br>into 4 buckets<br>row format delimited fields terminated by &#39;\t&#39;;<br><br><br></code></pre></td></tr></table></figure></li><li><p>分桶抽样查询</p></li><li><p>对于非常大的数据集，有时用户需要使用的是一个具有代表性的查询结果而不是全部结果。Hive可以通过对表进行抽样来满足这个需求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from stu_buck tablesample(bucket 1 out of 4 on id);<br>--tablesample是抽样语句，语法：TABLESAMPLE(BUCKET x OUT OF y) <br>--y必须是table总bucket数的倍数或者因子。hive根据y的大小，决定抽样的比例<br>把数据按照bucket分成y份，取其中的第x份<br></code></pre></td></tr></table></figure></li></ul><h3 id="常用查询函数"><a href="#常用查询函数" class="headerlink" title="常用查询函数"></a>常用查询函数</h3><h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">hive中查询函数<br>show functions<br>show functions like &quot;collect*&quot;<br>查看函数的描述<br>desc function 函数名<br>--nvl空字段赋值<br>select comm, nvl(comm, -1) from emp;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--case when<br>--统计不同部门男女各有多少人<br>select<br>    dept_id,<br>    count(*) total,<br>    sum(case sex when &#39;男&#39; then 1 else 0 end) male,<br>    sum(case sex when &#39;女&#39; then 1 else 0 end) female<br>from<br>    emp_sex<br>group by<br>    dept_id;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">在 Group by 子句中，Select 查询的列，要么需要是 Group by 中的列，要么得是用聚合函数（比如 sum、count 等）加工过的列。不支持直接引用非 Group by 的列。这一点和 MySQL 有所区别。Hive 错误 Expression not in GROUP BY key的原因。<br>--行转列<br>collect_list(x),聚合成一个数组，聚合函数<br>concat_ws(&quot;分隔符&quot;，数组)，把数组按分割符拼成一个字符串<br>contact(str1,str2......,strn)拼接几列在一起<br><br>select<br>    concat(constellation,&quot;,&quot;,blood_type) xzxx,<br>    concat_ws(&quot;|&quot;, collect_list(name)) rentou<br>from<br>    person_info<br>group by<br>    constellation,blood_type;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--列转行<br>--explode(a)函数<br>--如果传入的是一个数组，则将其分成多行<br>--如果传入一个map,按照key,value分成两列<br>--split(str,regrex)函数<br>--将一个字符串按照正则表达式规则划分成一个数组<br>lateral view 后面接一个表名，起一个列名，列名取决于explode()炸开后的效果。<br>select<br>    m.movie,<br>    tbl.cate<br>from<br>    movie_info m<br>lateral view<br>    explode(split(category, &quot;,&quot;)) tbl as cate;<br></code></pre></td></tr></table></figure><h4 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h4><ul><li><p>相关函数说明</p><p>OVER()：指定分析函数工作的数据窗口大小，这个数据窗口大小可能会随着行的变而变化。</p><p>CURRENT ROW：当前行</p><p>n PRECEDING：往前n行数据</p><p>n FOLLOWING：往后n行数据</p><p>UNBOUNDED：起点，UNBOUNDED PRECEDING 表示从前面的起点， UNBOUNDED FOLLOWING表示到后面的终点</p><p>LAG(col,n,default_val)：往前第n行数据</p><p>LEAD(col,n, default_val)：往后第n行数据</p><p>NTILE(n)：把有序窗口的行分发到指定数据的组中，各个组有编号，编号从1开始，对于每一行，NTILE返回此行所属的组的编号。注意：n必须为int类型。</p><p>percent_rank()将数据按百分比分</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--聚合<br>select name,count(*) over () <br>from business <br>where substring(orderdate,1,7) &#x3D; &#39;2017-04&#39; <br>group by name;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--各种聚合<br>select name,orderdate,cost, <br>sum(cost) over() as sample1,--所有行相加 <br>sum(cost) over(partition by name) as sample2,--按name分组，组内数据相加 <br>sum(cost) over(partition by name order by orderdate) as sample3,--按name分组，组内数据累加 <br>sum(cost) over(partition by name order by orderdate rows between UNBOUNDED PRECEDING and current row ) as sample4 ,--和sample3一样,由起点到当前行的聚合 <br>sum(cost) over(partition by name order by orderdate rows between 1 PRECEDING and current row) as sample5, --当前行和前面一行做聚合 <br>sum(cost) over(partition by name order by orderdate rows between 1 PRECEDING AND 1 FOLLOWING ) as sample6,--当前行和前边一行及后面一行 <br>sum(cost) over(partition by name order by orderdate rows between current row and UNBOUNDED FOLLOWING ) as sample7 --当前行及后面所有行 <br>from business;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--结合其他函数使用<br>select<br>    name, orderdate, cost, <br>    lag(orderdate, 1) <br>    over(partition by name order by orderdate) last_order,<br>    lead(orderdate, 1) <br>    over(partition by name order by orderdate) next_order<br>from<br>    business;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--ntile<br>Ntile(group_num) 将所有记录分成group_num个组，每组序号一样<br>SELECT<br>*<br>FROM<br>(<br>select name,<br>orderdate,<br>cost,<br>ntile(5) over(<br>order by orderdate) n<br>from<br>business) t1<br>WHERE<br>n &#x3D; 1;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--percent_rank<br>select<br>name,<br>orderdate,<br>cost,<br>PERCENT_RANK() over(<br>order by orderdate) pr<br>from<br>business;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--rank<br>rank()排序，相同的一样排名，数字按照实际的来，类似于高考排名<br>dense_rank() 相同的一样排名，数字按照排名的数字来<br>row_number() 直接排名，相同的排名也不一样<br>SELECT<br>*,<br>rank() OVER(partition by subject<br>order by<br>score desc) r,<br>DENSE_RANK() OVER(partition by subject<br>order by<br>score desc) dr,<br>ROW_NUMBER() OVER(partition by subject<br>order by<br>score desc) rn<br>from<br>score;<br></code></pre></td></tr></table></figure><h4 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--current_date 返回当前日期<br>select current_date();<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--日期的加减<br>--今天开始90天以后的日期<br>select date_add(current_date(), 90);<br>--今天开始90天以前的日期<br>select date_sub(current_date(), 90);<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--日期差<br>SELECT datediff(CURRENT_DATE(), &quot;1990-06-04&quot;);<br></code></pre></td></tr></table></figure><p>习题：有哪些顾客连续两天来过我的店，数据是business表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--习题<br>selec<br><br>--time1下一次购买商品的时间<br>select<br>name,cost,orderdate,<br>lead(orderdate,1,&quot;2021-09-01&quot;) over(partition by name order by orderdate) time1<br>from<br>business<br><br>--时间差<br>select<br>name,cost,orderdate,time1,<br>datediff(time1,orderdate) difftime<br>from<br>    (select<br>name,cost,orderdate,<br>lead(orderdate,1,&quot;2021-09-01&quot;) over(partition by name order by orderdate) time1<br>from<br>business) tab;<br><br>--找到时间差为1的人<br>select<br>name,corderdate,time1,difftime<br>from<br>(select<br>name,cost,orderdate,time1,<br>datediff(time1,orderdate) difftime<br>from<br>    (select<br>name,cost,orderdate,<br>lead(orderdate,1,&quot;2021-09-01&quot;) over(partition by name order by orderdate) time1<br>from<br>business) tab) tab1<br>where<br>difftime&#x3D;1;<br><br></code></pre></td></tr></table></figure><ul><li>hive重点：写sql,熟练使用函数，尤其是开窗函数</li></ul><h3 id="SQL一般执行顺序"><a href="#SQL一般执行顺序" class="headerlink" title="SQL一般执行顺序"></a>SQL一般执行顺序</h3><ol><li>from 确定基表</li><li>join 如果一张基表不够, 再联接其他表</li><li>on 如果有联接表 必须要有on</li><li>where 过滤总基表中的行</li><li>group by 分组, 分组依据的列.</li><li>select 把分组依据的列放在select后, 再考虑要选择哪些列, 及进行哪些函数调用….</li><li>having 进一步把分组后的虚表行过滤</li><li><em><strong>窗口函数</strong></em></li><li>order by 最终表的一个排序显示.</li><li>limit</li></ol>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Hive</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大数据</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HA&amp;ZooKeeper</title>
    <link href="/2021/06/02/HAHA-zk/"/>
    <url>/2021/06/02/HAHA-zk/</url>
    
    <content type="html"><![CDATA[<h1 id="HA-amp-ZooKeeper"><a href="#HA-amp-ZooKeeper" class="headerlink" title="HA&amp;ZooKeeper"></a>HA&amp;ZooKeeper</h1><h2 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h2><h3 id="zk概述"><a href="#zk概述" class="headerlink" title="zk概述"></a>zk概述</h3><ul><li>ZooKeeper是一个开源的分布式的，为分布式应用提供协调服务的Apache项目。</li><li>设计模式：是一个基于观察者模式设计的分布式服务管理框架，它辅助存储和管理大家都关心的数据，然后接受观察者的注册，一旦这些数据的状态发生变化，Zookeeper就将负责通知已经在Zookeeper上注册的那些观察者做出相应的反应。</li><li>Zookeeper特点，数据结构<ul><li><a href="https://imgtu.com/i/2lpCjI"><img src="https://z3.ax1x.com/2021/06/02/2lpCjI.png" alt="2lpCjI.png"></a></li><li><a href="https://imgtu.com/i/2lpmCQ"><img src="https://z3.ax1x.com/2021/06/02/2lpmCQ.png" alt="2lpmCQ.png"></a></li></ul></li></ul><h3 id="zk实战应用"><a href="#zk实战应用" class="headerlink" title="zk实战应用"></a>zk实战应用</h3><ul><li><p>客户端命令</p></li><li><p>启动客户端：zkCli.sh</p><table><thead><tr><th>命令基本语法</th><th>功能描述</th></tr></thead><tbody><tr><td>help</td><td>显示所有操作命令</td></tr><tr><td>ls path [watch]</td><td>使用 ls 命令来查看当前znode中所包含的内容</td></tr><tr><td>ls2 path [watch]</td><td>查看当前节点数据并能看到更新次数等数据</td></tr><tr><td>create</td><td>普通创建-s  含有序列-e  临时（重启或者超时消失）</td></tr><tr><td>get path [watch]</td><td>获得节点的值</td></tr><tr><td>set</td><td>设置节点的具体值</td></tr><tr><td>stat</td><td>查看节点状态</td></tr><tr><td>delete</td><td>删除节点</td></tr><tr><td>rmr</td><td>递归删除节点</td></tr></tbody></table></li></ul><h3 id="zk内部原理"><a href="#zk内部原理" class="headerlink" title="zk内部原理"></a>zk内部原理</h3><ul><li><p>节点类型</p><p><a href="https://imgtu.com/i/2lpq2j"><img src="https://z3.ax1x.com/2021/06/02/2lpq2j.png" alt="2lpq2j.png"></a></p></li></ul><ul><li><p>Stat结构体</p><ol><li><p>czxid-创建节点的事务zxid</p><p>每次修改ZooKeeper状态都会收到一个zxid形式的时间戳，也就是ZooKeeper事务ID。</p><p>事务ID是ZooKeeper中所有修改总的次序。每个修改都有唯一的zxid，如果zxid1小于zxid2，那么zxid1在zxid2之前发生。</p></li></ol></li><li><p>监听器原理</p><p> <img src="C:\Users\Hasee\AppData\Roaming\Typora\typora-user-images\image-20210602195353003.png" alt="image-20210602195353003"></p></li><li><p>选举机制</p><ul><li><a href="https://imgtu.com/i/2l9oO1"><img src="https://z3.ax1x.com/2021/06/02/2l9oO1.png" alt="2l9oO1.png"></a><ol><li>集群会通过比较先会比较zxid,若zxid相同则比较myid选择leader(每次修改ZooKeeper状态都会收到一个zxid形式的时间戳，也就是ZooKeeper事务ID)</li><li>若第一次启动集群（zxid相等）myid如图所示：则大致流程如下：<ol><li>server1投票给自己，但是票数没到集群机器的半数以上，选举无法进行。server1状态为LOOKING</li><li>server2启动，发起选举，投票给自己，1发现2的myid大，更改选票为2。同理选举依然没法完成。</li><li>3启动，发起选举，投给自己，1，2发现3的myid大。则1，2将选票投给3，3获得三票。成为Leader,1,2更改状态为FOLLOWING。3更改状态为LEADING。</li><li>4启动，发起选举，1，2，3不在是LOOKING状态，不会更改选票信息。交换选票信息后，3为3票，4为一票，少数服从多数，更改选票信息为server3，更改状态为FOLLOWING。</li><li>同4一样</li></ol></li></ol></li></ul></li><li><p>ZAB</p><ul><li><p>ZAB协议是专门为zookeeper实现分布式协调功能而设计。zookeeper主要是根据ZAB协议是实现分布式系统数据一致性</p></li><li><p>写数据流程：</p><p><a href="https://imgtu.com/i/2lERBj"><img src="https://z3.ax1x.com/2021/06/02/2lERBj.png" alt="2lERBj.png"></a></p><ul><li>三个服务器会对是否写数据提出意见，都同意那正常执行写操作</li><li>一个server不同意而总票数支持同意，该server自杀再重启，再朝Leader同步信息</li><li>leader不同意，但总票数同意。leader自杀重启，重新选举leader，重启后再向leader同步数据</li><li>为什么会不同意：查看zxid，如果发来的zxid事物请求比自身的大才会同意</li><li>总之就是要尽可能的保持集群数据的一致性。</li></ul></li></ul></li></ul><h2 id="HA"><a href="#HA" class="headerlink" title="HA"></a>HA</h2><h3 id="HA概述"><a href="#HA概述" class="headerlink" title="HA概述"></a>HA概述</h3><ul><li>HA（High Availablity）</li><li>实现高可用最重要的是消除单点故障</li><li>防止出现namenode节点挂了，无法正常提供服务</li></ul><h3 id="HA工作机制"><a href="#HA工作机制" class="headerlink" title="HA工作机制"></a>HA工作机制</h3><ul><li><p>故障转移机制 HDFS-HA</p><p><a href="https://imgtu.com/i/2lA1SS"><img src="https://z3.ax1x.com/2021/06/02/2lA1SS.png" alt="2lA1SS.png"></a></p></li><li><p>故障转移机制</p><ul><li>为了保证数据不丢失，一个失效后另一个补上不会丢失数据，日志文件写到第三方平台（相当于2nn）</li><li>新激活的namenode 可以从第三方，读取edits文件将缺少的数据补上，防止数据丢失</li><li>Zkfc检测到假死后是通过zookeeper服务器将信息传到其它的namenode的zkfc</li></ul></li><li><p>YARN-HA</p><p><a href="https://imgtu.com/i/2lAaF0"><img src="https://z3.ax1x.com/2021/06/02/2lAaF0.png" alt="2lAaF0.png"></a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Hadoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>zookeeper</tag>
      
      <tag>HA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaWeb</title>
    <link href="/2021/05/26/JavaWeb/"/>
    <url>/2021/05/26/JavaWeb/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaWeb"><a href="#JavaWeb" class="headerlink" title="JavaWeb"></a>JavaWeb</h1><h2 id="网页的组成"><a href="#网页的组成" class="headerlink" title="网页的组成"></a>网页的组成</h2><ul><li>结构（HTML)<ul><li>超文本标记语言</li><li>网页的主要内容通过html来实现</li><li>用来写网页的语言</li></ul></li><li>表现（CSS)<ul><li>层叠样式表</li><li>网页的字体颜色、背景色、背景图片等通过它来实现</li><li>用来美化网页</li></ul></li><li>行为（JavaScript/jQuery）<ul><li>用来实现网页上的一下动态的效果</li></ul></li><li>一个良好的网页要求结构、表现、行为三者分离</li></ul><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><ul><li><p>常用的标签</p><ul><li><p>标题标签</p><ul><li>一共六个（h1到h6）</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><br>    一级标题<br><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span><br>    二级标题<br><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>...<br><span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span><br>    六级标题<br><span class="hljs-tag">&lt;/<span class="hljs-name">h6</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>超链接</p><ul><li><p>通过a标签创建一个超链接</p><ul><li>通过a标签中的href属性指定要跳转的页面的地址</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;设置要跳转的页面的地址&quot;</span>&gt;</span>我是超链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>表格</p><ul><li>通过table标签创建一个表格<ul><li>表格中的行通过tr标签来表示<ul><li>表格中的表头通过th标签来表示</li><li>表格中的列（单元格）通过td标签来标签<ul><li>通过rowspan属性跨行合并单元格</li><li>通过colspan属性跨列合并单元格</li></ul></li></ul></li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>性别<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>年龄<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>盖伦<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>19<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>表单</p><ul><li>使用form标签创建一个表单<ul><li>通过action属性指定要提交的服务器的地址</li><li>通过method属性指定提交的请求方式</li><li>通过input标签创建表单项<ul><li>type值是text的是文本框</li><li>type值是password的是密码框</li><li>type值是submit的是提交按钮</li><li>type值不可用任意指定，通过alt+/根据提示选择</li><li>必须给input指定name属性值<ul><li>name属性值可用任意指定</li></ul></li></ul></li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 通过form标签创建一个表单 </span><br><span class="hljs-comment">action属性：设置要提交的服务器的地址</span><br><span class="hljs-comment">method属性：设置请求方式</span><br><span class="hljs-comment">get：将发送一个GET请求，此时用户输入的数据是通过浏览器的地址栏进行传输</span><br><span class="hljs-comment">post：将发送一个POST请求，此时用户输入的数据通过HTTP协议中请求报文中的请求体进行传输</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;success.html&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">表单中的表单项通过input标签来创建，表单项的类型通过type属性来指定；</span><br><span class="hljs-comment">必须给表单项指定name属性值，用户输入的数据通过name属性值进行携带，并以键值对的形式发送到</span><br><span class="hljs-comment">服务器，多个键值对之间使用 &amp;符号分隔，例如：username=admin&amp;password=123456</span><br><span class="hljs-comment"> --&gt;</span><br>用户名称：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>用户密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 提交按钮上显示的文字通过value指定 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;登录&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><ul><li><p>CSS样式可用书写的位置</p><ul><li><p>1）写在标签的style属性中</p><ul><li>结构与表现相耦合，不建议使用</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red;font-size: &quot;</span>&gt;</span>我是一个段落<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>2）写在style标签中，style标签放在head标签中</p><ul><li>开发测试阶段使用这种方式</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><br><span class="css"><span class="hljs-selector-id">#rd</span>&#123;</span><br><span class="css"><span class="hljs-selector-tag">color</span>: <span class="hljs-selector-id">#FBA</span></span><br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>3）引入外部的css文件</p><ul><li>项目上线后使用这种方式</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;style.css&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>CSS种的基本选择器</p><ul><li>标签选择器</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &#123;<br><span class="hljs-attribute">color</span>: red<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>ID选择器<ul><li>格式：#id属性值</li></ul></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#p1</span> &#123;<br><span class="hljs-attribute">color</span>: green<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>类选择器<ul><li>格式：.class属性值</li></ul></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.p2</span> &#123;<br><span class="hljs-attribute">color</span>: blue<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>分组选择器</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#p1</span>, <span class="hljs-selector-class">.p2</span> &#123;<br><span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><ul><li><p>JavaScript可用书写的位置跟CSS类似，一共三种方式</p></li><li><p>变量</p><ul><li>通过var关键字声明一个变量</li><li>在使用变量的过程种可用给它赋任意值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a; a=<span class="hljs-number">123</span>; a=<span class="hljs-string">&quot;hello&quot;</span>;a=函数；a=对象；<br><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;javascript&quot;</span>;<br></code></pre></td></tr></table></figure></li><li><p>函数</p><ul><li>通过function关键字声明一个函数</li><li>在声明函数时不需要指定返回值的类型及形参的类型</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//方式一：</span><br><span class="hljs-comment">//不带参数的函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-comment">//函数体</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a,b</span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-comment">//方式二：</span><br><span class="hljs-keyword">var</span> sum2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b,c</span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> a + b + c;<br>&#125;<br><span class="hljs-comment">//我们通常是通过方式二这种方式将一个函数赋给对象的事件属性</span><br></code></pre></td></tr></table></figure></li><li><p>DOM</p><ul><li>全称：Document Object Model，文档对象模型</li><li>DOM种常用的属性和方法<ul><li>document.getElementById(“id属性值”)<ul><li>根据标签的id属性值获取一个具体的标签对象</li></ul></li><li>对象.innerHTML<ul><li>获取或设置成对出现的标签中的文本内容<ul><li>对象.innerHTML<ul><li>获取文本内容</li></ul></li><li>对象.innerHTML=”new valule”<ul><li>设置文本内容</li></ul></li></ul></li><li>在jQuery中与之对应的是text()/html()方法</li></ul></li><li>对象.onclick<ul><li>给对象绑定单击事件</li><li>在jQuery中与之对应的是click()方法</li></ul></li><li>对象.onfocus<ul><li>给对象绑定获取焦点事件</li><li>在jQuery中与之对应的是focus()方法</li></ul></li><li>对象.onblur<ul><li>给对象绑定失去焦点的事件</li><li>在jQuery中与之对应的是blur()方法</li></ul></li><li>对象.onchange<ul><li>给对象内容改变的事件</li><li>在jQuery中与之对应的是change()方法</li></ul></li></ul></li></ul></li></ul><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><ul><li>Servlet是服务器端的一个组件，用来处理用户的请求</li><li>直接new一个Sersvlet，然后配置映射的请求地址即可</li><li>doGet和doPost方法中的两个参数request和response的作用<ul><li>request的作用<ul><li>获取请求参数</li><li>转发</li><li>它是一个域对象</li></ul></li><li>response的作用<ul><li>给浏览器响应一个字符串或一个页面</li><li>重定向</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//处理GET请求的方法</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;doGet方法被调用&quot;</span>);<br><span class="hljs-comment">//request的作用</span><br><span class="hljs-comment">//1.获取请求参数</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * GET请求的请求中文乱码问题的解决方案：</span><br><span class="hljs-comment"> * 在Tomcat的配置文件server.xml中的第一个Connector标签中添加属性URIEncoding=&quot;UTF-8&quot;</span><br><span class="hljs-comment"> */</span><br>String username = request.getParameter(<span class="hljs-string">&quot;username&quot;</span>);<br>String password = request.getParameter(<span class="hljs-string">&quot;password&quot;</span>);<br>System.out.println(username);<br>System.out.println(password);<br><span class="hljs-comment">//2.转发</span><br><span class="hljs-comment">//获取转发器</span><br>RequestDispatcher requestDispatcher = request.getRequestDispatcher(<span class="hljs-string">&quot;WEB-INF/success.html&quot;</span>);<br><span class="hljs-comment">//进行请求的转发</span><br>requestDispatcher.forward(request, response);<br><span class="hljs-comment">//3.request是一个域对象（下回分解）</span><br>&#125;<br><span class="hljs-comment">//处理POST请求的方法</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;doPost方法被调用&quot;</span>);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * POST请求的请求中文乱码问题的解决方案：</span><br><span class="hljs-comment"> * 在第一次获取请求参数之前，通过request设置字符集位UTF-8</span><br><span class="hljs-comment"> */</span><br>request.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>String username = request.getParameter(<span class="hljs-string">&quot;username&quot;</span>);<br>String password = request.getParameter(<span class="hljs-string">&quot;password&quot;</span>);<br>System.out.println(username);<br>System.out.println(password);<br><span class="hljs-comment">//response的作用</span><br><span class="hljs-comment">//1.给浏览器响应一个字符串或一个页面</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 响应中文乱码的解决方案：</span><br><span class="hljs-comment"> * 在获取流之前设置内容的类型，内容的类型中包含UTF-8字符集</span><br><span class="hljs-comment"> */</span><br>response.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<br>PrintWriter writer = response.getWriter();<br><span class="hljs-comment">//writer.write(&quot;Response Success!&quot;);</span><br><span class="hljs-comment">//writer.write(&quot;响应成功！&quot;);</span><br><span class="hljs-comment">//writer.write(&quot;&lt;!DOCTYPE html&gt;\r\n&quot; + </span><br><span class="hljs-comment">//&quot;&lt;html&gt;\r\n&quot; + </span><br><span class="hljs-comment">//&quot;&lt;head&gt;\r\n&quot; + </span><br><span class="hljs-comment">//&quot;&lt;meta charset=\&quot;UTF-8\&quot;&gt;\r\n&quot; + </span><br><span class="hljs-comment">//&quot;&lt;title&gt;Insert title here&lt;/title&gt;\r\n&quot; + </span><br><span class="hljs-comment">//&quot;&lt;/head&gt;\r\n&quot; + </span><br><span class="hljs-comment">//&quot;&lt;body&gt;\r\n&quot; + </span><br><span class="hljs-comment">//&quot;&lt;h1&gt;请求处理成功！&lt;/h1&gt;\r\n&quot; + </span><br><span class="hljs-comment">//&quot;&lt;/body&gt;\r\n&quot; + </span><br><span class="hljs-comment">//&quot;&lt;/html&gt;&quot;);</span><br><span class="hljs-comment">//2.重定向</span><br>response.sendRedirect(<span class="hljs-string">&quot;WEB-INF/success.html&quot;</span>);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 转发与重定向的区别：</span><br><span class="hljs-comment"> * 1.转发浏览器发送一次请求；重定向浏览器发送两次请求</span><br><span class="hljs-comment"> * 2.转发浏览器地址栏地址无变化；重定向浏览器地址栏地址有变化</span><br><span class="hljs-comment"> * 3.转发可以访问WEB-INF目录下的资源；重定向不可以访问WEB-INF目录下的资源</span><br><span class="hljs-comment"> * 4.转发可以共享request域中的数据；重定向不可以共享request域中的数据</span><br><span class="hljs-comment"> */</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><ul><li><p>JSP必须运行服务器上，它本质上是一个Servlet</p></li><li><p>HTML和Servlet能实现的功能JSP都可用实现</p></li><li><p>JSP中的基本语法</p><ul><li>JSP脚本片段<ul><li>格式：&lt;%   %&gt;</li><li>作用：在里面写Java代码</li></ul></li><li>JSP表达式<ul><li>格式：&lt;%=  %&gt;</li><li>作用：用来输出对象</li></ul></li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">10</span> ; i++)&#123;<br><span class="hljs-comment">//out.print(&quot;伊朗要干美国了！&quot;);</span><br>%&gt;<br>&lt;h1&gt;伊朗要干美国了！&lt;/h1&gt;<br>&lt;%<br>&#125;<br>%&gt;<br><br> &lt;%=<span class="hljs-string">&quot;我是通过JSP表达式输出的&quot;</span> %&gt;<br></code></pre></td></tr></table></figure></li><li><p>四个域</p><ul><li>page域<ul><li>范围：当前页面</li><li>对应的域对象：pageContext</li><li>域对象的类型：PageContext</li></ul></li><li>request域<ul><li>范围：当前请求（一次请求）</li><li>对应的域对象：request</li><li>域对象的类型：HttpServletRequest</li></ul></li><li>session<ul><li>范围：当前会话（一次会话）</li><li>对应的域对象：session</li><li>域对象的类型：HttpSession</li></ul></li><li>application域<ul><li>范围：当前Web应用</li><li>对应的域对象：application</li><li>域对象的类型：ServletContext</li></ul></li><li>四个域对象都有以下三个方法<ul><li>void setAttribute(String key , Object value)</li><li>Object getAttribute(String key)</li><li>void removeAttribute(String key)</li></ul></li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;!-- 在当前页面中分别向四个域中添加四个属性 --&gt;<br> &lt;%<br> pageContext.setAttribute(<span class="hljs-string">&quot;pageKey&quot;</span>, <span class="hljs-string">&quot;pageValue&quot;</span>);<br> request.setAttribute(<span class="hljs-string">&quot;reqKey&quot;</span>, <span class="hljs-string">&quot;reqValue&quot;</span>);<br> session.setAttribute(<span class="hljs-string">&quot;sessKey&quot;</span>, <span class="hljs-string">&quot;sessValue&quot;</span>);<br> application.setAttribute(<span class="hljs-string">&quot;appKey&quot;</span>, <span class="hljs-string">&quot;appValue&quot;</span>);<br> %&gt;<br> &lt;h1&gt;在当前页面中分别获取四个域中的属性值&lt;/h1&gt;<br> page域中的属性值是：&lt;%=pageContext.getAttribute(<span class="hljs-string">&quot;pageKey&quot;</span>) %&gt;&lt;br&gt;<br> request域中的属性值是：&lt;%=request.getAttribute(<span class="hljs-string">&quot;reqKey&quot;</span>) %&gt;&lt;br&gt;<br> session域中的属性值是：&lt;%=session.getAttribute(<span class="hljs-string">&quot;sessKey&quot;</span>) %&gt;&lt;br&gt;<br> application域中的属性值是：&lt;%=application.getAttribute(<span class="hljs-string">&quot;appKey&quot;</span>) %&gt;&lt;br&gt;<br></code></pre></td></tr></table></figure></li><li><p>EL</p><ul><li>EL全称是Expression Language，是JSP的内置表达式</li><li>格式：${表达式}</li><li>作用：主要用来获取域对象中的属性值，用来代替JSP的表达式</li><li>EL表达式获取数据时才输出，获取不到数据则什么也不输出</li><li>EL中的四个Scope对象<ul><li>pageScope<ul><li>获取page域中的属性值</li></ul></li><li>requestScope<ul><li>获取request域中的属性值</li></ul></li><li>sessionScope<ul><li>获取session域中的属性值</li></ul></li><li>applicationScope<ul><li>获取application域中的属性值</li></ul></li></ul></li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%<br> Date date = <span class="hljs-keyword">new</span> Date();<br> <span class="hljs-comment">//分别向四个域中添加四个属性</span><br> pageContext.setAttribute(<span class="hljs-string">&quot;date&quot;</span>, date+<span class="hljs-string">&quot;-&quot;</span>);<br> request.setAttribute(<span class="hljs-string">&quot;date&quot;</span>, date+<span class="hljs-string">&quot;--&quot;</span>);<br> session.setAttribute(<span class="hljs-string">&quot;date&quot;</span>, date+<span class="hljs-string">&quot;---&quot;</span>);<br> application.setAttribute(<span class="hljs-string">&quot;date&quot;</span>, date+<span class="hljs-string">&quot;----&quot;</span>);<br> %&gt;<br> 通过JSP表达式获取域对象中的属性值：&lt;%=pageContext.getAttribute(<span class="hljs-string">&quot;date&quot;</span>) %&gt;&lt;br&gt;<br> 通过EL表达式获取域对象中的属性值：$&#123;date &#125;&lt;br&gt;<br> 通过EL表达式获取request域中的属性值：$&#123;requestScope.date &#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><ul><li><p>全称：Asynchronous JavaScript And XML，通过JavaScript发送请求，使用XML作为响应数据，后来XML已经被另外一种数据格式JSON所替代</p></li><li><p>同步请求和异步请求的区别</p><ul><li>同步请求<ul><li>发送请求之后必须等待服务器的响应成功之后才能发送其他请求，有一个等待的过程</li><li>响应成功之后会刷新整个页面</li></ul></li><li>异步请求<ul><li>发送请求之后无需等待服务器的响应即可发送其他请求</li><li>响应成功之后不会刷新整个页面，可用局部更新页面中的内容</li></ul></li></ul></li><li><p>如果通过jQuery发送ajax请求</p><ul><li><p>使用$.ajax()方法发送Ajax请求</p><ul><li>ajax()方法中的常用选项<ul><li>url<ul><li>必须的。用来设置请求地址，值是一个字符串</li></ul></li><li>type<ul><li>可选的。用来设置请求方式。GET或POST，默认是GET，值是一个字符串</li></ul></li><li>data<ul><li>可选的。用来设置请求参数，值是一个字符串</li></ul></li><li>success<ul><li>可选的。用来设置一个回调函数，当响应成功之后系统会自动调用该函数，响应数据会以参数的形式传入到该函数中</li></ul></li><li>dataType<ul><li>可选的。用来设置响应数据的类型，如 text、json等</li></ul></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$.ajax(&#123;<br>url:<span class="hljs-string">&quot;AjaxServlet&quot;</span>,<br>type:<span class="hljs-string">&quot;get&quot;</span>,<br>data:<span class="hljs-string">&quot;username=admin&amp;password=123456&quot;</span>,<br>success:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)</span>&#123;<br><span class="hljs-comment">//将响应数据设置到span标签中</span><br>$(<span class="hljs-string">&quot;#msg&quot;</span>).text(res);<br>&#125;,<br>dataType:<span class="hljs-string">&quot;text&quot;</span><br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>JSON</p><ul><li>JOSN格式<ul><li>JSON对象</li><li>JSON数组</li></ul></li><li>JSON中接受的数据类型<ul><li>字符串</li><li>数字</li><li>null</li><li>布尔类型</li><li>数组</li><li>对象</li></ul></li><li>在JS中JSON对象和JSON字符串之间的转换<ul><li>JSON对象转JSON字符串<ul><li>JSON.stringify(JSON对象)</li></ul></li><li>JSON字符串转JSON对象<ul><li>JSON.parse(JSON字符串)</li></ul></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//JSON的格式：</span><br><span class="hljs-comment">//1.JSON对象</span><br><span class="hljs-comment">//属性名必须使用双引号括起来；属性名和属性值之间使用冒号分隔；多个属性之间使用逗号分隔</span><br><span class="hljs-keyword">var</span> jsonObj = &#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;孙悟空&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">520</span>&#125;;<br><span class="hljs-comment">// alert(jsonObj);</span><br><span class="hljs-comment">//2.JSON数组</span><br><span class="hljs-keyword">var</span> jsonArry = [<span class="hljs-string">&quot;猪八戒&quot;</span>,<span class="hljs-number">1500</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">null</span>,jsonObj];<br><span class="hljs-comment">//获取jsonArry中的jsonObj中的age属性值</span><br><span class="hljs-comment">// alert(jsonArry[4].age);</span><br><br><span class="hljs-comment">//在JS中将JSON对象转换为JSON字符串</span><br><span class="hljs-keyword">var</span> objToStr = <span class="hljs-built_in">JSON</span>.stringify(jsonObj);<br><span class="hljs-comment">// alert(objToStr);</span><br><span class="hljs-comment">//声明一个JSON字符串</span><br><span class="hljs-keyword">var</span> jsonStr = <span class="hljs-string">&#x27;&#123;&quot;name&quot;:&quot;唐僧&quot;,&quot;age&quot;:18&#125;&#x27;</span>;<br><span class="hljs-comment">// alert(jsonStr);</span><br><span class="hljs-comment">//在JS中将JSON字符串转换为JSON对象</span><br><span class="hljs-keyword">var</span> strToObj = <span class="hljs-built_in">JSON</span>.parse(jsonStr);<br><span class="hljs-comment">// alert(strToObj.name);</span><br></code></pre></td></tr></table></figure><ul><li><p>在Java中对象与JSON字符串之间的转换</p><ul><li><p>借助于第三方工具json-lib、jackson、gson等可用将Java对象转换为JSON字符串，也可用将JSON字符串转换回Java对象</p></li><li><p>通常是前端发送一个Ajax请求，在后台查询到对象之后将对象转换为JOSN字符串响应到前端</p></li><li><p>通过发送Ajax请求接收JSON格式的响应数据</p><ul><li>前端代码</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//发送Ajax请求接收JSON格式的响应数据</span><br>$.ajax(&#123;<br>url:<span class="hljs-string">&quot;JSONServlet&quot;</span>,<br>success:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)</span>&#123;<br>alert(res.id);<br>&#125;,<br>dataType:<span class="hljs-string">&quot;json&quot;</span><br>&#125;);<br></code></pre></td></tr></table></figure><ul><li>后端代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="hljs-function"><span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>response.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<br><span class="hljs-comment">//假设从数据库中查询到员工的信息</span><br>Employee employee = <span class="hljs-keyword">new</span> Employee(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;zhangsan@atguigu.com&quot;</span>);<br><span class="hljs-comment">//创建Gson对象</span><br>Gson gson = <span class="hljs-keyword">new</span> Gson();<br><span class="hljs-comment">//将Employee对象转换为JSON字符串</span><br>String json = gson.toJson(employee);<br>System.out.println(json);<br><span class="hljs-comment">//给浏览器响应一个JSON格式的字符串</span><br>response.getWriter().write(json);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop重要知识点</title>
    <link href="/2021/05/26/Hadoop/"/>
    <url>/2021/05/26/Hadoop/</url>
    
    <content type="html"><![CDATA[<h1 id="Hadoop重要知识点理解"><a href="#Hadoop重要知识点理解" class="headerlink" title="Hadoop重要知识点理解"></a>Hadoop重要知识点理解</h1><h2 id="Hadoop核心组件"><a href="#Hadoop核心组件" class="headerlink" title="Hadoop核心组件"></a>Hadoop核心组件</h2><ul><li><p>MapReduce（计算框架）</p></li><li><p>yarn （资源调度）</p></li><li><p>HDFS（hadoop的分布式文件系统，主要用于数据存储）</p></li><li><p>Common(辅助工具，包含一些依赖，jar包)</p></li><li><p>常用端口号</p><p>分类                             应用                                   端口<br>namenode                rpc-address          8020<br>namenode                http-address        9870<br>namenode                https-address      9871<br>datanode                  address                 9866<br>datanode                  http-address        9864<br>datanode                   https-address     9865<br>resourcemanager    http-address       8088</p></li></ul><h2 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h2><ul><li><p>定义</p><ul><li>HDFS（Hadoop Distributed File System）是一个分布式文件系统</li></ul></li><li><p>优点</p><ul><li>高容错性:多副本机制</li><li>适合处理大数据，可构建在廉价机器上</li></ul></li><li><p>缺点</p><ul><li>不适合低延时数据访问</li><li>无法高效的对大量小文件进行存储</li><li>只支持数据的追加，不支持文件的随机修改</li><li>一个文件只能有一个写，不允许多个线程同时写</li></ul></li><li><p>HDFS组成架构</p><ul><li><a href="https://imgtu.com/i/g2T94P"><img src="https://z3.ax1x.com/2021/05/17/g2T94P.png" alt="g2T94P.png"></a></li></ul></li></ul><h3 id="HDFS文件块大小"><a href="#HDFS文件块大小" class="headerlink" title="HDFS文件块大小"></a>HDFS文件块大小</h3><ul><li>hdfs中的文件在物理上是分块（BLOCK) 存储的</li><li>问题：为什么块大小不能设置太大，也不能设置太小？<ul><li>设置太大：增加数据的传输时间。从磁盘传输数据的时间会明显大于定位这个块开始位置所用的时间。导致程序处理这块数据时非常慢。</li><li>设置太小：分块太多，查找第一个块时会消耗大量时间。寻址时间增加。造成元数据增多，而元数据存储在namenode中，会消耗更多的namenode内存。</li></ul></li></ul><h2 id="HDFS的Shell操作"><a href="#HDFS的Shell操作" class="headerlink" title="HDFS的Shell操作"></a>HDFS的Shell操作</h2><ul><li>hadoop fs + (-命令)</li><li>hdfs dfs + (-命令)</li><li>dfs是fs的实现类</li></ul><ul><li><p>Hadoop fs 命令分类</p></li><li><p>本地-&gt;HDFS</p><pre><code>put #上传文件到HDFScopyFromLocal#与put相似，支持多线程moveFromLocal将本地文件移动到HDFS上appendToFile#追加文件信息,只能追加本地文件信息</code></pre></li><li><p>HDFS-&gt;HDFS(命令与linux类似)</p><p>​    cp<br>​    mv<br>​    chown<br>​    chgrp<br>​    chmod<br>​    mkdir<br>​    du<br>​    df<br>​    cat<br>​    rm</p></li><li><p>HDFS-&gt;本地</p><pre><code>get#从HDFS上下载文件到本地getmerge#合并下载，符合条件的全部下载到本地copyToLocal#与get完全一样</code></pre></li></ul><h2 id="HDFS的API操作"><a href="#HDFS的API操作" class="headerlink" title="HDFS的API操作"></a>HDFS的API操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testCopyFromLocalFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException, URISyntaxException </span>&#123;<br><br><span class="hljs-comment">// 1 获取文件系统</span><br>Configuration configuration = <span class="hljs-keyword">new</span> Configuration();<br>configuration.set(<span class="hljs-string">&quot;dfs.replication&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>);<br>FileSystem fs = FileSystem.get(<span class="hljs-keyword">new</span> URI(<span class="hljs-string">&quot;hdfs://hadoop100:8020&quot;</span>), configuration, <span class="hljs-string">&quot;zt&quot;</span>);<br><br><span class="hljs-comment">// 2 上传文件</span><br>fs.copyFromLocalFile(<span class="hljs-keyword">new</span> Path(<span class="hljs-string">&quot;e:/banzhang.txt&quot;</span>), <span class="hljs-keyword">new</span> Path(<span class="hljs-string">&quot;/banzhang.txt&quot;</span>));<br><br><span class="hljs-comment">// 3 关闭资源</span><br>fs.close();<br><br>System.out.println(<span class="hljs-string">&quot;over&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="HDFS的数据读写流程"><a href="#HDFS的数据读写流程" class="headerlink" title="HDFS的数据读写流程"></a>HDFS的数据读写流程</h2><ul><li><p>HDFS写数据流程</p><p><a href="https://imgtu.com/i/gWkJxS"><img src="https://z3.ax1x.com/2021/05/17/gWkJxS.md.png" alt="gWkJxS.md.png"></a></p></li></ul><ul><li>步骤：<ol><li>客户端通过DistributedFileSystem模块向NameNode请求上传文件，NameNode检查目标文件是否已经存在，父目录是否存在.</li><li>NameNode返回是否可以上传的一个响应</li><li>客户端向NameNode请求第一个BLock应该上传到那几个DataNode节点上</li><li>NameNode返回副本个数个DataNode节点，例如dn1,dn2,dn3</li><li>客户端通过FSDataOutputStream模块请求建立Block传输通道</li><li>dn1,dn2,dn3，等副本逐级应答客户端</li><li>应答成功后，开始传输数据（以Packet（一般为64kb）的形式），dn1收到一个Packet就会传给dn2,dn2传给dn3。dn1每传一个Packet会放入一个应答队列等待应答</li><li>第一个Block上传完成后，客户端再请求NameNode上传第二个Block的服务器。</li></ol></li></ul><ul><li><p>DataNode的选择</p><ul><li>每一块数据存到哪些DataNode节点上，NameNode会进行选择。</li><li>在HDFS写数据的过程中，NameNode会选择距离待上传数据最近距离的DataNode接收数据。</li><li>HDFS会通过机架感知技术，得到网络拓扑图，根据网络拓扑图选择最近的节点</li><li>那其他的副本是怎样选择的呢？：1.第一个副本再Client所处的节点上（自己距离自己最近），如果客户端在集群外面，随机选择一个。2.第二个副本和第一个副本位于相同机架上，随即节点。3.第三个副本位于不同机架，随机节点。</li></ul></li><li><p>HDFS读数据流程</p><p> <a href="https://imgtu.com/i/gWpZv9"><img src="https://z3.ax1x.com/2021/05/17/gWpZv9.md.png" alt="gWpZv9.md.png"></a></p></li></ul><ul><li>步骤：<ul><li>客户端通过Distributed FileSystem向NameNode请求下载文件，NameNode通过查询元数据，找到文件块所在的DataNode地址。</li><li>挑选一台DataNode（就近原则，然后随机）服务器，请求读取数据</li><li>DataNode开始传输数据给客户端（从磁盘里面读取数据输入流，以Packet为单位来做校验）。</li><li>客户端以Packet为单位接收，先在本地缓存，然后写入目标文件。</li></ul></li></ul><h2 id="NameNode和SecondaryNameNode"><a href="#NameNode和SecondaryNameNode" class="headerlink" title="NameNode和SecondaryNameNode"></a>NameNode和SecondaryNameNode</h2><ul><li><p>namenode中一个元数据占150个字节的空间。</p></li><li><p>思考：NameNode中的元数据是存储在哪里的？</p><p>首先，我们做个假设，如果存储在NameNode节点的磁盘中，因为经常需要进行随机访问，还有响应客户请求，必然是效率过低。因此，元数据需要存放在内存中。但如果只存在内存中，一旦断电，元数据丢失，整个集群就无法工作了。因此产生在磁盘中备份元数据的FsImage。</p><p>这样又会带来新的问题，当在内存中的元数据更新时，如果同时更新FsImage，就会导致效率过低，但如果不更新，就会发生一致性问题，一旦NameNode节点断电，就会产生数据丢失。因此，引入Edits文件(只进行追加操作，效率很高)。每当元数据有更新或者添加元数据时，修改内存中的元数据并追加到Edits中。这样，一旦NameNode节点断电，可以通过FsImage和Edits的合并，合成元数据。</p><p>但是，如果长时间添加数据到Edits中，会导致该文件数据过大，效率降低，而且一旦断电，恢复元数据需要的时间过长。因此，需要定期进行FsImage和Edits的合并，如果这个操作由NameNode节点完成，又会效率过低。因此，引入一个新的节点SecondaryNamenode，专门用于FsImage和Edits的合并。</p></li><li><p>工作机制</p><p><a href="https://imgtu.com/i/gW92Se"><img src="https://z3.ax1x.com/2021/05/17/gW92Se.md.png" alt="gW92Se.md.png"></a></p></li><li><p>具体步骤：</p><ul><li>第一阶段：NameNode<ul><li>第一次启动NameNode，格式化后，创建Fsimage和Edits文件。如果不是第一次启动，直接加载日志文件和镜像文件到内存中去</li><li>客户端对元数据的增删改请求</li><li>NameNode记录操作日志到Edits文件，更新滚动日志（当这一份日志已满，或者定时时间到了，重新创建一份新的日志文件（增删改记录写在新文件中），将旧的日志文件写到SecondaryNameNode中去）。</li><li>NameNode在内存中进行增删改操作</li></ul></li><li>第二阶段：SecondaryNameNode<ul><li>2nn询问nn是否需要CheckPoint，直接带回返回结果</li><li>请求执行CheckPoint（触发条件：1.2nn每隔一小时执行一次。2.当操作次数达到1百万时）</li><li>nn滚动正在写的Edits日志</li><li>将滚动前的日志文件和镜像文件拷贝到SecondaryNameNode中</li><li>2nn将从nn拷贝过来的日志文件和镜像文件在内存中合并</li><li>生成新的镜像文件fsimage.chkpoint</li><li>将新生成的镜像文件fsimage.chkpoint写到NameNode中</li><li>NameNode将fsimage.chkpoint重新命名成fsimage。</li></ul></li></ul></li><li><p>集群安全模式</p></li><li><p>集群在安全模式下，不能执行写操作，读操作会被延迟</p></li><li><p>在集群刚刚启动，或者集群的存储快要到达上限时会进入集群安全模式。</p></li></ul><h2 id="DataNode"><a href="#DataNode" class="headerlink" title="DataNode"></a>DataNode</h2><ul><li><p>DataNode工作机制</p><p><a href="https://imgtu.com/i/gWkiU1"><img src="https://z3.ax1x.com/2021/05/17/gWkiU1.md.png" alt="gWkiU1.md.png"></a></p></li></ul><ul><li>一个数据块在DataNode上以文件形式存储在磁盘上，包括两个文件，一个是数据本身，一个是元数据包括数据块的长度，块数据的校验和（保证数据完整性），以及时间戳。</li><li>DataNode启动后向NameNode注册，通过后，周期性（1小时）的向NameNode上报所有的块信息。</li><li>心跳是每3秒一次，心跳返回结果带有NameNode给该DataNode的命令如复制块数据到另一台机器，或删除某个数据块。如果超过10分钟没有收到某个DataNode的心跳，则认为该节点不可用。</li><li>集群运行中可以安全加入和退出一些机器。（通过配置黑白名单）<ul><li>添加到白名单的主机节点，都允许访问NameNode，不在白名单的主机节点，都会被退出。</li><li>在黑名单上面的主机都会被强制退出。（进入黑名单那后状态变为不可用10分钟+30s 后退役）</li><li>不允许白名单和黑名单中同时出现同一个主机名称</li></ul></li></ul><h2 id="MapReduce概述"><a href="#MapReduce概述" class="headerlink" title="MapReduce概述"></a>MapReduce概述</h2><ul><li><p>MapReduce是一个分布式运算程序的编程框架，是用户开发“基于Hadoop的数据分析应用”的核心框架。</p><p>MapReduce核心功能是将用户编写的业务逻辑代码和自带默认组件整合成一个完整的分布式运算程序，并发运行在一个Hadoop集群上。</p></li><li><p>一个完整的MapReduce程序在分布式运行时有三类实例进程：</p><p>（1）<strong>MrAppMaster</strong>：负责整个程序的过程调度及状态协调。</p><p>（2）<strong>MapTask</strong>：负责Map阶段的整个数据处理流程。</p><p>（3）<strong>ReduceTask</strong>：负责Reduce阶段的整个数据处理流程。</p></li><li><p>WC实例：</p><p>Mapper代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zt3019.wordcount;<br><br><span class="hljs-keyword">import</span> org.apache.hadoop.io.IntWritable;<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.LongWritable;<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.Text;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.Mapper;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">//（输入类型：框架会将数据分成一行一行的，LongWritable表示这一行的第一个字符的索引,Text表示这一行内容）KEYIN,VALUEIN,(输出类型：单词，1)KEYOUT,VALUEOUT</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WordCountMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mapper</span>&lt;<span class="hljs-title">LongWritable</span>,<span class="hljs-title">Text</span>,<span class="hljs-title">Text</span>, <span class="hljs-title">IntWritable</span>&gt; </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 框架将数据拆成一行一行输入进来，我们把数据变成（单词，1）的形式</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 行号</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 行内容</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> context 任务本身</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> InterruptedException</span><br><span class="hljs-comment">     */</span><br>    Text word=<span class="hljs-keyword">new</span> Text();<br>    IntWritable one=<span class="hljs-keyword">new</span> IntWritable(<span class="hljs-number">1</span>);<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">map</span><span class="hljs-params">(LongWritable key, Text value, Context context)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;<br>        <span class="hljs-comment">//拿到一行数据</span><br>        String line=value.toString();<br>        <span class="hljs-comment">//将一行拆成很多单词</span><br>        String[] words = line.split(<span class="hljs-string">&quot; &quot;</span>);<br><br>        <span class="hljs-comment">//将（单词，1）写回框架</span><br>        <span class="hljs-keyword">for</span> (String word : words) &#123;<br>            <span class="hljs-keyword">this</span>.word.set(word);<br>            context.write(<span class="hljs-keyword">this</span>.word,<span class="hljs-keyword">this</span>.one);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>Redecer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zt3019.wordcount;<br><br><span class="hljs-keyword">import</span> org.apache.hadoop.io.IntWritable;<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.Text;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.Reducer;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">//输入为map的输出，输出为（单词，单词出现的次数）</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WordCountReducer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Reducer</span>&lt;<span class="hljs-title">Text</span>, <span class="hljs-title">IntWritable</span>,<span class="hljs-title">Text</span>,<span class="hljs-title">IntWritable</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;<br>    IntWritable value=<span class="hljs-keyword">new</span> IntWritable();<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 框架把数据按照单词分好组输入给我们，我们将同一个单词的次数相加</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 单词</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> values 这个单词所有的1</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> context 任务本身</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> InterruptedException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reduce</span><span class="hljs-params">(Text key, Iterable&lt;IntWritable&gt; values, Context context)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;<br>        <span class="hljs-comment">//累加单词出现的次数</span><br>        <span class="hljs-keyword">for</span> (IntWritable value : values) &#123;<br>            sum+=value.get();<br>        &#125;<br>        <span class="hljs-comment">//封装结果</span><br>        value.set(sum);<br>        <span class="hljs-comment">//将结果写回框架</span><br>        context.write(key,value);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>Driver(本地集群模式)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zt3019.wordcount;<br><br><span class="hljs-keyword">import</span> org.apache.hadoop.conf.Configuration;<br><span class="hljs-keyword">import</span> org.apache.hadoop.fs.Path;<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.IntWritable;<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.Text;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.Job;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WordCountDriver</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException, InterruptedException </span>&#123;<br>        Configuration configuration = <span class="hljs-keyword">new</span> Configuration();<br>        <span class="hljs-comment">//配置yarn集群运行</span><br>        <span class="hljs-comment">//core-site.xml配置文件</span><br>        configuration.set(<span class="hljs-string">&quot;fs.defaultFS&quot;</span>, <span class="hljs-string">&quot;hdfs://hadoop100:8020&quot;</span>);<br>        <span class="hljs-comment">//MapRedece-site.xml配置文件</span><br>        configuration.set(<span class="hljs-string">&quot;mapreduce.framework.name&quot;</span>,<span class="hljs-string">&quot;yarn&quot;</span>);<br>        <span class="hljs-comment">//是否允许向linux提交任务</span><br>        configuration.set(<span class="hljs-string">&quot;mapreduce.app-submission.cross-platform&quot;</span>,<span class="hljs-string">&quot;true&quot;</span>);<br>        configuration.set(<span class="hljs-string">&quot;yarn.resourcemanager.hostname&quot;</span>,<span class="hljs-string">&quot;hadoop102&quot;</span>);<br>        <span class="hljs-comment">//1.获取job实例</span><br>        Job job= Job.getInstance(configuration);<br>        <span class="hljs-comment">//2.设置jar包</span><br>        job.setJarByClass(WordCountDriver.class);<br>        <span class="hljs-comment">//3.设置Mapper和Reducer</span><br>        job.setMapperClass(WordCountMapper.class);<br>        job.setReducerClass(WordCountReducer.class);<br>        <span class="hljs-comment">//4.设置Map和Reduce的输出类型</span><br>        <span class="hljs-comment">//设置Map的输出类型</span><br>        job.setMapOutputKeyClass(Text.class);<br>        job.setMapOutputValueClass(IntWritable.class);<br>        <span class="hljs-comment">//设置Reduce的输出类型</span><br>        job.setOutputKeyClass(Text.class);<br>        job.setOutputValueClass(IntWritable.class);<br>        <span class="hljs-comment">//5.设置输入输出文件</span><br>        FileInputFormat.setInputPaths(job,<span class="hljs-keyword">new</span> Path(args[<span class="hljs-number">0</span>]));<br>        FileOutputFormat.setOutputPath(job,<span class="hljs-keyword">new</span> Path(args[<span class="hljs-number">1</span>]));<br>        <span class="hljs-comment">//6.提交job</span><br>        <span class="hljs-comment">//提交任务得到运行结果，成功或者失败</span><br>        <span class="hljs-comment">//提交流程都在这个方法中，一些job的配置都可以在上面设置。</span><br>        <span class="hljs-keyword">boolean</span> b = job.waitForCompletion(<span class="hljs-keyword">true</span>);<br>        System.exit(b ? <span class="hljs-number">0</span>:<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>提交到集群上运行，先maven打包，</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">yarn jar 包名 主类引用(reference) args[<span class="hljs-string">0</span>](<span class="hljs-link">输入路径</span>) args[<span class="hljs-string">1</span>](<span class="hljs-link">s</span>)<br></code></pre></td></tr></table></figure></li></ul><h3 id="Hadoop序列化"><a href="#Hadoop序列化" class="headerlink" title="Hadoop序列化"></a>Hadoop序列化</h3><ul><li><p>序列化就是把内存中的对象，转换成字节序列（或其它数据传输协议）以便于存储到磁盘（持久化）和网络传输。</p></li><li><p>反序列化就是将收到的字节序列（或其它数据传输协议）或者是磁盘中持久化的数据，转换成内存中的对象。</p></li><li><p>为什么要序列化：一般来说，“活的”对象只存储在内存中，关机断电就没有了，而且“活的”对象只能由本地进程使用，不能被发送到网络上的另外一台计算机。而序列化可以存储“活的”对象，可以将“活的”对象发送到远程计算机。</p></li><li><p>自定义的数据类型要实现Writable接口实现序列化，反序列功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zt3019.flow;<br><br><span class="hljs-keyword">import</span> org.apache.hadoop.io.Writable;<br><br><span class="hljs-keyword">import</span> java.io.DataInput;<br><span class="hljs-keyword">import</span> java.io.DataOutput;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlowBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Writable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> upFlow;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> downFlow;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> sumFlow;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">long</span> upFlow,<span class="hljs-keyword">long</span> downFlow)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.upFlow=upFlow;<br>        <span class="hljs-keyword">this</span>.downFlow=downFlow;<br>        <span class="hljs-keyword">this</span>.sumFlow=upFlow+downFlow;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;FlowBean&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;upFlow=&quot;</span> + upFlow +<br>                <span class="hljs-string">&quot;, downFlow=&quot;</span> + downFlow +<br>                <span class="hljs-string">&quot;, sumFlow=&quot;</span> + sumFlow +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUpFlow</span><span class="hljs-params">(<span class="hljs-keyword">long</span> upFlow)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.upFlow = upFlow;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDownFlow</span><span class="hljs-params">(<span class="hljs-keyword">long</span> downFlow)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.downFlow = downFlow;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSumFlow</span><span class="hljs-params">(<span class="hljs-keyword">long</span> sumFlow)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.sumFlow = sumFlow;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getDownFlow</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> downFlow;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getSumFlow</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> sumFlow;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getUpFlow</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> upFlow;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 序列化</span><br><span class="hljs-comment">     * 将对象数据写出到框架指定的地方</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dataOutput 数据的容器</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(DataOutput dataOutput)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        dataOutput.writeLong(upFlow);<br>        dataOutput.writeLong(downFlow);<br>        dataOutput.writeLong(sumFlow);<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 反序列化</span><br><span class="hljs-comment">     *从框架指定地方读取数填充对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dataInput 数据的容器</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readFields</span><span class="hljs-params">(DataInput dataInput)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">this</span>.upFlow=dataInput.readLong();<br>        <span class="hljs-keyword">this</span>.downFlow=dataInput.readLong();<br>        <span class="hljs-keyword">this</span>.sumFlow=dataInput.readLong();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h2 id="MapReduce框架原理"><a href="#MapReduce框架原理" class="headerlink" title="MapReduce框架原理"></a>MapReduce框架原理</h2><h3 id="MapReduce的数据流"><a href="#MapReduce的数据流" class="headerlink" title="MapReduce的数据流"></a>MapReduce的数据流</h3><p><a href="https://imgtu.com/i/g72oxx"><img src="https://z3.ax1x.com/2021/05/21/g72oxx.md.png" alt="g72oxx.md.png"></a></p><h3 id="InputFormat"><a href="#InputFormat" class="headerlink" title="InputFormat"></a>InputFormat</h3><ul><li><p>InputFormat实现数据变成K,V值</p></li><li><p>数据切片与MapTask并行度决定机制</p></li></ul><p><a href="https://imgtu.com/i/gHPDHK"><img src="https://z3.ax1x.com/2021/05/21/gHPDHK.md.png" alt="gHPDHK.md.png"></a></p><ul><li></li><li><p>job提交流程源码重要流程（客户端向集群提交的作业）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java">waitForCompletion()<span class="hljs-comment">//等待提交任务</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">submit</span><span class="hljs-params">()</span></span>&#123;<br>    ensureState()<span class="hljs-comment">//1.确认job状态是定义的</span><br>    setUserNewAPI()<span class="hljs-comment">//2.设置新的API</span><br>    connect()<span class="hljs-comment">//获取连接</span><br>&#125;<br><br><span class="hljs-comment">// 1建立连接</span><br>connect();<br><span class="hljs-comment">// 1）创建提交Job的代理</span><br><span class="hljs-keyword">new</span> Cluster(getConfiguration());<br><span class="hljs-comment">// （1）判断是本地yarn还是远程</span><br>initialize(jobTrackAddr, conf); <br><br><span class="hljs-comment">// 2 提交job</span><br>submitter.submitJobInternal(Job.<span class="hljs-keyword">this</span>, cluster)<br><span class="hljs-comment">// 1）创建给集群提交数据的Stag路径</span><br>Path jobStagingArea = JobSubmissionFiles.getStagingDir(cluster, conf);<br><br><span class="hljs-comment">// 2）获取jobid ，并创建Job路径</span><br>JobID jobId = submitClient.getNewJobID();<br><br><span class="hljs-comment">// 3）拷贝jar包到集群</span><br>copyAndConfigureFiles(job, submitJobDir);<br>rUploader.uploadFiles(job, jobSubmitDir);<br><br><span class="hljs-comment">// 4）计算切片，生成切片信息，数据那一块给哪一个MapTask处理</span><br>writeSplits(job, submitJobDir);<br>maps = writeNewSplits(job, jobSubmitDir);<br>input.getSplits(job);<br><br><span class="hljs-comment">// 5）向Stag路径写XML配置文件</span><br>writeConf(conf, submitJobFile);<br>conf.writeXml(out);<br><br><span class="hljs-comment">// 6）提交Job,返回提交状态</span><br>status = submitClient.submitJob(jobId, submitJobDir.toString(), job.getCredentials());<br></code></pre></td></tr></table></figure></li><li><p>InputFormat两个重要过程</p><ul><li>切片：将文件切片，逻辑上的划分。默认是FileInputFormat，默认就是分块大小。在客户端完成，切几个片就有几个MapTask</li><li>RecordReader:对于给定的一个切片得到一个RecordReader，将数据划分成指定的K,V值，传到Map中，作为Map的输入。发生在MapTask中。</li></ul></li><li><p>自定义InputFormat方法</p><ul><li>自定义一个类继承FileInputFormat</li><li>Split：重写isSplitable()，将文件切片，可以自己定义切片规则，返回false 表示不切割</li><li>RecordReader：重写createRecordReader()，实现自定义输入到Map的K,V值</li></ul></li><li><p>Map阶段</p><ul><li>MapTask: Map阶段实际执行MapTask.run()方法，MapTask是一个Map的实现类</li><li>Mapper：在MapTask.run方法中会调用Mapper对象的map方法</li><li>map: 定义在Mapper中的方法</li></ul></li></ul><h3 id="Shuffle机制"><a href="#Shuffle机制" class="headerlink" title="Shuffle机制"></a>Shuffle机制</h3><ul><li>shuffle负责整理数据</li><li>shuffle流程<ul><li><a href="https://imgtu.com/i/gLfma6"><img src="https://z3.ax1x.com/2021/05/22/gLfma6.md.png" alt="gLfma6.md.png"></a><ol><li>MapTask收集map()方法输出的KV对，放到环形内存缓冲区中</li><li>在内存缓冲区中会进行快速排序，不断溢写到本地磁盘文件</li><li>多个溢出的文件会被合成大的溢出文件(溢写到磁盘耗时间，耗资源)</li><li>在溢出过程和合并过程中，都调用Partitiner进行分区和针对Key 进行排序，在环形缓冲区中溢出时进行快速排序，在合并时进行归并排序。</li><li>ReduceTask根据自己的分区号，去各个MapTask机器上取相应的结果分区数据</li><li>ReduceTask 会取到同一个分区的来自不同MapTask 的结果文件，ReduceTask会将这些文件再进行合并（归并排序）</li><li>合并成大文件后，shuffle过程结束，后面进入ReduceTask的逻辑运算过程（从文件中取出一个一个的键值对Gruop，调用用户自定义的reduce()方法）</li></ol></li></ul></li></ul><ul><li><p>Partition分区</p><ul><li><p>当设置多个ReduceTask时，需要对MapTask输出来的数据进行分区。若ReduceTask数量为1，不执行分区过程。ReduceTask数量默认为1</p></li><li><p>适应于将将结果按照条件输出到不同分区文件中（分区）。例如：词频统计中分连个区A-M一个分区，M-Z一个分区</p></li><li><p>当数据量太大时，将多个MapTask得到的结果放到一个Reduce中合并时会非常慢，为了提高效率，需要并行处理，即设置多个ReduceTask处理。ReduceTask需要设置，估算数据业务的量</p></li><li><p>分区在环形缓冲区时就已经开始进行了</p></li><li><p>默认分区是根据key的hashCode对ReduceTasks个数取模得到的。用户没法控制哪个key存储到哪个分区。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashPartitioner</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Partitioner</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getPartition</span><span class="hljs-params">(K key, V value, <span class="hljs-keyword">int</span> numReduceTasks)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (key.hashCode() &amp; Integer.MAX_VALUE) % numReduceTasks;<br>  &#125;<br><span class="hljs-comment">//&amp;的目的是去负号</span><br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://imgtu.com/i/gzRSkn"><img src="https://z3.ax1x.com/2021/05/25/gzRSkn.md.png" alt="gzRSkn.md.png"></a></p></li></ul></li><li><p><a href="https://imgtu.com/i/gzRmkR"><img src="https://z3.ax1x.com/2021/05/25/gzRmkR.md.png" alt="gzRmkR.md.png"></a></p></li><li><p>三次排序</p><ul><li>一次快排，两次归并排序</li><li> 对于MapTask，它会将处理的结果暂时放到环形缓冲区中，<em><strong>当环形缓冲区使用率达到一定阈值后，再对缓冲区中的数据进行一次快速排序</strong></em>，并将这些有序数据溢写到磁盘上，<em><strong>而当数据处理完毕后，它会对磁盘上所有文件进行归并排序。</strong></em></li><li>对于ReduceTask，它从每个MapTask上远程拷贝相应的数据文件，如果文件大小超过一定阈值，则溢写磁盘上，否则存储在内存中。如果磁盘上文件数目达到一定阈值，则进行一次归并排序以生成一个更大文件；如果内存中文件大小或者数目超过一定阈值，则进行一次合并后将数据溢写到磁盘上。<em><strong>当所有数据拷贝完毕后，ReduceTask统一对内存和磁盘上的所有数据进行一次归并排序。</strong></em></li></ul></li><li><p>三个比较器（一个排序比较器，两个分组比较器）</p><ul><li>排序比较器</li><li>Reducer分组比较器</li><li>Combiner分组比较器</li></ul></li><li><p>Hadoop中所有比较器默认都是WritableComparator（默认调用key的compareTo()方法）</p></li><li><p>自定义排序的两种方法</p><ul><li>实现接口WritableComparable（该接口继承Writable,Comparable）</li><li>自定义一个类的专用比较器，在Job中覆盖Comparator，自定义的比较器要继承WritableComparator</li></ul></li><li><p>Combiner合并</p><ul><li>Combiner与Reducer的区别：Combiner是在每一个MapTask所在节点运行，Reducer是接受全局所有Mapper的输出结果。</li><li>Combiner对每一个MapTask的输出进行局部汇总，以减少IO（网络IO，和本地IO）。</li><li>Combiner默认不开启，要根据情况使用。能够应用的前提是不影响最终的业务逻辑。</li></ul></li><li><p>GroupComparator分组</p><ul><li>分组比较器，根据排好顺序的数据，根据Key值进行分组</li><li>对Reduce阶段的数据根据某一个或几个字段进行分组。</li><li>分组比较器默认也是WritableComparator（默认调用key的compareTo()方法），当排序和分组比较方案不同时，需要自定义其中的一个比较器。</li><li>自定义分组比较器步骤：（1）自定义类继承WritableComparator（2）重写compare()方法  （3）创建一个构造将比较对象的类传给父类</li></ul></li><li><p>MapReduce传输数据的方式</p><ul><li>为了提高传输效率，传输的是用Writable序列化好的序列化数据</li><li>数据在从Map出来进入到到环形缓冲区时进行序列化，进入环形缓冲区的数据已经完成了序列化。之后的数据流动都是序列化的数据的流动</li><li>之后的排序先反序列化再实现排序</li></ul></li><li><p>环形缓冲区</p><ul><li>一边写索引，一边写数据</li><li>在环形缓冲区进行排序时，不改变数据的位置，改变索引的位置</li></ul></li></ul><h3 id="OutputFormat"><a href="#OutputFormat" class="headerlink" title="OutputFormat"></a>OutputFormat</h3><ul><li><p>将Reduce处理完的K，V值持久化到文件</p></li><li><p>几种实现</p><ul><li>默认的文本输出TextOutputFormat，把每条记录写为文本行，利用K，V的toString()方法将其转为字符串。</li><li>SequenceFileOutputFormat:将K，V值序列化成文件放到磁盘上</li><li>自定义OutputFormat</li></ul></li><li><p>源码重要方法</p><ul><li>checkOutputSpecs()检查输出参数</li><li>getOutputCommitter()获取outputformat提交器（保证output被正确提交）</li><li>自定义outputformat主要实现RecordWriter()。实现接收K,V值并将K,V值处理</li></ul></li></ul><h3 id="MapReduce工作机制"><a href="#MapReduce工作机制" class="headerlink" title="MapReduce工作机制"></a>MapReduce工作机制</h3><ul><li><p>MapReduce哪些阶段可以进行压缩</p><ul><li>map的输入端（主要看数据大小和切片，lzo,bzip2）</li><li>map的输出端(主要考虑速度，snappy，Lzo)</li><li>reduce的输出端(看需求，是要继续做mapreduce的输出，还是直接做分析的数据等)</li></ul></li><li><p>MapTask工作机制</p><ul><li><p><a href="https://imgtu.com/i/gzWpHH"><img src="https://z3.ax1x.com/2021/05/25/gzWpHH.md.png" alt="gzWpHH.md.png"></a></p></li><li></li><li><p>（1）Read阶段：MapTask通过用户编写的RecordReader，从输入InputSplit中解析出一个（2）Map阶段：该节点主要是将解析出的key/value交给用户编写map()函数处理，并产生一系列新的key/value。</p><p>​    （3）Collect收集阶段：在用户编写map()函数中，当数据处理完成后，一般会调用OutputCollector.collect()输出结果。在该函数内部，它会将生成的key/value分区（调用Partitioner），并写入一个环形内存缓冲区中。</p><p>​    （4）Spill阶段：即“溢写”，当环形缓冲区满后，MapReduce会将数据写到本地磁盘上，生成一个临时文件。需要注意的是，将数据写入本地磁盘之前，先要对数据进行一次本地排序，并在必要时对数据进行合并、压缩等操作。</p><p>个key/value。</p><p>​    溢写阶段详情：</p><p>​    步骤1：利用快速排序算法对缓存区内的数据进行排序，排序方式是，先按照分区编号Partition进行排序，然后按照key进行排序。这样，经过排序后，数据以分区为单位聚集在一起，且同一分区内所有数据按照key有序。</p><p>​    步骤2：按照分区编号由小到大依次将每个分区中的数据写入任务工作目录下的临时文件output/spillN.out（N表示当前溢写次数）中。如果用户设置了Combiner，则写入文件之前，对每个分区中的数据进行一次聚集操作。</p><p>​    步骤3：将分区数据的元信息写到内存索引数据结构SpillRecord中，其中每个分区的元信息包括在临时文件中的偏移量、压缩前数据大小和压缩后数据大小。如果当前内存索引大小超过1MB，则将内存索引写到文件output/spillN.out.index中。</p><p>​    （5）Combine阶段：当所有数据处理完成后，MapTask对所有临时文件进行一次合并，以确保最终只会生成一个数据文件。</p><p>​    当所有数据处理完后，MapTask会将所有临时文件合并成一个大文件，并保存到文件output/file.out中，同时生成相应的索引文件output/file.out.index。</p><p>​    在进行文件合并过程中，MapTask以分区为单位进行合并。对于某个分区，它将采用多轮递归合并的方式。每轮合并io.sort.factor（默认10）个文件，并将产生的文件重新加入待合并列表中，对文件排序后，重复以上过程，直到最终得到一个大文件。</p><p>​    让每个MapTask最终只生成一个数据文件，可避免同时打开大量文件和同时读取大量小文件产生的随机读取带来的开销。</p><ul><li><p>ReduceTask阶段</p><p><a href="https://imgtu.com/i/gzWxGq"><img src="https://z3.ax1x.com/2021/05/25/gzWxGq.md.png" alt="gzWxGq.md.png"></a></p><p>（1）Copy阶段：ReduceTask从各个MapTask上远程拷贝一片数据，并针对某一片数据，如果其大小超过一定阈值，则写到磁盘上，否则直接放到内存中。</p><p>​    （2）Merge阶段：在远程拷贝数据的同时，ReduceTask启动了两个后台线程对内存和磁盘上的文件进行合并，以防止内存使用过多或磁盘上文件过多。</p><p>​    （3）Sort阶段：按照MapReduce语义，用户编写reduce()函数输入数据是按key进行聚集的一组数据。为了将key相同的数据聚在一起，Hadoop采用了基于排序的策略。由于各个MapTask已经实现对自己的处理结果进行了局部排序，因此，ReduceTask只需对所有数据进行一次归并排序即可。</p><p>​    （4）Reduce阶段：reduce()函数将计算结果写到HDFS上。</p></li></ul></li></ul></li></ul><p>​    </p><pre><code>### Join多种应用* Reducejoin：  - Map段主要工作：为来自不同表或文件的key/value对，***打标签以区别不同来源的记录***。然后用连接字段作为key ,其余部分和新加的标志作为value，最后进行输出。  - Reduce端主要工作：在Reduce端以连接字段作为key的分组已经完成，我们只需要在每一个分组中将***来源不同文件的记录（在Map阶段已经打标签）分开***，最后进行合并。  - 缺点：这种方式中，合并操作是在Reduce阶段完成，Reduce端的处理压力太大，Map节点的运算负载很低，资源利用率不高，且在Reduce阶段容易产生数据倾斜。* Mapjoin  1．使用场景  Map Join适用于一张表十分小、一张表很大的场景。  2．优点  思考：在Reduce端处理过多的表，非常容易产生数据倾斜。怎么办？  在Map端缓存多张表，提前处理业务逻辑，这样增加Map端业务，减少Reduce端数据的压力，尽可能的减少数据倾斜。  3．具体办法：采用DistributedCache   ​    （1）在Mapper的setup阶段，将文件读取到缓存集合中。  ​    （2）在驱动函数中加载缓存。  // 缓存普通文件到Task运行节点。  job.addCacheFile(new URI(&quot;file://e:/cache/pd.txt&quot;));</code></pre><p>​      </p><p>​    </p><h2 id="Yarn资源调度器"><a href="#Yarn资源调度器" class="headerlink" title="Yarn资源调度器"></a>Yarn资源调度器</h2><h3 id="Yarn基本架构和工作机制"><a href="#Yarn基本架构和工作机制" class="headerlink" title="Yarn基本架构和工作机制"></a>Yarn基本架构和工作机制</h3><ul><li><p>基本架构</p></li><li><p><a href="https://imgtu.com/i/2iAWPf"><img src="https://z3.ax1x.com/2021/05/27/2iAWPf.png" alt="2iAWPf.png"></a></p></li><li><p>Yarn工作流程</p><ul><li><a href="https://imgtu.com/i/2ieAJ0"><img src="https://z3.ax1x.com/2021/05/27/2ieAJ0.png" alt="2ieAJ0.png"></a></li></ul></li><li><p>Yarn工作步骤</p><ul><li><ol start="0"><li>客户端执行程序job.waitForCompletion</li></ol></li><li><ol><li>申请一个Application</li></ol></li><li><ol start="2"><li>返回Application资源提交临时路径和job_Id</li></ol></li><li><ol start="3"><li>客户端提交job运行必要资源Job.split(分片信息)，Job.xml（配置信息），Wc.jar(所需的必要Jar包)</li></ol></li><li><ol start="4"><li>资源提交完毕，申请运行AppMaster</li><li>ResourceManager将用户的请求初始化成一个Task资源申请,放入资源调度器等待调度</li><li> 资源调度器中的任务会分配到一个NodeManager中</li><li>NodeManager会根据任务创建一个容器，在容器中运行对应的AppMaster</li><li>AppMaster获取必要资源到本地</li><li>AppMaster再向ResourceManager请求运行MapTask资源申请</li><li>ResourceManager指定一个NodeManager领取MapTask任务，创建容器，运行MapTask</li><li>AppMaster向执行MapTask的NodeManager发送程序启动脚本</li><li>同理AppMaster向RM请求运行ReduceTask资源申请，创建容器运行ReduceTask</li><li>Reduce向Map获取相应的分区数据</li></ol></li></ul></li><li><p>资源调度器：FIFO、Capacity Scheduler和Fair Scheduler。Hadoop3.1.3默认的资源调度器是Capacity Scheduler。</p><ul><li><p>FIFO，队列形式。基本不用</p></li><li><p>Capacity Scheduler，几个并行的FIFO。当集群资源不紧张时，采用此方式</p><p><a href="https://imgtu.com/i/2iGrQA"><img src="https://z3.ax1x.com/2021/05/27/2iGrQA.png" alt="2iGrQA.png"></a></p></li><li><p>Fair Scheduler　公平调度器。能最大程度利用集群的资源</p><p><a href="https://imgtu.com/i/2ilY4J"><img src="https://z3.ax1x.com/2021/05/27/2ilY4J.png" alt="2ilY4J.png"></a></p></li></ul></li></ul><h2 id="Hadoop常见优化"><a href="#Hadoop常见优化" class="headerlink" title="Hadoop常见优化"></a>Hadoop常见优化</h2><ul><li><p>数据倾斜问题:某个区域的数据量远远大于其它区域例如Map端和Reduce端的数据倾斜</p><ul><li>自定义分区，基于对原始数据的认知进行自定义分区。</li><li>Combine:Combine可以大量地减少数据倾斜。</li><li>采用Mapjoin，因为Reducejoin对Reduce端的压力非常大</li></ul></li><li><p>参数优化提升MapReduce 性能</p><ul><li><p>容错相关参数(MapReduce性能优化)</p><table><thead><tr><th>配置参数</th><th>参数说明</th></tr></thead><tbody><tr><td>mapreduce.map.maxattempts</td><td>每个Map Task最大重试次数，一旦重试参数超过该值，则认为Map Task运行失败，默认值：4。</td></tr><tr><td>mapreduce.reduce.maxattempts</td><td>每个Reduce Task最大重试次数，一旦重试参数超过该值，则认为Map Task运行失败，默认值：4。</td></tr><tr><td>mapreduce.task.timeout</td><td>Task超时时间，经常需要设置的一个参数，该参数表达的意思为：如果一个Task在一定时间内没有任何进入，即不会读取新的数据，也没有输出数据，则认为该Task处于Block状态，可能是卡住了，也许永远会卡住，为了防止因为用户程序永远Block住不退出，则强制设置了一个该超时时间（单位毫秒），默认是600000。如果你的程序对每条输入数据的处理时间过长（比如会访问数据库，通过网络拉取数据等），建议将该参数调大，该参数过小常出现的错误提示是“AttemptID:attempt_14267829456721_123456_m_000224_0 Timed out after 300 secsContainer killed by the ApplicationMaster.”。</td></tr></tbody></table></li></ul></li><li><p>小文件优化方法</p><ul><li>小文件的缺点：1.会占用namenode大量的内存资源。2.索引文件过大使得检索速度变慢。</li><li>优化：1.Sequence File:Sequence File由一系列的二进制key/value组成，Input如果key为文件名，value为文件内容，则可以将大批小文件合并成一个大文件。<ol start="2"><li>CombineFileInputFormat:用于将多个文件合并成一个单独的split。</li></ol></li></ul></li><li><p>MapReduce 优化</p><ul><li>InputFormat阶段 ：1. 合并小文件</li><li>Map阶段：1.减少溢写（Spill）次数。2.减少合并（Merge）次数</li><li>Reduce阶段<ol><li>合理设置Map和Reduce数：两个都不能设置太少，也不能设置太多。太少，会导致Task等待，延长处理时间；太多，会导致Map,Reduce任务竞争资源，造成处理超时等待。</li><li>设置Map,Reduce共存，调整slowstart.completedmaps参数，使Map运行到一定程度后，Reduce也开始运行，减少Reduce的等待时间。</li><li>规避使用Reduce，因为Reduce在用于连接数据集的时候会产生大量的网络消耗。</li><li>合理设置Reduce端的Buffer</li></ol></li><li>OutputFormat阶段<ol><li>采用数据压缩</li><li>使用SequenceFile二进制文件</li></ol></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Hadoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hadoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell介绍</title>
    <link href="/2021/05/11/shell_introduction/"/>
    <url>/2021/05/11/shell_introduction/</url>
    
    <content type="html"><![CDATA[<h1 id="shell介绍"><a href="#shell介绍" class="headerlink" title="shell介绍"></a>shell介绍</h1><h2 id="shell简介"><a href="#shell简介" class="headerlink" title="shell简介"></a>shell简介</h2><ul><li><p>shell是一个命令行解释器，它接受应用程序或者用户命令，然后调用操作系统内核</p></li><li><p>Linux提供的解释器有：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@hadoop101 ~]$ cat /etc/shells <br>/bin/sh<br>/bin/bash<br>/sbin/nologin<br>/bin/dash<br>/bin/tcsh<br>/bin/csh<br></code></pre></td></tr></table></figure></li><li><p>Centos默认的解析器是bash</p></li><li><p>bash和sh的关系：sh是引用了bash，最终sh实际上还是bash命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@hadoop101 bin]$ ll | grep bash<br>-rwxr-xr-x. 1 root root 941880 5月  11 2016 bash<br>lrwxrwxrwx. 1 root root      4 5月  27 2017 sh -&gt; bash<br></code></pre></td></tr></table></figure></li></ul><h2 id="shell脚本基本格式"><a href="#shell脚本基本格式" class="headerlink" title="shell脚本基本格式"></a>shell脚本基本格式</h2><ul><li><p>脚本以<font color=red>#!/bin/bash</font>开头</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@hadoop101 datas]$ touch helloworld.sh<br>[root@hadoop101 datas]$ vi helloworld.sh<br><br>在helloworld.sh中输入如下内容<br><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>echo &quot;helloworld&quot;<br></code></pre></td></tr></table></figure></li><li><p>执行方式</p><ul><li><p>采用bash或sh+脚本的相对路径或绝对路径（不用赋予脚本+x权限）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sh helloworld.sh<br>bash helloworld.sh<br></code></pre></td></tr></table></figure></li><li><p>采用输入脚本的绝对路径或相对路径执行脚本（必须具有可执行权限+x）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod +x helloworld.sh<br></code></pre></td></tr></table></figure></li></ul></li><li><p>第一种执行方法，本质是bash解析器帮你执行脚本，所以脚本本身不需要执行权限。第二种执行方法，本质是脚本需要自己执行，所以需要执行权限。</p></li></ul><h2 id="shell中的变量"><a href="#shell中的变量" class="headerlink" title="shell中的变量"></a>shell中的变量</h2><h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><ul><li><p>常用系统变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@hadoop101 datas]$ echo $HOME<br>/home/atguigu<br><span class="hljs-meta">#</span><span class="bash"> 常用系统变量 <span class="hljs-variable">$HOME</span>、<span class="hljs-variable">$PWD</span>、<span class="hljs-variable">$SHELL</span>、<span class="hljs-variable">$USER</span></span><br><span class="hljs-meta">#</span><span class="bash">显示当前shell中所有变量</span><br>set<br></code></pre></td></tr></table></figure></li></ul><h3 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h3><ul><li><p>（1）定义变量：变量=值 </p><p>（2）撤销变量：unset 变量</p><p>（3）声明静态变量：readonly变量，注意：不能unset</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@hadoop101 datas]$ A=5<br>[root@hadoop101 datas]$ echo $A<br>5<br>[root@hadoop101 datas]$ unset A<br>[root@hadoop101 datas]$ echo $A<br></code></pre></td></tr></table></figure></li></ul><h3 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-variable">$n</span>（功能描述：n为数字，<span class="hljs-variable">$0</span>代表该脚本名称，<span class="hljs-variable">$1</span>-<span class="hljs-variable">$9</span>代表第一到第九个参数，十以上的参数，十以上的参数需要用大括号包含，如<span class="hljs-variable">$&#123;10&#125;</span>）</span><br><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-variable">$#</span>（功能描述：获取所有输入参数个数，常用于循环）。</span><br><span class="hljs-meta">#</span><span class="bash">$*（功能描述：这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体）</span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-variable">$@</span>（功能描述：这个变量也代表命令行中所有的参数，不过<span class="hljs-variable">$@</span>把每个参数区分对待）</span><br><span class="hljs-meta">#</span><span class="bash"> $？（功能描述：最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值为非0（具体是哪个数，由命令自己来决定），则证明上一个命令执行不正确了。）</span><br><br></code></pre></td></tr></table></figure><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">（1）“$((运算式))”或“$[运算式]”</span><br><span class="hljs-meta">#</span><span class="bash">（2）expr  + , - , \*,  /,  %    加，减，乘，除，取余</span><br><span class="hljs-meta">#</span><span class="bash">注意：expr运算符间要有空格</span><br>expr 2 + 3<br></code></pre></td></tr></table></figure><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">[ condition ]（注意condition前后要有空格）</span><br><span class="hljs-meta">#</span><span class="bash">注意：条件非空即为<span class="hljs-literal">true</span>，[ atguigu ]返回<span class="hljs-literal">true</span>，[] 返回<span class="hljs-literal">false</span>。</span><br><span class="hljs-meta">#</span><span class="bash">两个整数之间比较</span><br><span class="hljs-meta">#</span><span class="bash">2. 常用判断条件</span><br>字符串比较<br><br>字符串比较：<br>    =       等于,如:if [ &quot;$a&quot; = &quot;$b&quot; ]<br>    ==     等于,如:if [ &quot;$a&quot; == &quot;$b&quot; ], 与=等价<br>               注意:==的功能在[[]]和[]中的行为是不同的,如下:<br>               1 [[ $a == z* ]]    # 如果$a以&quot;z&quot;开头(模式匹配)那么将为true<br>               2 [[ $a == &quot;z*&quot; ]] # 如果$a等于z*(字符匹配),那么结果为true<br>               3<br>               4 [ $a == z* ]      # File globbing 和word splitting将会发生<br>               5 [ &quot;$a&quot; == &quot;z*&quot; ] # 如果$a等于z*(字符匹配),那么结果为true<br><br>    !=      不等于,如:if [ &quot;$a&quot; != &quot;$b&quot; ]， 这个操作符将在[[]]结构中使用模式匹配.<br>    &lt;       小于,在ASCII字母顺序下.如:<br>               if [[ &quot;$a&quot; &lt; &quot;$b&quot; ]]<br>               if [ &quot;$a&quot; \&lt; &quot;$b&quot; ]     在[]结构中&quot;&lt;&quot;需要被转义.<br>    &gt;       大于,在ASCII字母顺序下.如:<br>           if [[ &quot;$a&quot; &gt; &quot;$b&quot; ]]<br>           if [ &quot;$a&quot; \&gt; &quot;$b&quot; ]  在[]结构中&quot;&gt;&quot;需要被转义.<br>    -z       字符串为&quot;null&quot;.就是长度为0.<br>    -n       字符串不为&quot;null&quot;<br><span class="hljs-meta">#</span><span class="bash">（1）两个整数之间比较</span><br><span class="hljs-meta">#</span><span class="bash">-lt 小于（less than）-le 小于等于（less equal）</span><br><span class="hljs-meta">#</span><span class="bash">-eq 等于（equal）-gt 大于（greater than）</span><br><span class="hljs-meta">#</span><span class="bash">-ge 大于等于（greater equal）-ne 不等于（Not equal）</span><br><span class="hljs-meta">#</span><span class="bash">（2）按照文件权限进行判断</span><br><span class="hljs-meta">#</span><span class="bash">-r 有读的权限（<span class="hljs-built_in">read</span>）-w 有写的权限（write）</span><br><span class="hljs-meta">#</span><span class="bash">-x 有执行的权限（execute）</span><br><span class="hljs-meta">#</span><span class="bash">（3）按照文件类型进行判断</span><br><span class="hljs-meta">#</span><span class="bash">-f 文件存在并且是一个常规的文件（file）</span><br><span class="hljs-meta">#</span><span class="bash">-e 文件存在（existence）-d 文件存在并是一个目录（directory）</span><br></code></pre></td></tr></table></figure><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><ul><li>if语句</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">（1）[ 条件判断式 ]，中括号和条件判断式之间必须有空格</span><br><span class="hljs-meta">#</span><span class="bash">（2）<span class="hljs-keyword">if</span>后要有空格</span><br><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><br>if [ $1 -eq &quot;1&quot; ]<br>then<br>        echo &quot;banzhang zhen shuai&quot;<br>elif [ $1 -eq &quot;2&quot; ]<br>then<br>        echo &quot;cls zhen mei&quot;<br>fi<br><br></code></pre></td></tr></table></figure><ul><li><p>case语句</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">1)<span class="hljs-keyword">case</span>行尾必须为单词“<span class="hljs-keyword">in</span>”，每一个模式匹配必须以右括号“）”结束。</span><br><span class="hljs-meta">#</span><span class="bash">2)双分号“;;”表示命令序列结束，相当于java中的<span class="hljs-built_in">break</span>。</span><br><span class="hljs-meta">#</span><span class="bash">3)最后的“*）”表示默认模式，相当于java中的default。</span><br><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><br>case $1 in<br>&quot;1&quot;)<br>        echo &quot;banzhang&quot;<br>;;<br><br>&quot;2&quot;)<br>        echo &quot;cls&quot;<br>;;<br>*)<br>        echo &quot;renyao&quot;<br>;;<br>esac<br></code></pre></td></tr></table></figure></li><li><p>for循环</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 基本语法一：</span><br><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><br>s=0<br>for((i=0;i&lt;=100;i++))<br>do<br>        s=$[$s+$i]<br>done<br><span class="hljs-meta">#</span><span class="bash"> 基本语法二：</span><br><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><span class="hljs-meta">#</span><span class="bash">打印数字</span><br><br>for i in $*<br>    do<br>      echo &quot;ban zhang love $i &quot;<br>    done<br></code></pre></td></tr></table></figure></li><li><p>while循环</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-keyword">while</span>循环从1叫到100</span><br><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>s=0<br>i=1<br>while [ $i -le 100 ]<br>do<br>        s=$[$s+$i]<br>        i=$[$i+1]<br>done<br><br>echo $s<br></code></pre></td></tr></table></figure></li></ul><h2 id="read读取控制台输入"><a href="#read读取控制台输入" class="headerlink" title="read读取控制台输入"></a>read读取控制台输入</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-built_in">read</span>(选项)(参数)</span><br><span class="hljs-meta">#</span><span class="bash">选项：</span><br><span class="hljs-meta">#</span><span class="bash">-p：指定读取值时的提示符；</span><br><span class="hljs-meta">#</span><span class="bash">-t：指定读取值时等待的时间（秒）。</span><br><span class="hljs-meta">#</span><span class="bash">参数</span><br><span class="hljs-meta">#</span><span class="bash">变量：指定读取值的变量名</span><br><span class="hljs-meta">#</span><br><span class="hljs-meta">#</span><br><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><br>read -t 7 -p &quot;Enter your name in 7 seconds &quot; NAME<br>echo $NAME<br></code></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li><p>系统函数</p></li><li><p>basename [string / pathname] [suffix]  （功能描述：basename命令会删掉所有的前缀包括最后一个（‘/’）字符，然后将字符串显示出来。</p></li><li><p>选项：</p><p>suffix为后缀，如果suffix被指定了，basename会将pathname或string中的suffix去掉。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@hadoop101 datas]$ basename /home/atguigu/banzhang.txt <br>banzhang.txt<br>[root@hadoop101 datas]$ basename /home/atguigu/banzhang.txt .txt<br>banzhang<br></code></pre></td></tr></table></figure></li><li><p>dirname 文件绝对路径        （功能描述：从给定的包含绝对路径的文件名中去除文件名（非目录的部分），然后返回剩下的路径（目录的部分））</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@hadoop101 ~]$ dirname /home/atguigu/banzhang.txt <br>/home/atguigu<br></code></pre></td></tr></table></figure></li><li><p>自定义函数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">1．基本语法</span><br><span class="hljs-meta">#</span><span class="bash">[ <span class="hljs-keyword">function</span> ] funname[()]</span><br><span class="hljs-meta">#</span><span class="bash">&#123;</span><br><span class="hljs-meta">#</span><span class="bash">Action;</span><br><span class="hljs-meta">#</span><span class="bash">[<span class="hljs-built_in">return</span> int;]</span><br><span class="hljs-meta">#</span><span class="bash">&#125;</span><br><span class="hljs-meta">#</span><span class="bash">funname</span><br><span class="hljs-meta">#</span><span class="bash">2．经验技巧</span><br><span class="hljs-meta">#</span><span class="bash">（1）必须在调用函数地方之前，先声明函数，shell脚本是逐行运行。不会像其它语言一样先编译。</span><br><span class="hljs-meta">#</span><span class="bash">（2）函数返回值，只能通过$?系统变量获得，可以显示加：<span class="hljs-built_in">return</span>返回，如果不加，将以最后一条<span class="hljs-comment">#命令运行结果，作为返回值。return后跟数值n(0-255)</span></span><br><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>function sum()<br>&#123;<br>    s=0<br>    s=$[ $1 + $2 ]<br>    echo &quot;$s&quot;<br>&#125;<br><br>read -p &quot;Please input the number1: &quot; n1;<br>read -p &quot;Please input the number2: &quot; n2;<br>sum $n1 $n2;<br></code></pre></td></tr></table></figure></li></ul><h2 id="shell工具"><a href="#shell工具" class="headerlink" title="shell工具"></a>shell工具</h2><h3 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h3><ul><li><p>cut:cut的工作就是“剪”，具体的说就是在文件中负责剪切数据用的。cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段输出。</p></li><li><p>cut [选项参数]  filename     说明：默认分隔符是制表符</p></li><li><table><thead><tr><th align="left">选项参数</th><th>功能</th></tr></thead><tbody><tr><td align="left">-f</td><td>列号，提取第几列</td></tr><tr><td align="left">-d</td><td>分隔符，按照指定分隔符分割列</td></tr><tr><td align="left">-c</td><td>指定具体字符</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@hadoop101 datas]$ touch cut.txt<br>[root@hadoop101 datas]$ vim cut.txt<br>dong shen<br>guan zhen<br>wo  wo<br>lai  lai<br>le  le<br><br>[root@hadoop101 datas]$ cut -d &quot; &quot; -f 2,3 cut.txt <br>shen<br>zhen<br> wo<br> lai<br> le<br> <br> [root@hadoop101 datas]$ cut -d &quot; &quot; -f 1 cut.txt <br>dong<br>guan<br>wo<br>lai<br>le<br><br>[root@hadoop101 datas]$ cat cut.txt | grep &quot;guan&quot; | cut -d &quot; &quot; -f 1<br>guan<br></code></pre></td></tr></table></figure></li></ul><h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><ul><li><p>sed是一种流编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”，接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向存储输出。</p></li><li><ol><li>基本用法</li></ol><p>sed [选项参数]  ‘command’  filename</p><ol start="2"><li>选项参数说明</li></ol><table><thead><tr><th>选项参数</th><th>功能</th></tr></thead><tbody><tr><td>-e</td><td>直接在指令列模式上进行sed的动作编辑。</td></tr><tr><td>-i</td><td>直接编辑文件</td></tr></tbody></table><ol start="3"><li>命令功能描述</li></ol><table><thead><tr><th>命令</th><th>功能描述</th></tr></thead><tbody><tr><td><strong>a</strong></td><td>新增，a的后面可以接字串，在下一行出现,a前面可以指定行</td></tr><tr><td>d</td><td>删除</td></tr><tr><td>s</td><td>查找并替换</td></tr></tbody></table></li></ul><ul><li><p>command中可以匹配正则表达式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 将“mei nv”这个单词插入到sed.txt第二行下，打印。</span><br>[root@hadoop102 datas]$ sed &#x27;2a mei nv&#x27; sed.txt <br>dong shen<br>guan zhen<br>mei nv<br>wo  wo<br>lai  lai<br>le  le<br><span class="hljs-meta">#</span><span class="bash"> 文件内容并没有改变</span><br>[root@hadoop102 datas]$ cat sed.txt <br>dong shen<br>guan zhen<br>wo  wo<br>lai  lai<br>le  le<br><span class="hljs-meta">#</span><span class="bash"> 注意：‘g’表示global，全部替换</span><br>[atguigu@hadoop102 datas]$ sed &#x27;s/wo/ni/g&#x27; sed.txt <br>dong shen<br>guan zhen<br>ni  ni<br>lai  lai<br>le  le<br><br></code></pre></td></tr></table></figure></li></ul><h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><ul><li><p>一个强大的文本分析工具，把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行分析处理。</p></li><li><ol><li>基本用法</li></ol><p>awk [选项参数] ‘pattern1{action1} pattern2{action2}…’ filename</p><p>pattern：表示AWK在数据中查找的内容，就是匹配模式</p><p>action：在找到匹配内容时所执行的一系列命令</p><ol start="2"><li>选项参数说明</li></ol><table><thead><tr><th>选项参数</th><th>功能</th></tr></thead><tbody><tr><td>-F</td><td>指定输入文件折分隔符</td></tr><tr><td>-v</td><td>赋值一个用户定义变量</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br><span class="hljs-meta">#</span><span class="bash">（1）搜索passwd文件以root关键字开头的所有行，并输出该行的第7列。</span><br>[root@hadoop102 datas]$ awk -F: &#x27;/^root/&#123;print $7&#125;&#x27; passwd <br>/bin/bash<br><span class="hljs-meta">#</span><span class="bash">（2）搜索passwd文件以root关键字开头的所有行，并输出该行的第1列和第7列，中间以“，”号分割。</span><br>[root@hadoop102 datas]$ awk -F: &#x27;/^root/&#123;print $1&quot;,&quot;$7&#125;&#x27; passwd <br>root,/bin/bash<br><span class="hljs-meta">#</span><span class="bash">注意：只有匹配了pattern的行才会执行action</span><br><span class="hljs-meta">#</span><span class="bash">（3）只显示/etc/passwd的第一列和第七列，以逗号分割，且在所有行前面添加列名user，shell在<span class="hljs-comment">#最后一行添加&quot;dahaige，/bin/zuishuai&quot;。</span></span><br>[root@hadoop102 datas]$ awk -F : &#x27;BEGIN&#123;print &quot;user, shell&quot;&#125; &#123;print $1&quot;,&quot;$7&#125; END&#123;print &quot;dahaige,/bin/zuishuai&quot;&#125;&#x27; passwd<br>user, shell<br>root,/bin/bash<br>bin,/sbin/nologin<br>。。。<br>atguigu,/bin/bash<br>dahaige,/bin/zuishuai<br><span class="hljs-meta">#</span><span class="bash">注意：BEGIN 在所有数据读取行之前执行；END 在所有数据执行之后执行。</span><br><span class="hljs-meta">#</span><span class="bash">（4）将passwd文件中的用户id增加数值1并输出</span><br>[root@hadoop102 datas]$ awk -v i=1 -F: &#x27;&#123;print $3+i&#125;&#x27; passwd<br>1<br>2<br>3<br>4<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>awk的内置变量</p><table><thead><tr><th>变量</th><th>说明</th></tr></thead><tbody><tr><td>FILENAME</td><td>文件名</td></tr><tr><td>NR</td><td>已读的记录数</td></tr><tr><td>NF</td><td>浏览记录的域的个数（切割后，列的个数）</td></tr></tbody></table></li></ul><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><ul><li><p>sort命令是在Linux里非常有用，它将文件进行排序，并将排序结果标准输出。</p></li><li><p>基本语法</p><p>sort(选项)(参数)</p></li></ul><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-n</td><td>依照数值的大小排序</td></tr><tr><td>-r</td><td>以相反的顺序来排序</td></tr><tr><td>-t</td><td>设置排序时所用的分隔字符</td></tr><tr><td>-k</td><td>指定需要排序的列</td></tr></tbody></table><p>参数：指定待排序的文件列表</p>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大数据</tag>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux</title>
    <link href="/2021/05/11/Linux/"/>
    <url>/2021/05/11/Linux/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="vim的三种模式"><a href="#vim的三种模式" class="headerlink" title="vim的三种模式"></a>vim的三种模式</h2><h3 id="一般模式"><a href="#一般模式" class="headerlink" title="一般模式"></a>一般模式</h3><ul><li>以vi/vim编辑器打开一个文件就进入了一般默认，是默认的默认</li><li>在一般模式中可以对文件进行复制、粘贴、删除、撤销</li><li>常用的命令<ul><li>yy<ul><li>复制一行</li></ul></li><li>y数字y<ul><li>复制多行</li></ul></li><li>dd<ul><li>删除一行</li></ul></li><li>d数字d<ul><li>删除多行</li></ul></li><li>p<ul><li>粘贴</li></ul></li><li>u<ul><li>撤销</li></ul></li><li>^<ul><li>回到行头</li></ul></li><li>$<ul><li>回到行尾</li></ul></li><li>gg或1+G<ul><li>回到页头</li></ul></li><li>G<ul><li>回到页尾</li></ul></li><li>数字+G<ul><li>回到某一行<h3 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h3></li></ul></li></ul></li><li>在一般模式中输入i、o、a或I、O、A时就进入了编辑模式</li><li>在编辑模式中按Esc又回到一般模式</li><li>常用的命令<ul><li>i<ul><li>在光标前插入</li></ul></li><li>o<ul><li>在下一行插入<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3></li></ul></li></ul></li><li>在一般模式中输入:、/或？时就进入了命令模式</li><li>在命令模式中按Esc又回到一般模式</li><li>常用的命令<ul><li>:w<ul><li>保存</li></ul></li><li>:q<ul><li>推出</li></ul></li><li>:!<ul><li>强制执行</li></ul></li><li>:wq！<ul><li>保存并强制退出</li></ul></li><li>ZZ<ul><li>如果没有修改直接退出，修改了保存后退出</li></ul></li><li>:%s/old 字符/new 字符<ul><li>批量替换字符</li></ul></li><li>:nohl<ul><li>取消高亮显示</li></ul></li><li>/要查找的词或?要查找的词<ul><li>通过n或N进行向上或向下的查找</li></ul></li><li>:set nu<ul><li>设置显示行号</li></ul></li><li>:set nonu<ul><li>取消显示行号</li></ul></li></ul></li></ul><h2 id="网络相关命令"><a href="#网络相关命令" class="headerlink" title="网络相关命令"></a>网络相关命令</h2><ul><li>ifconfig<ul><li>查询ip地址</li></ul></li><li>hostname<ul><li>查看主机名</li><li>修改主机名<ul><li>vim /etc/sysconfig/network</li></ul></li><li>配置ip地址与主机名的映射关系<ul><li>vim /etc/hosts</li></ul></li></ul></li><li>service 管理后台服务<ul><li>service 服务名 start<ul><li>开启某个服务</li></ul></li><li>service 服务名 stop<ul><li>关闭某个服务</li></ul></li><li>service 服务名 status<ul><li>查看服务的状态</li></ul></li></ul></li><li>chkconfig 查看开机启动状态<ul><li>chkconfig 服务名 on<ul><li>开启某个服务开机自启</li></ul></li><li>chkconfig 服务名 off<ul><li>关闭某个服务开机自启</li></ul></li><li>chkconfig 服务名 –list<ul><li>查看某个服务的开机自启状态</li><li>一共有7个运行级别（0到6）<ul><li>如果2、3、4、5这四个运行级别是开启的则当前服务就是开机自启的</li></ul></li></ul></li></ul></li></ul><h2 id="帮助相关命令"><a href="#帮助相关命令" class="headerlink" title="帮助相关命令"></a>帮助相关命令</h2><ul><li>man和help<ul><li>查询命令的帮助信息</li></ul></li><li>常用的快捷键<ul><li>ctrl + l<ul><li>清屏</li></ul></li><li>ctrl + c<ul><li>停止进程</li></ul></li><li>一定要善用Tab键<ul><li>可以帮助我们自动补全路径，防止出错</li></ul></li><li>通过上下键查询最近输入过的命令</li><li>ctrl + alt<ul><li>鼠标在虚拟机之间和主机之间切换</li></ul></li></ul></li></ul><h2 id="文件相关命令"><a href="#文件相关命令" class="headerlink" title="文件相关命令"></a>文件相关命令</h2><ul><li>pwd<ul><li>查看当前所在的工作目录</li></ul></li><li>cd<ul><li>进入某个目录<ul><li>通过绝对路径和相对路径都可以进入某个目录</li></ul></li><li>cd -<ul><li>返回上一次所在的目录</li></ul></li><li>cd或cd ~<ul><li>回到自己的家目录</li></ul></li></ul></li><li>rm -rf <ul><li>强制删除文件或目录，不提示</li></ul></li><li>touch 文件名<ul><li>创建一个空文件</li></ul></li><li>mkdir<ul><li>创建目录</li></ul></li><li>echo “要输出的内容”<ul><li>输出内容到控制台</li></ul></li><li>cat 文件<ul><li>查看小文件</li></ul></li><li>less 文件<ul><li>查看大文件<ul><li>通过pageup和pagedown键翻页</li></ul></li></ul></li><li>cp 源文件 目录<ul><li>将某个文件复制到某个目录下</li></ul></li><li>mv<ul><li>mv 老名字 新名字<ul><li>给文件重命名</li></ul></li><li>mv 源文件 目录<ul><li>剪切文件到某个目录下</li></ul></li></ul></li></ul><h2 id="搜索查找类命令"><a href="#搜索查找类命令" class="headerlink" title="搜索查找类命令"></a>搜索查找类命令</h2><ul><li>find 某个目录 [选项] 内容<ul><li>在某个目录下查找相关内容</li><li>选项<ul><li>-name <ul><li>根据文件名称查找</li></ul></li><li>-user<ul><li>根据文件所属的用户查找</li></ul></li><li>-size<ul><li>根据文件的大小查找</li></ul></li></ul></li></ul></li><li>grep<ul><li>通常结合管道符 | 进行过滤查找</li><li>ll /root | grep -n atguigu.txt<ul><li>查找/root目录下是否包含atguigu.txt文件，并且会显示出行号</li></ul></li></ul></li><li>which<ul><li>查询某个命令在那个目录下</li></ul></li></ul><h2 id="压缩解压缩类命令"><a href="#压缩解压缩类命令" class="headerlink" title="压缩解压缩类命令"></a>压缩解压缩类命令</h2><ul><li>tar -zcvf  xxx.tar.gz 要压缩的内容<ul><li>压缩文件</li></ul></li><li>tar -zxvf xxx.tar.gz<ul><li>解压缩tar包</li></ul></li></ul><h2 id="进程线程类命令"><a href="#进程线程类命令" class="headerlink" title="进程线程类命令"></a>进程线程类命令</h2><ul><li>ps -aux | grep xxx<ul><li>查看内存和CPU的占用率</li></ul></li><li>ps -ef | grep xxx<ul><li>查看进程和父进程的ID</li></ul></li><li>kill -9 进程ID<ul><li>通过进程ID杀死进程</li></ul></li><li>killall 进程名<ul><li>通过进程名杀死进程</li></ul></li><li>netstat -nlp | grep 端口号<ul><li>查看端口号是否被占用</li></ul></li></ul><h2 id="RPM软件包和YUM仓库"><a href="#RPM软件包和YUM仓库" class="headerlink" title="RPM软件包和YUM仓库"></a>RPM软件包和YUM仓库</h2><ul><li>rpm -qa<ul><li>查询安装的所有的rpm软件包</li></ul></li><li>rpm -qa | grep 软件名<ul><li>查询安装的某个软件的rpm软件包名</li></ul></li><li>rpm -e –nodeps rpm软件包名<ul><li>不检查依赖协助某个rpm软件包</li></ul></li><li>rpm -ivh rpm软件包名<ul><li>安装rpm软件包</li></ul></li><li>yum -y install<ul><li>安装rpm软件包</li></ul></li><li>yum -y update<ul><li>更新rpm软件包</li></ul></li><li>yum -y check-update<ul><li>检查某个rpm软件包是否有更新</li></ul></li><li>yum -y remove<ul><li>卸载rpm软件包</li></ul></li><li>yum list<ul><li>查询所有缓存的rpm软件包</li></ul></li><li>yum clean all<ul><li>清除缓存</li></ul></li><li>yum makecache<ul><li>建立缓存</li></ul></li><li>yum deplist<ul><li>显示yum软件包的所有依赖关系</li></ul></li></ul><h2 id="文件权限管理"><a href="#文件权限管理" class="headerlink" title="文件权限管理"></a>文件权限管理</h2><ul><li>文件属性<ul><li>Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。在Linux中我们可以使用ll或者ls -l命令来显示一个文件的属性以及文件所属的用户和组。</li><li><a href="https://imgtu.com/i/ga5mY6"><img src="https://z3.ax1x.com/2021/05/11/ga5mY6.md.png" alt="ga5mY6.md.png"></a></li><li>首位表示类型<ul><li>符号 - 代表文件</li><li>符号 d 代表目录</li><li>符号 l 代表链接文档</li></ul></li><li>第1-3位确定属主（该文件的所有者）拥有该文件的权限。—User </li><li>第4-6位确定属组（所有者的同组用户）拥有该文件的权限，—Group </li><li>第7-9位确定其他用户拥有该文件的权限 —Other </li></ul></li><li>chmod修改权限<ul><li>方式一：<ul><li>chmod  [{ugoa}{+-=}{rwx}] 文件或目录 </li><li>chmod g+x houge.txt</li><li>chmod u-x,o+x houge.txt</li></ul></li><li>方式二：<ul><li>chmod  [mode=421 ]  [文件或目录]</li><li>u:所有者  g:所有组  o:其他人  a:所有人(u、g、o的总和)</li><li>r=4 w=2 x=1        rwx=4+2+1=7 </li><li>chmod 777 houge.txt</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM</title>
    <link href="/2021/05/02/JVM/"/>
    <url>/2021/05/02/JVM/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="JVM定义"><a href="#JVM定义" class="headerlink" title="JVM定义"></a>JVM定义</h2><blockquote><ul><li>JVM是运行在操作系统之上的，它与硬件没有直接的交互</li><li>通过编译器将 Java 程序转换成该虚拟机所能识别的指令序列，也称 Java 字节码。Java虚拟机会将字节码，即class文件加载到JVM中。由JVM进行解释和执行</li></ul></blockquote><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><blockquote><ul><li>类加载器，即ClassLoader,它负责加载class文件，class文件在文件开头有特定的文件标示，并且ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定</li></ul></blockquote><h3 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h3><h4 id="虚拟机自带的类加载器"><a href="#虚拟机自带的类加载器" class="headerlink" title="虚拟机自带的类加载器"></a>虚拟机自带的类加载器</h4><ol><li>启动类加载器：主要负责加载jre中的最为基础、最为重要的类。如$JAVA_HOME/jre/lib/rt.jar等，以及由虚拟机参数 -Xbootclasspath 指定的类。由于它由C++代码实现，没有对应的java对象，因此在java中，尝试获取此类时，只能使用null来指代。</li><li>扩展类加载器：由Java代码实现，用于加载相对次要、但又通用的类，比如存放在 JRE 的 lib/ext 目录下 jar 包中的类，以及由系统变量 java.ext.dirs 指定的类。如$JAVA_HOME/jre/lib/ext/*.jar。</li><li>应用程序类加载器：由Java代码实现， 它负责加载应用程序路径下的类。（这里的应用程序路径，便是指虚拟机参数 -cp/-classpath、系统变量 java.class.path 或环境变量 CLASSPATH 所指定的路径。）默认情况下，应用程序中包含的类便是由应用类加载器加载的。</li></ol><h4 id="用户自定义的加载器"><a href="#用户自定义的加载器" class="headerlink" title="用户自定义的加载器"></a>用户自定义的加载器</h4><blockquote><ul><li>Java.lang.ClassLoader的子类，用户可以定制类的加载方式。例如可以对 class 文件进行加密，加载时再利用自定义的类加载器对其解密。</li></ul></blockquote><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><blockquote><ul><li>双亲委派模型：每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。</li><li>应用程序类加载器的父类是扩展类加载器，扩展类加载器的父类是启动类加载器</li><li>优点：1.避免类的重复加载。2.防止核心API中定义的类型不会被用户恶意替换和篡改</li></ul></blockquote><h2 id="JVM的内存模型"><a href="#JVM的内存模型" class="headerlink" title="JVM的内存模型"></a>JVM的内存模型</h2><p><a href="https://imgtu.com/i/gZ2GDO" title="内存模型图片"><img src="https://z3.ax1x.com/2021/05/02/gZ2GDO.png" alt="gZ2GDO.png"></a></p><blockquote><ul><li>Execution Engine执行引擎负责解释命令，提交操作系统执行</li><li>Native Method Stack:定义了很多调用本地操作系统的方法，也称之为本地方法接口</li><li>每个线程都有一个程序计数器，是线程私有的,就是一个指针</li><li>方法区：所有定义的方法的信息都保存在该区域，此区属于共享区间。<br>  静态变量+常量+类信息(构造方法/接口定义)+运行时常量池存在方法区中。</li><li>JDK1.7之前通过永久代实现方法区，1.7之前字符串常量池放到方法区中</li><li>JDK1.8之后，通过元空间实现方法区，1.7之后字符串常量放到堆中</li></ul></blockquote><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><blockquote><ul><li>栈我们也叫内存，是线程私有的，生命周期随线程的生命周期，线程结束栈内存释放</li><li>栈：8种基本类型的变量+对象的引用变量+实例方法都是在栈内存中分配</li><li>在栈区域规定了两种异常状态：如果线程请求的栈深度大于虚拟机所允许的深度，则抛出StackOverflowError异常；如果虚拟机栈可以动态扩展，在扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</li><li>栈帧：一个线程的每个方法在调用时都会在栈上划分一块区域，用于存储方法所需要的变量等信息，这块区域称之为栈帧（stack frame）。栈由多个栈帧构成，好比一部电影由多个帧的画面构成。</li></ul></blockquote><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ul><li>堆内存:存储的是数组和对象（其实数组就是对象），凡是new建立的都是在堆中，堆中存放的都是实体（对象），实体用于封装数据，而且是封装多个（实体的多个属性），如果一个数据消失，这个实体也没有消失，还可以用，所以堆是不会随时释放的，但是栈不一样，栈里存放的都是单个变量，变量被释放了，那就没有了。堆里的实体虽然不会被释放，但是会被当成垃圾，Java有垃圾回收机制不定时的收取。</li></ul><blockquote><ul><li>逻辑上分为三部分：1.新生区。2.养老区。3.永久区。（1.8后改为元空间）</li><li>新生区进一步分为：<blockquote><ul><li>伊甸园区</li><li>幸存区<blockquote><ul><li>幸存from区</li><li>幸存to区</li></ul></blockquote></li></ul></blockquote></li><li>在物理上划分，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )。新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor</li><li>创建对象的过程<blockquote><ul><li>新new的对象会放在伊甸园区，伊甸园区的对象存活率非常低，当伊甸园区快满时会触发轻量级的垃圾回收机制（MinorGC）MinorGC会回收伊甸园区和幸存from区，会将伊甸园的幸存者标记复制到幸存to区，from区中的幸存者会根据它的年龄判断它的去向：默认情况下，如果年龄小于15则被标记到to区，如果年龄小于15则被标记复制到to区，如果年龄大于15则被标记复制到养老区，然后from区和to区交换角色</li><li>当养老区内存不足时会触发重量级垃圾回收机制（MajorGC/fullGC），如果养老区无法回收内存则会出现OOM异常</li></ul></blockquote></li></ul></blockquote><h3 id="JVM常见参数设置"><a href="#JVM常见参数设置" class="headerlink" title="JVM常见参数设置"></a>JVM常见参数设置</h3><blockquote><ul><li>-Xms:堆初始值（默认为物理内存的1/64）</li><li>-Xmx:堆最大可用值（默认为物理内存的1/4）</li><li>-Xss:每个线程的栈大小，默认为1M，此值不能设置过大，否则会减少线程并发数。</li></ul></blockquote><h3 id="常见异常"><a href="#常见异常" class="headerlink" title="常见异常"></a>常见异常</h3><blockquote><ul><li>错误原因: java.lang.OutOfMemoryError: Java heap space 堆内存溢出</li><li>解决办法:调大堆内存大小 </li><li>错误原因: java.lang.StackOverflowError表示为栈溢出，一般产生于递归调用。</li><li>解决办法:设置线程最大调用深度，默认是1m</li></ul></blockquote><h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><blockquote><ul><li>GC:JVM中的Garbage Collection，简称GC，它会不定时去堆内存中清理不可达对象。</li><li>分类：两种类型，一种是普通GC（minor GC），一种是全局GC（major GC or Full GC）</li><li>　新生代GC（minor GC）：只针对新生代区域的GC。</li><li>老年代GC（major GC or Full GC）：针对老年代的GC，偶尔伴随对新生代的GC以及对永久代的GC。</li><li>Minor GC触发机制：当年轻代满时就会触发Minor GC，这里的年轻代满指的是Eden区满，Survivor满不会引发GC。</li><li>Full GC触发机制：当年老代满时会引发Full GC，Full GC将会同时回收年轻代、年老代，当永久代满时也会引发Full GC，会导致Class、Method元信息的卸载</li><li>工作特点：理论上GC过程中会频繁收集Young区，很少收集Old区，基本不动Perm区（元空间/方法区）</li></ul></blockquote><h3 id="标记不可达对象"><a href="#标记不可达对象" class="headerlink" title="标记不可达对象"></a>标记不可达对象</h3><blockquote><ul><li>引用计数法：引用计数法就是如果一个对象没有被任何引用指向，则可视之为垃圾。这种方法的缺点就是不能检测到循环指向的存在。</li><li>可达性分析（GC ROOTS算法）简单理解，可以理解为堆外指向堆内的引用</li></ul></blockquote><h3 id="垃圾回收的三种方式"><a href="#垃圾回收的三种方式" class="headerlink" title="垃圾回收的三种方式"></a>垃圾回收的三种方式</h3><ol><li>清除：第一种是清除（sweep），即把死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表（free list）之中</li><li>压缩：第二种是压缩（compact），即把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间</li><li>复制第三种则是复制（copy），即把内存区域分为两等分，分别用两个指针 from 和 to 来维护，并且只是用 from 指针指向的内存区域来分配内<blockquote><ul><li>总结：回收死亡对象的内存共有三种方式，分别为：会造成内存碎片的清除、性能开销较大的压缩、以及堆使用效率较低的复制。</li></ul></blockquote></li></ol><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><ol><li>标记复制算法 因此Minor GC使用的则是标记-复制算法，理性情况下：，Eden 区中的对象基本都死亡了，那么需要复制的数据将非常少，因此采用这种标记 - 复制算法的效果极好。<blockquote><ul><li>优点：不会产生内存碎片 </li><li>缺点：需要双倍空间，浪费内存</li></ul></blockquote></li><li>标记清除算法 老年代一般是由标记清除或者是标记清除与标记压缩的混合实现<blockquote><ul><li>优点：不需要双倍空间</li><li>缺点：1.会产生内存碎片 2.需要停止整个应用程序 3.需要维护内存碎片的地址列表</li></ul></blockquote></li><li>标记压缩算法<blockquote><ul><li>优点：1.不需要双倍空间，也不会产生内存碎片 2.补血药维护内存碎片的列表，只需要记录内存的起始地址即可 </li><li>缺点：开销大，学要更新对象的地址</li></ul></blockquote></li><li>标记清楚压缩算法 标记清除压缩(Mark-Sweep-Compact)算法是标记清除算法和标记压缩算法的结合算法。其原理和标记清除算法一致，只不过会在多次GC后，进行一次Compact操作！</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL</title>
    <link href="/2021/04/25/mysql/"/>
    <url>/2021/04/25/mysql/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><blockquote><ul><li>C/S 架构</li><li>服务器程序是 mysqld.exe</li><li>客户端程序是 mysql.exe</li><li>cmd的打开方式：</li></ul></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">mysql -uroot -p123456 -h127.0.0.1 -P3306<br>长选项：<br>mysql <span class="hljs-attribute">--host</span>=主机地址 <span class="hljs-attribute">--port</span>=端口 <span class="hljs-attribute">--user</span>=用户名 <span class="hljs-attribute">--password</span>=密码 默认数据库<br></code></pre></td></tr></table></figure><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><blockquote><ul><li>查看服务器中的所有数据库</li></ul></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">databases</span>;<br></code></pre></td></tr></table></figure><blockquote><ul><li>创建新的数据库</li><li>数据库以目录的形式保存在服务器<br>安装目录/data目录下</li></ul></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">databases</span>;<br></code></pre></td></tr></table></figure><blockquote><ul><li>切换当前工作数据库<br>mysql&gt; use company;</li></ul></blockquote><blockquote><ul><li>查看当前数据库中的所有表<br>show tables;</li><li>跨库查看表<br>show tables from 其他库</li></ul></blockquote><blockquote><ul><li>把.sql文件中数据导入数据库<br>source e:sql/company.sql;</li></ul></blockquote><blockquote><ul><li>查看表中的所有数据<br>select * from employees;</li></ul></blockquote><blockquote><ul><li>创建world数据库, 并导入 world.sql , 查看表中的数据</li><li>create database world;</li></ul></blockquote><blockquote><ul><li>use world;</li></ul></blockquote><blockquote><ul><li>source d:/mywork/mysql/world.sql;</li><li>查看当前数据库<br>select database();</li><li>创建表</li></ul></blockquote><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs crystal">create table customer(<br>id int,<br>name varchar(<span class="hljs-number">20</span>),<br>age int,<br>email varchar(<span class="hljs-number">50</span>),<br>gender <span class="hljs-class"><span class="hljs-keyword">enum</span>(&#x27;男&#x27;, &#x27;女&#x27;)</span><br>);<br></code></pre></td></tr></table></figure><blockquote><ul><li>丢弃表<br>drop table customer;</li></ul></blockquote><blockquote><ul><li>查看表结构<br>describe customer;</li></ul></blockquote><blockquote><ul><li>desc 表名</li><li>查看表的建表语句<br>show create table 表名;</li><li>插入数据</li><li>存储引擎 : InnoDB(支持事务, 外键等高级特性), MyISAM(不支持事务, 不支持外键)</li><li>show engines;显示支持的引擎</li><li>``号专门用于包围数据库对象的名称(数据库, 表, 列, 主键, 外键, 索引, 函数, 存储过程, 触发器)<br>查询表中的所有数据</li><li>select * from 表名; from关键字可以省略</li></ul></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql">插入数据<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> customer(<br><span class="hljs-keyword">id</span>,<br><span class="hljs-keyword">name</span>,<br>age,<br>email,<br>gender <br>) <span class="hljs-keyword">values</span> (<br><span class="hljs-number">1</span>,<br><span class="hljs-string">&#x27;张三&#x27;</span>,<br><span class="hljs-number">30</span>,<br><span class="hljs-string">&#x27;zhang3@qq.com&#x27;</span>,<br><span class="hljs-string">&#x27;男&#x27;</span><br>);<br></code></pre></td></tr></table></figure><blockquote><ul><li>修改数据, 如果没有where 语句会导致修改所有记录</li></ul></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">update<span class="hljs-built_in"> customer </span><span class="hljs-builtin-name">set</span> <br>age = 3,<br>email = <span class="hljs-string">&#x27;QQQ&#x27;</span><br>where <br>id = 1;<br></code></pre></td></tr></table></figure><blockquote><ul><li>删除数据, 如果没有where语句会导致删除所有记录</li></ul></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">delete <span class="hljs-keyword">from</span> customer<br>where id = 3;<br></code></pre></td></tr></table></figure><blockquote><ul><li>针对数据的操作.</li></ul></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">C insert into  <span class="hljs-regexp">//</span>Create <br>R select <span class="hljs-regexp">//</span>Retrieve<br>U update <span class="hljs-regexp">//</span>Update<br>D <span class="hljs-keyword">delete</span> <span class="hljs-regexp">//</span>Delete<br></code></pre></td></tr></table></figure><blockquote><ul><li>查看表结构 :<br>desc 表名;</li></ul></blockquote><blockquote><ul><li>SQL注意 :<blockquote><ul><li>SQL 语言大小写不敏感。 </li><li>SQL 可以写在一行或者多行</li><li>关键字不能被缩写也不能分行</li><li>各子句一般要分行写。</li><li>使用缩进提高语句的可读性。</li></ul></blockquote></li><li>给列起别名, 可以省略as关键字, 别名中如果有特殊符号, 可以使用””包围.</li></ul></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <br>population <span class="hljs-keyword">as</span> pop,<br><span class="hljs-keyword">name</span> <span class="hljs-string">&quot;国家 名称&quot;</span>,<br>code<br><span class="hljs-keyword">from</span> <br>country;<br></code></pre></td></tr></table></figure><blockquote><ul><li>where 条件布尔(一个表达式，返回结果永远是一个布尔值)</li></ul></blockquote><blockquote><ul><li>执行顺序SQL：先from, 再where 最后select </li></ul></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">SELECT</span> <span class="hljs-string"></span><br><span class="hljs-attr">employee_id</span> <span class="hljs-string">empId, </span><br><span class="hljs-attr">last_name</span> <span class="hljs-string">name, </span><br><span class="hljs-attr">job_id</span> <span class="hljs-string">job, </span><br><span class="hljs-attr">department_id</span> <span class="hljs-string">deptId</span><br><span class="hljs-attr">FROM</span>   <span class="hljs-string"></span><br><span class="hljs-attr">employees</span><br><span class="hljs-attr">WHERE</span>  <span class="hljs-string"></span><br><span class="hljs-attr">department_id</span> = <span class="hljs-string">90 ;</span><br><br><span class="hljs-meta">--</span> <span class="hljs-string">错误!! where中不可以使用列的别名, 因为此时虚表的列还没有生成好.</span><br></code></pre></td></tr></table></figure><blockquote><ul><li>Between a and b 都包含</li><li>like <blockquote><ul><li>% 表示任意个任意字符</li><li>_ 表示一个任意字符</li></ul></blockquote></li></ul></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">查询姓名中第2个字母是o其他无所谓<br><span class="hljs-keyword">SELECT</span> last_name<br><span class="hljs-keyword">FROM</span>   employees<br><span class="hljs-keyword">WHERE</span>  last_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;_o%&#x27;</span>;<br></code></pre></td></tr></table></figure><blockquote><ul><li>只要有null参与比较运算, 结果一定是false</li></ul></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs sql">查询哪些国家没有首都<br>只要有null参与比较运算, 结果一定是false<br><span class="hljs-comment">--错误!!</span><br><span class="hljs-keyword">select</span> <br><span class="hljs-keyword">name</span>,<br>continent,<br>capital<br><span class="hljs-keyword">from</span> <br>country <br><span class="hljs-keyword">where</span> <br>capital = <span class="hljs-literal">null</span>;<br><br>查询哪些国家没有首都<br><span class="hljs-keyword">select</span> <br><span class="hljs-keyword">name</span>,<br>continent,<br>capital<br><span class="hljs-keyword">from</span> <br>country <br><span class="hljs-keyword">where</span> <br>capital <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span>;<br><br>查询哪些国家有首都<br><span class="hljs-keyword">select</span> <br><span class="hljs-keyword">name</span>,<br>continent,<br>capital<br><span class="hljs-keyword">from</span> <br>country <br><span class="hljs-keyword">where</span> <br>capital <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><blockquote><ul><li>where 也支持算术运算, 结果为0表示假非0表示真</li><li>distinct 去重, 要求列真的有重复的</li></ul></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span><br><span class="hljs-keyword">distinct</span><br>continent,<br><span class="hljs-keyword">name</span><br><span class="hljs-keyword">from</span><br>country;<br></code></pre></td></tr></table></figure><blockquote><ul><li>order by  可以排序, 只是给结果集虚表排序</li><li>默认是升充(asc)    </li><li>降序必须指定(desc)</li><li>order by 可以使用列的别名.</li><li>order by  列1, 列2 先以列1排序, 再在相同的列1数据中, 再依据列2再微排.</li></ul></blockquote><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> <br>last_name, <br>department_id, <br>salary<br><span class="hljs-keyword">FROM</span>   <br>employees<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <br>department_id, <br>salary <span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></table></figure><blockquote><ul><li>写SQL的步骤 : <blockquote><ul><li>(1) from 基表</li><li>(2) where 过滤哪些行</li><li>(3) select 选择哪些列</li><li>(4) order by 以哪些列为排序依据. </li></ul></blockquote></li></ul></blockquote><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h3 id="表联接"><a href="#表联接" class="headerlink" title="表联接"></a>表联接</h3><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">表联接<br><span class="hljs-keyword">select</span> <br>* <br><span class="hljs-keyword">from</span> <br>city2,<br>country2;<br>笛卡尔集中的数据绝大多数都是垃圾, 必须使用行过滤.<br></code></pre></td></tr></table></figure><blockquote><ul><li>笛卡尔集中的数据绝大多数都是垃圾, 必须使用行过滤.</li><li>解决列名冲突可以使用表名限定</li></ul></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">--表名也可以起别名, 而且是如果多表联接, 最好起别名.</span><br><span class="hljs-keyword">select</span> <br>ci.name cityName,<br>ci.population cityPop,<br>co.name countryName,<br>co.population countryPop,<br>co.continent<br><span class="hljs-keyword">from</span> <br>city2 ci,<br>country2 co <br><span class="hljs-keyword">where</span> <br>ci.countrycode = co.code;<br><br><span class="hljs-comment">--一旦给表起了别名, 原名不可以使用, 必须使用别名. 原因是from最先执行, 它把原始表名变了.</span><br><span class="hljs-keyword">select</span> <br>city2.name cityName,<br>city2.population cityPop,<br>country2.name countryName,<br>country2.population countryPop,<br>country2.continent<br><span class="hljs-keyword">from</span> <br>city2 ci,<br>country2 co <br><span class="hljs-keyword">where</span> <br>city2.countrycode = country2.code;<br></code></pre></td></tr></table></figure><blockquote><ul><li>复习 :<blockquote><ul><li>C/S </li><li>Server : mysqld.exe </li><li>Clinet : mysql.exe </li><li>必须通过客户端才能使用服务器</li><li>需要提供IP, 端口, 用户名, 密码.</li><li>mysql -h127.0.0.1 -P3306 -uroot -p123456</li><li>mysql –host=127.0.0.1 –port=3306 –user=root –password=123456 默认数据库</li><li>mysql –host=主机地址 –port=端口 –user=用户名 –password=密码 默认数据库</li><li>查看所有库<br>show databases;</li><li>切换成当前工作数据库<br>use 数据库;</li><li>查看库中的表<br>show tables;</li><li>跨库查看表<br>show tables from 其他库</li></ul></blockquote></li></ul></blockquote><blockquote><blockquote><ul><li>查看表结构<br>desc 表名;</li></ul></blockquote></blockquote><blockquote><blockquote><ul><li>查看表的建表语句<br>show create table 表名;</li></ul></blockquote></blockquote><blockquote><blockquote><ul><li>存储引擎 : InnoDB(支持事务, 外键等高级特性), MyISAM(不支持事务, 不支持外键)</li></ul></blockquote></blockquote><blockquote><blockquote><ul><li>``专门用于包围数据库对象的名称(数据库, 表, 列, 主键, 外键, 索引, 函数, 存储过程, 触发器)</li><li>查询表中的所有数据<br>select * from 表名; from关键字可以省略</li></ul></blockquote></blockquote><blockquote><blockquote><ul><li>相看当前数据库<br>select<br>  database(), – 函数<br>  now(),<br>  version()</li></ul></blockquote></blockquote><p>select<br>    100, – 常量<br>    ‘abc’<br>from<br>    dual;</p><blockquote><blockquote><ul><li>使用用户变量<br>set @var1 = 100, @var2 = ‘abc’;</li></ul></blockquote></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">--SQL99标准, 用内联代替逗号联接.</span><br><span class="hljs-keyword">select</span> <br>ci.name cityName,<br>ci.population cityPop,<br>co.name countryName,<br>co.population countryPop,<br>co.continent<br><span class="hljs-keyword">from</span> <br>city2 ci<br><span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> <br>country2 co <br><span class="hljs-keyword">on</span><br>ci.countrycode = co.code <span class="hljs-comment">-- 联接条件</span><br><span class="hljs-keyword">where</span>  <br>ci.population &gt; <span class="hljs-number">5000000</span> <span class="hljs-comment">-- 普通过滤</span><br><br><br><span class="hljs-comment">-- where 和 on在内联时可以混用, 但是千万不要.</span><br><span class="hljs-keyword">select</span> <br>ci.name cityName,<br>ci.population cityPop,<br>co.name countryName,<br>co.population countryPop,<br>co.continent<br><span class="hljs-keyword">from</span> <br>city2 ci<br><span class="hljs-keyword">join</span> <br>country2 co <br><span class="hljs-keyword">on</span><br>ci.countrycode = co.code <span class="hljs-comment">-- 联接条件</span><br><span class="hljs-keyword">where</span>  <br>ci.population &gt; <span class="hljs-number">5000000</span> <span class="hljs-comment">-- 普通过滤</span><br></code></pre></td></tr></table></figure><blockquote><ul><li>注意：<blockquote><ul><li>内联接的逻辑是从笛尔集中取出来的是满足联接条件的记录. 有可能会导致某张表的数据不完整.</li></ul></blockquote></li></ul></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <br>co.name countryName,<br>ci.name capitalName,<br>co.capital<br><span class="hljs-keyword">from</span> <br>country2 co <br><span class="hljs-keyword">left</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> <span class="hljs-comment">-- 左外联接, 保证左表数据完整</span><br>city2 ci <br><span class="hljs-keyword">on</span> <br>co.capital = ci.id ;<br><br><span class="hljs-keyword">select</span> <br>co.name countryName,<br>ci.name capitalName,<br>co.capital<br><span class="hljs-keyword">from</span> <br>country2 co <br><span class="hljs-keyword">right</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> <span class="hljs-comment">-- 左外联接, 保证左表数据完整</span><br>city2 ci <br><span class="hljs-keyword">on</span> <br>co.capital = ci.id ;<br><br><span class="hljs-comment">--外联时可以省略outer关键字</span><br><span class="hljs-keyword">select</span> <br>co.name countryName,<br>ci.name capitalName,<br>co.capital<br><span class="hljs-keyword">from</span> <br>country2 co <br><span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span><br>city2 ci <br><span class="hljs-keyword">on</span> <br>co.capital = ci.id ;<br></code></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h4><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">单行函数 -- 作用于结果集中的每一条记录的.<br><span class="hljs-keyword">select</span> <br>upper(name),<br>now(),<br><span class="hljs-keyword">concat</span>(continent, code2)<br><span class="hljs-keyword">from</span> <br>country;<br><br>查询国家表中的数据, 把国家名称,大洲, 国家代码 连接起来, 中间使用<span class="hljs-string">&#x27;=&gt;&#x27;</span>连接.<br>--<span class="hljs-keyword">concat</span>(<span class="hljs-keyword">concat</span>(<span class="hljs-keyword">concat</span>(<span class="hljs-keyword">concat</span>(name, <span class="hljs-string">&#x27;=&gt;&#x27;</span>), continent), <span class="hljs-string">&#x27;=&gt;&#x27;</span>), code)<br><span class="hljs-keyword">select</span> <br><span class="hljs-keyword">concat</span>(name, <span class="hljs-string">&#x27;=&gt;&#x27;</span>, continent, <span class="hljs-string">&#x27;=&gt;&#x27;</span>, code)<br><span class="hljs-keyword">from</span> <br>country;<br></code></pre></td></tr></table></figure><h4 id="组函数"><a href="#组函数" class="headerlink" title="组函数"></a>组函数</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">组函数 -- 作用于一组数据, 最终针对一组只有一个结果. 也称为统计处理<br><span class="hljs-function"><span class="hljs-title">avg</span><span class="hljs-params">()</span></span> 平均<br><span class="hljs-function"><span class="hljs-title">max</span><span class="hljs-params">()</span></span> 最大<br><span class="hljs-function"><span class="hljs-title">min</span><span class="hljs-params">()</span></span> 最小<br><span class="hljs-function"><span class="hljs-title">count</span><span class="hljs-params">()</span></span> 计数<br><span class="hljs-function"><span class="hljs-title">sum</span><span class="hljs-params">()</span></span>求和<br></code></pre></td></tr></table></figure><blockquote><ul><li>获取表中的记录数, 使用count(*)最好.</li><li>如果有group by , 必须让分组依据的列放在select中.</li></ul></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros">select <br>-- name, 代表个体信息的列<br>continent,<br>max(population)<br><span class="hljs-keyword">from</span> <br>country <br>group by <br>continent;<br></code></pre></td></tr></table></figure><blockquote><ul><li>对分组的虚表进行过滤, 必须使用having</li><li>having的执行晚于select, 所以可以使用列的别名</li></ul></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs routeros">select <br>GovernmentForm,<br>count(*) ct<br><span class="hljs-keyword">from</span> <br>country<br>group by <br>GovernmentForm<br>having<br>ct &gt; 10<br>order by <br>ct;<br></code></pre></td></tr></table></figure><p>sql语句一般的执行顺序：</p><ol><li>from         确定基表</li><li>join         如果一张基表不够, 再联接其他表</li><li>on             如果有联接表 必须要有on</li><li>where         过滤总基表中的行</li><li>group by     分组, 分组依据的列.</li><li>select         把分组依据的列放在select后, 再考虑要选择哪些列, 及进行哪些函数调用….</li><li>having         进一步把分组后的虚表行过滤</li><li>order by     最终表的一个排序显示.</li></ol><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><blockquote><ul><li>子查询 : 通常需要多步执行的简单查询</li></ul></blockquote><blockquote><ul><li>针对表中的数据进行的操作, 这样的语言称DML(数据操纵语句)<blockquote><ul><li>select R</li><li>update U </li><li>delete D </li><li>insert C</li></ul></blockquote></li></ul></blockquote><blockquote><ul><li>针对数据库中的对象的操作, 这样的语言称DDL(数据定义语言)</li><li>数据库 </li><li>表</li><li>列 </li><li>约束 </li><li>索引 </li><li>预编译</li><li>函数</li><li>存储过程 </li><li>触发器</li><li>事件…..</li></ul></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs sql">创建数据库 <br><span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> 数据库名 <span class="hljs-keyword">charset</span> 字符集;<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> school <span class="hljs-keyword">charset</span> utf8;<br><br>修改数据库 <br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">database</span> school <span class="hljs-keyword">charset</span> gbk;<br><br>丢弃数据库. 数据库中的所有内容全部丢弃. 慎重!!!!<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">database</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">exists</span> school;<br><br>常用数据类型<br>int 4字节整数<br>bigint8字节整数<br>char(长度)定长字符串<br>varchar(字符数) // 最多65535字节<br>double8字节双精度浮点<br>decimal定点数<br>date 日期<br>datetime日期时间<br>longtext 长文本<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> teacher(<br><span class="hljs-keyword">id</span> <span class="hljs-built_in">int</span> auto_increment,<br><span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>),<br>age <span class="hljs-built_in">int</span>,<br>phone <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>),<br>address <span class="hljs-built_in">varchar</span>(<span class="hljs-number">100</span>),<br>gender enum(<span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>) <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;男&#x27;</span>,<br>primary <span class="hljs-keyword">key</span>(<span class="hljs-keyword">id</span>)<br>) <span class="hljs-keyword">engine</span> <span class="hljs-keyword">innodb</span> <span class="hljs-keyword">charset</span> gbk;<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> classes(<br><span class="hljs-keyword">id</span> <span class="hljs-built_in">int</span> auto_increment,<br><span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">30</span>),<br>student_count <span class="hljs-built_in">int</span>,<br>room <span class="hljs-built_in">char</span>(<span class="hljs-number">3</span>),<br><span class="hljs-keyword">master</span> <span class="hljs-built_in">int</span>, <span class="hljs-comment">-- 班主任</span><br>begindate <span class="hljs-built_in">date</span>,<br>primary <span class="hljs-keyword">key</span>(<span class="hljs-keyword">id</span>)<br>);<br></code></pre></td></tr></table></figure><blockquote><ul><li>子查询题目例子</li></ul></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-number">5</span> 查询所有国家的首都和使用率最高的官方语言(选做)<br><span class="hljs-keyword">select</span> <br>co.name,<br>ci.name,<br>cl3.<span class="hljs-keyword">language</span>,<br>cl3.percentage<br><span class="hljs-keyword">from</span> <br>country co <br><span class="hljs-keyword">left join</span> <br>city ci <br><span class="hljs-keyword">on</span> <br>co.capital = ci.id <br><span class="hljs-keyword">left join</span> <br>(<span class="hljs-keyword">select</span> <br>cl.countrycode,<br>cl.<span class="hljs-keyword">language</span>,<br>cl.percentage,<br>cl.isofficial<br><span class="hljs-keyword">from</span> <br>countrylanguage cl <br><span class="hljs-keyword">join</span>  <br>(<span class="hljs-keyword">select</span> countrycode, max(Percentage) maxPer <span class="hljs-keyword">from</span> countrylanguage <span class="hljs-keyword">where</span> isofficial = <span class="hljs-string">&#x27;T&#x27;</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> countrycode) cl2<br><span class="hljs-keyword">on</span> <br>cl.countrycode = cl2.countrycode <br><span class="hljs-keyword">and</span> <br>cl.percentage = cl2.maxPer<br><span class="hljs-keyword">where</span> <br>cl.isofficial = <span class="hljs-string">&#x27;T&#x27;</span><br>) cl3<br><span class="hljs-keyword">on</span> <br>co.code = cl3.countrycode <br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <br>cl3.percentage;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sql">创建数据库 <br><span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> 数据库名 <span class="hljs-keyword">charset</span> utf8;<br><br>修改数据库 只能修改字符集<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">database</span> 数据库名 <span class="hljs-keyword">charset</span> 新字符集;<br><br>丢弃数据库<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">database</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">exists</span> 数据加名;<br><br>查看库或表<br><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span>(<span class="hljs-keyword">table</span>) 数据库名或表名<br><br><span class="hljs-keyword">SQL</span>语言分类<br><span class="hljs-number">1</span>) DML 数据操纵语言, 主要处理数据<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">select</span> <span class="hljs-keyword">update</span> <span class="hljs-keyword">delete</span> <br><br><span class="hljs-number">2</span>) <span class="hljs-keyword">DDL</span> 数据定义语言, 主要处理数据库对象<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">show</span> <span class="hljs-keyword">alter</span> <span class="hljs-keyword">drop</span> <br><br><span class="hljs-number">3</span>) DCL 数据控制语句, 主要用于控制事务<br><span class="hljs-keyword">commit</span> <span class="hljs-keyword">rollback</span><br><br></code></pre></td></tr></table></figure><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><blockquote><ul><li>全新方式创建表</li></ul></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs routeros">1) 全新方式建表<br>create table <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> exists 表名(<br>列1 数据类型1(长度) 其他选项,<br>列2 数据类型2(长度) 其他选项,<br><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>,<br>primary key(列) -- 表级主键<br>) engine 数据库引擎 charset 字符集;<br><br>数据库引擎 : <br>InnoDB : 缺省引擎, 支持事务, 外键等高级特性, 速度慢<br>MyIsam : 速度快, 早期的缺省引擎, 不支持事务,外键等高级特性<br><br>其他选项 : auto_increment,<span class="hljs-built_in"> default </span>缺省值, <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>, unique.<br></code></pre></td></tr></table></figure><blockquote><ul><li>基于子查询, 可以复制数据，不能复制各种约束（key）…</li></ul></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> 表名 <br>子查询 <br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> country3 <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> world.country <span class="hljs-keyword">where</span> continent = <span class="hljs-string">&#x27;asia&#x27;</span>;<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> country4 <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> world.country;<br></code></pre></td></tr></table></figure><blockquote><ul><li>完全复制表结构，不能复制数据</li></ul></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> 表名 <span class="hljs-keyword">like</span> 已有表名<br></code></pre></td></tr></table></figure><h3 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs sql">表结构的修改<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <br><span class="hljs-comment">--子句</span><br><br>添加新列<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <br><span class="hljs-keyword">add</span> 新列名 数据类型 其他选项;<br><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> teacher <br><span class="hljs-keyword">add</span> gender enum(<span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>) <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;男&#x27;</span>;<br><br>修改列<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <br><span class="hljs-keyword">modify</span> 列名 新数据类型 新其他选项;<br><br>修改列名<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <br><span class="hljs-keyword">change</span> 老列名 新列名 新数据类型 新其他选项;<br>丢弃一个列, 此列对应的所有数据都会删除<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">column</span> 列名 <br><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> teacher<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">column</span> address;<br>丢弃表 <br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">exists</span> 表名<span class="hljs-number">1</span>, 表名<span class="hljs-number">2</span>, ....;<br><br>清空表数据<br><span class="hljs-keyword">truncate</span> <span class="hljs-keyword">table</span> 表名; <span class="hljs-comment">-- 它是一个DDL语句, 一旦清除,就不能回滚, 效率高.</span><br><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> 表名; <span class="hljs-comment">-- 它是一个DML语句, 意味着是可以回滚的. 效率低.</span><br><br>修改表名<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名<br><span class="hljs-keyword">rename</span> <span class="hljs-keyword">to</span> 新表名<br></code></pre></td></tr></table></figure><h3 id="插入数据的方式"><a href="#插入数据的方式" class="headerlink" title="插入数据的方式"></a>插入数据的方式</h3><ol><li>全新方式插入<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">insert <span class="hljs-built_in">int</span>o 表名 (<br>列<span class="hljs-number">1</span>,<br>列<span class="hljs-number">2</span>,<br>列<span class="hljs-number">3</span>,<br>.....<br>) values (<br>值<span class="hljs-number">1</span>,<br>值<span class="hljs-number">2</span>,<br>值<span class="hljs-number">3</span>,<br>....<br>)<br></code></pre></td></tr></table></figure></li><li>使用子查询插入<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> students(<br><span class="hljs-keyword">name</span>,<br>age,<br>mobile,<br>gender,<br>address<br>) <span class="hljs-keyword">select</span> <br><span class="hljs-keyword">name</span>,<br>age, <br>mobile,<br>gender,<br><span class="hljs-string">&#x27;北京&#x27;</span><br><span class="hljs-keyword">from</span> <br>teachers <br><span class="hljs-keyword">where</span> <br><span class="hljs-keyword">id</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><span class="hljs-comment">-- 克隆表</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 新表 <span class="hljs-keyword">like</span> 旧表;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> 新表 <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> 旧表 <br>克隆城市表到当前库下新成中国城市表 (chinaCity)<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> chinaCity <span class="hljs-keyword">like</span> world.city; <br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> chinacity <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> world.city <span class="hljs-keyword">where</span> countrycode = <span class="hljs-string">&#x27;chn&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li> 插入一条数据 insert into 表名 set 数据<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <br>teachers <br><span class="hljs-keyword">set</span> <br><span class="hljs-keyword">name</span> = <span class="hljs-string">&#x27;丁老师&#x27;</span>,<br>age = <span class="hljs-number">25</span>,<br>mobile = <span class="hljs-string">&#x27;123234234&#x27;</span>;<br>修改数据 <br><span class="hljs-keyword">update</span> 表名 <span class="hljs-keyword">set</span> <br>列<span class="hljs-number">1</span> = 值<span class="hljs-number">1</span>,<br>列<span class="hljs-number">2</span> = 值<span class="hljs-number">2</span>,<br>列<span class="hljs-number">3</span> = 值<span class="hljs-number">3</span>,<br>....<br><span class="hljs-keyword">where</span> <br>行过滤<br><br><span class="hljs-keyword">update</span> teachers <span class="hljs-keyword">set</span> <br>age = <span class="hljs-number">40</span>,<br>mobile = <span class="hljs-string">&#x27;135342342&#x27;</span><br><span class="hljs-keyword">where</span> <br><span class="hljs-keyword">id</span> = <span class="hljs-number">1</span>;<br><br>删除数据 <br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> 表名 <br><span class="hljs-keyword">where</span> 行过滤<br><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> teachers <br><span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> &gt; <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="数据库事物"><a href="#数据库事物" class="headerlink" title="数据库事物"></a>数据库事物</h3><blockquote><ul><li>定义：让数据从一种状态到另一种状态</li><li>ACID特性</li><li>让一组逻辑操作单元当成一个单个的命令来执行.<blockquote><ul><li>A 原子性 : 不可分割 </li><li>C 一致性 : 数据前后是一致</li><li>I 独立性 : 事务间, (独立性有等级)</li><li>D 持久性 : 事务一旦提交, 数据持久化.</li></ul></blockquote></li></ul></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs sql">设置提交状态：<span class="hljs-keyword">SET</span> AUTOCOMMIT = <span class="hljs-literal">FALSE</span>;<br>或者显式的执行 <span class="hljs-keyword">start</span> <span class="hljs-keyword">transaction</span><br>            或 <span class="hljs-keyword">begin</span><br><br>以第一个 DML 语句的执行作为开始<br><br>以下面的其中之一作为结束:<br><span class="hljs-keyword">COMMIT</span> 或 <span class="hljs-keyword">ROLLBACK</span> 语句<br><span class="hljs-keyword">DDL</span> 语句（自动提交）<br>用户会话正常结束, 提交<br>系统异常终止      回滚<br><br><span class="hljs-keyword">SET</span> AUTOCOMMIT = <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">set</span> autocommit = <span class="hljs-literal">false</span>;<br><br>用一个客户端在事务中删除表数据, 另一个客户端查询??<br><br>预编译 : 提前把SQL编译成可执行的, 在执行时只需要调用它即可.<br><span class="hljs-keyword">prepare</span> 预编译名 <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;SQL&#x27;</span>; <br><br><span class="hljs-keyword">prepare</span> p1 <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;select * from teachers&#x27;</span><br><br>执行预编译 <br><span class="hljs-keyword">execute</span> p1; <br><br>丢弃预编译<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">prepare</span> p1;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">prepare</span> p2 <br><span class="hljs-keyword">from</span> <br><span class="hljs-string">&#x27;insert into teachers(</span><br><span class="hljs-string">name, </span><br><span class="hljs-string">age, </span><br><span class="hljs-string">mobile</span><br><span class="hljs-string">) values (</span><br><span class="hljs-string">?,</span><br><span class="hljs-string">?,</span><br><span class="hljs-string">?</span><br><span class="hljs-string">)&#x27;</span>;<br><br><span class="hljs-keyword">prepare</span> p3 <span class="hljs-keyword">from</span> <br><span class="hljs-string">&#x27;delete from teachers </span><br><span class="hljs-string"> where id = ?&#x27;</span>;<br><br>在执行时预编译时, 代替?的实参必须要用用户变量<br><br><span class="hljs-keyword">set</span> @变量名 = 值, @变量名<span class="hljs-number">2</span> = 值<span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">execute</span> 预编译 <span class="hljs-keyword">using</span> @变量名, @变量名<span class="hljs-number">2</span>;<br><br>? 只能代替值的部分, 表名, 列名绝不可以.<br>下面是错误!!<br><span class="hljs-keyword">prepare</span> p4 <span class="hljs-keyword">from</span> <br><span class="hljs-string">&#x27;insert into teachers(</span><br><span class="hljs-string">?, </span><br><span class="hljs-string">?, </span><br><span class="hljs-string">?</span><br><span class="hljs-string">) values (</span><br><span class="hljs-string">?,</span><br><span class="hljs-string">?,</span><br><span class="hljs-string">?</span><br><span class="hljs-string">)&#x27;</span>;<br><br>在SQL中要想使用&#x27;, 必须再加一个&#x27;, 起到转义的作用<br><span class="hljs-keyword">prepare</span> p2 <span class="hljs-keyword">from</span> <br><span class="hljs-string">&#x27;insert into teachers(</span><br><span class="hljs-string">name, </span><br><span class="hljs-string">age, </span><br><span class="hljs-string">mobile,</span><br><span class="hljs-string">gender</span><br><span class="hljs-string">) values (</span><br><span class="hljs-string">?,</span><br><span class="hljs-string">?,</span><br><span class="hljs-string">?,</span><br><span class="hljs-string">?</span><br><span class="hljs-string">)&#x27;</span>;<br></code></pre></td></tr></table></figure><blockquote><ul><li>有以下六种约束:<blockquote><ul><li>NOT NULL 非空约束，规定某个字段不能为空, 必须列级约束 </li><li>UNIQUE  唯一约束，规定某个字段在整个表中是唯一的</li><li>PRIMARY KEY  主键(非空且唯一)</li><li>FOREIGN KEY  外键</li><li>DEFAULT  默认值, 必须是列级</li><li>check</li></ul></blockquote></li></ul></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs sql"><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">test</span>(<br><span class="hljs-keyword">id</span> <span class="hljs-built_in">int</span> auto_increment,<br><span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>),<br>phone <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>, <span class="hljs-comment">-- 必须列级约束</span><br><span class="hljs-keyword">unique</span>(<span class="hljs-keyword">name</span>), <span class="hljs-comment">-- 可以表级约束</span><br>primary <span class="hljs-keyword">key</span>(<span class="hljs-keyword">id</span>)<br>);<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">test</span>(<br><span class="hljs-keyword">name</span>,<br>phone<br>) <span class="hljs-keyword">values</span> (<br><span class="hljs-string">&#x27;aaa&#x27;</span>,<br><span class="hljs-string">&#x27;234234&#x27;</span><br>);<br><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">test</span> <br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">key</span> <span class="hljs-keyword">name</span>; <span class="hljs-comment">-- 丢弃唯一键约束</span><br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test2(<br><span class="hljs-keyword">id</span> <span class="hljs-built_in">int</span> auto_increment,<br><span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>),<br>phone <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>, <span class="hljs-comment">-- 必须列级约束</span><br><span class="hljs-keyword">constraint</span> myunique <span class="hljs-keyword">unique</span>(<span class="hljs-keyword">name</span>, phone), <span class="hljs-comment">-- 可以表级约束, 联合键</span><br>primary <span class="hljs-keyword">key</span>(<span class="hljs-keyword">id</span>)<br>);<br><br></code></pre></td></tr></table></figure><h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><blockquote><ul><li>外键 : 让一个表中的记录的值要引用到另一张表中的数据…</li><li>一旦有了外键, 子表中插入数据必须要引用到真实的父表中数据</li><li>一旦父表中的记录被子表引用, 当删除父表中的相关记录时, 不允许删除.</li></ul></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql">foreign key(本表的外键列) references 父表(父表主键)<br><br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">exists</span> classes;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> classes(<br><span class="hljs-keyword">id</span> <span class="hljs-built_in">int</span> auto_increment,<br><span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">30</span>),<br>student_count <span class="hljs-built_in">int</span>,<br>room <span class="hljs-built_in">char</span>(<span class="hljs-number">3</span>),<br><span class="hljs-keyword">master</span> <span class="hljs-built_in">int</span>, <br>begindate <span class="hljs-built_in">date</span>,<br>primary <span class="hljs-keyword">key</span>(<span class="hljs-keyword">id</span>),<br><span class="hljs-keyword">foreign</span> <span class="hljs-keyword">key</span>(<span class="hljs-keyword">master</span>) <span class="hljs-keyword">references</span> teachers(<span class="hljs-keyword">id</span>)<br>);<br></code></pre></td></tr></table></figure><blockquote><ul><li>丢弃外键, 必须要知道外键名.</li></ul></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> classes <br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">foreign</span> <span class="hljs-keyword">key</span> classes_ibfk_1;<br></code></pre></td></tr></table></figure><blockquote><ul><li>添加外键</li><li>on delete do nothing, 是默认选项, 在删除父表被引用的记录时不允许</li><li>on delete cascade 级联删除, 当删除父表中的相关记录时, 子表中引用此记录的所有记录也会被删除.</li><li>on delete set null 级联置空.当删除父表中的相关记录时, 子表中引用此记录的所有记录会被置为空.</li></ul></blockquote><h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><blockquote><ul><li>limit n, 把结果集截断成n条记录.</li></ul></blockquote></li></ol><blockquote><ul><li>limit m, n 把结果集中的m条略过, 再截断成n条记录</li><li>limit子句必须放在整个查询语句的最后！</li></ul></blockquote><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><blockquote><ul><li>重点：DML数据操纵语言，主要就是查询</li><li>标准SQL<blockquote><ul><li>select </li><li>from </li><li>left join </li><li>on </li><li>where </li><li>group by </li><li>having </li><li>order by</li></ul></blockquote></li><li>注意点<blockquote><ul><li>注意多表连接的内联，外联 </li><li>函数的使用，where中不能使用</li><li>别名的使用，从group by开始可以使用select中的别名了</li></ul></blockquote></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java8新特性</title>
    <link href="/2021/04/23/java8-new-features/"/>
    <url>/2021/04/23/java8-new-features/</url>
    
    <content type="html"><![CDATA[<h1 id="Java8新特性"><a href="#Java8新特性" class="headerlink" title="Java8新特性"></a>Java8新特性</h1><h2 id="Lambda表达式与函数式接口"><a href="#Lambda表达式与函数式接口" class="headerlink" title="Lambda表达式与函数式接口"></a>Lambda表达式与函数式接口</h2><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><blockquote><ol><li>Consumer<T> 消费器, 作用是消费一个T类型的对象, 并没有返回.</li></ol><ul><li>void accept(T t) : 有输入无输出</li></ul></blockquote><hr><blockquote><ol start="2"><li>Supplier<T> 供给器, 作用是供给一个T类型的对象, 不需要参数.</li></ol><ul><li>T get() : 无输入有输出</li></ul></blockquote><hr><blockquote><ol start="3"><li>Function&lt;T, R&gt; 转换器, 作用是输入一个T类型对象, 经过处理, 返回的是R类型对象.</li></ol><ul><li>R apply(T t) : 有输入有输出</li></ul></blockquote><hr><blockquote><ol start="4"><li>Predicate<T> 判定器, 作用是输入一个T类型对象, 经过某种判断, 返回true或false</li></ol><ul><li>boolean test(T t) : 有输入有固定输出布尔</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> java8;<br><br><span class="hljs-keyword">import</span> java.util.function.Consumer;<br><span class="hljs-keyword">import</span> java.util.function.Function;<br><span class="hljs-keyword">import</span> java.util.function.Predicate;<br><span class="hljs-keyword">import</span> java.util.function.Supplier;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> javabean.Student;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 函数式接口</span><br><span class="hljs-comment"> * 只有一个抽象方法的接口, 可以用<span class="hljs-doctag">@FunctionalInterface</span>修饰</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * Consumer&lt;T&gt; 消费器, 作用是消费一个T类型的对象, 并没有返回.</span><br><span class="hljs-comment"> * void accept(T t) : 有输入无输出</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * Supplier&lt;T&gt; 供给器, 作用是供给一个T类型的对象, 不需要参数.</span><br><span class="hljs-comment"> * T get() : 无输入有输出</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * Function&lt;T, R&gt; 转换器, 作用是输入一个T类型对象, 经过处理, 返回的是R类型对象.</span><br><span class="hljs-comment"> * R apply(T t) : 有输入有输出</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * Predicate&lt;T&gt; 判定器, 作用是输入一个T类型对象, 经过某种判断, 返回true或false</span><br><span class="hljs-comment"> * boolean test(T t) : 有输入有固定输出布尔</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 方法引用 : 接口中的抽象方法的模式(输入和输出) 和 Lambda体中的方法调用是一致时, 就可以简化写法.</span><br><span class="hljs-comment"> * 类或对象 :: 方法名</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FunctionTest</span> </span>&#123;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exer22</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//Supplier&lt;Student&gt; supplier2 = () -&gt; new Student();</span><br>Supplier&lt;Student&gt; supplier2 = Student::<span class="hljs-keyword">new</span>;<br>System.out.println(supplier2.get());<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test42</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//Function&lt;Integer, String&gt; function2 = t -&gt; String.valueOf(t);</span><br>Function&lt;Integer, String&gt; function2 = String::valueOf;<br>System.out.println(function2.apply(<span class="hljs-number">1112</span>));<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test32</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//Supplier&lt;Double&gt; supplier2 = () -&gt; Math.random();</span><br>Supplier&lt;Double&gt; supplier2 = Math::random;<br>System.out.println(supplier2.get());<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test12</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//Consumer&lt;String&gt; consumer2 = t -&gt; System.out.println(t);</span><br>Consumer&lt;String&gt; consumer2 = System.out::println;<br>consumer2.accept(<span class="hljs-string">&quot;lkjxlkcjccc&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 写一个判定器, 判断一个学生是否及格</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exer4</span><span class="hljs-params">()</span> </span>&#123;<br>Predicate&lt;Integer&gt; predicate1 = <span class="hljs-keyword">new</span> Predicate&lt;Integer&gt;() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(Integer t)</span> </span>&#123;<br><span class="hljs-keyword">return</span> t&gt;= <span class="hljs-number">60</span>;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">boolean</span> test = predicate1.test(<span class="hljs-number">100</span>);<br>System.out.println(test);<br><br>Predicate&lt;Integer&gt; predicate2 = t -&gt; t &gt;= <span class="hljs-number">60</span>;<br>System.out.println(predicate2.test(<span class="hljs-number">100</span>));<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span> </span>&#123;<br>Predicate&lt;Integer&gt; predicate1 = <span class="hljs-keyword">new</span> Predicate&lt;Integer&gt;() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(Integer t)</span> </span>&#123;<br><span class="hljs-keyword">return</span> t % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">boolean</span> test = predicate1.test(<span class="hljs-number">83</span>);<br>System.out.println(test);<br><br>Predicate&lt;Integer&gt; predicate2 = t -&gt; t % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<br>System.out.println(predicate2.test(<span class="hljs-number">20</span>));<br>&#125;<br><br><span class="hljs-comment">// 写一个转换器, 把学生对象转换成字符串, 内容是姓名+分数</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exer3</span><span class="hljs-params">()</span> </span>&#123;<br>Function&lt;Student, String&gt; function1 = <span class="hljs-keyword">new</span> Function&lt;Student, String&gt;() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">apply</span><span class="hljs-params">(Student t)</span> </span>&#123;<br><span class="hljs-keyword">return</span> t.getName() + <span class="hljs-string">&quot;:&quot;</span> + t.getScore();<br>&#125;<br>&#125;;<br>String apply = function1.apply(<span class="hljs-keyword">new</span> Student(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;小刚&quot;</span>, <span class="hljs-number">5</span>, <span class="hljs-number">80</span>));<br>System.out.println(apply);<br><br>Function&lt;Student, String&gt; function2 = t -&gt; t.getName() + <span class="hljs-string">&quot;:&quot;</span> + t.getScore();<br>System.out.println(function2.apply(<span class="hljs-keyword">new</span> Student(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;小花&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">100</span>)));<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>&#123;<br>Function&lt;Integer, String&gt; function1 = <span class="hljs-keyword">new</span> Function&lt;Integer, String&gt;() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">apply</span><span class="hljs-params">(Integer t)</span> </span>&#123;<br><span class="hljs-keyword">return</span> String.valueOf(t);<br>&#125;<br>&#125;;<br><br>String apply = function1.apply(<span class="hljs-number">9238</span>);<br>System.out.println(apply);<br><br>Function&lt;Integer, String&gt; function2 = t -&gt; String.valueOf(t);<br>System.out.println(function2.apply(<span class="hljs-number">1112</span>));<br>&#125;<br><br><span class="hljs-comment">// 写一个供给器, 每调用一次供给一个学生对象</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exer2</span><span class="hljs-params">()</span> </span>&#123;<br>Supplier&lt;Student&gt; supplier1 = <span class="hljs-keyword">new</span> Supplier&lt;Student&gt;() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Student();<br>&#125;<br>&#125;;<br>Student student = supplier1.get();<br>System.out.println(student);<br><br>Supplier&lt;Student&gt; supplier2 = () -&gt; <span class="hljs-keyword">new</span> Student();<br>System.out.println(supplier2.get());<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;<br>Supplier&lt;Double&gt; supplier = <span class="hljs-keyword">new</span> Supplier&lt;Double&gt;() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Double <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> Math.random();<br>&#125;<br>&#125;;<br>System.out.println(supplier.get());<br><br>Supplier&lt;Double&gt; supplier2 = () -&gt; Math.random();<br>System.out.println(supplier2.get());<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br>Supplier&lt;Integer&gt; supplier1 = <span class="hljs-keyword">new</span> Supplier&lt;Integer&gt;() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>&#125;<br>&#125;;<br>Integer integer = supplier1.get();<br>System.out.println(integer);<br><br>Supplier&lt;Integer&gt; supplier2 = () -&gt; <span class="hljs-number">100</span>;<br>Integer integer2 = supplier2.get();<br>System.out.println(integer2);<br>&#125;<br><br><span class="hljs-comment">// 写一个消费器, 消费一个Student对象.</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exer1</span><span class="hljs-params">()</span> </span>&#123;<br>Consumer&lt;Student&gt; consumer1 = <span class="hljs-keyword">new</span> Consumer&lt;Student&gt;() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Student t)</span> </span>&#123;<br>System.out.println(t);<br>&#125;<br>&#125;;<br>consumer1.accept(<span class="hljs-keyword">new</span> Student());<br><br>Consumer&lt;Student&gt; consumer2 = t -&gt; System.out.println(t);<br>consumer2.accept(<span class="hljs-keyword">new</span> Student(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;小花&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">50</span>));<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br>Consumer&lt;String&gt; consumer1 = <span class="hljs-keyword">new</span> Consumer&lt;String&gt;() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(String t)</span> </span>&#123;<br>System.out.println(t);<br>&#125;<br>&#125;;<br>consumer1.accept(<span class="hljs-string">&quot;alsdkjfalksdjf&quot;</span>);<br><br>Consumer&lt;String&gt; consumer2 = t -&gt; System.out.println(t);<br>consumer2.accept(<span class="hljs-string">&quot;lkjxlkcjccc&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> java8;<br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.stream.Collectors;<br><span class="hljs-keyword">import</span> java.util.stream.Stream;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> javabean.Student;<br><span class="hljs-keyword">import</span> javabean.StudentTest;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Stream : </span><br><span class="hljs-comment"> * 1) 不保存数据, 只负责处理数据</span><br><span class="hljs-comment"> * 2) 处理数据不会造成原始数据的变化 , 每次处理都会产生新的流</span><br><span class="hljs-comment"> * 3) 所有操作都是延迟执行的, 只有终止操作执行时才执行中间操作</span><br><span class="hljs-comment"> * 4) 每个流只能&quot;消费&quot;一次, 消费过后就作废.</span><br><span class="hljs-comment"> * 5) 单向, 一次性使用, 可以支持高并发...</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 典型的操作 :</span><br><span class="hljs-comment"> * 1) 创建流(获取流) </span><br><span class="hljs-comment"> * 1) 从集合获取流, 集合.stream();</span><br><span class="hljs-comment"> * 2) 从数组获取流, Arrays.stream(Xxx[] arr);</span><br><span class="hljs-comment"> * 3) 基于散数据, Stream.of(T... objs)</span><br><span class="hljs-comment"> * 4) 使用供给器, 无限流</span><br><span class="hljs-comment"> * 2) 中间操作, 多个中间操作就形成流水线, 是延迟执行的, 中间操作可以省略</span><br><span class="hljs-comment"> * ***filter(Predicate p) : 让流中的每个对象都经过判定器, 如果结果为true留下, 如果是false丢弃. 产生新流</span><br><span class="hljs-comment"> * distinct(); 把流中的数据去重并产生新流, 依据对象的hashCode和equals</span><br><span class="hljs-comment"> * limit(long maxSize) 限制流中的最大数据量</span><br><span class="hljs-comment"> * skip(long n) 跳过前n个元素</span><br><span class="hljs-comment"> * ***map(Function f) 让流中的每个对象都转换为新对象, 所以它的结果的流全变了.</span><br><span class="hljs-comment"> * sorted() 把流中的对象排序 , 自然排序</span><br><span class="hljs-comment"> * *sorted(Comparator c) 定制排序</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 3) 终止操作, 一旦中止, 所有的中间操作就开始执行, 终止操作是必须的.</span><br><span class="hljs-comment"> * ***forEach(Consumer c) : 让流中的每个对象都经过消费器消费一下.</span><br><span class="hljs-comment"> * findFirst() 返回流中的第一个对象</span><br><span class="hljs-comment"> * **count() 计数</span><br><span class="hljs-comment"> * **collect(采集器) 可以把结果集采集到一个新的容器中.</span><br><span class="hljs-comment"> * ***reduce(BinaryOperator op) 把流中的对象两两处理最后产生一个结果</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *Optional是一容器, 里面放一个引用, 如果引用为空, 获取时直接抛异常.</span><br><span class="hljs-comment"> *防止空指针.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamTest</span> </span>&#123;<br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exer6</span><span class="hljs-params">()</span> </span>&#123;<br>List&lt;Student&gt; collect = StudentTest.getList()<br>.stream()<br>.distinct()<br>.filter(t -&gt; t.getGrade() == <span class="hljs-number">3</span>)<br>.filter(t -&gt; t.getScore() &lt; <span class="hljs-number">60</span>).sorted((o1, o2) -&gt; -(<span class="hljs-keyword">int</span>)(o1.getScore() - o2.getScore()))<br>.collect(Collectors.toList());<br><span class="hljs-keyword">for</span> (Student student : collect) &#123;<br>System.out.println(student);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 找出全校最高分</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exer5</span><span class="hljs-params">()</span> </span>&#123;<br>Optional&lt;Double&gt; reduce = StudentTest.getList().stream().distinct().map(t -&gt; t.getScore()).reduce((d1, d2) -&gt; d1 &gt; d2 ? d1 : d2);<br>Double orElse = reduce.orElse((<span class="hljs-keyword">double</span>) <span class="hljs-number">999</span>);<br>System.out.println(orElse);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exer4</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">long</span> count = StudentTest.getList().stream().distinct().count();<br>System.out.println(count);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exer3</span><span class="hljs-params">()</span> </span>&#123;<br>Optional&lt;Student&gt; findFirst = StudentTest.getList()<br>.stream()<br>.distinct()<br>.filter(t -&gt; t.getGrade() == <span class="hljs-number">4</span>)<br>.filter(t -&gt; t.getScore() &lt; <span class="hljs-number">60</span>).sorted((o1, o2) -&gt; -(<span class="hljs-keyword">int</span>)(o1.getScore() - o2.getScore()))<br>.limit(<span class="hljs-number">2</span>).findFirst();<br><span class="hljs-comment">//Student student = findFirst.get();</span><br>Student student = findFirst.orElse(<span class="hljs-keyword">new</span> Student()); <span class="hljs-comment">// 最大化减少空指针</span><br>System.out.println(student);<br>&#125;<br><br><span class="hljs-comment">// 3年级没有及格的同学倒序, 取出前2个.</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exer2</span><span class="hljs-params">()</span> </span>&#123;<br>StudentTest.getList()<br>.stream()<br>.distinct()<br>.filter(t -&gt; t.getGrade() == <span class="hljs-number">3</span>)<br>.filter(t -&gt; t.getScore() &lt; <span class="hljs-number">60</span>).sorted((o1, o2) -&gt; -(<span class="hljs-keyword">int</span>)(o1.getScore() - o2.getScore()))<br>.limit(<span class="hljs-number">2</span>).forEach(System.out::println);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test9</span><span class="hljs-params">()</span> </span>&#123;<br>StudentTest.getList().stream().distinct().sorted((t1, t2) -&gt; (<span class="hljs-keyword">int</span>)(t1.getScore() - t2.getScore())).forEach(System.out::println);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test8</span><span class="hljs-params">()</span> </span>&#123;<br>StudentTest.getList().stream().distinct().map(t -&gt; t.getScore()).forEach(System.out::println);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test7</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 第6个到第10个</span><br>StudentTest.getList().stream().distinct().skip(<span class="hljs-number">10</span>).limit(<span class="hljs-number">5</span>).forEach(System.out::println);<br>&#125;<br><br><span class="hljs-comment">// 找出5年级姓张的同学</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exer1</span><span class="hljs-params">()</span> </span>&#123;<br>List&lt;Student&gt; list = StudentTest.getList();<br>list.stream().filter(t -&gt; t.getGrade() == <span class="hljs-number">5</span>).filter(t -&gt; t.getName().startsWith(<span class="hljs-string">&quot;张&quot;</span>)).forEach(System.out::println);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test62</span><span class="hljs-params">()</span> </span>&#123;<br>List&lt;Student&gt; list = StudentTest.getList();<br>list.stream().filter(t -&gt; t.getGrade() == <span class="hljs-number">3</span>).filter(t -&gt; t.getScore() &gt;= <span class="hljs-number">60</span>).forEach(System.out::println);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test6</span><span class="hljs-params">()</span> </span>&#123;<br>List&lt;Student&gt; list = StudentTest.getList();<br>Stream&lt;Student&gt; stream = list.stream();<br>Stream&lt;Student&gt; stream2 = stream.filter(t -&gt; t.getGrade() == <span class="hljs-number">3</span>);<br>Stream&lt;Student&gt; stream3 = stream2.filter(t -&gt; t.getScore() &gt;= <span class="hljs-number">60</span>);<br>stream3.forEach(System.out::println);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span> </span>&#123;<br>Stream.generate(Math::random).limit(<span class="hljs-number">10</span>).forEach(System.out::println);<span class="hljs-comment">// 无限流</span><br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>&#123;<br>Stream&lt;Integer&gt; generate = Stream.generate(() -&gt; <span class="hljs-number">200</span>); <span class="hljs-comment">// 无限流</span><br>generate.forEach(System.out::println);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;<br>Stream&lt;Number&gt; of = Stream.of(<span class="hljs-number">3.22</span>, <span class="hljs-number">9.33</span>, <span class="hljs-number">4.88</span>, <span class="hljs-number">4.2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>of.forEach(System.out::println);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br>String[] arr = &#123;<span class="hljs-string">&quot;kjsf&quot;</span>, <span class="hljs-string">&quot;qqa&quot;</span>, <span class="hljs-string">&quot;cv&quot;</span>, <span class="hljs-string">&quot;XXX&quot;</span>&#125;;<br>Stream&lt;String&gt; stream = Arrays.stream(arr);<br>stream.forEach(System.out::println);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br>List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>list.add((<span class="hljs-keyword">int</span>)(Math.random() * <span class="hljs-number">20</span>));<br>&#125;<br>System.out.println(list);<br><br>Stream&lt;Integer&gt; stream = list.stream();<br>stream.forEach(System.out::println);<br><br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java网络编程基础</title>
    <link href="/2021/04/23/Java-network/"/>
    <url>/2021/04/23/Java-network/</url>
    
    <content type="html"><![CDATA[<h1 id="Java网络编程基础"><a href="#Java网络编程基础" class="headerlink" title="Java网络编程基础"></a>Java网络编程基础</h1><h2 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> network;<br><br><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.BufferedWriter;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.io.InputStreamReader;<br><span class="hljs-keyword">import</span> java.io.OutputStream;<br><span class="hljs-keyword">import</span> java.io.OutputStreamWriter;<br><span class="hljs-keyword">import</span> java.net.ServerSocket;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><span class="hljs-keyword">import</span> java.time.LocalDateTime;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetTest</span> </span>&#123;<br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">server3</span><span class="hljs-params">()</span> </span>&#123;<br>ServerSocket server = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8888</span>); <span class="hljs-comment">// 绑定端口</span><br><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>System.out.println(<span class="hljs-string">&quot;服务器在8888端口监听中.....&quot;</span>);<br><span class="hljs-keyword">final</span> Socket socket1 = server.accept();<br>;<br>Runnable runner = <span class="hljs-keyword">new</span> Runnable() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>BufferedWriter bufferedWriter = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>bufferedWriter = <span class="hljs-keyword">new</span> BufferedWriter(<span class="hljs-keyword">new</span> OutputStreamWriter(socket1.getOutputStream()));<br>bufferedWriter.write(<span class="hljs-string">&quot;我是服务器, 现在时间 : &quot;</span> + LocalDateTime.now());<br>bufferedWriter.newLine();<br>bufferedWriter.flush(); <span class="hljs-comment">// 把数据真的刷入网线中</span><br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (bufferedWriter != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>bufferedWriter.close();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (socket1 != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>socket1.close();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">5000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">new</span> Thread(runner).start();<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><br><span class="hljs-keyword">if</span> (server != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;服务器关闭....&quot;</span>);<br>server.close();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">client3</span><span class="hljs-params">()</span> </span>&#123;<br>Socket socket2 = <span class="hljs-keyword">null</span>;<br>BufferedReader bufferedReader = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>socket2 = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8888</span>);<br>bufferedReader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(socket2.getInputStream()));<br>String readLine = bufferedReader.readLine();<br>System.out.println(readLine);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (bufferedReader != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>bufferedReader.close();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (socket2 != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>socket2.close();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 从客户端发送文件给服务端，服务端保存到本地。并返回“发送成功”给客户端。并关闭相应的连接。</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">server2</span><span class="hljs-params">()</span> </span>&#123;<br>ServerSocket server = <span class="hljs-keyword">null</span>;<br>Socket socket1 = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 网络套接字</span><br><br>InputStream nis = <span class="hljs-keyword">null</span>;<br>FileOutputStream fos = <span class="hljs-keyword">null</span>;<br>BufferedWriter netWriter = <span class="hljs-keyword">null</span>;<br><br><span class="hljs-keyword">try</span> &#123;<br>server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">7777</span>);<span class="hljs-comment">// 指定服务器接口</span><br>socket1 = server.accept();<br>nis = socket1.getInputStream();<br>fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;朴树 - 猎户星座2.mp3&quot;</span>);<br>netWriter = <span class="hljs-keyword">new</span> BufferedWriter(<span class="hljs-keyword">new</span> OutputStreamWriter(socket1.getOutputStream()));<br><br><span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">8192</span>];<br><span class="hljs-keyword">int</span> realCount = nis.read(buf);<br><span class="hljs-keyword">while</span> (realCount != -<span class="hljs-number">1</span>) &#123;<br>fos.write(buf, <span class="hljs-number">0</span>, realCount);<br>realCount = nis.read(buf);<br>&#125;<br>netWriter.write(<span class="hljs-string">&quot;发送成功&quot;</span>);<br>netWriter.newLine();<br>netWriter.flush();<br><br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (netWriter != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>netWriter.close();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (fos != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>fos.close();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (nis != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>nis.close();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (socket1 != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>socket1.close();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (server != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>server.close();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">client2</span><span class="hljs-params">()</span> </span>&#123;<br>Socket socket2 = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 网络套接字</span><br><br>FileInputStream fis = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 文件输入流</span><br>OutputStream nos = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 网络输出流</span><br>BufferedReader netReader = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 网络输入流</span><br><span class="hljs-keyword">try</span> &#123;<br>socket2 = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">7777</span>);<br>fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;src/朴树 - 猎户星座.mp3&quot;</span>);<span class="hljs-comment">// 要传到服务器端的文件，先读入到客户端</span><br>nos = socket2.getOutputStream();<span class="hljs-comment">// 传输到服务器端的文件输出流</span><br>netReader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(socket2.getInputStream()));<span class="hljs-comment">// 读取服务器端返回的数据</span><br><br><span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">8192</span>];<br><span class="hljs-comment">// 读取数据</span><br><span class="hljs-keyword">int</span> realCount = fis.read(buf);<br><span class="hljs-keyword">while</span> (realCount != -<span class="hljs-number">1</span>) &#123;<br><span class="hljs-comment">// 1) 处理已经读的数据</span><br>nos.write(buf, <span class="hljs-number">0</span>, realCount);<br><span class="hljs-comment">// 2) 继续读</span><br>realCount = fis.read(buf);<br>&#125;<br>nos.flush();<span class="hljs-comment">// 将在缓存中的数据全部输出去</span><br>socket2.shutdownOutput();<span class="hljs-comment">// 关闭输出流</span><br><br>String readLine = netReader.readLine();<span class="hljs-comment">// 接受服务器端的数据</span><br>System.out.println(readLine);<br><br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<span class="hljs-comment">// 关闭相应的资源</span><br><span class="hljs-keyword">if</span> (netReader != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>netReader.close();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (nos != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>nos.close();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (fis != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>fis.close();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (socket2 != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>socket2.close();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">server</span><span class="hljs-params">()</span> </span>&#123;<br>ServerSocket server = <span class="hljs-keyword">null</span>;<br>Socket socket1 = <span class="hljs-keyword">null</span>;<br>BufferedReader bufferedReader = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">9999</span>); <span class="hljs-comment">// 绑定9999端口.</span><br>socket1 = server.accept(); <span class="hljs-comment">// 接受客户端的连接请求, 此方法会引起阻塞.</span><br>System.out.println(socket1);<br><span class="hljs-comment">// 服务器端的socket1和客户端的socket2就建立了双向的网络通道</span><br>InputStream inputStream = socket1.getInputStream();<br>InputStreamReader isr = <span class="hljs-keyword">new</span> InputStreamReader(inputStream);<br><br>bufferedReader = <span class="hljs-keyword">new</span> BufferedReader(isr);<br>String readLine = bufferedReader.readLine();<br>System.out.println(readLine);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (bufferedReader != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>bufferedReader.close();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (socket1 != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>socket1.close();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (server != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>server.close();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>&#125;<br><br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">client</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 连接服务器, 必须知道ip和端口.</span><br>Socket socket2 = <span class="hljs-keyword">null</span>;<br>BufferedWriter bufferedWriter = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>socket2 = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">9999</span>);<br>System.out.println(socket2);<br><span class="hljs-comment">// 客户端的socket2和服务器端的socket1就建立了双向的网络通道</span><br>OutputStream outputStream = socket2.getOutputStream();<br>OutputStreamWriter osw = <span class="hljs-keyword">new</span> OutputStreamWriter(outputStream);<br>bufferedWriter = <span class="hljs-keyword">new</span> BufferedWriter(osw);<br>bufferedWriter.write(<span class="hljs-string">&quot;你好, 服务器, 俺是客户端.....&quot;</span>);<br>bufferedWriter.newLine();<span class="hljs-comment">// 必须要有换行</span><br>bufferedWriter.flush();<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (bufferedWriter != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>bufferedWriter.close();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (socket2 != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>socket2.close();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="杀死本机被占用的端口号"><a href="#杀死本机被占用的端口号" class="headerlink" title="杀死本机被占用的端口号"></a>杀死本机被占用的端口号</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">netstat</span> -ano   查看操作系统所有占用端口的进程<br><span class="hljs-attribute">netstat</span> -ano | findstr <span class="hljs-string">&quot;9999&quot;</span> 获取占用了<span class="hljs-number">9999</span>端口的进程<br><span class="hljs-attribute">taskkill</span> /F /pid <span class="hljs-number">1234</span> 关闭进程号为<span class="hljs-number">1234</span>的进程<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java反射</title>
    <link href="/2021/04/22/Java-reflect/"/>
    <url>/2021/04/22/Java-reflect/</url>
    
    <content type="html"><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="单元测试类"><a href="#单元测试类" class="headerlink" title="单元测试类"></a>单元测试类</h2><blockquote><ul><li>单元测试方法的要求：类必须是公共的，必需不能有任何构造器</li><li>方法必修是公共非静态无返回值参数</li><li>执行：在方法名中右击，点击run as -junit</li><li>包装类：把基本数据类型包装成对象</li></ul></blockquote><h2 id="反射概述"><a href="#反射概述" class="headerlink" title="反射概述"></a>反射概述</h2><ul><li><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p><p>要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象.</p></li><li><p>反射就是把Java类中的各种成分映射成一个个的Java对象</p><p>例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象。</p><p>   （其实：一个类中这些成员方法、构造方法、在加入类中都有一个类来描述）</p></li><li><p>参考链接：CSDN博客 <a href="https://blog.csdn.net/qq_36226453/article/details/82790375">链接</a></p></li></ul><h2 id="反射基础实例代码"><a href="#反射基础实例代码" class="headerlink" title="反射基础实例代码"></a>反射基础实例代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> reflect;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.junit.Assert.*;<br><br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.io.Serializable;<br><span class="hljs-keyword">import</span> java.lang.annotation.Annotation;<br><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map.Entry;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 反射 : java的动态处理技术</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(&#123;ElementType.TYPE, ElementType.FIELD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@interface</span> HelloAnnotation &#123;<br><span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;缺省名字&quot;</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">id</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 10</span>;<br>&#125;<br><br><span class="hljs-meta">@HelloAnnotation(name=&quot;abc&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ArrayList</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span>, <span class="hljs-title">Comparable</span>, <span class="hljs-title">Runnable</span> </span>&#123;<br><br><span class="hljs-meta">@HelloAnnotation</span><br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><span class="hljs-keyword">private</span> String gender;<br><br><span class="hljs-comment">//@HelloAnnotation</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Teacher</span><span class="hljs-params">()</span> </span>&#123;<br>&#125;<br><span class="hljs-comment">//构造方法，Ctrl+Alt+S+O</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Teacher</span><span class="hljs-params">(String name)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.name = name;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Teacher</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.age = age;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Teacher</span><span class="hljs-params">(String name,String gender)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.name = name;<br><span class="hljs-keyword">this</span>.gender = gender;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Teacher</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, String gender)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.name = name;<br><span class="hljs-keyword">this</span>.age = age;<br><span class="hljs-keyword">this</span>.gender = gender;<br>&#125;<br>    <span class="hljs-comment">//set,get方法 快捷键Ctrl+Alt+S+R</span><br><span class="hljs-comment">//@HelloAnnotation</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> name;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.name = name;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> age;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.age = age;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getGender</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> gender;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setGender</span><span class="hljs-params">(String gender)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.gender = gender;<br>&#125;<br>    <span class="hljs-comment">//Ctrl+Alt+S+S</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Teacher [name=&quot;</span> + name + <span class="hljs-string">&quot;, age=&quot;</span> + age + <span class="hljs-string">&quot;, gender=&quot;</span> + gender + <span class="hljs-string">&quot;]&quot;</span>;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Object o)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lesson</span><span class="hljs-params">(String content, <span class="hljs-keyword">int</span> time)</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;老师在上[&quot;</span> + content + <span class="hljs-string">&quot;]课, 共上了[&quot;</span> + time +<span class="hljs-string">&quot;]小时&quot;</span>);<br><span class="hljs-comment">//return true;</span><br><span class="hljs-comment">//throw new RuntimeException(&quot;一个异常&quot;);</span><br>&#125;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReflectTest</span> </span>&#123;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testName</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>Class clazz = Class.forName(<span class="hljs-string">&quot;reflect.Teacher&quot;</span>);<br>Annotation[] annotations = clazz.getAnnotations();<br>System.out.println(annotations.length);<br>System.out.println(annotations[<span class="hljs-number">0</span>]);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test14</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>Class clazz = Class.forName(<span class="hljs-string">&quot;reflect.Teacher&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;父类 : &quot;</span> + clazz.getSuperclass());<br>Constructor[] constructors = clazz.getConstructors();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; constructors.length; i++) &#123;<br>System.out.println(<span class="hljs-string">&quot;构造器 : &quot;</span> + constructors[i]);<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;************************************************&quot;</span>);<br>Field[] fields = clazz.getFields(); <span class="hljs-comment">// 所有公共属性</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; fields.length; i++) &#123;<br>System.out.println(<span class="hljs-string">&quot;公共属性：&quot;</span>+fields[i]);<br>&#125;<br><span class="hljs-comment">//反射尽量不要破坏封装性，容易发生严重后果，慎用getDeclared.....()方法</span><br>Field[] declaredFields = clazz.getDeclaredFields(); <span class="hljs-comment">// 所有本类属性</span><br><span class="hljs-keyword">for</span> (Field field : declaredFields) &#123;<br>System.out.println(<span class="hljs-string">&quot;本类属性：&quot;</span>+field);<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;************************************************&quot;</span>);<br>Method[] methods = clazz.getMethods();<span class="hljs-comment">//所有公共方法</span><br><span class="hljs-keyword">for</span> (Method method : methods) &#123;<br>System.out.println(<span class="hljs-string">&quot;公共方法&quot;</span>+method);<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;************************************************&quot;</span>);<br>Method[] declaredMethods = clazz.getDeclaredMethods();<span class="hljs-comment">//所有本类方法</span><br><span class="hljs-keyword">for</span> (Method method : declaredMethods) &#123;<br>System.out.println(<span class="hljs-string">&quot;本类方法：&quot;</span>+method);<br>&#125;<br>&#125;<br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test13</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br>Class clazz = Class.forName(<span class="hljs-string">&quot;reflect.Teacher&quot;</span>);<br>Method lessonMethod = clazz.getDeclaredMethod(<span class="hljs-string">&quot;lesson&quot;</span>, String.class, <span class="hljs-keyword">int</span>.class);<br>lessonMethod.setAccessible(<span class="hljs-keyword">true</span>);<br><br>Short n = <span class="hljs-number">3</span>;<br>Object retValue = lessonMethod.invoke(<span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;JavaWEB&quot;</span>, n); <span class="hljs-comment">// 静态方法传null, 不需要传入对象</span><br>System.out.println(retValue);<br>&#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (SecurityException e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (IllegalArgumentException e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test12</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br>Class clazz = Class.forName(<span class="hljs-string">&quot;reflect.Teacher&quot;</span>);<br>Constructor constructor = clazz.getConstructor(String.class, <span class="hljs-keyword">int</span>.class, String.class);<br>Object object = constructor.newInstance(<span class="hljs-string">&quot;佟刚&quot;</span>, <span class="hljs-number">40</span>, <span class="hljs-string">&quot;男&quot;</span>);<br><br><span class="hljs-comment">// getMethod只能获取公共的方法, 包括从父类继承的. </span><br><span class="hljs-comment">//Method lessonMethod = clazz.getMethod(&quot;lesson&quot;, String.class, int.class); </span><br><br><span class="hljs-comment">// getDeclaredMethod可以获取本类中所有声明的方法</span><br>Method lessonMethod = clazz.getDeclaredMethod(<span class="hljs-string">&quot;lesson&quot;</span>, String.class, <span class="hljs-keyword">int</span>.class);<br>lessonMethod.setAccessible(<span class="hljs-keyword">true</span>);<br><br>Short n = <span class="hljs-number">3</span>;<br>Object retValue = lessonMethod.invoke(object, <span class="hljs-string">&quot;JavaWEB&quot;</span>, n); <br>System.out.println(retValue);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    private String outOfBoundsMsg(int index) &#123;</span><br><span class="hljs-comment">        return &quot;Index: &quot;+index+&quot;, Size: &quot;+size;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    */</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">//拿父类的方法，会有警告，最好不要暴力访问私有方法，属性</span><br><span class="hljs-comment">Method declaredMethod = clazz.getSuperclass().getDeclaredMethod(&quot;outOfBoundsMsg&quot;, int.class);</span><br><span class="hljs-comment">System.out.println(declaredMethod);</span><br><span class="hljs-comment">//危险操作</span><br><span class="hljs-comment">declaredMethod.setAccessible(true);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Object invoke = declaredMethod.invoke(object, 20);</span><br><span class="hljs-comment">System.out.println(invoke);</span><br><span class="hljs-comment">*/</span><br>&#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123; <span class="hljs-comment">// 类未找到</span><br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123; <span class="hljs-comment">// 方法没有找到, 方法名错误或参数列表错误</span><br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (SecurityException e) &#123; <span class="hljs-comment">// 安全异常</span><br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (InstantiationException e) &#123; <span class="hljs-comment">// 创建对象时出现异常</span><br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123; <span class="hljs-comment">// 非法访问异常</span><br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (IllegalArgumentException e) &#123; <span class="hljs-comment">// 非法实参异常, 实参和形参不匹配, 类型和顺序和数量</span><br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123; <span class="hljs-comment">// 调用的目标方法内部出现异常了.</span><br>e.printStackTrace();<br>&#125;<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test11</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br>Class clazz = Class.forName(<span class="hljs-string">&quot;reflect.Teacher&quot;</span>);<br>Constructor constructor = clazz.getConstructor(String.class, <span class="hljs-keyword">int</span>.class, String.class);<br>Object object = constructor.newInstance(<span class="hljs-string">&quot;佟刚&quot;</span>, <span class="hljs-number">40</span>, <span class="hljs-string">&quot;男&quot;</span>);<br><br><span class="hljs-comment">//object.lesson(&quot;JavaWEB&quot;, 3);</span><br><span class="hljs-comment">//先获取方法</span><br><br>Method lessonMethod = clazz.getMethod(<span class="hljs-string">&quot;lesson&quot;</span>, String.class, <span class="hljs-keyword">int</span>.class); <span class="hljs-comment">// 后面是方法参数类型列表</span><br><span class="hljs-keyword">short</span> n = <span class="hljs-number">3</span>;<br>Object retValue = lessonMethod.invoke(object, <span class="hljs-string">&quot;JavaWEB&quot;</span>, n); <span class="hljs-comment">// 后面是实参列表, 如果方法没有返回值, 它的返回值是null</span><br>System.out.println(retValue);<br>&#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123; <span class="hljs-comment">// 类未找到</span><br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123; <span class="hljs-comment">// 方法没有找到, 方法名错误或参数列表错误</span><br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (SecurityException e) &#123; <span class="hljs-comment">// 安全异常</span><br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (InstantiationException e) &#123; <span class="hljs-comment">// 创建对象时出现异常</span><br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123; <span class="hljs-comment">// 非法访问异常</span><br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (IllegalArgumentException e) &#123; <span class="hljs-comment">// 非法实参异常, 实参和形参不匹配, 类型和顺序和数量</span><br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123; <span class="hljs-comment">// 调用的目标方法内部出现异常了.</span><br>e.printStackTrace();<br>&#125;<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test10</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br>Class clazz = Class.forName(<span class="hljs-string">&quot;reflect.Teacher&quot;</span>);<br><span class="hljs-comment">//Object object = clazz.newInstance(); 没有无参构造器时出问题</span><br><br><span class="hljs-comment">//public Teacher(String name, int age, String gender) 要想定位这个构造器, 必须让参数列表一致.</span><br><br><span class="hljs-comment">// 提供形式参数类型列表, 是类模板对象的列表</span><br>Constructor constructor = clazz.getConstructor(String.class, <span class="hljs-keyword">int</span>.class, String.class); <span class="hljs-comment">// 定位合适的构造器</span><br><span class="hljs-comment">// 调用时必须给定实参列表</span><br>Object object = constructor.newInstance(<span class="hljs-string">&quot;程程&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&quot;女&quot;</span>); <span class="hljs-comment">// new Teacher(&quot;程程&quot;, 20, &quot;女&quot;);</span><br>System.out.println(object);<br><br>&#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (InstantiationException e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123; <span class="hljs-comment">// 参数列表出错, 或者方法名出错</span><br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (SecurityException e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (IllegalArgumentException e) &#123; <span class="hljs-comment">// 方法调用时实参和形参不匹配</span><br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test9</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException  </span>&#123;<br><span class="hljs-comment">//FileInputStream fis = new FileInputStream(&quot;只能读当前目录下的文件&quot;);</span><br>ClassLoader classLoader = <span class="hljs-keyword">this</span>.getClass().getClassLoader();<br><span class="hljs-comment">// 只能加载build-path和src下的文件</span><br><span class="hljs-comment">//InputStream inputStream = classLoader.getResourceAsStream(&quot;com/sun/corba/se/impl/logging/LogStrings.properties&quot;); // 读取资源文件, 只要是Build-Path(classpath)中的文件都可以</span><br>InputStream inputStream = classLoader.getResourceAsStream(<span class="hljs-string">&quot;s2&quot;</span>);<br>Properties properties = <span class="hljs-keyword">new</span> Properties();<br>properties.load(inputStream);<br><br>Set&lt;Entry&lt;Object, Object&gt;&gt; entrySet = properties.entrySet();<br><span class="hljs-keyword">for</span> (Entry&lt;Object, Object&gt; entry : entrySet) &#123;<br>System.out.println(entry);<br>&#125;<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test8</span><span class="hljs-params">()</span>  </span>&#123;<br>ClassLoader classLoader1 = ClassLoader.getSystemClassLoader(); <span class="hljs-comment">// 获取系统类加载器</span><br>System.out.println(classLoader1);<br>ClassLoader classLoader2 = <span class="hljs-keyword">this</span>.getClass().getClassLoader(); <span class="hljs-comment">// 使用最多的, 获取当前类的类加载器</span><br>System.out.println(classLoader2);<br><br>ClassLoader classLoader3 = classLoader1.getParent(); <span class="hljs-comment">// 获取父 &quot;类加载器&quot;,  是 扩展 &quot;类加载器&quot;</span><br>System.out.println(classLoader3);<br><br>ClassLoader classLoader4 = classLoader3.getParent(); <span class="hljs-comment">// 获取到的是引导类加载器(Bootstrap )</span><br>System.out.println(classLoader4); <span class="hljs-comment">// 这个类加载器无法获取, 无法使用</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">双亲委派机制</span><br><span class="hljs-comment">用户类加载器加载类时, 必须把此加载请求转发给父类加载器, 父类加载器再继续向父类加载器委派, 直到Bootstrap类加载器</span><br><span class="hljs-comment">从Bootstrap类加载器开始真正加载, 各司其职. </span><br><span class="hljs-comment">*/</span><br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test7</span><span class="hljs-params">()</span>  </span>&#123;<br>Class strClazz = String.class;<br>System.out.println(strClazz);<br><br><span class="hljs-comment">// 基本数据类型的类模板只能用第一种方式获取.</span><br>Class clazz1 = <span class="hljs-keyword">int</span>.class; <span class="hljs-comment">// 基本数据类型也有相应的类模板对象, 但是不能获取属性和方法, 只能作为一个标记来使用.</span><br>Class clazz2 = Integer.class; <span class="hljs-comment">// 这是一个普通类模板.</span><br>System.out.println(clazz1 == clazz2);<br><br><span class="hljs-comment">// 判断类模板类型</span><br>System.out.println(<span class="hljs-string">&quot;是否是基本型 : &quot;</span> + clazz1.isPrimitive());<br>System.out.println(<span class="hljs-string">&quot;是否是基本型 : &quot;</span> + clazz2.isPrimitive());<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test6</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br><span class="hljs-comment">// 获取类模板对象的方法 ，有４种</span><br><span class="hljs-comment">// 1) 直接通过类.class, 效率最高, 最安全.</span><br>Class clazz1 = Teacher.class;<br><br><span class="hljs-comment">// 2) 根据对象, 调用它的getClass()方法获取, 此方法也很常用.</span><br>Teacher teacher = <span class="hljs-keyword">new</span> Teacher(<span class="hljs-string">&quot;佟刚&quot;</span>, <span class="hljs-number">40</span>, <span class="hljs-string">&quot;男&quot;</span>);<br>Class clazz2 = teacher.getClass();<br><br>System.out.println(clazz1 == clazz2);<br><br><span class="hljs-comment">// 3) 反射中最常用的 Class.forName(&quot;全限定类名&quot;);</span><br>Class clazz3 = Class.forName(<span class="hljs-string">&quot;reflect.Teacher&quot;</span>);<br>System.out.println(clazz2 == clazz3);<br><br><span class="hljs-comment">// 4) 通过类加载器对象动态加载类</span><br>ClassLoader classLoader = <span class="hljs-keyword">this</span>.getClass().getClassLoader();<br>Class clazz4 = classLoader.loadClass(<span class="hljs-string">&quot;reflect.Teacher&quot;</span>);<br>System.out.println(clazz3 == clazz4);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>Class clazz = Class.forName(<span class="hljs-string">&quot;reflect.Teacher&quot;</span>);<br>String name = clazz.getName();<br>System.out.println(<span class="hljs-string">&quot;类名 : &quot;</span> + name);<br>System.out.println(<span class="hljs-string">&quot;简单类名 :  &quot;</span> + clazz.getSimpleName());<br>Class superclass = clazz.getSuperclass();<br>System.out.println(<span class="hljs-string">&quot;父类 : &quot;</span> + superclass);<br>Class[] interfaces = clazz.getInterfaces();<br>System.out.println(<span class="hljs-string">&quot;接口列表 &quot;</span>);<br><span class="hljs-keyword">for</span> (Class class1 : interfaces) &#123;<br>System.out.println(class1);<br>&#125;<br><br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br>Class clazz = Class.forName(<span class="hljs-string">&quot;reflect.Teacher&quot;</span>);<br>Object object = clazz.newInstance();<br>System.out.println(object);<br><br><span class="hljs-comment">//Field ageField = clazz.getField(&quot;age&quot;); // getField方法只能获取公共的属性, 也包括从父类继承的属性, 不可以获取私有属性</span><br>Field ageField = clazz.getDeclaredField(<span class="hljs-string">&quot;age&quot;</span>); <span class="hljs-comment">// 获取本类中声明的任意属性 </span><br><span class="hljs-comment">// 暴力反射!!! 不推荐使用!!</span><br>ageField.setAccessible(<span class="hljs-keyword">true</span>); <span class="hljs-comment">// 设置此属性为可访问的.</span><br>ageField.set(object, <span class="hljs-number">40</span>); <br>System.out.println(ageField.get(object)); <br><br>Field nameField = clazz.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>nameField.setAccessible(<span class="hljs-keyword">true</span>);<br>nameField.set(object, <span class="hljs-string">&quot;佟刚&quot;</span>);<br><br>System.out.println(object);<br>&#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (InstantiationException e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123; <span class="hljs-comment">// 查找属性时, 有可能属性名不对, 可能是属性不存在</span><br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (SecurityException e) &#123; <span class="hljs-comment">// 如果有安全检查.</span><br>e.printStackTrace();<br>&#125;<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br>Class clazz = Class.forName(<span class="hljs-string">&quot;reflect.Teacher&quot;</span>);<br>Object object = clazz.newInstance();<br>System.out.println(object);<br><br><span class="hljs-comment">// 要想使用属性, 1)先获取属性定义对象 2) 配合目标this对象完成对象属性的间接访问.</span><br>Field ageField = clazz.getField(<span class="hljs-string">&quot;age&quot;</span>); <span class="hljs-comment">// 根据属性名获取属性的定义对象</span><br>ageField.set(object, <span class="hljs-number">40</span>); <span class="hljs-comment">// 设置属性值, 相当于 object.age = 40; </span><br>System.out.println(ageField.get(object)); <span class="hljs-comment">// 获取属性值,  相当于 System.out.println(object.age)</span><br><br>Field nameField = clazz.getField(<span class="hljs-string">&quot;name&quot;</span>);<br>nameField.set(object, <span class="hljs-string">&quot;佟刚&quot;</span>); <span class="hljs-comment">// object.name = &quot;佟刚&quot;</span><br><br>Field genderField = clazz.getField(<span class="hljs-string">&quot;gender&quot;</span>);<br>genderField.set(object, <span class="hljs-string">&quot;男&quot;</span>);<br><br>System.out.println(object);<br>&#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (InstantiationException e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123; <span class="hljs-comment">// 查找属性时, 有可能属性名不对, 可能是属性不存在</span><br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (SecurityException e) &#123; <span class="hljs-comment">// 如果有安全检查.</span><br>e.printStackTrace();<br>&#125;<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 软编码, 灵活, 把问题延迟到运行时.</span><br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 干预类的加载, 直接获取类模板对象.</span><br>Class clazz = Class.forName(<span class="hljs-string">&quot;reflect.Teacher&quot;</span>); <span class="hljs-comment">// 类名必须全限定!!!</span><br><span class="hljs-comment">// 通过类模板对象.newInstance创建实体对象</span><br>Object object = clazz.newInstance(); <span class="hljs-comment">// 调用无参构造器创建对象</span><br>System.out.println(object);<br>&#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123; <span class="hljs-comment">// 在运行时动态加载类时, 发现没有找到类</span><br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (InstantiationException e) &#123; <span class="hljs-comment">// 在创建对象时出现异常, 可能是构造器不存在</span><br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123; <span class="hljs-comment">// 非法访问, 访问权限不够时出现</span><br>e.printStackTrace();<br>&#125;<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 编译时必须依赖类, 硬编码</span><br><br><span class="hljs-comment">//Teacher t1 = new Teacher(); // 强烈依赖类</span><br><span class="hljs-comment">//t1.name = &quot;佟刚&quot;;</span><br><span class="hljs-comment">//t1.age = 40;</span><br><span class="hljs-comment">//t1.gender = &quot;男&quot;;</span><br><br><span class="hljs-comment">//System.out.println(t1.name);</span><br><span class="hljs-comment">//System.out.println(t1.age);</span><br><span class="hljs-comment">//System.out.println(t1.gender);</span><br><br><span class="hljs-comment">//System.out.println(t1);</span><br><br>Teacher t2 = <span class="hljs-keyword">new</span> Teacher(<span class="hljs-string">&quot;程程&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&quot;女&quot;</span>);<br>System.out.println(t2);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test0</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 测试方法所在的线程永远是守护线程</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">// 守护线程, setDaemon(true); 此方法必须在start()以前调用.</span><br><span class="hljs-comment">// 主线程永远是用户线程</span><br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>反射</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程基础</title>
    <link href="/2021/04/20/multithreading/"/>
    <url>/2021/04/20/multithreading/</url>
    
    <content type="html"><![CDATA[<h1 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h1><h2 id="1-程序，进程，线程"><a href="#1-程序，进程，线程" class="headerlink" title="1.程序，进程，线程"></a>1.程序，进程，线程</h2><blockquote><ul><li>程序：（可以执行的静态代码，是保存在硬盘上的一个文件）是为完成特定任务，用某种语言编写的一组指令的集合。即<em><strong>一段静态的代码</strong></em>，静态对象.</li><li>进程：（正在执行中的一个程序，在内存中处于激活状态，有生命周期）是程序的一次执行过程，或是<em><strong>正在运行的一个程序</strong></em>。动态过程：有它自身的产生、存在和消亡的过程</li><li>线程：（进程中的子任务）进程可以进一步细化为线程，是一个程序内部的一条执行路径</li></ul></blockquote><h2 id="2-Java中多线程的创建和使用"><a href="#2-Java中多线程的创建和使用" class="headerlink" title="2.Java中多线程的创建和使用"></a>2.Java中多线程的创建和使用</h2><blockquote><ul><li>实现Runnable接口与继承Thread类</li><li><h3 id="Thread类的主要方法"><a href="#Thread类的主要方法" class="headerlink" title="Thread类的主要方法"></a>Thread类的主要方法</h3><blockquote><ul><li>每个线程都是通过某个特定Thread对象的run()方法来完成操作的，经常把run()方法的主题称为线程体</li><li>通过该Thread对象的start()方法来调用这个线程</li><li>static Thread currentThread(),返回当前方法正在执行此方法所压入的栈的线程对象</li><li>void join()它的作用是调用此方法的另一个线程阻塞，当前线程执行完再执行另一个线程</li><li>static void sleep(long millis)作用是让当前线程（正在执行此方法的栈的线程）进入睡眠状态<blockquote><ul><li>两种方式结束sleep状态：1.时间到了。2.被其他进程打断 interrupt() 方法</li></ul></blockquote></li></ul></blockquote></li></ul></blockquote><h3 id="创建并启动线程的方式"><a href="#创建并启动线程的方式" class="headerlink" title="创建并启动线程的方式"></a>创建并启动线程的方式</h3><h4 id="实现Runnable的方式"><a href="#实现Runnable的方式" class="headerlink" title="实现Runnable的方式"></a>实现Runnable的方式</h4><blockquote><blockquote><ol><li>写一个具体类，实现Runnable接口，并实现接口中的抽象方法run(),这个run方法就是线程体</li><li>创建这个具体类对象，并把这个对象作为实参，创建Thread线程对象</li><li>调用Thread线程对象的start方法</li></ol><ul><li>代码示例</li></ul></blockquote></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> multi_thread;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">200</span>;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(cnt);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-string">&quot;&quot;</span>) &#123;<span class="hljs-comment">// ()中是一个锁对象，任意对象都可以做锁，称为互斥锁，作用是只允许一个线程进入执行，其他线程等待</span><br><br>cnt -= <span class="hljs-number">2</span>;<br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">10</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br><span class="hljs-comment">// TODO Auto-generated catch block</span><br>e.printStackTrace();<br>&#125;<br>System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;: &quot;</span> + cnt);<br>&#125;<br>&#125;<br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> multi_thread;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CounterTest</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Runnable counter = <span class="hljs-keyword">new</span> Counter();<br>Thread thread1 = <span class="hljs-keyword">new</span> Thread(counter);<br>Thread thread2 = <span class="hljs-keyword">new</span> Thread(counter);<br>thread1.start();<br>thread2.start();<br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="继承Thread的方式"><a href="#继承Thread的方式" class="headerlink" title="继承Thread的方式"></a>继承Thread的方式</h4><blockquote><blockquote><ol><li>写一个类，继承Thread,并重写run方法，此方法就是线程体</li><li>创建这个类的对象，相当于创建了线程对象</li><li>调用这个线程对象的start方法</li></ol><ul><li>代码示例</li></ul></blockquote></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> multi_thread;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++) &#123;<br>System.out.println(currentThread().getName()+<span class="hljs-string">&quot; &quot;</span>+i);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTest2</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Thread myThread1 = <span class="hljs-keyword">new</span> MyThread();<br>myThread1.start();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++) &#123;<br>System.out.println(<span class="hljs-string">&quot;-----main &quot;</span>+i);<br>&#125;<br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="使用callable接口创建多线程"><a href="#使用callable接口创建多线程" class="headerlink" title="使用callable接口创建多线程"></a>使用callable接口创建多线程</h4><blockquote><ul><li>落地方法call()</li><li>Callable接口作为JDK1.5新增的接口，与使用Runnable相比其功能更强大些。</li><li>相比run()方法，可以有返回值</li><li>方法可以抛出异常</li><li>支持泛型的返回值</li><li>需要借助FutureTask类，比如获取返回结果。</li><li>Callable接口一般用于配合ExecutorService使用</li></ul></blockquote><h5 id="Feture接口"><a href="#Feture接口" class="headerlink" title="Feture接口"></a>Feture接口</h5><blockquote><ul><li>可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等。</li><li>FutrueTask是Futrue接口的实现类</li><li>FutureTask 同时实现了Runnable, Future接口。它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。</li><li>多个线程同时执行一个FutureTask，只要一个线程执行完毕，其他线程不会再执行其call()方法。</li><li>get()方法会阻塞当前线程！<br>实例代码:</li></ul></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> MyThread implements Callable&lt;<span class="hljs-type">Integer</span>&gt; &#123;<br>@Override<br><span class="hljs-built_in">public</span> <span class="hljs-type">Integer</span> <span class="hljs-keyword">call</span>() throws <span class="hljs-keyword">Exception</span> &#123;<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(Thread.currentThread().getName()+&quot; Come in call&quot;);<br>//睡<span class="hljs-number">5</span>秒<br>TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);<br>//返回<span class="hljs-number">200</span>的状态码<br><span class="hljs-keyword">return</span> <span class="hljs-number">200</span>;<br><br>&#125;<br>&#125;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> CallableTest &#123;<br><span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) throws InterruptedException, ExecutionException &#123;<br>MyThread myThread = <span class="hljs-built_in">new</span> MyThread();<br>FutureTask&lt;<span class="hljs-type">Integer</span>&gt; futureTask = <span class="hljs-built_in">new</span> FutureTask&lt;&gt;(myThread);<br><span class="hljs-built_in">new</span> Thread(futureTask, &quot;未来任务&quot;).<span class="hljs-keyword">start</span>();<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;主线程结束！&quot;);<br><span class="hljs-type">Integer</span> <span class="hljs-type">integer</span> = futureTask.<span class="hljs-keyword">get</span>();<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-type">integer</span>);<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="线程池创建多线程"><a href="#线程池创建多线程" class="headerlink" title="线程池创建多线程"></a>线程池创建多线程</h4><blockquote><ul><li>线程池：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。因此提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。</li><li>优点<blockquote><ol><li>提高响应速度（减少了创建新线程的时间）</li><li>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</li><li>便于线程管理    </li></ol></blockquote></li><li>ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor。</li><li>void execute(Runnable command) ：执行任务/命令，没有返回值，一般用来执行Runnable</li><li><T> Future<T> submit(Callable<T> task)：执行任务，有返回值，一般用来执行Callable</li><li>void shutdown() ：关闭连接池</li><li>创建线程池的方式：<blockquote><ol><li>直接通过ThreadPoolExecutor实现类new</li><li>通过工厂类Executors的静态方法创建，本质上也是通过1)创建的线程池</li></ol></blockquote></li></ul></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br><span class="hljs-comment">//创建一个包含10个线程的线程池</span><br>ExecutorService executorService = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Executors</span>.</span></span><span class="hljs-keyword">new</span><span class="hljs-constructor">FixedThreadPool(10)</span>;<br><span class="hljs-comment">//ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">12</span>; i++) &#123;<br>executorService.execute(<span class="hljs-literal">()</span>-&gt;&#123;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>);<br>&#125;);<br>&#125;<br>executorService.shutdown<span class="hljs-literal">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-线程的同步"><a href="#3-线程的同步" class="headerlink" title="3.线程的同步"></a>3.线程的同步</h2><blockquote><ul><li>synchronized (lock){}</li><li>()中是一个锁对象，任意对象都可以做锁，称为互斥锁，作用是只允许一个线程进入执行，其他线程等待</li><li>具有原子性，不可分割</li><li>synchronized()可重入锁（同一个线程可以无限次获取同一个锁）</li><li>避免死锁：不要嵌套synchronized，即使有嵌套，锁对象尽量少</li></ul></blockquote><h3 id="synchronized和Lock的区别"><a href="#synchronized和Lock的区别" class="headerlink" title="synchronized和Lock的区别"></a>synchronized和Lock的区别</h3><blockquote><ul><li>synchronized不需要手动上锁和解锁，lock需要手动上锁和解锁</li><li>synchronized能实现的功能lock都可以实现，且lock更加强大</li></ul></blockquote><h2 id="JUC工具类"><a href="#JUC工具类" class="headerlink" title="JUC工具类"></a>JUC工具类</h2><h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">package com.atguigu.juc;<br><br>import java.util.concurrent.ExecutorService;<br>import java.util.concurrent.Executors;<br>import java.util.concurrent.locks.ReadWriteLock;<br>import java.util.concurrent.locks.ReentrantReadWriteLock;<br><br><span class="hljs-keyword">class</span> MyQueue &#123;<br><span class="hljs-comment">// 创建读写锁</span><br>ReadWriteLock rwl = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ReentrantReadWriteLock()</span>;<br><br><span class="hljs-keyword">private</span> Object obj;<br><br>public void read<span class="hljs-constructor">Obj()</span> &#123;<br><span class="hljs-comment">// 上读锁</span><br>rwl.read<span class="hljs-constructor">Lock()</span>.lock<span class="hljs-literal">()</span>;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">&quot;当前线程读到的内容是：&quot;</span> + obj);<br><br>&#125; finally &#123;<br><span class="hljs-comment">// 解读锁</span><br>rwl.read<span class="hljs-constructor">Lock()</span>.unlock<span class="hljs-literal">()</span>;<br>&#125;<br>&#125;<br><br>public void write<span class="hljs-constructor">Obj(Object <span class="hljs-params">obj</span>)</span> &#123;<br><span class="hljs-comment">// 上写锁</span><br>rwl.write<span class="hljs-constructor">Lock()</span>.lock<span class="hljs-literal">()</span>;<br><span class="hljs-keyword">try</span> &#123;<br>this.obj = obj;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">&quot;当前线程写入的内容是：&quot;</span> + obj);<br>&#125; finally &#123;<br><span class="hljs-comment">// 解写锁</span><br>rwl.write<span class="hljs-constructor">Lock()</span>.unlock<span class="hljs-literal">()</span>;<br>&#125;<br>&#125;<br><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @Description: 一个线程写入,100个线程读取</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> */</span><br>public <span class="hljs-keyword">class</span> ReadWriteLockDemo &#123;<br>public static void main(String<span class="hljs-literal">[]</span> args) throws InterruptedException &#123;<br><span class="hljs-comment">// 创建资源对象</span><br>MyQueue mq = <span class="hljs-keyword">new</span> <span class="hljs-constructor">MyQueue()</span>;<br><span class="hljs-comment">// 一个线程写入</span><br><span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(()</span> -&gt; &#123;<br>mq.write<span class="hljs-constructor">Obj(<span class="hljs-string">&quot;写入的内容&quot;</span>)</span>;<br>&#125;, <span class="hljs-string">&quot;AA&quot;</span>).start<span class="hljs-literal">()</span>;<br><span class="hljs-comment">// 100个线程读取</span><br>ExecutorService executorService = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Executors</span>.</span></span><span class="hljs-keyword">new</span><span class="hljs-constructor">FixedThreadPool(100)</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>executorService.execute(<span class="hljs-literal">()</span> -&gt; &#123;<br>mq.read<span class="hljs-constructor">Obj()</span>;<br>&#125;);<br>&#125;<br>executorService.shutdown<span class="hljs-literal">()</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">package com.atguigu.juc;<br><br>import java.util.concurrent.CountDownLatch;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @Description:</span><br><span class="hljs-comment"> *  *让一些线程阻塞直到另一些线程完成一系列操作后才被唤醒。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 解释：6个同学陆续离开教室后值班同学才可以关门。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * main主线程必须要等前面6个线程完成全部工作后，自己才能开干 </span><br><span class="hljs-comment"> */</span><br>public <span class="hljs-keyword">class</span> CountDownLatchDemo<br>&#123;<br>public static void main(String<span class="hljs-literal">[]</span> args) throws InterruptedException<br>&#123;<br>CountDownLatch cd = <span class="hljs-keyword">new</span> <span class="hljs-constructor">CountDownLatch(6)</span>;<br><span class="hljs-comment">//6个同学离开教室</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">6</span>; i++) &#123;<br><span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(()</span>-&gt;&#123;<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>+<span class="hljs-string">&quot;号同学离开教室&quot;</span>);&#125;, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>value<span class="hljs-constructor">Of(<span class="hljs-params">i</span>)</span>).start<span class="hljs-literal">()</span>;<br><span class="hljs-comment">//减少计数</span><br>cd.count<span class="hljs-constructor">Down()</span>;<br>&#125;<br><span class="hljs-comment">//等待</span><br>cd.await<span class="hljs-literal">()</span>;<br><span class="hljs-comment">//班长锁门</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>+<span class="hljs-string">&quot;班长锁门&quot;</span>);<br>&#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package com.atguigu.juc;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.BrokenBarrierException;<br><span class="hljs-keyword">import</span> java.util.concurrent.CyclicBarrier;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @Description: TODO(这里用一句话描述这个类的作用)  </span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * CyclicBarrier</span><br><span class="hljs-comment"> * 的字面意思是可循环（Cyclic）使用的屏障（Barrier）。它要做的事情是，</span><br><span class="hljs-comment"> * 让一组线程到达一个屏障（也可以叫同步点）时被阻塞，</span><br><span class="hljs-comment"> * 直到最后一个线程到达屏障时，屏障才会开门，所有</span><br><span class="hljs-comment"> * 被屏障拦截的线程才会继续干活。</span><br><span class="hljs-comment"> * 线程进入屏障通过CyclicBarrier的await()方法。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 集齐7颗龙珠就可以召唤神龙</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CyclicBarrierDemo</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> NUMBER = <span class="hljs-number">7</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//CyclicBarrier(int parties, Runnable barrierAction) </span><br>CyclicBarrier cb = <span class="hljs-keyword">new</span> CyclicBarrier(NUMBER, ()-&gt; &#123;System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;可以召唤神龙了&quot;</span>);&#125;);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=NUMBER;i++) &#123;<br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;System.out.<span class="hljs-built_in">println</span>(Thread.currentThread().getName()+<span class="hljs-string">&quot;号被收集&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br>cb.await();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125; <br>&#125;,<span class="hljs-keyword">String</span>.valueOf(i) ).start();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">package com.atguigu.juc;<br><br>import java.util.Random;<br>import java.util.concurrent.Semaphore;<br>import java.util.concurrent.TimeUnit;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @Description: TODO(这里用一句话描述这个类的作用)</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> *               在信号量上我们定义两种操作： acquire（获取）</span><br><span class="hljs-comment"> *               当一个线程调用acquire操作时，它要么通过成功获取信号量（信号量减1）， 要么一直等下去，直到有线程释放信号量，或超时。</span><br><span class="hljs-comment"> *               release（释放）实际上会将信号量的值加1，然后唤醒等待的线程。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> *               信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> *               情景：3个停车位，6部汽车争抢车位</span><br><span class="hljs-comment"> */</span><br>public <span class="hljs-keyword">class</span> SemaphoreDemo &#123;<br>public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br><span class="hljs-comment">// 3个停车位</span><br>Semaphore semaphore = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Semaphore(3)</span>;<br><span class="hljs-comment">// 6部汽车抢车位</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">6</span>; i++) &#123;<br><span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(()</span> -&gt; &#123;<br><span class="hljs-comment">// 获取资源</span><br><span class="hljs-keyword">try</span> &#123;<br>semaphore.acquire<span class="hljs-literal">()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">&quot;号驶入停车位&quot;</span>);<br><span class="hljs-comment">// 停车3秒</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TimeUnit</span>.</span><span class="hljs-module"><span class="hljs-identifier">SECONDS</span>.</span></span>sleep(<span class="hljs-number">3</span>);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">&quot;号驶出停车位&quot;</span>);<br><span class="hljs-comment">// 释放资源</span><br>semaphore.release<span class="hljs-literal">()</span>;<br>&#125; catch (Exception e) &#123;<br>e.print<span class="hljs-constructor">StackTrace()</span>;<br>&#125;<br>&#125;, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>value<span class="hljs-constructor">Of(<span class="hljs-params">i</span>)</span>).start<span class="hljs-literal">()</span>;<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java杂记</title>
    <link href="/2021/04/14/Java-mutirecord/"/>
    <url>/2021/04/14/Java-mutirecord/</url>
    
    <content type="html"><![CDATA[<h1 id="Java杂记"><a href="#Java杂记" class="headerlink" title="Java杂记"></a>Java杂记</h1><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul><li><h3 id="异常定义"><a href="#异常定义" class="headerlink" title="异常定义"></a>异常定义</h3></li><li>程序在运行时有可能出现的非正常状况，会导致程序崩溃 </li><li><h3 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h3></li><li><h4 id="按程度分："><a href="#按程度分：" class="headerlink" title="按程度分："></a>按程度分：</h4></li><li>Error：虚拟机都无法处理的错误状况</li><li>Exception：一般性的问题     </li><li><h4 id="按照处理方式为分："><a href="#按照处理方式为分：" class="headerlink" title="按照处理方式为分："></a>按照处理方式为分：</h4></li><li>受检异常，在程序中必须对其进行处理的异常，如果不处理，编译出错</li><li>Exception及其子类，RuntimeException及其子类除外：问题程序不容忽视         </li><li>非受检异常 在程序中不是必须对其进行处理的异常</li><li>Error及其子类：太严重了 </li><li>RuntimeException及其子类：太轻微了</li><li><h3 id="异常处理："><a href="#异常处理：" class="headerlink" title="异常处理："></a>异常处理：</h3></li><li><h3 id="1）捕获-try-catch-try-可能抛出异常的语句-catch-可能的异常类型-引用-通过异常处理异常对象"><a href="#1）捕获-try-catch-try-可能抛出异常的语句-catch-可能的异常类型-引用-通过异常处理异常对象" class="headerlink" title="1）捕获 try catch try{ 可能抛出异常的语句 }catch(可能的异常类型 引用){ 通过异常处理异常对象 }"></a>1）捕获 try catch try{ 可能抛出异常的语句 }catch(可能的异常类型 引用){ 通过异常处理异常对象 }</h3></li><li><h3 id="2）异常抛出-在方法中使用throw异常对象，方法一旦执行了throw和执行return效果是一样的，都会导致方法结束"><a href="#2）异常抛出-在方法中使用throw异常对象，方法一旦执行了throw和执行return效果是一样的，都会导致方法结束" class="headerlink" title="2）异常抛出 在方法中使用throw异常对象，方法一旦执行了throw和执行return效果是一样的，都会导致方法结束"></a>2）异常抛出 在方法中使用throw异常对象，方法一旦执行了throw和执行return效果是一样的，都会导致方法结束</h3></li><li>return时正常结束返回，throw时异常结束返回 </li><li>在签名中使用throws，可能的异常类型列表，警告调用者，调用此方法有风险，请考虑清楚</li><li>方法中的throw作用是真的产生破环</li><li><h3 id="3）先捕获再抛出"><a href="#3）先捕获再抛出" class="headerlink" title="3）先捕获再抛出"></a>3）先捕获再抛出</h3></li><li>在方法中先尝试执行某代码，如果真的出现了异常，再把这个异常关联到自定义异常对象中，再抛出自定义异常对象       </li><li>异常处理的选择：</li><li>入口方法尽量捕获（这个方法出问题会不会影响栈）</li><li>普通方法尽量抛出</li><li>如果代码中有潜在风险，尽量先捕再抛</li><li>如果代码中没有风险，但是有时不满足方法继续的条件时，直接抛出<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2></li><li>volatile :提醒子线程，此主存中的属性不要制作副本…</li></ul><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="冒泡排序："><a href="#冒泡排序：" class="headerlink" title="冒泡排序："></a>冒泡排序：</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] arr=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.length;i++) &#123;<br>arr[i]=(<span class="hljs-keyword">int</span>)(Math.random()*<span class="hljs-number">20</span>);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> tmp:arr) &#123;<br>System.out.print(tmp+<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br>System.out.println();<br><span class="hljs-comment">//冒泡排序</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.length-<span class="hljs-number">1</span>;i++) &#123;<span class="hljs-comment">//控制趟数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;arr.length-<span class="hljs-number">1</span>-i;j++) &#123;<span class="hljs-comment">//控制每一趟的交换次数，应该随着外循环的增加而减少</span><br><span class="hljs-keyword">if</span>(arr[j]&gt;arr[j+<span class="hljs-number">1</span>]) &#123;<span class="hljs-comment">//比较相邻元素，满足条件，则交换.</span><br><span class="hljs-keyword">int</span> tmp=arr[j];<br>arr[j]=arr[j+<span class="hljs-number">1</span>];<br>arr[j+<span class="hljs-number">1</span>]=tmp;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> tmp:arr) &#123;<br>System.out.print(tmp+<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br>System.out.println();<br></code></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] arr1=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;arr1.length;i++) &#123;<br>arr1[i]=(<span class="hljs-keyword">int</span>)(Math.random()*<span class="hljs-number">20</span>);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> tmp:arr1) &#123;<br>System.out.print(tmp+<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br>System.out.println();<br><span class="hljs-comment">//选择排序</span><br><span class="hljs-keyword">int</span> minindex;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;arr1.length-<span class="hljs-number">1</span>;i++) &#123;<span class="hljs-comment">//从0开始到倒数第二个位置</span><br>minindex=i;<span class="hljs-comment">//最小下标先默认等于i</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;arr1.length;j++) &#123;<span class="hljs-comment">//遍历从i+1开始到数组长度的所有数</span><br><span class="hljs-keyword">if</span>(arr1[j]&lt;arr1[minindex]) &#123;<span class="hljs-comment">//找最小值</span><br>minindex=j;<span class="hljs-comment">//更新最小下标</span><br>&#125;<br>&#125;<br><span class="hljs-comment">//交换元素，实现最小值赋值到基准位置i</span><br><span class="hljs-keyword">int</span> tmp=arr1[i];<br>arr1[i]=arr1[minindex];<br>arr1[minindex]=tmp;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> tmp:arr1) &#123;<br>System.out.print(tmp+<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br>System.out.println();<br></code></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuickSort</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quick</span><span class="hljs-params">(<span class="hljs-keyword">int</span> []arr,<span class="hljs-keyword">int</span> begin,<span class="hljs-keyword">int</span> end)</span> </span>&#123;<span class="hljs-comment">//结束索引不包含</span><br><span class="hljs-keyword">if</span>(end-begin&lt;=<span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//递归结束条件</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//分区，分三个部分，中间是键，左边比键小，右边比键大</span><br><span class="hljs-comment">//定位索引最关键</span><br><span class="hljs-keyword">int</span> key=arr[begin];<span class="hljs-comment">//总是取第一个元素为键值</span><br><span class="hljs-keyword">int</span> keyIndex=begin;<span class="hljs-comment">// 键索引值，用于动态保存比键值小的值的索引</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=begin+<span class="hljs-number">1</span>;i&lt;end;i++) &#123;<br><span class="hljs-keyword">if</span>(arr[i]&lt;key) &#123;<br>keyIndex++;<span class="hljs-comment">//只要找到比key小的数据，keyIndex就往右移</span><br><span class="hljs-comment">//交换下标为keyIndex和i位置的数据</span><br><span class="hljs-keyword">int</span> tmp=arr[keyIndex];<br>arr[keyIndex]=arr[i];<span class="hljs-comment">//保证比键小的值在键的右面依次保存</span><br>arr[i]=tmp;<br>&#125;<br>&#125;<br><span class="hljs-comment">//让键值归为到keyIndex位置处</span><br>arr[begin]=arr[keyIndex];<br>arr[keyIndex]=key;<br><span class="hljs-comment">//左子列递归</span><br>quick(arr,begin,keyIndex-<span class="hljs-number">1</span>);<br><span class="hljs-comment">//右子列递归</span><br> quick(arr,keyIndex+<span class="hljs-number">1</span>,end);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span>[] arr=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.length;i++) &#123;<br>arr[i]=(<span class="hljs-keyword">int</span>)(Math.random()*<span class="hljs-number">20</span>);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> tmp:arr) &#123;<br>System.out.print(tmp+<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br>System.out.println();<br>quick(arr,<span class="hljs-number">0</span>,arr.length);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> tmp:arr) &#123;<br>System.out.print(tmp+<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br>System.out.println();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-keyword">import</span> javax.lang.model.element.Element;<br><br><span class="hljs-keyword">import</span> jdk.jfr.Registered;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 注解的处理只能通过反射，要想反射，必须使用元注解<span class="hljs-doctag">@Retention</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Hasee</span><br><span class="hljs-comment"> *注解：是一种特殊的注释，不参与程序的执行，特殊之处在于编译器和JVM都可以识别它.</span><br><span class="hljs-comment"> *<span class="hljs-doctag">@Override</span> 作用是告诉编译器，它修饰的方法要完成方法覆盖，请帮助做条件检查，只能修饰方法</span><br><span class="hljs-comment"> *<span class="hljs-doctag">@Deprecated</span> 作用是警告使用者，它修饰的目标过期了，可以修饰类，属性，方法，构造器，形参，局部变量</span><br><span class="hljs-comment"> *<span class="hljs-doctag">@SuppressWarnings</span> 作用是抑制编译器警告，并且可以传递参数，参数可以是一个值也可以是一个数组</span><br><span class="hljs-comment"> *注解：</span><br><span class="hljs-comment"> *1）没有属性的，称为标记型注解</span><br><span class="hljs-comment"> *2）有属性的，可以进一步传递数据</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-comment">//自定义注解,默认可以修饰类，属性，构造器，方法，形参，局部变量</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-comment">//只有注解的停留期定义在运行时才可以被反射</span><br><span class="hljs-meta">@interface</span> MyAnnotation&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">int</span> <span class="hljs-title">id</span><span class="hljs-params">()</span><span class="hljs-keyword">default</span> 10</span>;<br><span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;我是缺省值&quot;</span>;<span class="hljs-comment">//可以有缺省值</span><br><span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;qaq&quot;</span>;<span class="hljs-comment">//当属性名为value()时可以省略属性名</span><br>&#125;<br><span class="hljs-meta">@MyAnnotation(id = 0, name = &quot;sda&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><span class="hljs-keyword">private</span> String gender;<br><span class="hljs-meta">@SuppressWarnings(&quot;unused&quot;)</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span> </span>&#123;<br><br>&#125;<br><span class="hljs-meta">@MyAnnotation</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, String gender)</span> </span>&#123;<br><span class="hljs-keyword">super</span>();<br><span class="hljs-keyword">this</span>.name = name;<br><span class="hljs-keyword">this</span>.age = age;<br><span class="hljs-keyword">this</span>.gender = gender;<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person [name=&quot;</span> + name + <span class="hljs-string">&quot;, age=&quot;</span> + age + <span class="hljs-string">&quot;, gender=&quot;</span> + gender + <span class="hljs-string">&quot;]&quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> name;<br>&#125;<br><span class="hljs-meta">@MyAnnotation(&quot;aqa&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.name = name;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> age;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.age = age;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getGender</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> gender;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setGender</span><span class="hljs-params">(String gender)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.gender = gender;<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnnotationTest</span> </span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="路径问题："><a href="#路径问题：" class="headerlink" title="路径问题："></a>路径问题：</h2><blockquote><ul><li>绝对路径：以根目录为开始的路径</li><li>相对路径：以当前目录未开始的路径（./）</li></ul></blockquote><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 泛型要解决类型安全问题</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&lt;<span class="hljs-title">X</span>&gt; </span>&#123; <span class="hljs-comment">// X表示某种类型, X在这里称为泛型的类型参数(是一个形参)</span><br><span class="hljs-comment">// X类型的真实类型会在创建对象时确定下来, 隶属于对象的存在而存在.</span><br><br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> X info;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span> </span>&#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, X info)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.name = name;<br><span class="hljs-keyword">this</span>.info = info;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> X <span class="hljs-title">getInfo</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> info;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setInfo</span><span class="hljs-params">(X info)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.info = info;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> name;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.name = name;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person [name=&quot;</span> + name + <span class="hljs-string">&quot;, info=&quot;</span> + info + <span class="hljs-string">&quot;]&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">//在静态方法中不可以使用泛型类中的泛型</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(X x)</span> </span>&#123;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 泛型和继承之间的关系</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&lt;<span class="hljs-title">Y</span>&gt; </span>&#123;<br><span class="hljs-keyword">private</span> Y y;<br><span class="hljs-function"><span class="hljs-keyword">public</span> Y <span class="hljs-title">getY</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> y;<br>&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;&#125; <span class="hljs-comment">// 子类中没有处理父类的泛型. 泛型类型就是类型最模糊的Object, 这种不好</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;&#125; <span class="hljs-comment">// 子类在继承时把父类的泛型写死了 ,  这是最简单</span><br><span class="hljs-comment">//class B3 extends A&lt;Teacher&gt; &#123;&#125; // 在创建子类对象后, 其泛型是固定的.</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B4</span>&lt;<span class="hljs-title">Y</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span>&lt;<span class="hljs-title">Y</span>&gt; </span>&#123;&#125; <span class="hljs-comment">// 子类在继承时仍然继续泛型, 这是最灵活</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericMethod</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(T t)</span> </span>&#123;<br>&#125;<br><br><span class="hljs-comment">//public Object get(Object obj) &#123;</span><br><span class="hljs-comment">// 泛型方法中必须传入泛型类型的参数, 如果不传泛型永远无法确定.</span><br><span class="hljs-comment">// 这个泛型类型由实参的类型来决定, 所以它是和方法的某次调用相关</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-function">E <span class="hljs-title">get</span><span class="hljs-params">(E e)</span> </span>&#123; <span class="hljs-comment">// E表示只可以在此方法中使用的某种类型</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericTest</span> </span>&#123;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//Object object = GenericMethod.get();</span><br>String string = GenericMethod.get(<span class="hljs-string">&quot;abc&quot;</span>); <span class="hljs-comment">// 泛型方法必须通过实参来告诉方法, 泛型的具体类型是什么</span><br>Integer integer = GenericMethod.get(<span class="hljs-number">200</span>);<br>Boolean boolean1 = GenericMethod.get(<span class="hljs-keyword">false</span>);<br>Object object = GenericMethod.get(<span class="hljs-keyword">null</span>); <span class="hljs-comment">// 如果实参是null, 将会导致泛型类型无法感知!!! </span><br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>&#123;<br>B1 b1 = <span class="hljs-keyword">new</span> B1();<br>Object y = b1.getY();<br><br>Integer y2 = <span class="hljs-keyword">new</span> B2().getY();<br>Integer y3 = <span class="hljs-keyword">new</span> B2().getY();<br><br><span class="hljs-comment">//Teacher y4 = new B3().getY();</span><br><br>B4 b4 = <span class="hljs-keyword">new</span> B4();<br>Object y5 = b4.getY();<br>Double y6 = <span class="hljs-keyword">new</span> B4&lt;Double&gt;().getY();<br>String y7 = <span class="hljs-keyword">new</span> B4&lt;String&gt;().getY();<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;<br>Person&lt;Integer&gt; person1 = <span class="hljs-keyword">new</span> Person&lt;Integer&gt;(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">20</span>); <span class="hljs-comment">// 使用了泛型后, 类型就安全了.</span><br>Integer info1 = person1.getInfo(); <span class="hljs-comment">// 获取到的属性也安全了, 清晰了.</span><br><br>Person&lt;Boolean&gt; person2 = <span class="hljs-keyword">new</span> Person&lt;Boolean&gt;(<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-keyword">true</span>);<br>Boolean info2 = person2.getInfo();<br><br>Person person3 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;王五&quot;</span>, <span class="hljs-number">3.22</span>);<br>Object info3 = person3.getInfo();<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br>Person person1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">30</span>);<br>Object info1 = person1.getInfo();<br><br>Person person2 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;女&quot;</span>);<br>Object info2 = person2.getInfo();<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br>List list1 = <span class="hljs-keyword">new</span> ArrayList();<br>list1.add(<span class="hljs-number">1</span>);<br>list1.add(<span class="hljs-string">&quot;abc&quot;</span>);<br><br>Object object = list1.get(<span class="hljs-number">0</span>);<br><br>List&lt;Integer&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>list2.add(<span class="hljs-number">3</span>);<br><span class="hljs-comment">//list2.add(&quot;abc&quot;);</span><br><br>List&lt;Object&gt; list3 = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;();<br>&#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> collection;<br><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Collection 集合 : 保存一个一个的对象, 特点 : 无序可重复</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * Set 特点 : 无序不可重复</span><br><span class="hljs-comment"> * HashSet : 基于数组使用哈希算法实现的Set集合, 判定重复的标准是两个对象的equals为true, 并且两个对象的hashCode一样</span><br><span class="hljs-comment"> * 优点 : 全是优点</span><br><span class="hljs-comment"> * 缺点 : 对内存要求高</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * TreeSet : 基于二叉搜索树(红黑树)实现的Set集合, 判定重复的标准是两个对象的比较结果为0</span><br><span class="hljs-comment"> * 优点 : 对内存要求低, 搜索速度快</span><br><span class="hljs-comment"> * 缺点 : 插入和删除的速度慢，大量元素的比较和树的旋转</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * List : 特点 : 有序可重复</span><br><span class="hljs-comment"> * ArrayList : 基于数组实现的List集合, 线程不安全.</span><br><span class="hljs-comment"> * 缺点 : 对内存要求高, 因为内存必须连续, 非末端数据的插入和删除都是最慢的, 因为有大量元素的移动.</span><br><span class="hljs-comment"> * 优点 : 末端插入删除速度快</span><br><span class="hljs-comment"> * 适用场景 : 存档数据, 主要用于查询检索</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * Vector : 和ArrayList一样, 是一个古老的实现. 但是线程安全</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * LinkedList : 基于链表实现的List集合</span><br><span class="hljs-comment"> * 优点 : 对内存要求低. 插入,删除速度非常快</span><br><span class="hljs-comment"> * 缺点 : 检索速度慢,</span><br><span class="hljs-comment"> * 适用场景 : 频繁修改数据, 很少检索</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> *泛型 : 类型安全问题, 在集合中使用泛型的好处是约束中的元素的数据类型, 类型可以是确定的, 不再是类型最模糊的Object</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *遍历 : 增强for</span><br><span class="hljs-comment"> *for (元素数据类型 临时变量 : 集合) &#123;</span><br><span class="hljs-comment"> *&#125;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  迭代器 Iterator</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> 必须从集合对象获取迭代器</span><br><span class="hljs-comment"> while (迭代器.hasNext()) &#123;</span><br><span class="hljs-comment"> 元素 = 迭代器.next();</span><br><span class="hljs-comment"> 处理元素;</span><br><span class="hljs-comment"> &#125;</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> Map集合 : 保存的是一对一对的对象. 是具有映射关系的键值对象, 键值对象都可以是任意对象. 键到值是单向一对一映射.</span><br><span class="hljs-comment"> Map可以简单地看作是一个词典, 键是词条, 值是解释.</span><br><span class="hljs-comment"> Object put(Object key, Object value); //写入条目</span><br><span class="hljs-comment"> Object remove(Object key); // 根据键删除 一个条目</span><br><span class="hljs-comment"> Object get(Object key); // 根据键查找值, 查词典</span><br><span class="hljs-comment"> Set keySet(); // 获取一个保存所有键对象的Set子集合</span><br><span class="hljs-comment"> Set entrySet(); // 获取保存所有条件对象的Set集合</span><br><span class="hljs-comment"> int size() ; 条目个数</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> HashMap 是典型实现, 使用哈希算法实现的Map集合</span><br><span class="hljs-comment"> TreeMap 是基于二叉树实现的Map集合</span><br><span class="hljs-comment"> Hashtable 是古老的实现, 和HashMap一样, 它是线程安全, 效率低.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span></span>&#123;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> weight;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dog</span><span class="hljs-params">()</span> </span>&#123;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> name;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.name = name;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> age;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.age = age;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getWeight</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> weight;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setWeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> weight)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.weight = weight;<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Dog [name=&quot;</span> + name + <span class="hljs-string">&quot;, age=&quot;</span> + age + <span class="hljs-string">&quot;, weight=&quot;</span> + weight + <span class="hljs-string">&quot;]&quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dog</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, <span class="hljs-keyword">int</span> weight)</span> </span>&#123;<br><span class="hljs-keyword">super</span>();<br><span class="hljs-keyword">this</span>.name = name;<br><span class="hljs-keyword">this</span>.age = age;<br><span class="hljs-keyword">this</span>.weight = weight;<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Object o)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(o <span class="hljs-keyword">instanceof</span> Dog) &#123;<br><span class="hljs-keyword">return</span> ((Dog)o).age-<span class="hljs-keyword">this</span>.age;<br>&#125;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;对象不可比&quot;</span>);<br>&#125;<br> <br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollectionTest</span> </span>&#123;<br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br><br>&#125;<br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br>Set set=<span class="hljs-keyword">new</span> TreeSet();<br>Dog dog1=<span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&quot;小白&quot;</span>, <span class="hljs-number">5</span>, <span class="hljs-number">25</span>);<br>Dog dog2=<span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&quot;小黄&quot;</span>, <span class="hljs-number">6</span>, <span class="hljs-number">50</span>);<br>Dog dog3=<span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&quot;小黑&quot;</span>, <span class="hljs-number">4</span>, <span class="hljs-number">30</span>);<br>Dog dog4=<span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&quot;狗蛋&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">10</span>);<br>set.add(dog1);<br>set.add(dog2);<br>set.add(dog3);<br>set.add(dog4);<br><br><span class="hljs-keyword">for</span> (Object object : set) &#123;<br>System.out.println(object);<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> date;<br><br><span class="hljs-keyword">import</span> java.text.ParseException;<br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><span class="hljs-keyword">import</span> java.time.LocalDate;<br><span class="hljs-keyword">import</span> java.time.LocalDateTime;<br><span class="hljs-keyword">import</span> java.time.LocalTime;<br><span class="hljs-keyword">import</span> java.time.format.DateTimeFormatter;<br><span class="hljs-keyword">import</span> java.util.Calendar;<br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * LocalDate,LocalTime,LocalDateTime Java8中新提供的处理时间的类</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DateTest</span> </span>&#123;<br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test6</span><span class="hljs-params">()</span> </span>&#123;<br>LocalDateTime of = LocalDateTime.of(<span class="hljs-number">2000</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>,<span class="hljs-number">1</span>);<br>System.out.println(of);<br>DateTimeFormatter dtf = DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy年MM月dd天&quot;</span>);<br>System.out.println(dtf.format(of));<br>&#125;<br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span> </span>&#123;<br>LocalTime time=LocalTime.now();<br>System.out.println(time);<br>LocalDateTime now = LocalDateTime.now();<br>System.out.println(now);<br>DateTimeFormatter dtf = DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>System.out.println(dtf.format(now));<br>&#125;<br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>&#123;<br>String str1 = <span class="hljs-string">&quot;abcwerthelloyuiodef &quot;</span>;<br>String str2 = <span class="hljs-string">&quot;cvhellobnm&quot;</span>;<br><span class="hljs-keyword">int</span> length = str2.length();<br>l1: <span class="hljs-keyword">while</span> (length &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> begin = <span class="hljs-number">0</span>; begin + length &lt;= str2.length(); begin++) &#123;<br><span class="hljs-keyword">if</span> (str1.contains(str2.substring(begin, begin + length))) &#123;<br>System.out.println(str2.substring(begin, begin + length));<br><span class="hljs-keyword">break</span> l1;<br>&#125;<br>&#125;<br>length--;<br>&#125;<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;<br>LocalDate date = LocalDate.now();<br>System.out.println(date);<br>LocalDate withYear = date.withYear(<span class="hljs-number">2000</span>).withMonth(<span class="hljs-number">8</span>).withDayOfMonth(<span class="hljs-number">10</span>);<br>System.out.println(withYear);<br>LocalDate plusYears = withYear.plusDays(<span class="hljs-number">100</span>);<br>System.out.println(plusYears);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br>Calendar instance = Calendar.getInstance();<br><span class="hljs-comment">//</span><br>instance.set(Calendar.YEAR, <span class="hljs-number">2000</span>);<br>instance.set(Calendar.MONTH, <span class="hljs-number">7</span>);<br>instance.set(Calendar.YEAR, <span class="hljs-number">10</span>);<br>System.out.println(instance.getTime());<br>instance.add(Calendar.DAY_OF_MONTH, <span class="hljs-number">100</span>);<br>System.out.println(instance.getTime());<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(System.currentTimeMillis());<span class="hljs-comment">// 距离1970-01-01 00:00:00:000的毫秒数</span><br>Date date = <span class="hljs-keyword">new</span> Date();<br>System.out.println(date);<br>SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>String format = sdf.format(date);<br>System.out.println(format);<br>String string = <span class="hljs-string">&quot;2001-12-06 20:45:19&quot;</span>;<br><span class="hljs-keyword">try</span> &#123;<br>System.out.println(sdf.parse(string));<br>&#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;<br><span class="hljs-comment">// TODO Auto-generated catch block</span><br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="大数"><a href="#大数" class="headerlink" title="大数"></a>大数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> math;<br><br><span class="hljs-keyword">import</span> java.math.BigInteger;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * java中所有字符都是两个字节</span><br><span class="hljs-comment"> * C语言中汉字占两个字节，其他字符1个字节</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MathClassTest</span> </span>&#123;<br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(Math.random());<br>System.out.println(Math.round(-<span class="hljs-number">4.5</span>));<br>BigInteger bi1=<span class="hljs-keyword">new</span> BigInteger(<span class="hljs-string">&quot;41654894789415618977465187416518948651327849816354184894561564897488465415415&quot;</span>);<br>BigInteger bi2=<span class="hljs-keyword">new</span> BigInteger(<span class="hljs-string">&quot;41654894789415641568977465187416518948651327849816354184894561564897488465415415&quot;</span>);<br>System.out.println(bi2.add(bi1));<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> string;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * StringBuffer :内容可以改变的Unicode字符序列，任何修改都不会产生新对象，是内部的数据的变化，效率高</span><br><span class="hljs-comment"> * 是一个容器，是一个可以保存字符的容器，底层仍让使用数组</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * StringBuilder append(...) 在字符串末尾追加任意数据. StringBuilder insert(int index, ...)</span><br><span class="hljs-comment"> * 在指定位置处插入任意新数据 StringBuilder delete(int begin, int end) 删除指定区间的所有字符</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * StringBuffer是线程安全的, 效率低 .</span><br><span class="hljs-comment"> * StringBuilder是线程不安全的, 效率高.(优先使用)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringBuilderTest</span> </span>&#123;<br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br>String str=<span class="hljs-keyword">null</span>;<br>StringBuffer sb=<span class="hljs-keyword">new</span> StringBuffer();<br>sb.append(str);<span class="hljs-comment">//如果append null会把null分解成单个字符，加入到StringBuffer中，count+=4</span><br>System.out.println(sb.length());<br>System.out.println(sb);<br>StringBuffer sb1=<span class="hljs-keyword">new</span> StringBuffer(str);<span class="hljs-comment">//空指针错误,无法运行</span><br>System.out.println(sb1);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> string;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 字符串：内容不可改变的Unicode字符的序列，任何对自负床的修改都一定会产生新的字符串对象</span><br><span class="hljs-comment"> * 底层使用byte[]来保存字符，字符串的处理与下标密切相关</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//System.arrycopy(value,0,result,0,value.length)实现从源数组到目标数组的复制</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 字符串 : 内容不可改变的Unicode字符的序列, 任何的对字符串的修改都一定会产生新的字符串对象.</span><br><span class="hljs-comment"> * 底层使用了char[]来保存字符, 字符串的处理和下标密切相关.</span><br><span class="hljs-comment"> * 0 2         12       17        23        29      37 39</span><br><span class="hljs-comment"> * String string = &quot;  abcABXXyy 我喜欢你,你喜欢我吗?我不喜欢你 qqyyZZ123  &quot;;</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * *****public int length() 获取字符串长度(字符数) string.length() =&gt; 40</span><br><span class="hljs-comment">*****public char charAt(int index) 获取参数指定的下标位置处的字符 string.charAt(10) =&gt; y. string.charAt(13) =&gt; 喜</span><br><span class="hljs-comment">public char[] toCharArray() 获取字符串相应的字符数组, 是内部数组的一个副本</span><br><span class="hljs-comment">System.arraycopy(value, 0, result, 0, value.length);</span><br><span class="hljs-comment">// 第一个参数是源数组, </span><br><span class="hljs-comment"> * 第2个参数是源数组开始下标</span><br><span class="hljs-comment">// 第3个参数是目标数组, </span><br><span class="hljs-comment"> * 第4个参数是目标数组的开始复制的下标, </span><br><span class="hljs-comment"> * 第5个参数是总共要复制的元素个数.</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment">效果相当于 : </span><br><span class="hljs-comment">for (int i = 0; i &lt; value.length; i++) &#123;</span><br><span class="hljs-comment">result[i] = value[i];</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">****public boolean equals(Object anObject)</span><br><span class="hljs-comment">public int compareTo(String anotherString)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * 0 2         12       17        23        29      37 39</span><br><span class="hljs-comment"> * String string = &quot;  abcABXXyy 我喜欢你,你喜欢我吗?我不喜欢你 qqyyZZ123  &quot;;</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment">***public int indexOf(String s), 获取参数中的子串在当前字符串中首次出现的下标值 string.indexOf(&quot;喜欢&quot;) =&gt; 13, 如果搜索失败返回-1</span><br><span class="hljs-comment">public int indexOf(String s ,int startpoint) 获取第2个喜欢 : string.indexOf(&quot;喜欢&quot;, 14) =&gt; 18, </span><br><span class="hljs-comment">  获取第3个喜欢 : string.indexOf(&quot;喜欢&quot;, 19) =&gt; 25,</span><br><span class="hljs-comment">  </span><br><span class="hljs-comment">public int lastIndexOf(String s) 从右向左搜索子串出现的下标, string.lastIndexOf(&quot;喜欢&quot;) =&gt; 25</span><br><span class="hljs-comment">public int lastIndexOf(String s ,int startpoint) 获取第2个喜欢 : string.lastIndexOf(&quot;喜欢&quot;, 24) =&gt; 18</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">// 通常获取文件列表名, 对文件名进行判断</span><br><span class="hljs-comment">*public boolean startsWith(String prefix) 判断字符串是否以参数中的子串为开始 string.startsWith(&quot;  abc&quot;) =&gt; true</span><br><span class="hljs-comment">*public boolean endsWith(String suffix) 判断字符串是否以参数中的子串为结束 string.endsWith(&quot;123&quot;) =&gt; false</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*****public String substring(int start,int end) 从当前字符串中截取子串, start表示开始下标(包含), end表示结束下标(不包含)</span><br><span class="hljs-comment">string.substring(12, 16) =&gt; &quot;我喜欢你&quot;,  结束下标-开始下标 == 子串长度</span><br><span class="hljs-comment">public String substring(int startpoint) 从当前字符串中取子串,从start开始到结束</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">public String replace(char oldChar,char newChar) 替换字符串中的所有旧字符为新字符</span><br><span class="hljs-comment">public String replaceAll(String old,String new) 全部替换老串为新串, 特殊字符 \ [ * +</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">public String trim() 修剪字符串的首尾的空白字符(Unicode码值小于等于32的字符，都是空白字符)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">public String concat(String str)</span><br><span class="hljs-comment">public String toUpperCase() 改变大小写</span><br><span class="hljs-comment">public String toLowerCase()</span><br><span class="hljs-comment">public String[] split(String regex) 以参数中的子串为切割器, 把字符串切割成多个部分.</span><br><span class="hljs-comment">*****public boolean equalsIgnoreCase(String s2) 比较字符串的内容, 忽略大小写</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringClassTest</span> </span>&#123;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>&#123;<br>String s=<span class="hljs-string">&quot;  \r\t\n  \r\tw \t\r\t\n\r&quot;</span>;<br><span class="hljs-keyword">int</span> begin=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++) &#123;<br><span class="hljs-keyword">if</span>(s.charAt(i)&gt;<span class="hljs-number">32</span>) &#123;<br>begin=i;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>System.out.println(begin);<br><span class="hljs-keyword">int</span> end=begin;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=s.length()-<span class="hljs-number">1</span>;i&gt;begin;i--) &#123;<br><span class="hljs-keyword">if</span>(s.charAt(i)&gt;<span class="hljs-number">32</span>) &#123;<br>end=i;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>System.out.println(end);<br>System.out.println(s.substring(begin, end+<span class="hljs-number">1</span>));<br><br><br><br>String string=<span class="hljs-string">&quot;PATH=C:\\Python38\\Scripts\\;C:\\Python38\\;C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\;C:\\Windows\\System32\\OpenSSH\\;C:\\Program Files (x86)\\NVIDIA Corporation\\PhysX\\Common;C:\\Program Files\\NVIDIA Corporation\\NVIDIA NGX;C:\\Program Files (x86)\\Intel\\Intel(R) Management Engine Components\\DAL;C:\\Program Files\\Intel\\Intel(R) Management Engine Components\\DAL;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\;C:\\WINDOWS\\System32\\OpenSSH\\;D:\\Program Files\\Java\\jdk-13.0.2\\bin;C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Anaconda3 (64-bit);D:\\python;D:\\python\\Scripts;D:\\python\\Library\\bin;D:\\Git\\cmd;C:\\ProgramData\\chocolatey\\bin;D:\\blog\\;C:\\Users\\Hasee\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Users\\Hasee\\AppData\\Local\\Programs\\Microsoft VS Code\\bin;D:\\python\\PyCharm Community Edition 2019.3.3\\bin;D:\\Fiddler;C:\\Users\\Hasee\\AppData\\Roaming\\npm;D:\\PyCharm Community Edition 2020.2.3\\bin;C:\\adb;C:\\Program Files\\NVIDIA Corporation\\NVIDIA NvDLISR;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\;C:\\WINDOWS\\System32\\OpenSSH\\;D:\\tomcat\\apache-tomcat-10.0.2\\bin;D:\\Program Files\\Java\\jdk-13.0.2\\bin;C:\\Users\\Hasee\\AppData\\Local\\Microsoft\\WindowsApps;;C:\\Users\\Hasee\\AppData\\Local\\Programs\\Microsoft VS Code\\bin;D:\\python\\PyCharm Community Edition 2019.3.3\\bin;D:\\Fiddler;C:\\Users\\Hasee\\AppData\\Roaming\\npm;D:\\PyCharm Community Edition 2020.2.3\\bin;;C:\\Users\\Hasee\\AppData\\Local\\Microsoft\\WindowsApps&quot;</span>;<br>String[] splitString=string.split(<span class="hljs-string">&quot;;&quot;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;splitString.length;i++) &#123;<br>System.out.println(splitString[i]);<br>&#125;<br>&#125;<br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;<br>String s=<span class="hljs-string">&quot;abcdefghijklmn&quot;</span>;<br><span class="hljs-keyword">int</span> begin=<span class="hljs-number">2</span>;<br><span class="hljs-keyword">int</span> end=<span class="hljs-number">6</span>;<br>String s1=s.substring(<span class="hljs-number">0</span>,begin);<br>String s2=s.substring(begin, end);<br>String s3=s.substring(end,s.length());<br>System.out.println(s1);<br>System.out.println(s2);<br>System.out.println(s3);<br>String news=<span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s2.length();i++) &#123;<br>news=s2.charAt(i)+news;<br>&#125;<br>System.out.println(news);<br>news=s1+news+s3;<br>System.out.println(news);<br>&#125;<br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">char</span>[] arr= &#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;7&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>&#125;;<br>String s1=<span class="hljs-keyword">new</span> String(arr);<br>System.out.println(s1);<br>String s2=<span class="hljs-keyword">new</span> String(arr,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<span class="hljs-comment">//new String(char[],startindex,count)</span><br>System.out.println(s2);<br>System.out.println(s2.length());<br>String s3=<span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=s1.length()-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--) &#123;<br>s3+=s1.charAt(i);<br>&#125;<br>System.out.println(s3);<br>&#125;<br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br>String s=<span class="hljs-string">&quot;abkkcadkabkebfkabkskab&quot;</span>;<br>String s1=<span class="hljs-string">&quot;ab&quot;</span>;<br><span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();) &#123;<br><span class="hljs-keyword">if</span>(s.indexOf(s1,i)!=-<span class="hljs-number">1</span>) &#123;<br>cnt++;<br>i=s.indexOf(s1,i)+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>i++;<br>&#125;<br>&#125;<br>System.out.println(cnt);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="装箱"><a href="#装箱" class="headerlink" title="装箱"></a>装箱</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> wrapper;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WrapperTest</span> </span>&#123;<br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> n=<span class="hljs-number">20</span>;<br>Integer obj1=<span class="hljs-keyword">new</span> Integer(n);<br>Integer obj2=n;<span class="hljs-comment">//自动装箱</span><br>System.out.println(obj1==obj2);<br>System.out.println(obj1.equals(obj2));<br>&#125;<br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br>Integer i=<span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);<br>Integer j=<span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);<br>System.out.println(i==j);<span class="hljs-comment">//false</span><br><span class="hljs-comment">//自动装箱，调用Integer.valueOf(n)</span><br><span class="hljs-comment">//在-128到127之间，自动装箱不会创建新的对象，会取缓冲对象数组中的一个，超过该范围，自动装箱会创建新对象</span><br>Integer m=<span class="hljs-number">1</span>;<span class="hljs-comment">//自动装箱</span><br>Integer n=<span class="hljs-number">1</span>;<br>System.out.println(m==n);<span class="hljs-comment">// true</span><br><br><br>Integer x=<span class="hljs-number">128</span>;<span class="hljs-comment">//自动装箱</span><br>Integer y=<span class="hljs-number">128</span>;<br>System.out.println(x==y);<span class="hljs-comment">//false</span><br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="JavaIo"><a href="#JavaIo" class="headerlink" title="JavaIo"></a>JavaIo</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedInputStream;<br><span class="hljs-keyword">import</span> java.io.BufferedOutputStream;<br><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.BufferedWriter;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.io.FileReader;<br><span class="hljs-keyword">import</span> java.io.FileWriter;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.io.InputStreamReader;<br><span class="hljs-keyword">import</span> java.io.ObjectInputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.io.OutputStreamWriter;<br><span class="hljs-keyword">import</span> java.io.Serializable;<br><span class="hljs-keyword">import</span> java.io.UnsupportedEncodingException;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 绝对路径：以根目录为开始的路径</span><br><span class="hljs-comment"> * 相对路径：以当前目录未开始的路径（./）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String school; <span class="hljs-comment">// 序列化不可以序列化静态属性</span><br><br><span class="hljs-comment">// 只序列化对象在GC区中的数据</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> grade;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">double</span> score;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span> </span>&#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name, <span class="hljs-keyword">int</span> grade, <span class="hljs-keyword">double</span> score)</span> </span>&#123;<br><span class="hljs-keyword">super</span>();<br><span class="hljs-keyword">this</span>.id = id;<br><span class="hljs-keyword">this</span>.name = name;<br><span class="hljs-keyword">this</span>.grade = grade;<br><span class="hljs-keyword">this</span>.score = score;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> id;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.id = id;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> name;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.name = name;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getGrade</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> grade;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setGrade</span><span class="hljs-params">(<span class="hljs-keyword">int</span> grade)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.grade = grade;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getScore</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> score;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setScore</span><span class="hljs-params">(<span class="hljs-keyword">double</span> score)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.score = score;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student [id=&quot;</span> + id + <span class="hljs-string">&quot;, name=&quot;</span> + name + <span class="hljs-string">&quot;, grade=&quot;</span> + grade + <span class="hljs-string">&quot;, score=&quot;</span> + score + <span class="hljs-string">&quot;]&quot;</span>;<br>&#125;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaIoTest</span> </span>&#123;<br><span class="hljs-comment">// 从键盘输入一些内容, 把文件保存成UTF8格式的文本文件content.txt</span><br><span class="hljs-comment">// 直到键盘输入over命令, 或ctrl+z </span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test13</span><span class="hljs-params">()</span> </span>&#123;<br>InputStream is = System.in; <span class="hljs-comment">// 以键盘为数据源</span><br>InputStreamReader isr = <span class="hljs-keyword">null</span>;<br>BufferedReader bufferedReader = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>isr = <span class="hljs-keyword">new</span> InputStreamReader(is);<br>bufferedReader = <span class="hljs-keyword">new</span> BufferedReader(isr);<br>String line = bufferedReader.readLine();<br><span class="hljs-keyword">while</span> (line != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-comment">// 1) 处理数据 </span><br><span class="hljs-keyword">if</span> (line.equals(<span class="hljs-string">&quot;exit&quot;</span>)) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>System.out.println(line);<br><span class="hljs-comment">// 2) 继续读</span><br>line = bufferedReader.readLine(); <span class="hljs-comment">// ctrl+z 提醒流数据已经结束</span><br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (bufferedReader != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>bufferedReader.close();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test12</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);<br>System.err.println(<span class="hljs-string">&quot;Error&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test11</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//FileWriter fileWriter = null;</span><br>FileOutputStream fos = <span class="hljs-keyword">null</span>;<br>OutputStreamWriter osw = <span class="hljs-keyword">null</span>;<br>BufferedWriter bufferedWriter = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//fileWriter = new FileWriter(&quot;一个文本文件&quot;);</span><br>fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;一个文本文件_UTF8&quot;</span>, <span class="hljs-keyword">true</span>); <span class="hljs-comment">// 在创建节点流时, 传入第2个参数true,表示追加</span><br>osw = <span class="hljs-keyword">new</span> OutputStreamWriter(fos, <span class="hljs-string">&quot;utf8&quot;</span>); <span class="hljs-comment">// 在写文件时, 把字符串全部按照UTF8编码方式进行编码</span><br>bufferedWriter = <span class="hljs-keyword">new</span> BufferedWriter(osw);<br>bufferedWriter.write(<span class="hljs-string">&quot;abc我和你&quot;</span>);<br><br><span class="hljs-comment">//bufferedWriter.flush(); // 把数据真的从缓冲区刷入硬盘</span><br><br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (bufferedWriter != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>bufferedWriter.close(); <span class="hljs-comment">// 在关闭前会自动flush</span><br>&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test10</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//FileReader fileReader = null; // 它太弱了, 不好用</span><br>FileInputStream fis = <span class="hljs-keyword">null</span>;<br>InputStreamReader isr = <span class="hljs-keyword">null</span>;<br>BufferedReader bufferedReader = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//fileReader = new FileReader(&quot;HashMap.java&quot;); // 只能处理和项目一致的编码的文本文件</span><br>fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;HashMap.java&quot;</span>);<br><span class="hljs-comment">//isr = new InputStreamReader(fis); // 在这里仍然使用的是默认编码方式</span><br>isr = <span class="hljs-keyword">new</span> InputStreamReader(fis, <span class="hljs-string">&quot;utf8&quot;</span>); <span class="hljs-comment">// 指明转换流在处理字节数据时按照UTF8编码方式处理字符串</span><br>bufferedReader = <span class="hljs-keyword">new</span> BufferedReader(isr);<br><br>String line = bufferedReader.readLine(); <br><span class="hljs-keyword">while</span> (line != <span class="hljs-keyword">null</span>) &#123;<br>System.out.println(line);<br>line = bufferedReader.readLine();<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (bufferedReader != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>bufferedReader.close();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unserialize</span><span class="hljs-params">()</span> </span>&#123;<br>FileInputStream fis = <span class="hljs-keyword">null</span>;<br>BufferedInputStream bis = <span class="hljs-keyword">null</span>;<br>ObjectInputStream ois = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;对象序列化&quot;</span>);<br>bis = <span class="hljs-keyword">new</span> BufferedInputStream(fis);<br>ois = <span class="hljs-keyword">new</span> ObjectInputStream(bis);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Object obj1 = ois.readObject();</span><br><span class="hljs-comment">Object obj2 = ois.readObject();</span><br><span class="hljs-comment">Object obj3 = ois.readObject();</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">System.out.println(obj1);</span><br><span class="hljs-comment">System.out.println(obj2);</span><br><span class="hljs-comment">System.out.println(obj3);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">System.out.println(Student.school);</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Student[] arr = (Student[])ois.readObject();</span><br><span class="hljs-comment">for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="hljs-comment">System.out.println(arr[i]);</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><br>List&lt;Student&gt; list = (List&lt;Student&gt;)ois.readObject();<br>Iterator&lt;Student&gt; iterator = list.iterator();<br><span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>System.out.println(iterator.next());<br>&#125;<br><br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (ois != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>ois.close();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">serialize</span><span class="hljs-params">()</span> </span>&#123;<br>FileOutputStream fos = <span class="hljs-keyword">null</span>;<br>BufferedOutputStream bos = <span class="hljs-keyword">null</span>;<br>ObjectOutputStream oos = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;对象序列化&quot;</span>);<br>bos = <span class="hljs-keyword">new</span> BufferedOutputStream(fos);<br>oos = <span class="hljs-keyword">new</span> ObjectOutputStream(bos);<br><br>Student s1 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">90</span>);<br>Student s2 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;小花&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">80</span>);<br>Student s3 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;小丽&quot;</span>, <span class="hljs-number">4</span>, <span class="hljs-number">20</span>);<br><br>s1.school = <span class="hljs-string">&quot;atguigu&quot;</span>;<br><br><span class="hljs-comment">//oos.writeObject(s1);</span><br><span class="hljs-comment">//oos.writeObject(s2);</span><br><span class="hljs-comment">//oos.writeObject(s3);</span><br><br><span class="hljs-comment">//Student[] arr = &#123;s1, s2, s3&#125;;</span><br><span class="hljs-comment">//oos.writeObject(arr);</span><br><br>List&lt;Student&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Student&gt;();<br>list.add(s1);<br>list.add(s2);<br>list.add(s3);<br>oos.writeObject(list);<br><br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (oos != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>oos.close();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test8</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> UnsupportedEncodingException </span>&#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Unicoode编码每个字符占两个字节</span><br><span class="hljs-comment">   GBK编码汉字占两个字节，其他字符一个字节</span><br><span class="hljs-comment">   UTF-8编码汉字占三个字节，其他字符占一个字节</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// e6 88 91 可变长度编码</span><br><span class="hljs-keyword">int</span> n1 = <span class="hljs-number">0x6211</span>; <span class="hljs-comment">// Unicode码是国际标准委员会制定</span><br>System.out.println(n1);<br>System.out.println((<span class="hljs-keyword">char</span>)n1);<br><br><span class="hljs-keyword">int</span> n2 = <span class="hljs-number">0xCED2</span>; <span class="hljs-comment">// GBK码值, 是中国人自己制定</span><br>System.out.println(n2);<br><br><span class="hljs-comment">// 编码 : 字符串 =&gt; 字节数组, string.getBytes(), 目标是把字符串保存到文件中或通过网络传输.</span><br>String string = <span class="hljs-string">&quot;abc我和你&quot;</span>;<br><span class="hljs-keyword">byte</span>[] bytes1 = string.getBytes(<span class="hljs-string">&quot;gbk&quot;</span>); <span class="hljs-comment">// 按照项目默认的编码方式: GBK编码方式进行编码</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; bytes1.length; i++) &#123;<br>System.out.print(Integer.toHexString(bytes1[i]) + <span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br>System.out.println();<br><br><span class="hljs-keyword">byte</span>[] bytes2 = string.getBytes(<span class="hljs-string">&quot;utf8&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; bytes2.length; i++) &#123;<br>System.out.print(Integer.toHexString(bytes2[i]) + <span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br>System.out.println();<br><br><span class="hljs-comment">// 解码 : 字节数组 =&gt; 字符串, new String(byte[]), 把文件中或从网络接收的数据还原成字符串</span><br>String string2 = <span class="hljs-keyword">new</span> String(bytes1, <span class="hljs-string">&quot;gbk&quot;</span>); <span class="hljs-comment">// 把字节数组按照gbk编码方式进行解码 </span><br><span class="hljs-comment">// 每2个字节凑一个整数, 是GBK码, 再查表找到对应的Unicode码</span><br>System.out.println(string2);<br><br>String string3 = <span class="hljs-keyword">new</span> String(bytes2, <span class="hljs-string">&quot;utf8&quot;</span>);<br><span class="hljs-comment">// 每3个字节凑一个字符, 从3个字节中拆出数据, 拆出的数据直接就是Unicode</span><br>System.out.println(string3);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test9</span><span class="hljs-params">()</span> </span>&#123;<br>FileInputStream fis = <span class="hljs-keyword">null</span>;<br>BufferedInputStream bis = <span class="hljs-keyword">null</span>;<br>ObjectInputStream ois = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;对象输出流文件2&quot;</span>);<br>bis = <span class="hljs-keyword">new</span> BufferedInputStream(fis);<br>ois = <span class="hljs-keyword">new</span> ObjectInputStream(bis);<br><br><span class="hljs-keyword">int</span> readInt = ois.readInt();<br>System.out.println(readInt);<br><span class="hljs-keyword">boolean</span> readBoolean1 = ois.readBoolean();<br><span class="hljs-keyword">boolean</span> readBoolean2 = ois.readBoolean();<br>System.out.println(readBoolean1);<br>System.out.println(readBoolean2);<br><span class="hljs-keyword">long</span> readLong = ois.readLong();<br>System.out.println(readLong);<br><span class="hljs-keyword">double</span> readDouble = ois.readDouble();<br>System.out.println(readDouble);<br>String readUTF = ois.readUTF(); <span class="hljs-comment">// 读文件要解码</span><br>System.out.println(readUTF);<br><br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (ois != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>ois.close();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test7</span><span class="hljs-params">()</span> </span>&#123;<br>FileOutputStream fos = <span class="hljs-keyword">null</span>;<br>BufferedOutputStream bos = <span class="hljs-keyword">null</span>;<br>ObjectOutputStream oos = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;对象输出流文件2&quot;</span>);<br>bos = <span class="hljs-keyword">new</span> BufferedOutputStream(fos);<br>oos = <span class="hljs-keyword">new</span> ObjectOutputStream(bos);<br><br>oos.writeInt(<span class="hljs-number">10</span>); <br>oos.writeBoolean(<span class="hljs-keyword">false</span>);<br>oos.writeBoolean(<span class="hljs-keyword">true</span>);<br>oos.writeLong(<span class="hljs-number">20</span>);<br>oos.writeDouble(<span class="hljs-number">3.14</span>);<br>oos.writeUTF(<span class="hljs-string">&quot;abc我和你xxx&quot;</span>); <span class="hljs-comment">// 写文件要编码</span><br><span class="hljs-comment">//oos.writeChars(&quot;abc我和你xxx&quot;); // 把字符串直接写文件</span><br><br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (oos != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>oos.close();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test6</span><span class="hljs-params">()</span> </span>&#123;<br>FileInputStream fis = <span class="hljs-keyword">null</span>;<br>BufferedInputStream bis = <span class="hljs-keyword">null</span>;<br>ObjectInputStream ois = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;对象输出流文件&quot;</span>);<br>bis = <span class="hljs-keyword">new</span> BufferedInputStream(fis);<br>ois = <span class="hljs-keyword">new</span> ObjectInputStream(bis);<br><br><span class="hljs-keyword">int</span> readInt = ois.readInt();<br>System.out.println(readInt);<br><span class="hljs-keyword">boolean</span> readBoolean1 = ois.readBoolean();<br><span class="hljs-keyword">boolean</span> readBoolean2 = ois.readBoolean();<br>System.out.println(readBoolean1);<br>System.out.println(readBoolean2);<br><span class="hljs-keyword">long</span> readLong = ois.readLong();<br>System.out.println(readLong);<br><span class="hljs-keyword">double</span> readDouble = ois.readDouble();<br>System.out.println(readDouble);<br><br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (ois != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>ois.close();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 使用对象流写文件, 写入50个100以内的随机整数</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exer1</span><span class="hljs-params">()</span> </span>&#123;<br>FileOutputStream fos = <span class="hljs-keyword">null</span>;<br>BufferedOutputStream bos = <span class="hljs-keyword">null</span>;<br>ObjectOutputStream oos = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;50个随机数&quot;</span>);<br>bos = <span class="hljs-keyword">new</span> BufferedOutputStream(fos);<br>oos = <span class="hljs-keyword">new</span> ObjectOutputStream(bos);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>oos.writeInt((<span class="hljs-keyword">int</span>)(Math.random() * <span class="hljs-number">100</span>));<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (oos != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>oos.close();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 使用对象输入流读取这50个随机整数</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exer2</span><span class="hljs-params">()</span> </span>&#123;<br>FileInputStream fis = <span class="hljs-keyword">null</span>;<br>BufferedInputStream bis = <span class="hljs-keyword">null</span>;<br>ObjectInputStream ois = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;50个随机数&quot;</span>);<br>bis = <span class="hljs-keyword">new</span> BufferedInputStream(fis);<br>ois = <span class="hljs-keyword">new</span> ObjectInputStream(bis);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>System.out.println(ois.readInt());<br>&#125;<br><br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (ois != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>ois.close();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// ObjectInputStream和ObjectOutputStream</span><br>FileOutputStream fos = <span class="hljs-keyword">null</span>;<br>BufferedOutputStream bos = <span class="hljs-keyword">null</span>;<br>ObjectOutputStream oos = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;对象输出流文件&quot;</span>);<br>bos = <span class="hljs-keyword">new</span> BufferedOutputStream(fos);<br>oos = <span class="hljs-keyword">new</span> ObjectOutputStream(bos);<br><br>oos.writeInt(<span class="hljs-number">10</span>); <span class="hljs-comment">// 数据在内存中如何 保存 它就如何写入文件</span><br>oos.writeBoolean(<span class="hljs-keyword">false</span>);<br>oos.writeBoolean(<span class="hljs-keyword">true</span>);<br>oos.writeLong(<span class="hljs-number">20</span>);<br>oos.writeDouble(<span class="hljs-number">3.14</span>);<br><br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (oos != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>oos.close();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>&#123;<br>FileWriter fileWriter = <span class="hljs-keyword">null</span>;<br>BufferedWriter bufferedWriter = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>fileWriter = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;使用缓冲流写文本&quot;</span>);<br>bufferedWriter = <span class="hljs-keyword">new</span> BufferedWriter(fileWriter);<br>String[] content = &#123;<span class="hljs-string">&quot;来上一些字符串内容1&quot;</span>,<br><span class="hljs-string">&quot;来上一些字符串内容2&quot;</span>,<br><span class="hljs-string">&quot;来上一些字符串内容3&quot;</span>,<br><span class="hljs-string">&quot;来上一些字符串内容4&quot;</span>,<br><span class="hljs-string">&quot;来上一些字符串内容5&quot;</span>,<br><span class="hljs-string">&quot;来上一些字符串内容6&quot;</span>,<br><span class="hljs-string">&quot;来上一些字符串内容7&quot;</span>,<br><span class="hljs-string">&quot;来上一些字符串内容8&quot;</span>,<br><span class="hljs-string">&quot;1234567890123456&quot;</span>,<br><span class="hljs-string">&quot;asdfkjasldfjalksdjflaksjdflkasjdflkasjdff&quot;</span>,<br><span class="hljs-string">&quot;xcvadsfasdfasdfasdfasdf&quot;</span>&#125;;<br><span class="hljs-keyword">for</span> (String string : content) &#123;<br>bufferedWriter.write(string);<br>bufferedWriter.newLine(); <span class="hljs-comment">// 最有价值方法</span><br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (bufferedWriter != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>bufferedWriter.close();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 使用缓冲流(处理流)</span><br>FileReader fileReader = <span class="hljs-keyword">null</span>;<br>BufferedReader bufferedReader = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 包装流, 使用对象关联, 包装流把节点流对象关联为属性.</span><br>fileReader = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;HashMap.java&quot;</span>);<br>bufferedReader = <span class="hljs-keyword">new</span> BufferedReader(fileReader);<br><span class="hljs-comment">// 最有价值方法</span><br>String line = bufferedReader.readLine(); <span class="hljs-comment">// 读到的字符串没有换行</span><br><span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (line != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-comment">// 处理读到的行</span><br>System.out.println(num++ + <span class="hljs-string">&quot; &quot;</span> + line);<br><span class="hljs-comment">// 继续读后面的行, 直到null</span><br>line = bufferedReader.readLine();<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-comment">// 只需要关闭高级流, 因为低级流被关联, 并且会在关闭高级流时自动关闭</span><br><span class="hljs-keyword">if</span> (bufferedReader != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>bufferedReader.close();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br>FileWriter fileWriter = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>fileWriter = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;写一个文件&quot;</span>);<br><span class="hljs-comment">// 写数组</span><br>String[] content = &#123;<span class="hljs-string">&quot;来上一些字符串内容1&quot;</span>,<br><span class="hljs-string">&quot;来上一些字符串内容2&quot;</span>,<br><span class="hljs-string">&quot;来上一些字符串内容3&quot;</span>,<br><span class="hljs-string">&quot;来上一些字符串内容4&quot;</span>,<br><span class="hljs-string">&quot;来上一些字符串内容5&quot;</span>,<br><span class="hljs-string">&quot;来上一些字符串内容6&quot;</span>,<br><span class="hljs-string">&quot;来上一些字符串内容7&quot;</span>,<br><span class="hljs-string">&quot;来上一些字符串内容8&quot;</span>,<br><span class="hljs-string">&quot;1234567890123456&quot;</span>,<br><span class="hljs-string">&quot;asdfkjasldfjalksdjflaksjdflkasjdflkasjdff&quot;</span>,<br><span class="hljs-string">&quot;xcvadsfasdfasdfasdfasdf&quot;</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; content.length; i++) &#123;<br><span class="hljs-keyword">char</span>[] charArray = content[i].toCharArray();<br><span class="hljs-comment">//fileWriter.write(charArray);// 直接把一个数组的全部内容写入到输出流中</span><br><span class="hljs-comment">//这是超重点方法, 把数组的一部分写入文件</span><br>fileWriter.write(charArray, <span class="hljs-number">1</span>, charArray.length - <span class="hljs-number">1</span>); <span class="hljs-comment">// 第2个参数是offset偏移, 第3个参数是length长度</span><br><br>fileWriter.write(<span class="hljs-number">13</span>); <span class="hljs-comment">// 写回车</span><br>fileWriter.write(<span class="hljs-number">10</span>); <span class="hljs-comment">// 写换行</span><br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (fileWriter != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>fileWriter.close();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//使用缓冲区读文件, 要求在每一行前面加上行号</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> line = <span class="hljs-number">1</span>;<br>System.out.print(line++ + <span class="hljs-string">&quot; &quot;</span>);<br>FileReader fileReader = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>fileReader = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;HashMap.java&quot;</span>);<br><span class="hljs-keyword">char</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">8192</span>];<br><span class="hljs-keyword">int</span> realCount = fileReader.read(buf);<br><span class="hljs-keyword">while</span> (realCount != -<span class="hljs-number">1</span>) &#123;<br><span class="hljs-comment">// 1) 处理已经实际读到的数据</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; realCount; i++) &#123;<br>System.out.print(buf[i]);<br><span class="hljs-keyword">if</span> (buf[i] == <span class="hljs-number">10</span>) &#123;<br>System.out.print(line++ + <span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-comment">// 2) 继续读后面的数据, 直到-1为止</span><br>realCount = fileReader.read(buf);<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (fileReader != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>fileReader.close();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><ul><li>文件复制</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> javaio;<br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileCopy</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>FileInputStream fis=<span class="hljs-keyword">null</span>;<br>FileOutputStream fos=<span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>fis=<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;s&quot;</span>);<br>fos=<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;s2&quot;</span>);<br><span class="hljs-keyword">byte</span>[] buf=<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">8192</span>];<br><span class="hljs-keyword">int</span> realCount=fis.read(buf);<br><span class="hljs-keyword">while</span>(realCount!=-<span class="hljs-number">1</span>) &#123;<br><span class="hljs-comment">//处理数据</span><br>fos.write(buf, <span class="hljs-number">0</span>, realCount);<br><span class="hljs-comment">//继续读</span><br>realCount=fis.read(buf);<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>e.printStackTrace();<br>&#125;<span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span>(fis!=<span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>fis.close();<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(fos!=<span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>fos.close();<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> jdbc;<br><br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> com.mysql.jdbc.Statement;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.Driver;<br><span class="hljs-keyword">import</span> java.sql.DriverManager;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 1) 在project项目下创建目录</span><br><span class="hljs-comment"> * 2) 把相关的.jar文件复制到这个目录中</span><br><span class="hljs-comment"> * 3) 再把jar文件导入到build-path中</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * url : uniform resource locator </span><br><span class="hljs-comment"> * 统一资源定位器 jdbc:mysql://127.0.0.1:3306/test</span><br><span class="hljs-comment"> * jdbc是主协议</span><br><span class="hljs-comment"> * mysql是子协议 </span><br><span class="hljs-comment"> * 127.0.0.1是Mysql服务器主机地址</span><br><span class="hljs-comment"> * 3306是mysql服务器的端口</span><br><span class="hljs-comment"> * test是数据库名</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcTest</span> </span>&#123;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test6</span><span class="hljs-params">()</span> </span>&#123;<br>Connection connection=<span class="hljs-keyword">null</span>;<br>Statement statement=<span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br> connection = JdbcUtil.getConnection();<br> statement=(Statement) connection.createStatement();<span class="hljs-comment">//通过连接获取执行体对象</span><br> System.out.println(statement);<br> String sql=<span class="hljs-string">&quot;create table if not exists customer(id int auto_increment,&quot;</span><br> +<span class="hljs-string">&quot;name varchar(10),&quot;</span><br> +<span class="hljs-string">&quot;gender char(1) default &#x27;男&#x27;,&quot;</span><br> +<span class="hljs-string">&quot;age int,&quot;</span><br> +<span class="hljs-string">&quot;phone char(11),&quot;</span><br> + <span class="hljs-string">&quot;primary key(id),&quot;</span><br> + <span class="hljs-string">&quot;unique(phone))&quot;</span>;<br> <span class="hljs-keyword">int</span> rows=statement.executeUpdate(sql);<span class="hljs-comment">//可以执行update,delete,insert,DDL，除了select的DML操作等sql操作</span><br> System.out.println(rows);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125;<span class="hljs-keyword">finally</span> &#123;<br>JdbcUtil.close(connection,statement);<br>&#125;<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException, ClassNotFoundException, IOException </span>&#123;<br>InputStream inputStream = <span class="hljs-keyword">this</span>.getClass().getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;jdbc.properties&quot;</span>);<br>Properties properties = <span class="hljs-keyword">new</span> Properties();<br>properties.load(inputStream);<br>inputStream.close();<br>String driverClassName = properties.getProperty(<span class="hljs-string">&quot;driverClassName&quot;</span>);<br>String url = properties.getProperty(<span class="hljs-string">&quot;url&quot;</span>);<br>String user = properties.getProperty(<span class="hljs-string">&quot;user&quot;</span>);<br>String password = properties.getProperty(<span class="hljs-string">&quot;password&quot;</span>);<br>System.out.println(driverClassName);<br>Class.forName(driverClassName); <span class="hljs-comment">// 在类的静态语句块中完成自我注册</span><br>Connection connection = DriverManager.getConnection(url, user, password);<br>System.out.println(connection);<br>connection.close();<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException, ClassNotFoundException </span>&#123;<br>Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>); <span class="hljs-comment">// 在类的静态语句块中完成自我注册</span><br>String url = <span class="hljs-string">&quot;jdbc:mysql://127.0.0.1:3306/jdbc&quot;</span>;<br>String user = <span class="hljs-string">&quot;root&quot;</span>;<br>String password = <span class="hljs-string">&quot;123456&quot;</span>;<br>Connection connection = DriverManager.getConnection(url, user, password);<br>System.out.println(connection);<br>connection.close();<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException, ClassNotFoundException, InstantiationException, IllegalAccessException </span>&#123;<br>Class clazz = Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>); <span class="hljs-comment">// 在类的静态语句块中完成自我注册</span><br><span class="hljs-comment">// Driver driver = new com.mysql.jdbc.Driver();</span><br>Driver driver = (Driver) clazz.newInstance();<br>DriverManager.registerDriver(driver);<br><span class="hljs-comment">// 通过驱动程序管理器来间接获取连接</span><br>String url = <span class="hljs-string">&quot;jdbc:mysql://127.0.0.1:3306/jdbc&quot;</span>;<br>String user = <span class="hljs-string">&quot;root&quot;</span>;<br>String password = <span class="hljs-string">&quot;123456&quot;</span>;<br>Connection connection = DriverManager.getConnection(url, user, password);<br>System.out.println(connection);<br>connection.close();<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>Driver driver = <span class="hljs-keyword">new</span> com.mysql.jdbc.Driver();<br>DriverManager.registerDriver(driver);<br><span class="hljs-comment">// 通过驱动程序管理器来间接获取连接</span><br>String url = <span class="hljs-string">&quot;jdbc:mysql://127.0.0.1:3306/jdbc&quot;</span>;<br>String user = <span class="hljs-string">&quot;root&quot;</span>;<br>String password = <span class="hljs-string">&quot;123456&quot;</span>;<br>Connection connection = DriverManager.getConnection(url, user, password);<br>System.out.println(connection);<br>connection.close();<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>Driver driver = <span class="hljs-keyword">new</span> com.mysql.jdbc.Driver(); <span class="hljs-comment">// 创建子类对象, 当成接口类型的对象来使用</span><br>String url = <span class="hljs-string">&quot;jdbc:mysql://127.0.0.1:3306/jdbc&quot;</span>; <span class="hljs-comment">// 统一资源定位器</span><br>Properties info = <span class="hljs-keyword">new</span> Properties();<br>info.setProperty(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>); <span class="hljs-comment">// 用户名</span><br>info.setProperty(<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>); <span class="hljs-comment">// 密码</span><br>Connection connection = driver.connect(url, info); <span class="hljs-comment">// 直接通过驱动程序来连接</span><br>System.out.println(connection);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数据修改"><a href="#数据修改" class="headerlink" title="数据修改"></a>数据修改</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> jdbc;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.PreparedStatement;<br><span class="hljs-keyword">import</span> java.sql.ResultSet;<br><span class="hljs-keyword">import</span> java.sql.ResultSetMetaData;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommonUtil</span> </span>&#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通过查询操作</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;T&gt; 表示要处理的表中的数据对应的对象类型</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> connection 连接对象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> clazz 类模板对象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> sql 查询</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> args 代替sql中的?的实参列表</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 一个保存了所有对象的集合</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">getList</span><span class="hljs-params">(Connection connection, Class&lt;T&gt; clazz, String sql, Object... args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>List&lt;T&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>PreparedStatement preparedStatement = <span class="hljs-keyword">null</span>;<br>ResultSet resultSet = <span class="hljs-keyword">null</span>; <br><span class="hljs-keyword">try</span> &#123;<br>preparedStatement = connection.prepareStatement(sql);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; args.length; i++) &#123; <span class="hljs-comment">// 替换SQL中的?</span><br>preparedStatement.setObject(i + <span class="hljs-number">1</span>, args[i]);<br>&#125;<br>resultSet = preparedStatement.executeQuery(); <br>ResultSetMetaData metaData = resultSet.getMetaData(); <span class="hljs-comment">// 获取元数据</span><br><span class="hljs-keyword">int</span> cols = metaData.getColumnCount(); <span class="hljs-comment">// 获取列数</span><br><span class="hljs-keyword">while</span> (resultSet.next()) &#123; <br>T instance = clazz.newInstance(); <span class="hljs-comment">// 反射的方式, 通过类模板创建实体对象</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cols; i++) &#123;<br>String label = metaData.getColumnLabel(i + <span class="hljs-number">1</span>); <span class="hljs-comment">// label是列标签 , 同时又是属性名</span><br>Object value = resultSet.getObject(label); <span class="hljs-comment">// 从结果集中获取列标签对应的值, 也同时就是目标对象的属性值.</span><br>Field field = clazz.getDeclaredField(label); <span class="hljs-comment">// 反射的方式, 根据属性名获取属性定义对象</span><br>field.setAccessible(<span class="hljs-keyword">true</span>); <span class="hljs-comment">// 暴力反射</span><br>field.set(instance, value); <span class="hljs-comment">// 通过反射的方式为目标对象的属性赋值.</span><br>&#125;<br>list.add(instance);<br>&#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>JdbcUtil.close(<span class="hljs-keyword">null</span>, preparedStatement, resultSet);<br>&#125;<br><span class="hljs-keyword">return</span> list;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">getList</span><span class="hljs-params">(Class&lt;T&gt; clazz, String sql, Object... args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>Connection connection = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>connection = JdbcUtil.getConnection();<br><span class="hljs-keyword">return</span> getList(connection,  clazz, sql, args);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>JdbcUtil.close(connection);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通用更新操作</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> sql 需要执行的SQL语句, 可以执行除了select外的DML和所有DDL</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> args 用于代替SQL中的?的实参列表</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 影响行数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">update</span><span class="hljs-params">(Connection connection, String sql, Object... args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, IOException, SQLException </span>&#123;<br>PreparedStatement preparedStatement = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>preparedStatement = connection.prepareStatement(sql); <span class="hljs-comment">// 根据传入 的SQL预编译</span><br><span class="hljs-comment">// 循环处理?</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; args.length; i++) &#123;<br>preparedStatement.setObject(i + <span class="hljs-number">1</span>, args[i]);<br>&#125;<br><span class="hljs-keyword">int</span> rows = preparedStatement.executeUpdate(); <span class="hljs-comment">// 真正的执行</span><br><span class="hljs-keyword">return</span> rows;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>JdbcUtil.close(<span class="hljs-keyword">null</span>, preparedStatement); <span class="hljs-comment">// 无论有没有发生异常,都要释放资源</span><br>&#125;<br>&#125; <br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通用更新操作</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> sql 需要执行的SQL语句, 可以执行除了select外的DML和所有DDL</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> args 用于代替SQL中的?的实参列表</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 影响行数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">update</span><span class="hljs-params">(String sql, Object... args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, IOException, SQLException </span>&#123;<br>Connection connection = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>connection = JdbcUtil.getConnection(); <span class="hljs-comment">// 获取连接</span><br><span class="hljs-keyword">return</span> update(connection, sql, args);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>JdbcUtil.close(connection); <span class="hljs-comment">// 无论有没有发生异常,都要释放资源</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>异常</tag>
      
      <tag>Java关键字</tag>
      
      <tag>排序算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hbase简介</title>
    <link href="/2020/11/17/HBase%20introduction/"/>
    <url>/2020/11/17/HBase%20introduction/</url>
    
    <content type="html"><![CDATA[<h1 id="分布式数据库HBase简介"><a href="#分布式数据库HBase简介" class="headerlink" title="分布式数据库HBase简介"></a>分布式数据库HBase简介</h1><ol><li><p>概述    </p><ul><li>HBase是针对谷歌BigTable的开源实现，是一个高可靠，高性能，面向列，可伸缩的分布式数据库           </li><li>可以用来存储非结构化和半结构化的松散数据</li></ul></li><li><p>数据模型</p><ul><li>索引通过四个元素来定位：行键，列族，列限定符，时间戳</li><li> 面向列的存储</li></ul></li><li><p>实现原理 </p><ul><li>HBase的功能组件<blockquote><p>库函数<br>Master服务器<br>Region服务器    </p></blockquote></li><li>两个核心概念表和Region<blockquote><p>一个HBase表被划分成多个Region<br>一个Region会分裂成多个新的Region</p></blockquote></li><li>怎么实现Region定位<blockquote><p>三层结构索引实现Region的定位<br>Zookeeper文件<br>-ROOT-表<br>.MEAT.表      </p></blockquote></li></ul></li><li><p>运行机制</p><ul><li>HBase的系统架构<blockquote><p><img src="https://img-blog.csdnimg.cn/2020070104123335.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTE1NDU1OQ==,size_16,color_FFFFFF,t_70#pic_center" title="系统架构图"><br>Zookeeper服务器（被大量用于分布式系统，提供配置维护，域名服务，分布式同步服务）实现协同管理服务，提供管家功能（维护和管理整个HBase集群）<br>Master服务器作用：1.对表增删改查。2.负责不同Region服务器的负载均衡。3.负责调整分裂合并后Region的分布。4.负责重新分配故障，失效的Region服务器</p></blockquote></li><li>Region服务器（负责用户数据的存储和管理）的工作原理</li><li>Store的工作原理</li><li>HLog的工作原理</li></ul></li><li><p>编程实践<br>HBase安装及实践，参考厦门大学数据库实验室博客<br><a href="http://dblab.xmu.edu.cn/blog/2442-2/">参考链接</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>老hadoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hadoop</tag>
      
      <tag>大数据</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown语法介绍</title>
    <link href="/2020/10/27/markdown-introduction/"/>
    <url>/2020/10/27/markdown-introduction/</url>
    
    <content type="html"><![CDATA[<h1 id="markdow语法的简单介绍"><a href="#markdow语法的简单介绍" class="headerlink" title="markdow语法的简单介绍"></a>markdow语法的简单介绍</h1><blockquote><ul><li>第一项：markdown标题  <blockquote><ul><li>用“#”号的个数来表示标题的级数</li></ul><ul><li>使用 = 和 - 标记一级和二级标题</li></ul></blockquote></li></ul><ul><li>第二项：段落格式<blockquote><ul><li>Markdown 段落没有特殊的格式<br>直接编写文字，<strong>段落的换行是使用两个以上空格加回车,也可以在段落后面使用一个空行来表示重新开始一个段落</strong>  </li></ul><ul><li><em><strong>字体：</strong></em><br>markdown可以使用斜体文本（一个<em>或_在文字的两边），粗体文本（两个</em>或_在文字的两边），粗斜体文本（三个）    </li></ul></blockquote></li><li>斜体文本*<br><em>斜体文本</em>    </li><li><em>粗体文本</em>*<br><strong>粗体文本</strong>    </li><li><strong>粗斜体文本</strong>*<br><em><strong>粗斜体文本</strong></em>    <blockquote><ul><li><em><strong>分隔线：</strong></em><br>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。    </li></ul></blockquote></li></ul></blockquote><hr><hr><hr><blockquote><blockquote><ul><li><em><strong>删除线：</strong></em><br>删除线： 如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可<br><del>删除线</del></li><li><strong>下划线：</strong><br>下划线可以通过 HTML 的 <u> 标签来实现</u><br><u>下划线</u></li><li><strong>脚注：</strong><br>脚注是对文本的补充说明。<br>创建脚注格式类似这样 [^RUNOOB]。<br>[^RUNOOB]: 菜鸟教程 – 学的不仅是技术，更是梦想！！！</li></ul></blockquote><ul><li>第三项：列表<br>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容     <blockquote><ul><li><strong>嵌套列表：</strong><br>列表嵌套只需在子列表中的选项前面添加四个空格即可    </li></ul></blockquote></li><li>第四项：<strong>区块</strong><br>Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号<br>另外区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推<br>区块中可以使用列表，列表中也可以使用区块</li><li>第五项：<strong>markdown代码</strong><br><code>printf()</code>函数<br>如果是段落上的一个函数或片段的代码可以用反引号把它包起来(`)    <blockquote><ul><li>代码区块：<br>四个空格或者制表符（代码区块使用 4 个空格或者一个制表符（Tab 键）。）<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/6DC89E5C-B41A-4938-97D8-D7D06B879F91.jpg" alt="展示" title="结果展示"><br>你也可以用 ``` 包裹一段代码，并指定一种语言（也可以不指定）    </li></ul></blockquote></li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">include &lt;bits/stdc++.h&gt;    <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;hello world&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <br>&#125;    <br></code></pre></td></tr></table></figure><blockquote><ul><li><strong>第六项：Markdown 链接:</strong><br>参考<a href="https://www.runoob.com/markdown/md-tutorial.html">菜鸟教程</a></li><li><strong>第七项：markdown 表格</strong><br>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。  </li></ul></blockquote><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr><tr><td>我们可以设置表格的对齐方式：</td><td></td></tr></tbody></table><pre><code>-: 设置内容和标题栏居右对齐。:- 设置内容和标题栏居左对齐。:-: 设置内容和标题栏居中对齐。</code></pre><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table><blockquote><ul><li><strong>第八项：markdown高级技巧</strong><br>参考连接<a href="https://www.runoob.com/markdown/md-advance.html">菜鸟教程</a></li></ul></blockquote><hr><hr><p>本文参考菜鸟教程的markdown教学，超链接上文已给出。（<a href="https://www.runoob.com/markdown/md-tutorial.html%EF%BC%89">https://www.runoob.com/markdown/md-tutorial.html）</a></p>]]></content>
    
    
    <categories>
      
      <category>Blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop简介</title>
    <link href="/2020/10/21/hadoop-introduction/"/>
    <url>/2020/10/21/hadoop-introduction/</url>
    
    <content type="html"><![CDATA[<h1 id="hadoop简介"><a href="#hadoop简介" class="headerlink" title="hadoop简介"></a>hadoop简介</h1><p>1.定义：<br>hadoop是一个开源分布式计算平台，为用户提供了底层细节透明的分布式基础框架。<br>2.特性：    </p><ul><li>高可靠性    </li><li>高效性</li><li>高可扩展性</li><li>高容错性</li><li>成本低</li><li>运行在linux中</li><li>支持多种编程语言</li></ul><p>3.版本</p><ul><li>1.0</li><li>2.0</li></ul><p>4.hadoop结构</p><ul><li><img src="https://img-blog.csdnimg.cn/20191024090622860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZtMzQ1Njg5,size_16,color_FFFFFF,t_70" alt="图片展示" title="Hadoop项目结构图"></li><li>参考别人博客的<a href="https://blog.csdn.net/fm345689/article/details/102715230">文字记录</a></li></ul><p>5.Hadoop项目核心模块</p><ul><li>Hadoop Common：为Hadoop其他模块提供支持实用程序。</li><li>HDFS：提供对应用程序数据的高吞吐量访问</li><li>Hadoop YARN：作业调度和集群资源管理的框架</li><li>MapReduce：YARN系统的大型数据集并行处理技术</li></ul><p>6.Hadoop RPC工作原理</p><p>7.MapReduce工作原理</p><blockquote><ul><li>策略：分而治之</li><li>计算向数据靠拢而不是数据向计算靠拢</li></ul></blockquote><p>8.HDFS工作原理</p><p>9.YARN工作原理</p>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>老hadoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hadoop</tag>
      
      <tag>大数据</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/09/22/hello-world/"/>
    <url>/2020/09/22/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
