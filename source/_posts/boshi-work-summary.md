---
title: boshi_work_summary
date: 2024-02-21 11:22:00
tags:
- 项目总结
hide: true
categories:
- 复盘
index_img: https://pic2.zhimg.com/v2-5b5bf59a17d6947d72b22b358b6805ca_r.jpg
banner_img: https://pic2.zhimg.com/v2-5b5bf59a17d6947d72b22b358b6805ca_r.jpg
---

# 总结

* 工作总结

## 数据仓库

### 数仓分层

* ODS 原始数据层

  - 基本数据存储格式
    - orc+snappy
    - parquet+lzo

  - 数据源基本上都是来自mysql等关系型数据库
  - 同步采用**datax**脚本同步数据
  - 启信宝数据采用分区表做每日增量更新操作
    - 做增量更新筛选时命中时间索引字段，加速查询
    - 增量更新出现**数据漂移问题**，**新增真实入库时间字段**保证数据不会丢失

* DW层 (临时处理层)  对每日新增数据做开窗取第一条数据，取最新的业务数据

  - 这种方式比较消耗时间，增加了一层数据层级，没有做分区无法找到历史数据
  - 采用制作拉链表的方式，可以找到历史数据，速度更快

#### 拉链表

* 适用场景：缓慢变化维度
  - 在业务场景中，维度属性并不是静态的，而是随时间的变化而变化，这也体现了数据仓库的特点之一，就是反映历史变化。相对于数据增长较为快速的事实表，维度的变化是相对缓慢的。
  - 维度建模理论中，处理缓慢变化维有三种方式：
    - 新的维度属性直接覆盖旧的维度属性，不保留历史数据
    - 增加新的维度行。
    - 增加维度列，设计时包含两列，新属性和旧属性。扩展性不好，保留历史数据有限
* 历史拉链表是通过增加维度行来实现，时间键包含两个字段，开始时间，结束时间。一般以天为粒度保留变更的维度数据。
* 采用拉链表适用的场景：缓慢变化维度的数据，比起全量数据来说，每天的新增不会很多，比如系统的用户表。

##### 分区方式

* 方式一（start_date）作为分区键：缺点是查询最新数据无法走分区；
  - 查最新数据时：`select * from A where end_date='99991231' `
  - 查询某一天数据时：`select * from A where start_date='20230227'`
* 方式二（适用end_date作为分区键）：缺点是查询某一天时start_date限制条件无法走



##### 引用内容

* 方式1（使用start_day作为分区键）：缺点是查询最新数据无法走分区；查询某一天数据时end_day限制条件无法走分区；加工历史拉链表数据时，end_day=30001231的结果数据不方便入库
* 方式2（使用end_day作为分区键）：缺点是查询某一天数据时start_day限制条件无法走分区；优点是加工历史拉链表数据时，结果数据入库方便，直接insert overwrite覆盖分区30001231和20200201即可
* 方式3（使用start_day和end_day作为联合分区键，start_day为父分区）：查询最新数据时需要改变下SQL语句，不然无法走分区（比如当前日期是20200401，SQL语句需改为select * from table_name where start_day <= ‘20200401’ and end_day > '20200401'，即查询某一天数据的写法）；缺点是加工历史拉链表数据时，end_day=30001231和end_day=20200201的结果数据都不方便入库；而且分区数会越来越多，一年下来最多可能产生365*364/2=66430个分区；优点是查询数据时start_day和end_day的限制条件都可以走分区
* 方式4（使用start_day和end_day作为联合分区键，end_day为父分区）：缺点同方式3，但加工历史拉链表数据时，结果数据入库相对方便（首先将结果数据存入临时表，然后清空拉链表的分区end_day=30001231和end_day=20200201，最后将临时表数据以insert into方式入库）；优点同方式3

综上所述，分区方式可在2和4中选择。

- 选择方式2，需要考虑随着时间的推移，查询某一天的维度状态数据，消耗的计算资源会越来越多。可考虑删除或者备份部分历史数据至其他地方。
- 选择方式4，需要考虑随着时间的推移，分区数量会越来越多。可考虑定期重构历史拉链表，比如在每个月月初强制重新开始做历史拉链表（比如在20200401时，先将end_day=30001231的数据修改为end_day=20200401，再基于最新全量快照表生成一份start_day=20200401，end_day=30001231的数据）。
- **设计历史拉链表时，需要移除变化频率高的维度属性，不然生成新拉链的概率会很高，导致无法达到节省存储的目的。**

